{"version":3,"sources":["webpack:///vendor.js","webpack:///./vendor.js","webpack:///./vendor/code-prettify/prettify.js","webpack:////projects/rede_gsti/resources/~/summernote/dist/summernote.js","webpack:///(webpack)/buildin/amd-options.js","webpack:////projects/rede_gsti/resources/~/codemirror/lib/codemirror.js","webpack:////projects/rede_gsti/resources/~/summernote/lang/summernote-pt-BR.js","webpack:///./vendor/summernote/plugins/summernote-oembed-plugin.js","webpack:///./vendor/summernote/plugins/summernote-prettyprint-plugin.js"],"names":["webpackJsonp",0,"module","exports","__webpack_require__",76,"PR","prettyPrint",77,"IN_GLOBAL_SCOPE","window","prettyPrintOne","combinePrefixPatterns","regexs","decodeEscape","charsetPart","cc0","charCodeAt","c1","charAt","escapeCharToCodeUnit","parseInt","substring","encodeEscape","charCode","toString","ch","String","fromCharCode","caseFoldCharset","charSet","charsetParts","length","match","RegExp","ranges","inverse","out","push","i","n","p","test","end","start","Math","max","min","sort","a","b","consolidatedRanges","lastRange","range","join","allowAnywhereFoldCaseAndRenumberGroups","regex","parts","source","capturedGroups","groupIndex","decimalValue","capturedGroupIndex","ignoreCase","needToFoldCase","ch0","replace","cc","t","v","f","r","rewritten","global","multiline","Error","extractSourceSpans","node","isPreformatted","walk","type","nodeType","nocode","className","child","firstChild","nextSibling","nodeName","toLowerCase","chunks","k","spans","text","nodeValue","sourceCode","appendDecorations","sourceNode","basePos","langHandler","job","pre","langExtension","numberLines","decorations","apply","childContentWrapper","element","wrapper","undefined","c","notWs","createSimpleLexer","shortcutStylePatterns","fallthroughStylePatterns","tokenizer","shortcuts","allPatterns","concat","allRegexs","regexKeys","patternParts","shortcutChars","hasOwnProperty","nPatterns","decorate","PR_PLAIN","pos","tokens","styleCache","ti","nTokens","isEmbedded","token","style","PR_SOURCE","tokenStart","embeddedSource","embeddedSourceStart","indexOf","embeddedSourceEnd","lang","langHandlerForExtension","sourceDecorator","options","PR_STRING","hc","PR_COMMENT","regexLiterals","regexExcls","regexAny","REGEX_LITERAL","REGEXP_PRECEDER_PATTERN","types","PR_TYPE","keywords","PR_KEYWORD","punctuation","PR_LITERAL","PR_PUNCTUATION","startLineNum","lineBreak","firstLine","index","tail","parent","parentNode","insertBefore","document","createTextNode","breakAfter","removeChild","lineEndNode","breakLeftOf","limit","copy","rightSide","cloneNode","parentClone","next","appendChild","sibling","copiedListItem","listItems","ownerDocument","li","createElement","setAttribute","ol","offset","recombineTagsAndDecorations","isIE8OrEarlier","exec","navigator","userAgent","newlineRe","sourceLength","sourceIndex","nSpans","spanIndex","nDecorations","decorationIndex","decPos","startPos","startDec","oldDisplay","display","styledText","spanEnd","decEnd","textNode","span","replaceChild","registerLangHandler","handler","fileExtensions","ext","langHandlerRegistry","win","console","extension","applyDecorator","opt_langExtension","sourceAndSpans","e","$prettyPrintOne","sourceCodeHtml","opt_numberLines","nl","container","innerHTML","$prettyPrint","opt_whenDone","opt_root","byTagName","tn","root","getElementsByTagName","doWork","endTime","clock","Infinity","elements","cs","attrs","EMPTY","preceder","previousSibling","nt","value","_","name","prettyPrintRe","prettyPrintedRe","nested","tagName","preCodeXmpRe","langExtensionRe","codeRe","preformatted","preformattedTagNameRe","currentStyle","defaultView","doc","whitespace","getComputedStyle","getPropertyValue","lineNums","prettyPrintingJob","setTimeout","body","codeSegments","j","Date","now","FLOW_CONTROL_KEYWORDS","C_KEYWORDS","COMMON_KEYWORDS","CPP_KEYWORDS","JAVA_KEYWORDS","CSHARP_KEYWORDS","COFFEE_KEYWORDS","JSCRIPT_KEYWORDS","PERL_KEYWORDS","PYTHON_KEYWORDS","RUBY_KEYWORDS","SH_KEYWORDS","ALL_KEYWORDS","C_TYPES","PR_TAG","PR_DECLARATION","PR_ATTRIB_NAME","PR_ATTRIB_VALUE","PR_NOCODE","decorateSource","hashComments","cStyleComments","multiLineStrings","verbatimStrings","tripleQuotedStrings","multilineStrings","define",78,"__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","$","func","eq","itemA","itemB","eq2","peq2","propName","ok","fail","not","arguments","and","fA","fB","item","self","invoke","obj","method","idCounter","uniqueId","prefix","id","rect2bnd","rect","$document","top","scrollTop","left","scrollLeft","width","right","height","bottom","invertObject","inverted","key","namespaceToCamel","namespace","split","map","toUpperCase","debounce","wait","immediate","timeout","context","this","args","later","callNow","clearTimeout","list","head","array","last","initial","slice","find","pred","idx","len","all","inArray","contains","sum","fn","reduce","memo","from","collection","result","isEmpty","clusterBy","aTail","aLast","compact","aResult","unique","results","prev","isSupportAmd","isFontInstalled","fontName","testFontName","$tester","css","position","fontSize","appendTo","originalWidth","remove","isMSIE","browserVersion","matches","parseFloat","isEdge","hasCodeMirror","CodeMirror","agent","isMac","appVersion","isFF","isPhantom","isWebkit","isChrome","isSafari","jqueryVersion","jquery","isW3CRangeSupport","createRange","NBSP_CHAR","ZERO_WIDTH_NBSP_CHAR","dom","isEditable","hasClass","isControlSizing","makePredByNodeName","isText","isElement","isVoid","isPara","isHeading","isPre","isLi","isPurePara","isTable","isData","isInline","isBodyContainer","isList","isHr","isBlockquote","isCell","isAnchor","isParaInline","ancestor","isBodyInline","isBody","isClosestSibling","nodeA","nodeB","withClosestSiblings","siblings","blankHTML","nodeLength","childNodes","paddingBlankHTML","singleChildAncestor","listAncestor","ancestors","el","lastAncestor","filter","commonAncestor","listPrev","nodes","listNext","listDescendant","descendants","fnWalk","current","wrap","wrapperName","insertAfter","preceding","appendChildNodes","aChild","each","isLeftEdgePoint","point","isRightEdgePoint","isEdgePoint","isLeftEdgeOf","isRightEdgeOf","isLeftEdgePointOf","isRightEdgePointOf","hasChildren","prevPoint","isSkipInnerOffset","nextPoint","isSamePoint","pointA","pointB","isVisiblePoint","leftNode","rightNode","prevPointUntil","nextPointUntil","isCharPoint","walkPoint","startPoint","endPoint","isSkipOffset","makeOffsetPath","reverse","fromOffsetPath","offsets","splitNode","isSkipPaddingBlankHTML","isNotSplitEdgePoint","splitText","childNode","clone","splitTree","splitPoint","splitRoot","topAncestor","pivot","create","createText","isRemoveChild","removeNode","removeWhile","newNode","cssText","isTextarea","$node","stripLinebreaks","val","html","isNewlineOnBlock","markup","regexTag","endSlash","isEndOfInlineContainer","isBlockNode","trim","posFromPlaceholder","placeholder","$placeholder","outerHeight","attachEvents","events","Object","keys","forEach","on","detachEvents","off","blank","emptyPara","isBlock","isDiv","isBR","isSpan","isB","isU","isS","isI","isImg","isEmptyAnchor","Context","$note","ui","summernote","memos","modules","layoutInfo","initialize","createLayout","_initialize","hide","destroy","_destroy","removeData","removeLayout","reset","disabled","isDisabled","code","disable","buttons","extend","plugins","initializeModule","removeModule","removeMemo","isActivated","codable","editable","triggerEvent","attr","enable","callback","callbacks","trigger","shouldInitialize","ModuleClass","withoutIntialize","createInvokeHandler","event","preventDefault","target","closest","data","splits","hasSeparator","moduleName","methodName","isExternalAPICalled","hasInitOptions","langInfo","icons","note","first","focus","Renderer","children","render","$parent","contents","addClass","click","$container","append","renderer","isArray","editor","toolbar","editingArea","statusbar","airEditor","airEditable","buttonGroup","button","tooltip","title","placement","dropdown","items","content","template","dropdownCheck","icon","checkClassName","palette","row","rowSize","colors","eventName","col","colSize","color","dialog","fade","footer","popover","direction","hideArrow","iconClassName","toggleBtn","$btn","isEnable","toggleClass","toggleBtnActive","isActive","onDialogShown","$dialog","one","onDialogHidden","showDialog","modal","hideDialog","$editor","airMode","show","en-US","font","bold","italic","underline","clear","strikethrough","subscript","superscript","size","image","insert","resizeFull","resizeHalf","resizeQuarter","floatLeft","floatRight","floatNone","shapeRounded","shapeCircle","shapeThumbnail","shapeNone","dragImageHere","dropImage","selectFromFiles","maximumFileSize","maximumFileSizeError","url","video","videoLink","providers","link","unlink","edit","textToDisplay","openInNewWindow","table","hr","normal","blockquote","h1","h2","h3","h4","h5","h6","lists","unordered","ordered","help","fullscreen","codeview","paragraph","outdent","indent","center","justify","recent","more","background","foreground","transparent","setTransparent","resetToDefault","shortcut","close","textFormatting","action","paragraphFormatting","documentStyle","extraKeys","insertParagraph","undo","redo","tab","untab","removeFormat","justifyLeft","justifyCenter","justifyRight","justifyFull","insertUnorderedList","insertOrderedList","formatPara","formatH1","formatH2","formatH3","formatH4","formatH5","formatH6","insertHorizontalRule","linkDialog.show","history","specialChar","select","keyMap","BACKSPACE","TAB","ENTER","SPACE","LEFT","UP","RIGHT","DOWN","NUM0","NUM1","NUM2","NUM3","NUM4","NUM5","NUM6","NUM7","NUM8","B","E","I","J","K","L","R","S","U","V","Y","Z","SLASH","LEFTBRACKET","BACKSLASH","RIGHTBRACKET","isEdit","keyCode","isMove","nameFromCode","textRangeToPoint","textRange","isStart","prevContainer","parentElement","tester","createTextRange","moveToElementText","compareEndPoints","textRangeStart","curTextNode","collapse","pointTester","duplicate","setEndPoint","textCount","cont","pointToTextRange","textRangeInfo","isCollapseToStart","prevTextNodes","collapseToStart","info","moveStart","WrappedRange","sc","so","ec","eo","nativeRange","w3cRange","setStart","setEnd","getPoints","getStartPoint","getEndPoint","nativeRng","selection","getSelection","rangeCount","removeAllRanges","addRange","scrollIntoView","offsetTop","abs","normalize","getVisiblePoint","isLeftToRight","block","isCollapsed","includeAncestor","fullyContains","leftEdgeNodes","expand","startAncestor","endAncestor","boundaryPoints","isSameContainer","deleteContents","rng","emptyParents","makeIsOn","isOnEditable","isOnList","isOnAnchor","isOnCell","isOnData","wrapBodyInlineWithPara","inlineSiblings","para","insertNode","pasteHTML","contentsContainer","getWordRange","findAfter","bookmark","s","path","paraBookmark","paras","getClientRects","wrappedRange","createFromSelection","createFromNode","anchorNode","getRangeAt","startContainer","startOffset","endContainer","endOffset","textRangeEnd","isTextNode","createFromNodeBefore","createFromNodeAfter","createFromBookmark","createFromParaBookmark","async","readFileAsDataURL","file","Deferred","deferred","FileReader","onload","dataURL","resolve","onerror","reject","readAsDataURL","promise","createImage","$img","detach","History","$editable","stack","stackOffset","makeSnapshot","emptyBookmark","applySnapshot","snapshot","rewind","recordUndo","Style","jQueryCSS","$obj","propertyNames","propertyName","call","fromNode","properties","styleInfo","stylePara","styleNodes","expandClosestSibling","onlyPartialContains","nodesInRange","tails","elem","$cont","font-bold","queryCommandState","font-italic","font-underline","font-subscript","font-superscript","font-strikethrough","orderedTypes","isUnordered","lineHeight","toFixed","anchor","Bullet","toggleList","clustereds","wrapList","releaseList","listName","wrappedParas","diffLists","listNode","prevList","nextList","isEscapseToBody","releasedParas","headList","lastList","middleList","rootLists","rootList","listNodes","Typing","bullet","insertTab","tabsize","Array","nextPara","emptyAnchors","Table","isShift","cell","cells","nextCell","createTable","colCount","rowCount","tdHTML","tds","idxCol","trHTML","trs","idxRow","$table","tableClassName","KEY_BOGUS","Editor","typing","isDefaultPrevented","handleKeyMap","preventDefaultEditableShortCuts","changeEventName","outerWidth","maxHeight","minHeight","metaKey","ctrlKey","altKey","shiftKey","keyName","afterCommand","saveRange","thenCollapse","restoreRange","saveTarget","clearTarget","restoreTarget","styleFromNode","beforeCommand","isPreventTrigger","commands","sCmd","execCommand","tabSize","wrapCommand","insertImage","src","param","then","$image","insertImages","files","filename","maximumImageFileSize","insertImagesOrCallback","onImageUpload","insertText","getSelectedText","formatBlock","firstSpan","font-size","hrNode","removeBogus","bogusNode","bogusCharIdx","deleteData","createLink","linkInfo","linkUrl","linkText","isNewWindow","isTextChanged","onCreateLink","anchors","removeAttr","startRange","endRange","getLinkInfo","$anchor","colorInfo","foreColor","backColor","insertTable","dim","dimension","floatMe","$target","resize","resizeTo","bKeepRatio","imageSize","newRatio","y","x","ratio","removeMedia","hasFocus","is","empty","Clipboard","summernote.keydown","we","needKeydownHook","$paste","pasteByHook","opacity","before","pasteByEvent","dataURI","decodedData","atob","Uint8Array","blob","Blob","pasteContent","clipboardData","originalEvent","kind","getAsFile","Dropzone","documentEventHandlers","$dropzone","prependTo","detachDocumentEvent","substr","disableDragAndDrop","onDrop","attachDragAndDropEvent","$dropzoneMessage","onDragenter","isCodeview","hasEditorSize","add","onDragleave","removeClass","dataTransfer","getData","__WEBPACK_AMD_REQUIRE_ARRAY__","cm","Codeview","$codable","sync","save","toggle","deactivate","activate","prettifyHtml","cmEditor","fromTextArea","codemirror","tern","server","TernServer","ternServer","updateArgHints","setSize","getValue","toTextArea","isChange","EDITABLE_PADDING","Statusbar","$statusbar","disableResizeEditor","stopPropagation","editableTop","clientY","minheight","Fullscreen","$toolbar","$window","$scrollbar","h","setsize","isFullscreen","Handle","$editingArea","summernote.mousedown","update","summernote.keyup summernote.scroll summernote.change summernote.dialog.shown","$handle","disableResizeImage","posStart","clientX","isImage","$selection","w","sizingText","AutoLink","defaultScheme","linkPattern","summernote.keyup","handleKeyup","handleKeydown","lastWordRange","keyword","wordRange","AutoSync","summernote.change","Placeholder","summernote.init summernote.change","summernote.codeview.toggled","isShow","Buttons","invertedKeyMap","representShortcut","editorMethod","addToolbarButtons","addImagePopoverButtons","addLinkPopoverButtons","fontInstalledMap","fontNamesIgnoreCheck","magic","caret","styleTags","tag","eraser","menuCheck","fontNames","fontSizes","$button","currentTarget","$recentColor","$dropdown","$holder","$color","$currentButton","unorderedlist","orderedlist","alignLeft","alignCenter","alignRight","alignJustify","textHeight","lineHeights","$catcher","insertTableMaxSize","mousedown","tableMoveHandler","picture","minus","arrowsAlt","question","trash","build","groups","groupIdx","groupLen","group","groupName","$group","updateCurrentStyle","updateBtnStates",".note-btn-bold",".note-btn-italic",".note-btn-underline",".note-btn-subscript",".note-btn-superscript",".note-btn-strikethrough","isChecked","infos","selector","posOffset","PX_PER_EM","$picker","$dimensionDisplay","$highlighted","$unhighlighted","offsetX","posCatcher","pageX","pageY","offsetY","ceil","Toolbar","toolbarContainer","updateFullscreen","updateCodeview","isIncludeCodeview","LinkDialog","dialogsInBody","disableLinkTarget","dialogsFade","bindEnterKey","$input","toggleLinkBtn","$linkBtn","$linkText","$linkUrl","showLinkDialog","$openInNewWindow","handleLinkTextUpdate","handleLinkUrlUpdate","prop","state","LinkPopover","summernote.keyup summernote.mouseup summernote.change summernote.scroll","summernote.dialog.shown","$popover","$content","prepend","href","ImageDialog","imageLimitation","unit","floor","log","readableSize","pow","showImageDialog","$imageInput","$imageUrl","$imageBtn","replaceWith","ImagePopover","VideoDialog","createVideoNode","$video","ytRegExp","ytMatch","igRegExp","igMatch","vRegExp","vMatch","vimRegExp","vimMatch","dmRegExp","dmMatch","youkuRegExp","youkuMatch","mp4RegExp","mp4Match","oggRegExp","oggMatch","webmRegExp","webmMatch","youtubeId","showVideoDialog","$videoUrl","$videoBtn","HelpDialog","createShortCutList","command","$row","margin-right","max-height","overflow","showHelpDialog","AirPopover","AIR_MODE_POPOVER_X_OFFSET","summernote.keyup summernote.mouseup summernote.scroll","summernote.change summernote.dialog.shown","summernote.focusout","relatedTarget","air","bnd","HintPopover","POPOVER_DIST","hint","hintDirection","hints","selectItem","$item","innerHeight","moveDown","$current","$next","$nextGroup","moveUp","$prev","$prevGroup","nodeFromItem","createItemTemplates","hintIdx","searchKeyword","search","createGroup","version","clipboard","dropzone","handle","hintPopover","autoLink","autoSync","linkDialog","linkPopover","imageDialog","imagePopover","videoDialog","helpDialog","airPopover","styleWithSpan","textareaAutoSync","onInit","onFocus","onBlur","onEnter","onKeyup","onKeydown","onImageUploadError","mode","htmlMode","lineNumbers","pc","CTRL+Z","CTRL+Y","SHIFT+TAB","CTRL+B","CTRL+I","CTRL+U","CTRL+SHIFT+S","CTRL+BACKSLASH","CTRL+SHIFT+L","CTRL+SHIFT+E","CTRL+SHIFT+R","CTRL+SHIFT+J","CTRL+SHIFT+NUM7","CTRL+SHIFT+NUM8","CTRL+LEFTBRACKET","CTRL+RIGHTBRACKET","CTRL+NUM0","CTRL+NUM1","CTRL+NUM2","CTRL+NUM3","CTRL+NUM4","CTRL+NUM5","CTRL+NUM6","CTRL+ENTER","CTRL+K","mac","CMD+Z","CMD+SHIFT+Z","CMD+B","CMD+I","CMD+U","CMD+SHIFT+S","CMD+BACKSLASH","CMD+SHIFT+L","CMD+SHIFT+E","CMD+SHIFT+R","CMD+SHIFT+J","CMD+SHIFT+NUM7","CMD+SHIFT+NUM8","CMD+LEFTBRACKET","CMD+RIGHTBRACKET","CMD+NUM0","CMD+NUM1","CMD+NUM2","CMD+NUM3","CMD+NUM4","CMD+NUM5","CMD+NUM6","CMD+ENTER","CMD+K","align","circle","frame","pencil","square",79,"__webpack_amd_options__",80,"mod","place","copyObj","defaults","setGuttersForLineNumbers","Doc","lineSeparator","input","inputStyles","inputStyle","Display","updateGutters","themeChanged","lineWrapping","autofocus","mobile","initScrollbars","keyMaps","overlays","modeGen","overwrite","delayingBlurEvent","focused","suppressEdits","pasteIncoming","cutIncoming","selectingText","draggingText","highlight","Delayed","keySeq","specialChars","ie","ie_version","registerEventHandlers","ensureGlobalHandlers","startOperation","curOp","forceUpdate","attachDoc","bind","opt","optionHandlers","Init","maybeUpdateLineNumberWidth","finishInit","initHooks","endOperation","webkit","lineDiv","textRendering","d","scrollbarFiller","elt","gutterFiller","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","mover","sizer","sizerWidth","heightForcer","scrollerGap","gutters","lineGutter","scroller","zIndex","paddingRight","gecko","draggable","viewFrom","viewTo","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","activeTouch","init","loadMode","getMode","modeOption","resetModeState","iter","line","stateAfter","styles","frontier","startWorker","regChange","wrappingChanged","minWidth","rmClass","findMaxLine","estimateLineHeights","clearCaches","updateScrollbars","estimateHeight","th","wrapping","perLine","clientWidth","charWidth","lineIsHidden","widgetsHeight","widgets","est","estHeight","updateLineHeight","theme","guttersChanged","alignHorizontally","specs","removeChildren","gutterClass","gElt","updateGutterSpace","offsetWidth","marginLeft","lineLength","merged","cur","collapsedSpanAtStart","found","to","collapsedSpanAtEnd","getLine","splice","measureForScrollbars","gutterW","docH","round","paddingVert","clientHeight","viewHeight","scrollWidth","viewWidth","barLeft","fixedGutter","docHeight","scrollHeight","scrollGap","gutterWidth","NativeScrollbars","scroll","vert","horiz","checkedZeroWidth","NullScrollbars","scrollbars","scrollbarModel","scrollbarStyle","axis","setScrollLeft","setScrollTop","startWidth","startHeight","updateScrollbarsInner","updateHeightsInViewport","sizes","paddingBottom","borderBottom","coverGutterNextToScrollbar","visibleLines","viewport","paddingTop","lineAtHeight","ensure","ensureFrom","ensureTo","heightAtLine","lastLine","comp","compensateForHScroll","hidden","gutter","alignable","lineNumberFor","innerW","padding","lineNumberFormatter","firstLineNumber","getBoundingClientRect","DisplayUpdate","force","visible","editorIsHidden","wrapperHeight","wrapperWidth","oldDisplayWidth","displayWidth","dims","getDimensions","maybeClipScrollbars","marginBottom","borderRightWidth","updateDisplayIfNeeded","resetView","countDirtyView","viewportMargin","sawCollapsedSpans","visualLineNo","visualLineEndNo","different","adjustView","toUpdate","activeElt","patchDisplay","offsetHeight","postUpdateDisplay","displayHeight","barMeasure","updateSelection","setDocumentHeight","signal","updateDisplaySimple","finish","prevBottom","bot","box","diff","updateWidgetHeight","rest","gutterLeft","clientLeft","offsetLeft","fixedPos","gutterTotalWidth","updateNumbersFrom","rm","currentWheelTarget","lineN","lineView","updateNumber","lineNumber","changes","updateLineForChanges","buildLineElement","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","updateLineBackground","cls","bgClass","getLineContent","built","buildLineContent","textClass","wrapClass","gutterBackground","markers","gutterMarkers","gutterWrap","setUneditable","insertLineWidgets","insertLineWidgetsFor","allowAbove","ws","widget","handleMouseEvents","positionLineWidget","above","signalLater","noHScroll","coverGutter","paddingLeft","copyPos","Pos","maxPos","cmp","minPos","ensureFocus","applyTextInput","inserted","deleted","sel","origin","paste","textLines","splitLines","multiPaste","lastCopied","l","lst","lineWise","updateInput","changeEvent","makeChange","triggerElectric","ensureCursorVisible","handlePaste","pasted","isReadOnly","disableInput","runInOp","electricChars","smartIndent","getModeAt","indented","indentLine","electricInput","copyableRanges","lineRange","getRange","disableBrowserMagic","field","TextareaInput","prevInput","pollingFast","polling","inaccurateSelection","hasSelection","composing","hiddenTextarea","te","div","ios","border","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","gracePeriod","posToDOM","findViewForLine","mapFromLineView","order","getOrder","side","partPos","getBidiPartAt","nodeAndOffsetInLineMap","badPos","bad","domToPos","lineNode","clipPos","locateNodeInLineView","topNode","maps","curNode","lineNo","after","dist","textContent","domTextBetween","fromLine","toLine","recognizeMarker","marker","cmText","getAttribute","markerID","findMarks","getBetween","lineSep","closing","Selection","primIndex","Range","normalizeSelection","prim","inv","simpleSelection","clipLine","clipToLen","linelen","isLine","clipPosArray","extendRange","other","posBefore","extendSelection","setSelection","primary","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","setSelectionReplaceHistory","done","setSelectionNoUndo","addSelectionToHistory","NaN","hasHandler","bias","setSelectionInner","skipAtomicInSelection","equals","selectionChanged","signalCursorActivity","reCheckSelection","sel_dontScroll","mayClear","old","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","dir","markedSpans","sp","m","inclusiveLeft","inclusiveRight","explicitlyCleared","atomic","near","movePos","far","cantEdit","showSelection","prepareSelection","curFragment","cursors","createDocumentFragment","selFragment","collapsed","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","output","cursorCoords","singleCursorHeightPerLine","cursor","cursorHeight","otherCursor","fragment","drawForLine","fromArg","toArg","coords","charCoords","lineObj","lineLen","iterateBidiSections","rightPos","leftPos","tmp","leftSide","paddingH","sFrom","sTo","singleVLine","visualLine","leftEnd","rightStart","restartBlink","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","time","startState","set","highlightWorker","workTime","copyState","getStateBefore","changedLines","oldStyles","tooLong","maxHighlightLength","highlighted","highlightLine","oldCls","styleClasses","newCls","classes","ischange","processLine","workDelay","regLineChange","findStartLine","precise","minindent","minline","lim","innerMode","countColumn","removeChildrenAndAdd","isNaN","ensureLineHeights","curWidth","heights","rects","cache","caches","updateExternalMeasurement","LineView","measureChar","measureCharPrepared","prepareMeasureForLine","findViewIndex","hasHeights","prepared","varHeight","measureCharInner","bogus","rtop","rbottom","mStart","mEnd","insertLeft","coverStart","coverEnd","getUsefulRect","nullRect","isExtendingChar","maybeUpdateRectForZooming","rSpan","rbot","mid","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","pageScrollX","pageXOffset","documentElement","pageScrollY","pageYOffset","intoCoordSystem","widgetHeight","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","preparedMeasure","get","getBidi","part","level","bidiLeft","bidiRight","bidiOther","estimateCoords","PosWithInfo","outside","xRel","coordsChar","coordsCharInner","mergedPos","getX","wrongLine","innerOff","adjust","bidi","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","charSize","step","middle","middleX","measureText","viewChanged","changeObjs","cursorActivityHandlers","cursorActivityCalled","updateMaxLine","scrollToPos","nextOpId","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","op","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","mustUpdate","updatedDisplay","adjustWidthTo","maxScrollLeft","preparedSelection","takeFocus","forceScroll","scrollPosIntoView","margin","isCursor","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","lines","operation","methodOp","docMethodOp","visualLineContinued","buildViewArray","nextPos","lendiff","cut","viewCuttingPoint","cutTop","cutBot","arr","oldN","newN","dirty","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touches","touch","radiusX","radiusY","farAway","dx","dy","onMouseDown","signalDOMEvent","posFromMouse","clickInGutter","eventInWidget","e_preventDefault","word","findWordAt","captureRightClick","onContextMenu","moved","onScrollWheel","dragFunctions","enter","e_stop","over","onDragOver","onDragStart","drop","leave","clearDragCursor","inp","getField","onKeyUp","onKeyDown","onKeyPress","dragDropChanged","wasOn","funcs","onResize","e_target","liberal","forRect","space","colDiff","supportsTouch","e_button","leftButtonDown","lastMiddleDown","delayBlurEvent","lastDoubleClick","lastClick","contained","modifier","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","startTime","dragEnd","e2","addNew","extendTo","lastPos","startCol","posCol","findColumn","startSel","ourIndex","oldRange","ourRange","sel_mouse","curCount","counter","editorSize","move","up","lastSelOrigin","chromeOS","gutterEvent","prevent","mX","mY","lineBox","e_defaultPrevented","g","lastDrop","File","read","loadFile","allowDropFileTypes","reader","change","changeEnd","readAsText","selected","listSelections","replaceRange","replaceSelection","setData","effectAllowed","setDragImage","safari","img","presto","_top","frag","dragCursor","isScroller","delta","wheelEventDelta","canScrollX","canScrollY","outer","wheelPixelsPerUnit","pixels","wheelSamples","movedX","movedY","sample","doHandleBinding","bound","dropShift","ensurePolled","prevShift","Pass","lookupKeyForEditor","lookupKey","dispatchKey","seq","isModifierKey","stopSeq","handleKeyBinding","motion","handleCharBinding","returnValue","handled","lastStoppedKey","hasCopyEvent","showCrossHair","which","readOnly","receivedFocus","contextMenuInGutter","adjustForChange","computeSelAfterChange","offsetPos","nw","computeReplacedSel","oldPrev","newPrev","filterChange","canceled","cancel","ignoreReadOnly","sawReadOnlySpans","removeReadOnlyRanges","makeChangeInner","selAfter","addChangeToHistory","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","rebaseHist","makeChangeFromHistory","allowSelectionOnly","hist","undone","dest","lastOrigin","pop","pushSelectionToHistory","clearRedo","antiChanges","generation","maxGeneration","historyChangeFromChange","mergeOldSpans","shiftDoc","distance","removed","makeChangeSingleDocInEditor","updateDoc","recomputeMaxLength","checkWidthStart","full","isWholeLineUpdate","changesHandler","changeHandler","doScroll","phantom","scrollNode","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","x1","y1","x2","y2","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollPos","resolveScrollToPos","getCursor","cursorScrollMargin","sPos","scrollTo","how","aggressive","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","spaceStr","changeLine","changeType","no","deleteNearSelection","compute","kill","toKill","replaced","findPosH","visually","findNextLine","moveOnce","boundToLine","moveLogically","origDir","sawType","helper","getHelper","isWordChar","hitSide","findPosV","pageSize","option","deflt","notOnInit","normalizeKeyName","alt","ctrl","cmd","getKeyMap","markText","shared","markTextShared","TextMarker","clearWhenEmpty","replacedWith","widgetNode","conflictingCollapsedRange","addToHistory","curLine","addMarkedSpan","MarkedSpan","clearOnEnter","clearHistory","nextMarkerId","startStyle","endStyle","linked","isParent","SharedTextMarker","findSharedMarkers","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","getMarkedSpanFor","removeMarkedSpan","attachLine","markedSpansBefore","startCh","isInsert","startsBefore","endsAfter","markedSpansAfter","endCh","oldFirst","oldLast","sameLine","clearEmptySpans","newMarkers","gapMarkers","gap","getOldSpans","stretched","oldCur","stretchCur","mark","mk","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","vis","lineIsHiddenInner","adjustScrollWhenAboveVisible","parentStyle","addLineWidget","LineWidget","insertAt","aboveVisible","updateLine","cleanUpLine","extractLineClasses","lineClass","callBlankLine","blankLine","inner","readToken","stream","takeToken","asArray","getObj","string","StringStream","eol","runMode","lineClasses","forceToEnd","flattenSpans","curStart","curStyle","addModeClass","mName","st","o","overlay","at","i_end","opaque","getLineStyles","updateFrontier","startAt","interpretTokenStyle","styleToClassCacheWithMode","styleToClassCache","builder","trailingSpace","splitSpaces","getOption","addToken","buildToken","hasBadBidiRects","buildTokenBadBidi","allowFrontierUpdate","insertLineContent","joinClasses","zeroWidthElement","lastChild","querySelector","defaultSpecialCharPlaceholder","displayText","special","mustWrap","lastIndex","skipped","txt","tabWidth","specialCharPlaceholder","fullStyle","trailingBefore","spaceBefore","buildCollapsedSpan","ignoreWidget","needsContentAttribute","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","endStyles","foundBookmarks","upto","tokenText","wholeLineUpdateBefore","spansFor","linesFor","Line","lastText","lastSpans","nlines","added","LeafChunk","BranchChunk","chunkSize","sharedHistOnly","propagate","skip","rel","chunk","sz","getLines","lh","bidiOrdering","startGen","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","opId","historyEventDelay","selectionEventCanBeMerged","somethingSelected","existing","removeClearedSpans","copyHistoryArray","newGroup","instantiateSel","prototype","deepCopy","newChanges","Number","rebaseHistSelSingle","rebaseHistArray","sub","copied","defaultPrevented","srcElement","getHandlers","emitter","_handlers","noHandlers","orphanDelayedCallbacks","fireOrphanDelayed","delayed","override","codemirrorIgnore","cursorActivity","eventMixin","ctor","spaceStrs","nothing","createObj","base","props","inst","isWordCharBasic","extendingChars","count","activeElement","classTest","as","forEachCodeMirror","getElementsByClassName","byClass","globalsRegistered","registerGlobalHandlers","resizeTimer","zwspSupported","badBidiRects","r0","r1","badZoomedRects","fromRange","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","compareBidiLevel","linedir","moveInLine","byUnit","platform","ie_upto10","ie_11up","documentMode","qtwebkit","chrome","vendor","mac_geMountainLion","windows","presto_version","flipCtrlCmd","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","pointerEvents","bar","delay","maybeDisable","elementFromPoint","native","null","cmpPos","prepareCopyCut","getSelections","selectInput","lineWiseCopyCut","setSelections","textarea","poll","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","minimal","blur","resetPosition","slowPoll","pollInterval","missed","same","prepareSelectAllHack","selectionStart","extval","selectionEnd","rehide","oldWrapperCSS","oldCSS","selectAll","detectingSelectAll","resetSelectionOnContextMenu","wrapperBox","oldScrollY","scrollY","mouseup","readOnlyChanged","onCopyCut","clearData","kludge","hadFocus","startData","ours","applyComposition","forceCompositionEnd","pollContent","showPrimarySelection","showMultipleSelections","curAnchor","anchorOffset","curFocus","focusNode","focusOffset","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","pollSelection","fromIndex","toIndex","toNode","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","contenteditable","here","there","wheelDeltaX","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","constructor","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","spec","modeSpec","removeOverlay","indentSelection","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","helpers","helperType","_global","getStateAfter","defaultTextHeight","defaultCharWidth","setGutterMarker","gutterID","clearGutter","lineInfo","getViewport","addWidget","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","amount","moveH","extendSelectionsBy","rtlMoveVisually","sel_move","deleteH","goalColumn","moveV","goals","startChar","check","toggleOverwrite","getScrollInfo","interpret","refresh","oldHeight","swapDoc","getInputField","getWrapperElement","getScrollerElement","getGutterElement","setValue","newBreaks","attach","integer","tabIndex","modes","mimeModes","defineMode","dependencies","defineMIME","mime","resolveMode","mfactory","modeObj","modeExtensions","exts","modeProps","skipToEnd","extendMode","defineExtension","defineDocExtension","defineOption","defineInitHook","registerHelper","registerGlobalHelper","predicate","nstate","a1","a2","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","undoSelection","redoSelection","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","goLineDown","goPageUp","goPageDown","goCharLeft","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertSoftTab","spaces","replaceSelections","defaultTab","transposeChars","newlineAndIndent","openLine","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","fallthrough","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","normalizeKeyMap","keymap","keyname","keyNames","noShift","altGraphKey","tabindex","form","leaveSubmitMethodAlone","realSubmit","submit","wrappedSubmit","getTextArea","lastColumnPos","lastColumnValue","sol","peek","eat","eatWhile","eatSpace","skipTo","backUp","column","pattern","consume","caseInsensitive","cased","str","hideFirstChars","withOp","dHeight","oldH","removeInner","insertInner","iterN","remaining","leaf","maybeSpill","me","spilled","myIndex","used","nextDocId","cleanGeneration","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","addSelection","dup","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","unlinkDoc","splitIds","iterLinkedDocs","getEditor","splitLinesAuto","eachLine","dontDelegate","e_stopPropagation","cancelBubble","addEventListener","attachEvent","removeEventListener","detachEvent","handlers","ms","startIndex","startValue","nextTab","goal","_e","nonASCIISingleCaseWordChar","endNode","moveEnd","host","rt","oncopy",3,8,9,13,16,17,18,19,20,27,32,33,34,35,36,37,38,39,40,44,45,46,59,61,91,92,93,106,107,109,110,111,127,173,186,187,188,189,190,191,192,219,220,221,222,63232,63233,63234,63235,63272,63273,63275,63276,63277,63302,"charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","nstart","unshift",81,"jQuery","pt-BR",82,"embedToSummernote","inToolbar","oEmbedOptions","service","oEmbed","oEmbedButton","showEmbedDialog","insertEmbedToEditor","uri","disableAddButton","$embedInput","$addBtn","createDialog","dialogOption","oEmbedDialog","label","closeOnEscape","$embedContainer","enableAddButton","iframe","$div","getJSON","normalizeEmbed","$iframe","padding-top","padding-bottom","errorMessage","invalid_provider","initOembed","spinner","message","summernote.init","oembed",83,"summernotePrettyprint","prettyprintOpitions","prettyprint","insertToEditor","$code","$codeLanguage","language","languages","dialogPrettyfi","selectLabel","codeLabel","innerOptions","_options","class"],"mappings":"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","file":"vendor.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(76);\n\n\n/***/ },\n\n/***/ 76:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t__webpack_require__(77);\n\t__webpack_require__(78);\n\t__webpack_require__(81);\n\t__webpack_require__(82);\n\t__webpack_require__(83);\n\t\n\tPR.prettyPrint();\n\n/***/ },\n\n/***/ 77:\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (C) 2006 Google Inc.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * @fileoverview\n\t * some functions for browser-side pretty printing of code contained in html.\n\t *\n\t * <p>\n\t * For a fairly comprehensive set of languages see the\n\t * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n\t * file that came with this source.  At a minimum, the lexer should work on a\n\t * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n\t * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n\t * and a subset of Perl, but, because of commenting conventions, doesn't work on\n\t * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n\t * <p>\n\t * Usage: <ol>\n\t * <li> include this source file in an html page via\n\t *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n\t * <li> define style rules.  See the example page for examples.\n\t * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n\t *    {@code class=prettyprint.}\n\t *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n\t *    printer needs to do more substantial DOM manipulations to support that, so\n\t *    some css styles may not be preserved.\n\t * </ol>\n\t * That's it.  I wanted to keep the API as simple as possible, so there's no\n\t * need to specify which language the code is in, but if you wish, you can add\n\t * another class to the {@code <pre>} or {@code <code>} element to specify the\n\t * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n\t * starts with \"lang-\" followed by a file extension, specifies the file type.\n\t * See the \"lang-*.js\" files in this directory for code that implements\n\t * per-language file handlers.\n\t * <p>\n\t * Change log:<br>\n\t * cbeust, 2006/08/22\n\t * <blockquote>\n\t *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n\t * </blockquote>\n\t * @requires console\n\t */\n\t\n\t// JSLint declarations\n\t/*global console, document, navigator, setTimeout, window, define */\n\t\n\t/**\n\t * {@type !{\n\t *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n\t *   'registerLangHandler': function (function (JobT), Array.<string>),\n\t *   'PR_ATTRIB_NAME': string,\n\t *   'PR_ATTRIB_NAME': string,\n\t *   'PR_ATTRIB_VALUE': string,\n\t *   'PR_COMMENT': string,\n\t *   'PR_DECLARATION': string,\n\t *   'PR_KEYWORD': string,\n\t *   'PR_LITERAL': string,\n\t *   'PR_NOCODE': string,\n\t *   'PR_PLAIN': string,\n\t *   'PR_PUNCTUATION': string,\n\t *   'PR_SOURCE': string,\n\t *   'PR_STRING': string,\n\t *   'PR_TAG': string,\n\t *   'PR_TYPE': string,\n\t *   'prettyPrintOne': function (string, string, number|boolean),\n\t *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n\t * }}\n\t * @const\n\t */\n\t/**\n\t* @typedef {!Array.<number|string>}\n\t* Alternating indices and the decorations that should be inserted there.\n\t* The indices are monotonically increasing.\n\t*/\n\t\"use strict\";\n\t\n\tvar DecorationsT;\n\t\n\t/**\n\t* @typedef {!{\n\t*   sourceNode: !Element,\n\t*   pre: !(number|boolean),\n\t*   langExtension: ?string,\n\t*   numberLines: ?(number|boolean),\n\t*   sourceCode: ?string,\n\t*   spans: ?(Array.<number|Node>),\n\t*   basePos: ?number,\n\t*   decorations: ?DecorationsT\n\t* }}\n\t* <dl>\n\t*  <dt>sourceNode<dd>the element containing the source\n\t*  <dt>sourceCode<dd>source as plain text\n\t*  <dt>pre<dd>truthy if white-space in text nodes\n\t*     should be considered significant.\n\t*  <dt>spans<dd> alternating span start indices into source\n\t*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n\t*     span.\n\t*  <dt>decorations<dd>an array of style classes preceded\n\t*     by the position at which they start in job.sourceCode in order\n\t*  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n\t*     source.\n\t* </dl>\n\t*/\n\tvar JobT;\n\t\n\t/**\n\t* @typedef {!{\n\t*   sourceCode: string,\n\t*   spans: !(Array.<number|Node>)\n\t* }}\n\t* <dl>\n\t*  <dt>sourceCode<dd>source as plain text\n\t*  <dt>spans<dd> alternating span start indices into source\n\t*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n\t*     span.\n\t* </dl>\n\t*/\n\tvar SourceSpansT;\n\t\n\t/** @define {boolean} */\n\tvar IN_GLOBAL_SCOPE = false;\n\t\n\tvar PR;\n\t\n\t/**\n\t * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n\t * UI events.\n\t * If set to {@code false}, {@code prettyPrint()} is synchronous.\n\t */\n\twindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\t\n\t/**\n\t * Pretty print a chunk of code.\n\t * @param {string} sourceCodeHtml The HTML to pretty print.\n\t * @param {string} opt_langExtension The language name to use.\n\t *     Typically, a filename extension like 'cpp' or 'java'.\n\t * @param {number|boolean} opt_numberLines True to number lines,\n\t *     or the 1-indexed number of the first line in sourceCodeHtml.\n\t * @return {string} code as html, but prettier\n\t */\n\tvar prettyPrintOne;\n\t/**\n\t * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n\t * {@code class=prettyprint} and prettify them.\n\t *\n\t * @param {Function} opt_whenDone called when prettifying is done.\n\t * @param {HTMLElement|HTMLDocument} opt_root an element or document\n\t *   containing all the elements to pretty print.\n\t *   Defaults to {@code document.body}.\n\t */\n\tvar prettyPrint;\n\t\n\t(function () {\n\t  var win = window;\n\t  // Keyword lists for various languages.\n\t  // We use things that coerce to strings to make them compact when minified\n\t  // and to defeat aggressive optimizers that fold large string constants.\n\t  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n\t  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"auto,case,char,const,default,\" + \"double,enum,extern,float,goto,inline,int,long,register,short,signed,\" + \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n\t  var COMMON_KEYWORDS = [C_KEYWORDS, \"catch,class,delete,false,import,\" + \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n\t  var CPP_KEYWORDS = [COMMON_KEYWORDS, \"alignof,align_union,asm,axiom,bool,\" + \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" + \"dynamic_cast,explicit,export,friend,generic,late_check,\" + \"mutable,namespace,nullptr,property,reinterpret_cast,static_assert,\" + \"static_cast,template,typeid,typename,using,virtual,where\"];\n\t  var JAVA_KEYWORDS = [COMMON_KEYWORDS, \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" + \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" + \"throws,transient\"];\n\t  var CSHARP_KEYWORDS = [COMMON_KEYWORDS, \"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,\" + \"dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,\" + \"internal,into,is,let,lock,null,object,out,override,orderby,params,\" + \"partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,\" + \"unchecked,unsafe,ushort,var,virtual,where\"];\n\t  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" + \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" + \"throw,true,try,unless,until,when,while,yes\";\n\t  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS, \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" + \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" + \"yield,Infinity,NaN\"];\n\t  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" + \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" + \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n\t  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" + \"elif,except,exec,finally,from,global,import,in,is,lambda,\" + \"nonlocal,not,or,pass,print,raise,try,with,yield,\" + \"False,True,None\"];\n\t  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" + \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" + \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" + \"BEGIN,END\"];\n\t  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" + \"function,in,local,set,then,until\"];\n\t  var ALL_KEYWORDS = [CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n\t  var C_TYPES = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\t\n\t  // token style names.  correspond to css classes\n\t  /**\n\t   * token style for a string literal\n\t   * @const\n\t   */\n\t  var PR_STRING = 'str';\n\t  /**\n\t   * token style for a keyword\n\t   * @const\n\t   */\n\t  var PR_KEYWORD = 'kwd';\n\t  /**\n\t   * token style for a comment\n\t   * @const\n\t   */\n\t  var PR_COMMENT = 'com';\n\t  /**\n\t   * token style for a type\n\t   * @const\n\t   */\n\t  var PR_TYPE = 'typ';\n\t  /**\n\t   * token style for a literal value.  e.g. 1, null, true.\n\t   * @const\n\t   */\n\t  var PR_LITERAL = 'lit';\n\t  /**\n\t   * token style for a punctuation string.\n\t   * @const\n\t   */\n\t  var PR_PUNCTUATION = 'pun';\n\t  /**\n\t   * token style for plain text.\n\t   * @const\n\t   */\n\t  var PR_PLAIN = 'pln';\n\t\n\t  /**\n\t   * token style for an sgml tag.\n\t   * @const\n\t   */\n\t  var PR_TAG = 'tag';\n\t  /**\n\t   * token style for a markup declaration such as a DOCTYPE.\n\t   * @const\n\t   */\n\t  var PR_DECLARATION = 'dec';\n\t  /**\n\t   * token style for embedded source.\n\t   * @const\n\t   */\n\t  var PR_SOURCE = 'src';\n\t  /**\n\t   * token style for an sgml attribute name.\n\t   * @const\n\t   */\n\t  var PR_ATTRIB_NAME = 'atn';\n\t  /**\n\t   * token style for an sgml attribute value.\n\t   * @const\n\t   */\n\t  var PR_ATTRIB_VALUE = 'atv';\n\t\n\t  /**\n\t   * A class that indicates a section of markup that is not code, e.g. to allow\n\t   * embedding of line numbers within code listings.\n\t   * @const\n\t   */\n\t  var PR_NOCODE = 'nocode';\n\t\n\t  /**\n\t   * A set of tokens that can precede a regular expression literal in\n\t   * javascript\n\t   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n\t   * has the full list, but I've removed ones that might be problematic when\n\t   * seen in languages that don't support regular expression literals.\n\t   *\n\t   * <p>Specifically, I've removed any keywords that can't precede a regexp\n\t   * literal in a syntactically legal javascript program, and I've removed the\n\t   * \"in\" keyword since it's not a keyword in many languages, and might be used\n\t   * as a count of inches.\n\t   *\n\t   * <p>The link above does not accurately describe EcmaScript rules since\n\t   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n\t   * very well in practice.\n\t   *\n\t   * @private\n\t   * @const\n\t   */\n\t  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n\t\n\t  // CAVEAT: this does not properly handle the case where a regular\n\t  // expression immediately follows another since a regular expression may\n\t  // have flags for case-sensitivity and the like.  Having regexp tokens\n\t  // adjacent is not valid in any language I'm aware of, so I'm punting.\n\t  // TODO: maybe style special characters inside a regexp as punctuation.\n\t\n\t  /**\n\t   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n\t   * matches the union of the sets of strings matched by the input RegExp.\n\t   * Since it matches globally, if the input strings have a start-of-input\n\t   * anchor (/^.../), it is ignored for the purposes of unioning.\n\t   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n\t   * @return {RegExp} a global regex.\n\t   */\n\t  function combinePrefixPatterns(regexs) {\n\t    var capturedGroupIndex = 0;\n\t\n\t    var needToFoldCase = false;\n\t    var ignoreCase = false;\n\t    for (var i = 0, n = regexs.length; i < n; ++i) {\n\t      var regex = regexs[i];\n\t      if (regex.ignoreCase) {\n\t        ignoreCase = true;\n\t      } else if (/[a-z]/i.test(regex.source.replace(/\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n\t        needToFoldCase = true;\n\t        ignoreCase = false;\n\t        break;\n\t      }\n\t    }\n\t\n\t    var escapeCharToCodeUnit = {\n\t      'b': 8,\n\t      't': 9,\n\t      'n': 0xa,\n\t      'v': 0xb,\n\t      'f': 0xc,\n\t      'r': 0xd\n\t    };\n\t\n\t    function decodeEscape(charsetPart) {\n\t      var cc0 = charsetPart.charCodeAt(0);\n\t      if (cc0 !== 92 /* \\\\ */) {\n\t          return cc0;\n\t        }\n\t      var c1 = charsetPart.charAt(1);\n\t      cc0 = escapeCharToCodeUnit[c1];\n\t      if (cc0) {\n\t        return cc0;\n\t      } else if ('0' <= c1 && c1 <= '7') {\n\t        return parseInt(charsetPart.substring(1), 8);\n\t      } else if (c1 === 'u' || c1 === 'x') {\n\t        return parseInt(charsetPart.substring(2), 16);\n\t      } else {\n\t        return charsetPart.charCodeAt(1);\n\t      }\n\t    }\n\t\n\t    function encodeEscape(charCode) {\n\t      if (charCode < 0x20) {\n\t        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n\t      }\n\t      var ch = String.fromCharCode(charCode);\n\t      return ch === '\\\\' || ch === '-' || ch === ']' || ch === '^' ? \"\\\\\" + ch : ch;\n\t    }\n\t\n\t    function caseFoldCharset(charSet) {\n\t      var charsetParts = charSet.substring(1, charSet.length - 1).match(new RegExp(\"\\\\\\\\u[0-9A-Fa-f]{4}\" + '|\\\\\\\\x[0-9A-Fa-f]{2}' + '|\\\\\\\\[0-3][0-7]{0,2}' + '|\\\\\\\\[0-7]{1,2}' + '|\\\\\\\\[\\\\s\\\\S]' + '|-' + '|[^-\\\\\\\\]', 'g'));\n\t      var ranges = [];\n\t      var inverse = charsetParts[0] === '^';\n\t\n\t      var out = ['['];\n\t      if (inverse) {\n\t        out.push('^');\n\t      }\n\t\n\t      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n\t        var p = charsetParts[i];\n\t        if (/\\\\[bdsw]/i.test(p)) {\n\t          // Don't muck with named groups.\n\t          out.push(p);\n\t        } else {\n\t          var start = decodeEscape(p);\n\t          var end;\n\t          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n\t            end = decodeEscape(charsetParts[i + 2]);\n\t            i += 2;\n\t          } else {\n\t            end = start;\n\t          }\n\t          ranges.push([start, end]);\n\t          // If the range might intersect letters, then expand it.\n\t          // This case handling is too simplistic.\n\t          // It does not deal with non-latin case folding.\n\t          // It works for latin source code identifiers though.\n\t          if (!(end < 65 || start > 122)) {\n\t            if (!(end < 65 || start > 90)) {\n\t              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n\t            }\n\t            if (!(end < 97 || start > 122)) {\n\t              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n\t      // -> [[1, 12], [14, 14], [16, 17]]\n\t      ranges.sort(function (a, b) {\n\t        return a[0] - b[0] || b[1] - a[1];\n\t      });\n\t      var consolidatedRanges = [];\n\t      var lastRange = [];\n\t      for (var i = 0; i < ranges.length; ++i) {\n\t        var range = ranges[i];\n\t        if (range[0] <= lastRange[1] + 1) {\n\t          lastRange[1] = Math.max(lastRange[1], range[1]);\n\t        } else {\n\t          consolidatedRanges.push(lastRange = range);\n\t        }\n\t      }\n\t\n\t      for (var i = 0; i < consolidatedRanges.length; ++i) {\n\t        var range = consolidatedRanges[i];\n\t        out.push(encodeEscape(range[0]));\n\t        if (range[1] > range[0]) {\n\t          if (range[1] + 1 > range[0]) {\n\t            out.push('-');\n\t          }\n\t          out.push(encodeEscape(range[1]));\n\t        }\n\t      }\n\t      out.push(']');\n\t      return out.join('');\n\t    }\n\t\n\t    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n\t      // Split into character sets, escape sequences, punctuation strings\n\t      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n\t      // include any of the above.\n\t      var parts = regex.source.match(new RegExp('(?:' + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]' // a character set\n\t       + \"|\\\\\\\\u[A-Fa-f0-9]{4}\" // a unicode escape\n\t       + '|\\\\\\\\x[A-Fa-f0-9]{2}' // a hex escape\n\t       + '|\\\\\\\\[0-9]+' // a back-reference or octal escape\n\t       + '|\\\\\\\\[^ux0-9]' // other escape sequence\n\t       + '|\\\\(\\\\?[:!=]' // start of a non-capturing group\n\t       + '|[\\\\(\\\\)\\\\^]' // start/end of a group, or line start\n\t       + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+' // run of other characters\n\t       + ')', 'g'));\n\t      var n = parts.length;\n\t\n\t      // Maps captured group numbers to the number they will occupy in\n\t      // the output or to -1 if that has not been determined, or to\n\t      // undefined if they need not be capturing in the output.\n\t      var capturedGroups = [];\n\t\n\t      // Walk over and identify back references to build the capturedGroups\n\t      // mapping.\n\t      for (var i = 0, groupIndex = 0; i < n; ++i) {\n\t        var p = parts[i];\n\t        if (p === '(') {\n\t          // groups are 1-indexed, so max group index is count of '('\n\t          ++groupIndex;\n\t        } else if ('\\\\' === p.charAt(0)) {\n\t          var decimalValue = +p.substring(1);\n\t          if (decimalValue) {\n\t            if (decimalValue <= groupIndex) {\n\t              capturedGroups[decimalValue] = -1;\n\t            } else {\n\t              // Replace with an unambiguous escape sequence so that\n\t              // an octal escape sequence does not turn into a backreference\n\t              // to a capturing group from an earlier regex.\n\t              parts[i] = encodeEscape(decimalValue);\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      // Renumber groups and reduce capturing groups to non-capturing groups\n\t      // where possible.\n\t      for (var i = 1; i < capturedGroups.length; ++i) {\n\t        if (-1 === capturedGroups[i]) {\n\t          capturedGroups[i] = ++capturedGroupIndex;\n\t        }\n\t      }\n\t      for (var i = 0, groupIndex = 0; i < n; ++i) {\n\t        var p = parts[i];\n\t        if (p === '(') {\n\t          ++groupIndex;\n\t          if (!capturedGroups[groupIndex]) {\n\t            parts[i] = '(?:';\n\t          }\n\t        } else if ('\\\\' === p.charAt(0)) {\n\t          var decimalValue = +p.substring(1);\n\t          if (decimalValue && decimalValue <= groupIndex) {\n\t            parts[i] = '\\\\' + capturedGroups[decimalValue];\n\t          }\n\t        }\n\t      }\n\t\n\t      // Remove any prefix anchors so that the output will match anywhere.\n\t      // ^^ really does mean an anchored match though.\n\t      for (var i = 0; i < n; ++i) {\n\t        if ('^' === parts[i] && '^' !== parts[i + 1]) {\n\t          parts[i] = '';\n\t        }\n\t      }\n\t\n\t      // Expand letters to groups to handle mixing of case-sensitive and\n\t      // case-insensitive patterns if necessary.\n\t      if (regex.ignoreCase && needToFoldCase) {\n\t        for (var i = 0; i < n; ++i) {\n\t          var p = parts[i];\n\t          var ch0 = p.charAt(0);\n\t          if (p.length >= 2 && ch0 === '[') {\n\t            parts[i] = caseFoldCharset(p);\n\t          } else if (ch0 !== '\\\\') {\n\t            // TODO: handle letters in numeric escapes.\n\t            parts[i] = p.replace(/[a-zA-Z]/g, function (ch) {\n\t              var cc = ch.charCodeAt(0);\n\t              return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n\t            });\n\t          }\n\t        }\n\t      }\n\t\n\t      return parts.join('');\n\t    }\n\t\n\t    var rewritten = [];\n\t    for (var i = 0, n = regexs.length; i < n; ++i) {\n\t      var regex = regexs[i];\n\t      if (regex.global || regex.multiline) {\n\t        throw new Error('' + regex);\n\t      }\n\t      rewritten.push('(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n\t    }\n\t\n\t    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n\t  }\n\t\n\t  /**\n\t   * Split markup into a string of source code and an array mapping ranges in\n\t   * that string to the text nodes in which they appear.\n\t   *\n\t   * <p>\n\t   * The HTML DOM structure:</p>\n\t   * <pre>\n\t   * (Element   \"p\"\n\t   *   (Element \"b\"\n\t   *     (Text  \"print \"))       ; #1\n\t   *   (Text    \"'Hello '\")      ; #2\n\t   *   (Element \"br\")            ; #3\n\t   *   (Text    \"  + 'World';\")) ; #4\n\t   * </pre>\n\t   * <p>\n\t   * corresponds to the HTML\n\t   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n\t   *\n\t   * <p>\n\t   * It will produce the output:</p>\n\t   * <pre>\n\t   * {\n\t   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n\t   *   //                     1          2\n\t   *   //           012345678901234 5678901234567\n\t   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n\t   * }\n\t   * </pre>\n\t   * <p>\n\t   * where #1 is a reference to the {@code \"print \"} text node above, and so\n\t   * on for the other text nodes.\n\t   * </p>\n\t   *\n\t   * <p>\n\t   * The {@code} spans array is an array of pairs.  Even elements are the start\n\t   * indices of substrings, and odd elements are the text nodes (or BR elements)\n\t   * that contain the text for those substrings.\n\t   * Substrings continue until the next index or the end of the source.\n\t   * </p>\n\t   *\n\t   * @param {Node} node an HTML DOM subtree containing source-code.\n\t   * @param {boolean|number} isPreformatted truthy if white-space in\n\t   *    text nodes should be considered significant.\n\t   * @return {SourceSpansT} source code and the nodes in which they occur.\n\t   */\n\t  function extractSourceSpans(node, isPreformatted) {\n\t    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\t\n\t    var chunks = [];\n\t    var length = 0;\n\t    var spans = [];\n\t    var k = 0;\n\t\n\t    function walk(node) {\n\t      var type = node.nodeType;\n\t      if (type == 1) {\n\t        // Element\n\t        if (nocode.test(node.className)) {\n\t          return;\n\t        }\n\t        for (var child = node.firstChild; child; child = child.nextSibling) {\n\t          walk(child);\n\t        }\n\t        var nodeName = node.nodeName.toLowerCase();\n\t        if ('br' === nodeName || 'li' === nodeName) {\n\t          chunks[k] = '\\n';\n\t          spans[k << 1] = length++;\n\t          spans[k++ << 1 | 1] = node;\n\t        }\n\t      } else if (type == 3 || type == 4) {\n\t        // Text\n\t        var text = node.nodeValue;\n\t        if (text.length) {\n\t          if (!isPreformatted) {\n\t            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n\t          } else {\n\t            text = text.replace(/\\r\\n?/g, '\\n'); // Normalize newlines.\n\t          }\n\t          // TODO: handle tabs here?\n\t          chunks[k] = text;\n\t          spans[k << 1] = length;\n\t          length += text.length;\n\t          spans[k++ << 1 | 1] = node;\n\t        }\n\t      }\n\t    }\n\t\n\t    walk(node);\n\t\n\t    return {\n\t      sourceCode: chunks.join('').replace(/\\n$/, ''),\n\t      spans: spans\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Apply the given language handler to sourceCode and add the resulting\n\t   * decorations to out.\n\t   * @param {!Element} sourceNode\n\t   * @param {number} basePos the index of sourceCode within the chunk of source\n\t   *    whose decorations are already present on out.\n\t   * @param {string} sourceCode\n\t   * @param {function(JobT)} langHandler\n\t   * @param {DecorationsT} out\n\t   */\n\t  function appendDecorations(sourceNode, basePos, sourceCode, langHandler, out) {\n\t    if (!sourceCode) {\n\t      return;\n\t    }\n\t    /** @type {JobT} */\n\t    var job = {\n\t      sourceNode: sourceNode,\n\t      pre: 1,\n\t      langExtension: null,\n\t      numberLines: null,\n\t      sourceCode: sourceCode,\n\t      spans: null,\n\t      basePos: basePos,\n\t      decorations: null\n\t    };\n\t    langHandler(job);\n\t    out.push.apply(out, job.decorations);\n\t  }\n\t\n\t  var notWs = /\\S/;\n\t\n\t  /**\n\t   * Given an element, if it contains only one child element and any text nodes\n\t   * it contains contain only space characters, return the sole child element.\n\t   * Otherwise returns undefined.\n\t   * <p>\n\t   * This is meant to return the CODE element in {@code <pre><code ...>} when\n\t   * there is a single child element that contains all the non-space textual\n\t   * content, but not to return anything where there are multiple child elements\n\t   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n\t   * is textual content.\n\t   */\n\t  function childContentWrapper(element) {\n\t    var wrapper = undefined;\n\t    for (var c = element.firstChild; c; c = c.nextSibling) {\n\t      var type = c.nodeType;\n\t      wrapper = type === 1 ? // Element Node\n\t      wrapper ? element : c : type === 3 ? // Text Node\n\t      notWs.test(c.nodeValue) ? element : wrapper : wrapper;\n\t    }\n\t    return wrapper === element ? undefined : wrapper;\n\t  }\n\t\n\t  /** Given triples of [style, pattern, context] returns a lexing function,\n\t    * The lexing function interprets the patterns to find token boundaries and\n\t    * returns a decoration list of the form\n\t    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n\t    * where index_n is an index into the sourceCode, and style_n is a style\n\t    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n\t    * all characters in sourceCode[index_n-1:index_n].\n\t    *\n\t    * The stylePatterns is a list whose elements have the form\n\t    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n\t    *\n\t    * Style is a style constant like PR_PLAIN, or can be a string of the\n\t    * form 'lang-FOO', where FOO is a language extension describing the\n\t    * language of the portion of the token in $1 after pattern executes.\n\t    * E.g., if style is 'lang-lisp', and group 1 contains the text\n\t    * '(hello (world))', then that portion of the token will be passed to the\n\t    * registered lisp handler for formatting.\n\t    * The text before and after group 1 will be restyled using this decorator\n\t    * so decorators should take care that this doesn't result in infinite\n\t    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n\t    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n\t    * '<script>foo()<\\/script>', which would cause the current decorator to\n\t    * be called with '<script>' which would not match the same rule since\n\t    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n\t    * the generic tag rule.  The handler registered for the 'js' extension would\n\t    * then be called with 'foo()', and finally, the current decorator would\n\t    * be called with '<\\/script>' which would not match the original rule and\n\t    * so the generic tag rule would identify it as a tag.\n\t    *\n\t    * Pattern must only match prefixes, and if it matches a prefix, then that\n\t    * match is considered a token with the same style.\n\t    *\n\t    * Context is applied to the last non-whitespace, non-comment token\n\t    * recognized.\n\t    *\n\t    * Shortcut is an optional string of characters, any of which, if the first\n\t    * character, gurantee that this pattern and only this pattern matches.\n\t    *\n\t    * @param {Array} shortcutStylePatterns patterns that always start with\n\t    *   a known character.  Must have a shortcut string.\n\t    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n\t    *   order if the shortcut ones fail.  May have shortcuts.\n\t    *\n\t    * @return {function (JobT)} a function that takes an undecorated job and\n\t    *   attaches a list of decorations.\n\t    */\n\t  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n\t    var shortcuts = {};\n\t    var tokenizer;\n\t    (function () {\n\t      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n\t      var allRegexs = [];\n\t      var regexKeys = {};\n\t      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n\t        var patternParts = allPatterns[i];\n\t        var shortcutChars = patternParts[3];\n\t        if (shortcutChars) {\n\t          for (var c = shortcutChars.length; --c >= 0;) {\n\t            shortcuts[shortcutChars.charAt(c)] = patternParts;\n\t          }\n\t        }\n\t        var regex = patternParts[1];\n\t        var k = '' + regex;\n\t        if (!regexKeys.hasOwnProperty(k)) {\n\t          allRegexs.push(regex);\n\t          regexKeys[k] = null;\n\t        }\n\t      }\n\t      allRegexs.push(/[\\0-\\uffff]/);\n\t      tokenizer = combinePrefixPatterns(allRegexs);\n\t    })();\n\t\n\t    var nPatterns = fallthroughStylePatterns.length;\n\t\n\t    /**\n\t     * Lexes job.sourceCode and attaches an output array job.decorations of\n\t     * style classes preceded by the position at which they start in\n\t     * job.sourceCode in order.\n\t     *\n\t     * @type{function (JobT)}\n\t     */\n\t    var decorate = function decorate(job) {\n\t      var sourceCode = job.sourceCode,\n\t          basePos = job.basePos;\n\t      var sourceNode = job.sourceNode;\n\t      /** Even entries are positions in source in ascending order.  Odd enties\n\t        * are style markers (e.g., PR_COMMENT) that run from that position until\n\t        * the end.\n\t        * @type {DecorationsT}\n\t        */\n\t      var decorations = [basePos, PR_PLAIN];\n\t      var pos = 0; // index into sourceCode\n\t      var tokens = sourceCode.match(tokenizer) || [];\n\t      var styleCache = {};\n\t\n\t      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n\t        var token = tokens[ti];\n\t        var style = styleCache[token];\n\t        var match = void 0;\n\t\n\t        var isEmbedded;\n\t        if (typeof style === 'string') {\n\t          isEmbedded = false;\n\t        } else {\n\t          var patternParts = shortcuts[token.charAt(0)];\n\t          if (patternParts) {\n\t            match = token.match(patternParts[1]);\n\t            style = patternParts[0];\n\t          } else {\n\t            for (var i = 0; i < nPatterns; ++i) {\n\t              patternParts = fallthroughStylePatterns[i];\n\t              match = token.match(patternParts[1]);\n\t              if (match) {\n\t                style = patternParts[0];\n\t                break;\n\t              }\n\t            }\n\t\n\t            if (!match) {\n\t              // make sure that we make progress\n\t              style = PR_PLAIN;\n\t            }\n\t          }\n\t\n\t          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n\t          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n\t            isEmbedded = false;\n\t            style = PR_SOURCE;\n\t          }\n\t\n\t          if (!isEmbedded) {\n\t            styleCache[token] = style;\n\t          }\n\t        }\n\t\n\t        var tokenStart = pos;\n\t        pos += token.length;\n\t\n\t        if (!isEmbedded) {\n\t          decorations.push(basePos + tokenStart, style);\n\t        } else {\n\t          // Treat group 1 as an embedded block of source code.\n\t          var embeddedSource = match[1];\n\t          var embeddedSourceStart = token.indexOf(embeddedSource);\n\t          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n\t          if (match[2]) {\n\t            // If embeddedSource can be blank, then it would match at the\n\t            // beginning which would cause us to infinitely recurse on the\n\t            // entire token, so we catch the right context in match[2].\n\t            embeddedSourceEnd = token.length - match[2].length;\n\t            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n\t          }\n\t          var lang = style.substring(5);\n\t          // Decorate the left of the embedded source\n\t          appendDecorations(sourceNode, basePos + tokenStart, token.substring(0, embeddedSourceStart), decorate, decorations);\n\t          // Decorate the embedded source\n\t          appendDecorations(sourceNode, basePos + tokenStart + embeddedSourceStart, embeddedSource, langHandlerForExtension(lang, embeddedSource), decorations);\n\t          // Decorate the right of the embedded section\n\t          appendDecorations(sourceNode, basePos + tokenStart + embeddedSourceEnd, token.substring(embeddedSourceEnd), decorate, decorations);\n\t        }\n\t      }\n\t      job.decorations = decorations;\n\t    };\n\t    return decorate;\n\t  }\n\t\n\t  /** returns a function that produces a list of decorations from source text.\n\t    *\n\t    * This code treats \", ', and ` as string delimiters, and \\ as a string\n\t    * escape.  It does not recognize perl's qq() style strings.\n\t    * It has no special handling for double delimiter escapes as in basic, or\n\t    * the tripled delimiters used in python, but should work on those regardless\n\t    * although in those cases a single string literal may be broken up into\n\t    * multiple adjacent string literals.\n\t    *\n\t    * It recognizes C, C++, and shell style comments.\n\t    *\n\t    * @param {Object} options a set of optional parameters.\n\t    * @return {function (JobT)} a function that examines the source code\n\t    *     in the input job and builds a decoration list which it attaches to\n\t    *     the job.\n\t    */\n\t  function sourceDecorator(options) {\n\t    var shortcutStylePatterns = [],\n\t        fallthroughStylePatterns = [];\n\t    if (options['tripleQuotedStrings']) {\n\t      // '''multi-line-string''', 'single-line-string', and double-quoted\n\t      shortcutStylePatterns.push([PR_STRING, /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/, null, '\\'\"']);\n\t    } else if (options['multiLineStrings']) {\n\t      // 'multi-line-string', \"multi-line-string\"\n\t      shortcutStylePatterns.push([PR_STRING, /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/, null, '\\'\"`']);\n\t    } else {\n\t      // 'single-line-string', \"single-line-string\"\n\t      shortcutStylePatterns.push([PR_STRING, /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/, null, '\"\\'']);\n\t    }\n\t    if (options['verbatimStrings']) {\n\t      // verbatim-string-literal production from the C# grammar.  See issue 93.\n\t      fallthroughStylePatterns.push([PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n\t    }\n\t    var hc = options['hashComments'];\n\t    if (hc) {\n\t      if (options['cStyleComments']) {\n\t        if (hc > 1) {\n\t          // multiline hash comments\n\t          shortcutStylePatterns.push([PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n\t        } else {\n\t          // Stop C preprocessor declarations at an unclosed open comment\n\t          shortcutStylePatterns.push([PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/, null, '#']);\n\t        }\n\t        // #include <stdio.h>\n\t        fallthroughStylePatterns.push([PR_STRING, /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/, null]);\n\t      } else {\n\t        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n\t      }\n\t    }\n\t    if (options['cStyleComments']) {\n\t      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n\t      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n\t    }\n\t    var regexLiterals = options['regexLiterals'];\n\t    if (regexLiterals) {\n\t      /**\n\t       * @const\n\t       */\n\t      var regexExcls = regexLiterals > 1 ? '' // Multiline regex literals\n\t      : '\\n\\r';\n\t      /**\n\t       * @const\n\t       */\n\t      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n\t      /**\n\t       * @const\n\t       */\n\t      var REGEX_LITERAL =\n\t      // A regular expression literal starts with a slash that is\n\t      // not followed by * or / so that it is not confused with\n\t      // comments.\n\t      '/(?=[^/*' + regexExcls + '])'\n\t      // and then contains any number of raw characters,\n\t       + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n\t      // escape sequences (\\x5C),\n\t       + '|\\\\x5C' + regexAny\n\t      // or non-nesting character sets (\\x5B\\x5D);\n\t       + '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']' + '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n\t      // finally closed by a /.\n\t       + '/';\n\t      fallthroughStylePatterns.push(['lang-regex', RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')]);\n\t    }\n\t\n\t    var types = options['types'];\n\t    if (types) {\n\t      fallthroughStylePatterns.push([PR_TYPE, types]);\n\t    }\n\t\n\t    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n\t    if (keywords.length) {\n\t      fallthroughStylePatterns.push([PR_KEYWORD, new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'), null]);\n\t    }\n\t\n\t    shortcutStylePatterns.push([PR_PLAIN, /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\t\n\t    var punctuation =\n\t    // The Bash man page says\n\t\n\t    // A word is a sequence of characters considered as a single\n\t    // unit by GRUB. Words are separated by metacharacters,\n\t    // which are the following plus space, tab, and newline: { }\n\t    // | & $ ; < >\n\t    // ...\n\t\n\t    // A word beginning with # causes that word and all remaining\n\t    // characters on that line to be ignored.\n\t\n\t    // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n\t    // comment but empirically\n\t    // $ echo {#}\n\t    // {#}\n\t    // $ echo \\$#\n\t    // $#\n\t    // $ echo }#\n\t    // }#\n\t\n\t    // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\t\n\t    // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n\t    // suggests that this definition is compatible with a\n\t    // default mode that tries to use a single token definition\n\t    // to recognize both bash/python style comments and C\n\t    // preprocessor directives.\n\t\n\t    // This definition of punctuation does not include # in the list of\n\t    // follow-on exclusions, so # will not be broken before if preceeded\n\t    // by a punctuation character.  We could try to exclude # after\n\t    // [|&;<>] but that doesn't seem to cause many major problems.\n\t    // If that does turn out to be a problem, we should change the below\n\t    // when hc is truthy to include # in the run of punctuation characters\n\t    // only when not followint [|&;<>].\n\t    '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n\t    if (options['regexLiterals']) {\n\t      punctuation += '(?!\\s*\\/)';\n\t    }\n\t\n\t    fallthroughStylePatterns.push(\n\t    // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n\t    [PR_LITERAL, /^@[a-z_$][a-z_$@0-9]*/i, null], [PR_TYPE, /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null], [PR_PLAIN, /^[a-z_$][a-z_$@0-9]*/i, null], [PR_LITERAL, new RegExp('^(?:'\n\t    // A hex number\n\t     + '0x[a-f0-9]+'\n\t    // or an octal or decimal number,\n\t     + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n\t    // possibly in scientific notation\n\t     + '(?:e[+\\\\-]?\\\\d+)?' + ')'\n\t    // with an optional modifier like UL for unsigned long\n\t     + '[a-z]*', 'i'), null, '0123456789'],\n\t    // Don't treat escaped quotes in bash as starting strings.\n\t    // See issue 144.\n\t    [PR_PLAIN, /^\\\\[\\s\\S]?/, null], [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\t\n\t    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n\t  }\n\t\n\t  var decorateSource = sourceDecorator({\n\t    'keywords': ALL_KEYWORDS,\n\t    'hashComments': true,\n\t    'cStyleComments': true,\n\t    'multiLineStrings': true,\n\t    'regexLiterals': true\n\t  });\n\t\n\t  /**\n\t   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n\t   * list item.\n\t   *\n\t   * @param {Node} node modified in place.  Its content is pulled into an\n\t   *     HTMLOListElement, and each line is moved into a separate list item.\n\t   *     This requires cloning elements, so the input might not have unique\n\t   *     IDs after numbering.\n\t   * @param {number|null|boolean} startLineNum\n\t   *     If truthy, coerced to an integer which is the 1-indexed line number\n\t   *     of the first line of code.  The number of the first line will be\n\t   *     attached to the list.\n\t   * @param {boolean} isPreformatted true iff white-space in text nodes should\n\t   *     be treated as significant.\n\t   */\n\t  function numberLines(node, startLineNum, isPreformatted) {\n\t    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\t    var lineBreak = /\\r\\n?|\\n/;\n\t\n\t    var document = node.ownerDocument;\n\t\n\t    var li = document.createElement('li');\n\t    while (node.firstChild) {\n\t      li.appendChild(node.firstChild);\n\t    }\n\t    // An array of lines.  We split below, so this is initialized to one\n\t    // un-split line.\n\t    var listItems = [li];\n\t\n\t    function walk(node) {\n\t      var type = node.nodeType;\n\t      if (type == 1 && !nocode.test(node.className)) {\n\t        // Element\n\t        if ('br' === node.nodeName) {\n\t          breakAfter(node);\n\t          // Discard the <BR> since it is now flush against a </LI>.\n\t          if (node.parentNode) {\n\t            node.parentNode.removeChild(node);\n\t          }\n\t        } else {\n\t          for (var child = node.firstChild; child; child = child.nextSibling) {\n\t            walk(child);\n\t          }\n\t        }\n\t      } else if ((type == 3 || type == 4) && isPreformatted) {\n\t        // Text\n\t        var text = node.nodeValue;\n\t        var match = text.match(lineBreak);\n\t        if (match) {\n\t          var firstLine = text.substring(0, match.index);\n\t          node.nodeValue = firstLine;\n\t          var tail = text.substring(match.index + match[0].length);\n\t          if (tail) {\n\t            var parent = node.parentNode;\n\t            parent.insertBefore(document.createTextNode(tail), node.nextSibling);\n\t          }\n\t          breakAfter(node);\n\t          if (!firstLine) {\n\t            // Don't leave blank text nodes in the DOM.\n\t            node.parentNode.removeChild(node);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Split a line after the given node.\n\t    function breakAfter(lineEndNode) {\n\t      // If there's nothing to the right, then we can skip ending the line\n\t      // here, and move root-wards since splitting just before an end-tag\n\t      // would require us to create a bunch of empty copies.\n\t      while (!lineEndNode.nextSibling) {\n\t        lineEndNode = lineEndNode.parentNode;\n\t        if (!lineEndNode) {\n\t          return;\n\t        }\n\t      }\n\t\n\t      function breakLeftOf(limit, copy) {\n\t        // Clone shallowly if this node needs to be on both sides of the break.\n\t        var rightSide = copy ? limit.cloneNode(false) : limit;\n\t        var parent = limit.parentNode;\n\t        if (parent) {\n\t          // We clone the parent chain.\n\t          // This helps us resurrect important styling elements that cross lines.\n\t          // E.g. in <i>Foo<br>Bar</i>\n\t          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n\t          var parentClone = breakLeftOf(parent, 1);\n\t          // Move the clone and everything to the right of the original\n\t          // onto the cloned parent.\n\t          var next = limit.nextSibling;\n\t          parentClone.appendChild(rightSide);\n\t          for (var sibling = next; sibling; sibling = next) {\n\t            next = sibling.nextSibling;\n\t            parentClone.appendChild(sibling);\n\t          }\n\t        }\n\t        return rightSide;\n\t      }\n\t\n\t      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n\t\n\t      // Walk the parent chain until we reach an unattached LI.\n\t      for (var parent;\n\t      // Check nodeType since IE invents document fragments.\n\t      (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n\t        copiedListItem = parent;\n\t      }\n\t      // Put it on the list of lines for later processing.\n\t      listItems.push(copiedListItem);\n\t    }\n\t\n\t    // Split lines while there are lines left to split.\n\t    for (var i = 0; // Number of lines that have been split so far.\n\t    i < listItems.length; // length updated by breakAfter calls.\n\t    ++i) {\n\t      walk(listItems[i]);\n\t    }\n\t\n\t    // Make sure numeric indices show correctly.\n\t    if (startLineNum === (startLineNum | 0)) {\n\t      listItems[0].setAttribute('value', startLineNum);\n\t    }\n\t\n\t    var ol = document.createElement('ol');\n\t    ol.className = 'linenums';\n\t    var offset = Math.max(0, startLineNum - 1 /* zero index */ | 0) || 0;\n\t    for (var i = 0, n = listItems.length; i < n; ++i) {\n\t      li = listItems[i];\n\t      // Stick a class on the LIs so that stylesheets can\n\t      // color odd/even rows, or any other row pattern that\n\t      // is co-prime with 10.\n\t      li.className = 'L' + (i + offset) % 10;\n\t      if (!li.firstChild) {\n\t        li.appendChild(document.createTextNode('\\xA0'));\n\t      }\n\t      ol.appendChild(li);\n\t    }\n\t\n\t    node.appendChild(ol);\n\t  }\n\t\n\t  /**\n\t   * Breaks {@code job.sourceCode} around style boundaries in\n\t   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n\t   * @param {JobT} job\n\t   * @private\n\t   */\n\t  function recombineTagsAndDecorations(job) {\n\t    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n\t    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n\t    var newlineRe = /\\n/g;\n\t\n\t    var source = job.sourceCode;\n\t    var sourceLength = source.length;\n\t    // Index into source after the last code-unit recombined.\n\t    var sourceIndex = 0;\n\t\n\t    var spans = job.spans;\n\t    var nSpans = spans.length;\n\t    // Index into spans after the last span which ends at or before sourceIndex.\n\t    var spanIndex = 0;\n\t\n\t    var decorations = job.decorations;\n\t    var nDecorations = decorations.length;\n\t    // Index into decorations after the last decoration which ends at or before\n\t    // sourceIndex.\n\t    var decorationIndex = 0;\n\t\n\t    // Remove all zero-length decorations.\n\t    decorations[nDecorations] = sourceLength;\n\t    var decPos, i;\n\t    for (i = decPos = 0; i < nDecorations;) {\n\t      if (decorations[i] !== decorations[i + 2]) {\n\t        decorations[decPos++] = decorations[i++];\n\t        decorations[decPos++] = decorations[i++];\n\t      } else {\n\t        i += 2;\n\t      }\n\t    }\n\t    nDecorations = decPos;\n\t\n\t    // Simplify decorations.\n\t    for (i = decPos = 0; i < nDecorations;) {\n\t      var startPos = decorations[i];\n\t      // Conflate all adjacent decorations that use the same style.\n\t      var startDec = decorations[i + 1];\n\t      var end = i + 2;\n\t      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n\t        end += 2;\n\t      }\n\t      decorations[decPos++] = startPos;\n\t      decorations[decPos++] = startDec;\n\t      i = end;\n\t    }\n\t\n\t    nDecorations = decorations.length = decPos;\n\t\n\t    var sourceNode = job.sourceNode;\n\t    var oldDisplay = \"\";\n\t    if (sourceNode) {\n\t      oldDisplay = sourceNode.style.display;\n\t      sourceNode.style.display = 'none';\n\t    }\n\t    try {\n\t      var decoration = null;\n\t      while (spanIndex < nSpans) {\n\t        var spanStart = spans[spanIndex];\n\t        var spanEnd = /** @type{number} */spans[spanIndex + 2] || sourceLength;\n\t\n\t        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n\t\n\t        var end = Math.min(spanEnd, decEnd);\n\t\n\t        var textNode = /** @type{Node} */spans[spanIndex + 1];\n\t        var styledText;\n\t        if (textNode.nodeType !== 1 // Don't muck with <BR>s or <LI>s\n\t        // Don't introduce spans around empty text nodes.\n\t         && (styledText = source.substring(sourceIndex, end))) {\n\t          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n\t          // code to display with spaces instead of line breaks.\n\t          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n\t          // space to appear at the beginning of every line but the first.\n\t          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n\t          if (isIE8OrEarlier) {\n\t            styledText = styledText.replace(newlineRe, '\\r');\n\t          }\n\t          textNode.nodeValue = styledText;\n\t          var document = textNode.ownerDocument;\n\t          var span = document.createElement('span');\n\t          span.className = decorations[decorationIndex + 1];\n\t          var parentNode = textNode.parentNode;\n\t          parentNode.replaceChild(span, textNode);\n\t          span.appendChild(textNode);\n\t          if (sourceIndex < spanEnd) {\n\t            // Split off a text node.\n\t            spans[spanIndex + 1] = textNode\n\t            // TODO: Possibly optimize by using '' if there's no flicker.\n\t             = document.createTextNode(source.substring(end, spanEnd));\n\t            parentNode.insertBefore(textNode, span.nextSibling);\n\t          }\n\t        }\n\t\n\t        sourceIndex = end;\n\t\n\t        if (sourceIndex >= spanEnd) {\n\t          spanIndex += 2;\n\t        }\n\t        if (sourceIndex >= decEnd) {\n\t          decorationIndex += 2;\n\t        }\n\t      }\n\t    } finally {\n\t      if (sourceNode) {\n\t        sourceNode.style.display = oldDisplay;\n\t      }\n\t    }\n\t  }\n\t\n\t  /** Maps language-specific file extensions to handlers. */\n\t  var langHandlerRegistry = {};\n\t  /** Register a language handler for the given file extensions.\n\t    * @param {function (JobT)} handler a function from source code to a list\n\t    *      of decorations.  Takes a single argument job which describes the\n\t    *      state of the computation and attaches the decorations to it.\n\t    * @param {Array.<string>} fileExtensions\n\t    */\n\t  function registerLangHandler(handler, fileExtensions) {\n\t    for (var i = fileExtensions.length; --i >= 0;) {\n\t      var ext = fileExtensions[i];\n\t      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n\t        langHandlerRegistry[ext] = handler;\n\t      } else if (win['console']) {\n\t        console['warn']('cannot override language handler %s', ext);\n\t      }\n\t    }\n\t  }\n\t  function langHandlerForExtension(extension, source) {\n\t    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n\t      // Treat it as markup if the first non whitespace character is a < and\n\t      // the last non-whitespace character is a >.\n\t      extension = /^\\s*</.test(source) ? 'default-markup' : 'default-code';\n\t    }\n\t    return langHandlerRegistry[extension];\n\t  }\n\t  registerLangHandler(decorateSource, ['default-code']);\n\t  registerLangHandler(createSimpleLexer([], [[PR_PLAIN, /^[^<?]+/], [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/], [PR_COMMENT, /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n\t  // Unescaped content in an unknown language\n\t  ['lang-', /^<\\?([\\s\\S]+?)(?:\\?>|$)/], ['lang-', /^<%([\\s\\S]+?)(?:%>|$)/], [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/], ['lang-', /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n\t  // Unescaped content in javascript.  (Or possibly vbscript).\n\t  ['lang-js', /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n\t  // Contains unescaped stylesheet content\n\t  ['lang-css', /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i], ['lang-in.tag', /^(<\\/?[a-z][^<>]*>)/i]]), ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n\t  registerLangHandler(createSimpleLexer([[PR_PLAIN, /^[\\s]+/, null, ' \\t\\r\\n'], [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']], [[PR_TAG, /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i], [PR_ATTRIB_NAME, /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i], ['lang-uq.val', /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/], [PR_PUNCTUATION, /^[=<>\\/]+/], ['lang-js', /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i], ['lang-js', /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i], ['lang-js', /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i], ['lang-css', /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i], ['lang-css', /^style\\s*=\\s*\\'([^\\']+)\\'/i], ['lang-css', /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]]), ['in.tag']);\n\t  registerLangHandler(createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': CPP_KEYWORDS,\n\t    'hashComments': true,\n\t    'cStyleComments': true,\n\t    'types': C_TYPES\n\t  }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': 'null,true,false'\n\t  }), ['json']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': CSHARP_KEYWORDS,\n\t    'hashComments': true,\n\t    'cStyleComments': true,\n\t    'verbatimStrings': true,\n\t    'types': C_TYPES\n\t  }), ['cs']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': JAVA_KEYWORDS,\n\t    'cStyleComments': true\n\t  }), ['java']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': SH_KEYWORDS,\n\t    'hashComments': true,\n\t    'multiLineStrings': true\n\t  }), ['bash', 'bsh', 'csh', 'sh']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': PYTHON_KEYWORDS,\n\t    'hashComments': true,\n\t    'multiLineStrings': true,\n\t    'tripleQuotedStrings': true\n\t  }), ['cv', 'py', 'python']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': PERL_KEYWORDS,\n\t    'hashComments': true,\n\t    'multiLineStrings': true,\n\t    'regexLiterals': 2 // multiline regex literals\n\t  }), ['perl', 'pl', 'pm']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': RUBY_KEYWORDS,\n\t    'hashComments': true,\n\t    'multiLineStrings': true,\n\t    'regexLiterals': true\n\t  }), ['rb', 'ruby']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': JSCRIPT_KEYWORDS,\n\t    'cStyleComments': true,\n\t    'regexLiterals': true\n\t  }), ['javascript', 'js', 'ts', 'typescript']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': COFFEE_KEYWORDS,\n\t    'hashComments': 3, // ### style block comments\n\t    'cStyleComments': true,\n\t    'multilineStrings': true,\n\t    'tripleQuotedStrings': true,\n\t    'regexLiterals': true\n\t  }), ['coffee']);\n\t  registerLangHandler(createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\t\n\t  /** @param {JobT} job */\n\t  function applyDecorator(job) {\n\t    var opt_langExtension = job.langExtension;\n\t\n\t    try {\n\t      // Extract tags, and convert the source code to plain text.\n\t      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n\t      /** Plain text. @type {string} */\n\t      var source = sourceAndSpans.sourceCode;\n\t      job.sourceCode = source;\n\t      job.spans = sourceAndSpans.spans;\n\t      job.basePos = 0;\n\t\n\t      // Apply the appropriate language handler\n\t      langHandlerForExtension(opt_langExtension, source)(job);\n\t\n\t      // Integrate the decorations and tags back into the source code,\n\t      // modifying the sourceNode in place.\n\t      recombineTagsAndDecorations(job);\n\t    } catch (e) {\n\t      if (win['console']) {\n\t        console['log'](e && e['stack'] || e);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Pretty print a chunk of code.\n\t   * @param sourceCodeHtml {string} The HTML to pretty print.\n\t   * @param opt_langExtension {string} The language name to use.\n\t   *     Typically, a filename extension like 'cpp' or 'java'.\n\t   * @param opt_numberLines {number|boolean} True to number lines,\n\t   *     or the 1-indexed number of the first line in sourceCodeHtml.\n\t   */\n\t  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n\t    /** @type{number|boolean} */\n\t    var nl = opt_numberLines || false;\n\t    /** @type{string|null} */\n\t    var langExtension = opt_langExtension || null;\n\t    /** @type{!Element} */\n\t    var container = document.createElement('div');\n\t    // This could cause images to load and onload listeners to fire.\n\t    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n\t    // We assume that the inner HTML is from a trusted source.\n\t    // The pre-tag is required for IE8 which strips newlines from innerHTML\n\t    // when it is injected into a <pre> tag.\n\t    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n\t    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n\t    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n\t    container = /** @type{!Element} */container.firstChild;\n\t    if (nl) {\n\t      numberLines(container, nl, true);\n\t    }\n\t\n\t    /** @type{JobT} */\n\t    var job = {\n\t      langExtension: langExtension,\n\t      numberLines: nl,\n\t      sourceNode: container,\n\t      pre: 1,\n\t      sourceCode: null,\n\t      basePos: null,\n\t      spans: null,\n\t      decorations: null\n\t    };\n\t    applyDecorator(job);\n\t    return container.innerHTML;\n\t  }\n\t\n\t  /**\n\t   * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n\t   * {@code class=prettyprint} and prettify them.\n\t   *\n\t   * @param {Function} opt_whenDone called when prettifying is done.\n\t   * @param {HTMLElement|HTMLDocument} opt_root an element or document\n\t   *   containing all the elements to pretty print.\n\t   *   Defaults to {@code document.body}.\n\t   */\n\t  function $prettyPrint(opt_whenDone, opt_root) {\n\t    var root = opt_root || document.body;\n\t    var doc = root.ownerDocument || document;\n\t    function byTagName(tn) {\n\t      return root.getElementsByTagName(tn);\n\t    }\n\t    // fetch a list of nodes to rewrite\n\t    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n\t    var elements = [];\n\t    for (var i = 0; i < codeSegments.length; ++i) {\n\t      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n\t        elements.push(codeSegments[i][j]);\n\t      }\n\t    }\n\t    codeSegments = null;\n\t\n\t    var clock = Date;\n\t    if (!clock['now']) {\n\t      clock = { 'now': function now() {\n\t          return +new Date();\n\t        } };\n\t    }\n\t\n\t    // The loop is broken into a series of continuations to make sure that we\n\t    // don't make the browser unresponsive when rewriting a large page.\n\t    var k = 0;\n\t\n\t    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n\t    var prettyPrintRe = /\\bprettyprint\\b/;\n\t    var prettyPrintedRe = /\\bprettyprinted\\b/;\n\t    var preformattedTagNameRe = /pre|xmp/i;\n\t    var codeRe = /^code$/i;\n\t    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n\t    var EMPTY = {};\n\t\n\t    function doWork() {\n\t      var endTime = win['PR_SHOULD_USE_CONTINUATION'] ? clock['now']() + 250 /* ms */ : Infinity;\n\t      for (; k < elements.length && clock['now']() < endTime; k++) {\n\t        var cs = elements[k];\n\t\n\t        // Look for a preceding comment like\n\t        // <?prettify lang=\"...\" linenums=\"...\"?>\n\t        var attrs = EMPTY;\n\t        {\n\t          for (var preceder = cs; preceder = preceder.previousSibling;) {\n\t            var nt = preceder.nodeType;\n\t            // <?foo?> is parsed by HTML 5 to a comment node (8)\n\t            // like <!--?foo?-->, but in XML is a processing instruction\n\t            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n\t            if (value ? !/^\\??prettify\\b/.test(value) : nt !== 3 || /\\S/.test(preceder.nodeValue)) {\n\t              // Skip over white-space text nodes but not others.\n\t              break;\n\t            }\n\t            if (value) {\n\t              attrs = {};\n\t              value.replace(/\\b(\\w+)=([\\w:.%+-]+)/g, function (_, name, value) {\n\t                attrs[name] = value;\n\t              });\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        var className = cs.className;\n\t        if ((attrs !== EMPTY || prettyPrintRe.test(className)) &&\n\t        // Don't redo this if we've already done it.\n\t        // This allows recalling pretty print to just prettyprint elements\n\t        // that have been added to the page since last call.\n\t        !prettyPrintedRe.test(className)) {\n\t\n\t          // make sure this is not nested in an already prettified element\n\t          var nested = false;\n\t          for (var p = cs.parentNode; p; p = p.parentNode) {\n\t            var tn = p.tagName;\n\t            if (preCodeXmpRe.test(tn) && p.className && prettyPrintRe.test(p.className)) {\n\t              nested = true;\n\t              break;\n\t            }\n\t          }\n\t          if (!nested) {\n\t            // Mark done.  If we fail to prettyprint for whatever reason,\n\t            // we shouldn't try again.\n\t            cs.className += ' prettyprinted';\n\t\n\t            // If the classes includes a language extensions, use it.\n\t            // Language extensions can be specified like\n\t            //     <pre class=\"prettyprint lang-cpp\">\n\t            // the language extension \"cpp\" is used to find a language handler\n\t            // as passed to PR.registerLangHandler.\n\t            // HTML5 recommends that a language be specified using \"language-\"\n\t            // as the prefix instead.  Google Code Prettify supports both.\n\t            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n\t            var langExtension = attrs['lang'];\n\t            if (!langExtension) {\n\t              langExtension = className.match(langExtensionRe);\n\t              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n\t              var wrapper;\n\t              if (!langExtension && (wrapper = childContentWrapper(cs)) && codeRe.test(wrapper.tagName)) {\n\t                langExtension = wrapper.className.match(langExtensionRe);\n\t              }\n\t\n\t              if (langExtension) {\n\t                langExtension = langExtension[1];\n\t              }\n\t            }\n\t\n\t            var preformatted;\n\t            if (preformattedTagNameRe.test(cs.tagName)) {\n\t              preformatted = 1;\n\t            } else {\n\t              var currentStyle = cs['currentStyle'];\n\t              var defaultView = doc.defaultView;\n\t              var whitespace = currentStyle ? currentStyle['whiteSpace'] : defaultView && defaultView.getComputedStyle ? defaultView.getComputedStyle(cs, null).getPropertyValue('white-space') : 0;\n\t              preformatted = whitespace && 'pre' === whitespace.substring(0, 3);\n\t            }\n\t\n\t            // Look for a class like linenums or linenums:<n> where <n> is the\n\t            // 1-indexed number of the first line.\n\t            var lineNums = attrs['linenums'];\n\t            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n\t              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n\t              lineNums = lineNums ? lineNums[1] && lineNums[1].length ? +lineNums[1] : true : false;\n\t            }\n\t            if (lineNums) {\n\t              numberLines(cs, lineNums, preformatted);\n\t            }\n\t\n\t            // do the pretty printing\n\t            var prettyPrintingJob = {\n\t              langExtension: langExtension,\n\t              sourceNode: cs,\n\t              numberLines: lineNums,\n\t              pre: preformatted,\n\t              sourceCode: null,\n\t              basePos: null,\n\t              spans: null,\n\t              decorations: null\n\t            };\n\t            applyDecorator(prettyPrintingJob);\n\t          }\n\t        }\n\t      }\n\t      if (k < elements.length) {\n\t        // finish up in a continuation\n\t        win.setTimeout(doWork, 250);\n\t      } else if ('function' === typeof opt_whenDone) {\n\t        opt_whenDone();\n\t      }\n\t    }\n\t\n\t    doWork();\n\t  }\n\t\n\t  /**\n\t   * Contains functions for creating and registering new language handlers.\n\t   * @type {Object}\n\t   */\n\t  var PR = win['PR'] = {\n\t    'createSimpleLexer': createSimpleLexer,\n\t    'registerLangHandler': registerLangHandler,\n\t    'sourceDecorator': sourceDecorator,\n\t    'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n\t    'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n\t    'PR_COMMENT': PR_COMMENT,\n\t    'PR_DECLARATION': PR_DECLARATION,\n\t    'PR_KEYWORD': PR_KEYWORD,\n\t    'PR_LITERAL': PR_LITERAL,\n\t    'PR_NOCODE': PR_NOCODE,\n\t    'PR_PLAIN': PR_PLAIN,\n\t    'PR_PUNCTUATION': PR_PUNCTUATION,\n\t    'PR_SOURCE': PR_SOURCE,\n\t    'PR_STRING': PR_STRING,\n\t    'PR_TAG': PR_TAG,\n\t    'PR_TYPE': PR_TYPE,\n\t    'prettyPrintOne': IN_GLOBAL_SCOPE ? win['prettyPrintOne'] = $prettyPrintOne : prettyPrintOne = $prettyPrintOne,\n\t    'prettyPrint': prettyPrint = IN_GLOBAL_SCOPE ? win['prettyPrint'] = $prettyPrint : prettyPrint = $prettyPrint\n\t  };\n\t\n\t  // Make PR available via the Asynchronous Module Definition (AMD) API.\n\t  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n\t  // The Asynchronous Module Definition (AMD) API specifies a\n\t  // mechanism for defining modules such that the module and its\n\t  // dependencies can be asynchronously loaded.\n\t  // ...\n\t  // To allow a clear indicator that a global define function (as\n\t  // needed for script src browser loading) conforms to the AMD API,\n\t  // any global define function SHOULD have a property called \"amd\"\n\t  // whose value is an object. This helps avoid conflict with any\n\t  // other existing JavaScript code that could have defined a define()\n\t  // function that does not conform to the AMD API.\n\t  var define = win['define'];\n\t  if (typeof define === \"function\" && define['amd']) {\n\t    define(\"google-code-prettify\", [], function () {\n\t      return PR;\n\t    });\n\t  }\n\t})();\n\n/***/ },\n\n/***/ 78:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\t * Super simple wysiwyg editor v0.8.2\n\t * http://summernote.org/\n\t *\n\t * summernote.js\n\t * Copyright 2013-2016 Alan Hong. and other contributors\n\t * summernote may be freely distributed under the MIT license./\n\t *\n\t * Date: 2016-08-07T05:11Z\n\t */\n\t(function (factory) {\n\t  /* global define */\n\t  if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof module === 'object' && module.exports) {\n\t    // Node/CommonJS\n\t    module.exports = factory(require('jquery'));\n\t  } else {\n\t    // Browser globals\n\t    factory(window.jQuery);\n\t  }\n\t}(function ($) {\n\t  'use strict';\n\t\n\t  /**\n\t   * @class core.func\n\t   *\n\t   * func utils (for high-order func's arg)\n\t   *\n\t   * @singleton\n\t   * @alternateClassName func\n\t   */\n\t  var func = (function () {\n\t    var eq = function (itemA) {\n\t      return function (itemB) {\n\t        return itemA === itemB;\n\t      };\n\t    };\n\t\n\t    var eq2 = function (itemA, itemB) {\n\t      return itemA === itemB;\n\t    };\n\t\n\t    var peq2 = function (propName) {\n\t      return function (itemA, itemB) {\n\t        return itemA[propName] === itemB[propName];\n\t      };\n\t    };\n\t\n\t    var ok = function () {\n\t      return true;\n\t    };\n\t\n\t    var fail = function () {\n\t      return false;\n\t    };\n\t\n\t    var not = function (f) {\n\t      return function () {\n\t        return !f.apply(f, arguments);\n\t      };\n\t    };\n\t\n\t    var and = function (fA, fB) {\n\t      return function (item) {\n\t        return fA(item) && fB(item);\n\t      };\n\t    };\n\t\n\t    var self = function (a) {\n\t      return a;\n\t    };\n\t\n\t    var invoke = function (obj, method) {\n\t      return function () {\n\t        return obj[method].apply(obj, arguments);\n\t      };\n\t    };\n\t\n\t    var idCounter = 0;\n\t\n\t    /**\n\t     * generate a globally-unique id\n\t     *\n\t     * @param {String} [prefix]\n\t     */\n\t    var uniqueId = function (prefix) {\n\t      var id = ++idCounter + '';\n\t      return prefix ? prefix + id : id;\n\t    };\n\t\n\t    /**\n\t     * returns bnd (bounds) from rect\n\t     *\n\t     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n\t     * - Scroll Issue: http://goo.gl/sNjUc\n\t     *\n\t     * @param {Rect} rect\n\t     * @return {Object} bounds\n\t     * @return {Number} bounds.top\n\t     * @return {Number} bounds.left\n\t     * @return {Number} bounds.width\n\t     * @return {Number} bounds.height\n\t     */\n\t    var rect2bnd = function (rect) {\n\t      var $document = $(document);\n\t      return {\n\t        top: rect.top + $document.scrollTop(),\n\t        left: rect.left + $document.scrollLeft(),\n\t        width: rect.right - rect.left,\n\t        height: rect.bottom - rect.top\n\t      };\n\t    };\n\t\n\t    /**\n\t     * returns a copy of the object where the keys have become the values and the values the keys.\n\t     * @param {Object} obj\n\t     * @return {Object}\n\t     */\n\t    var invertObject = function (obj) {\n\t      var inverted = {};\n\t      for (var key in obj) {\n\t        if (obj.hasOwnProperty(key)) {\n\t          inverted[obj[key]] = key;\n\t        }\n\t      }\n\t      return inverted;\n\t    };\n\t\n\t    /**\n\t     * @param {String} namespace\n\t     * @param {String} [prefix]\n\t     * @return {String}\n\t     */\n\t    var namespaceToCamel = function (namespace, prefix) {\n\t      prefix = prefix || '';\n\t      return prefix + namespace.split('.').map(function (name) {\n\t        return name.substring(0, 1).toUpperCase() + name.substring(1);\n\t      }).join('');\n\t    };\n\t\n\t    /**\n\t     * Returns a function, that, as long as it continues to be invoked, will not\n\t     * be triggered. The function will be called after it stops being called for\n\t     * N milliseconds. If `immediate` is passed, trigger the function on the\n\t     * leading edge, instead of the trailing.\n\t     * @param {Function} func\n\t     * @param {Number} wait\n\t     * @param {Boolean} immediate\n\t     * @return {Function}\n\t     */\n\t    var debounce = function (func, wait, immediate) {\n\t      var timeout;\n\t      return function () {\n\t        var context = this, args = arguments;\n\t        var later = function () {\n\t          timeout = null;\n\t          if (!immediate) {\n\t            func.apply(context, args);\n\t          }\n\t        };\n\t        var callNow = immediate && !timeout;\n\t        clearTimeout(timeout);\n\t        timeout = setTimeout(later, wait);\n\t        if (callNow) {\n\t          func.apply(context, args);\n\t        }\n\t      };\n\t    };\n\t\n\t    return {\n\t      eq: eq,\n\t      eq2: eq2,\n\t      peq2: peq2,\n\t      ok: ok,\n\t      fail: fail,\n\t      self: self,\n\t      not: not,\n\t      and: and,\n\t      invoke: invoke,\n\t      uniqueId: uniqueId,\n\t      rect2bnd: rect2bnd,\n\t      invertObject: invertObject,\n\t      namespaceToCamel: namespaceToCamel,\n\t      debounce: debounce\n\t    };\n\t  })();\n\t\n\t  /**\n\t   * @class core.list\n\t   *\n\t   * list utils\n\t   *\n\t   * @singleton\n\t   * @alternateClassName list\n\t   */\n\t  var list = (function () {\n\t    /**\n\t     * returns the first item of an array.\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var head = function (array) {\n\t      return array[0];\n\t    };\n\t\n\t    /**\n\t     * returns the last item of an array.\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var last = function (array) {\n\t      return array[array.length - 1];\n\t    };\n\t\n\t    /**\n\t     * returns everything but the last entry of the array.\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var initial = function (array) {\n\t      return array.slice(0, array.length - 1);\n\t    };\n\t\n\t    /**\n\t     * returns the rest of the items in an array.\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var tail = function (array) {\n\t      return array.slice(1);\n\t    };\n\t\n\t    /**\n\t     * returns item of array\n\t     */\n\t    var find = function (array, pred) {\n\t      for (var idx = 0, len = array.length; idx < len; idx ++) {\n\t        var item = array[idx];\n\t        if (pred(item)) {\n\t          return item;\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * returns true if all of the values in the array pass the predicate truth test.\n\t     */\n\t    var all = function (array, pred) {\n\t      for (var idx = 0, len = array.length; idx < len; idx ++) {\n\t        if (!pred(array[idx])) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    };\n\t\n\t    /**\n\t     * returns index of item\n\t     */\n\t    var indexOf = function (array, item) {\n\t      return $.inArray(item, array);\n\t    };\n\t\n\t    /**\n\t     * returns true if the value is present in the list.\n\t     */\n\t    var contains = function (array, item) {\n\t      return indexOf(array, item) !== -1;\n\t    };\n\t\n\t    /**\n\t     * get sum from a list\n\t     *\n\t     * @param {Array} array - array\n\t     * @param {Function} fn - iterator\n\t     */\n\t    var sum = function (array, fn) {\n\t      fn = fn || func.self;\n\t      return array.reduce(function (memo, v) {\n\t        return memo + fn(v);\n\t      }, 0);\n\t    };\n\t  \n\t    /**\n\t     * returns a copy of the collection with array type.\n\t     * @param {Collection} collection - collection eg) node.childNodes, ...\n\t     */\n\t    var from = function (collection) {\n\t      var result = [], idx = -1, length = collection.length;\n\t      while (++idx < length) {\n\t        result[idx] = collection[idx];\n\t      }\n\t      return result;\n\t    };\n\t\n\t    /**\n\t     * returns whether list is empty or not\n\t     */\n\t    var isEmpty = function (array) {\n\t      return !array || !array.length;\n\t    };\n\t  \n\t    /**\n\t     * cluster elements by predicate function.\n\t     *\n\t     * @param {Array} array - array\n\t     * @param {Function} fn - predicate function for cluster rule\n\t     * @param {Array[]}\n\t     */\n\t    var clusterBy = function (array, fn) {\n\t      if (!array.length) { return []; }\n\t      var aTail = tail(array);\n\t      return aTail.reduce(function (memo, v) {\n\t        var aLast = last(memo);\n\t        if (fn(last(aLast), v)) {\n\t          aLast[aLast.length] = v;\n\t        } else {\n\t          memo[memo.length] = [v];\n\t        }\n\t        return memo;\n\t      }, [[head(array)]]);\n\t    };\n\t  \n\t    /**\n\t     * returns a copy of the array with all false values removed\n\t     *\n\t     * @param {Array} array - array\n\t     * @param {Function} fn - predicate function for cluster rule\n\t     */\n\t    var compact = function (array) {\n\t      var aResult = [];\n\t      for (var idx = 0, len = array.length; idx < len; idx ++) {\n\t        if (array[idx]) { aResult.push(array[idx]); }\n\t      }\n\t      return aResult;\n\t    };\n\t\n\t    /**\n\t     * produces a duplicate-free version of the array\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var unique = function (array) {\n\t      var results = [];\n\t\n\t      for (var idx = 0, len = array.length; idx < len; idx ++) {\n\t        if (!contains(results, array[idx])) {\n\t          results.push(array[idx]);\n\t        }\n\t      }\n\t\n\t      return results;\n\t    };\n\t\n\t    /**\n\t     * returns next item.\n\t     * @param {Array} array\n\t     */\n\t    var next = function (array, item) {\n\t      var idx = indexOf(array, item);\n\t      if (idx === -1) { return null; }\n\t\n\t      return array[idx + 1];\n\t    };\n\t\n\t    /**\n\t     * returns prev item.\n\t     * @param {Array} array\n\t     */\n\t    var prev = function (array, item) {\n\t      var idx = indexOf(array, item);\n\t      if (idx === -1) { return null; }\n\t\n\t      return array[idx - 1];\n\t    };\n\t\n\t    return { head: head, last: last, initial: initial, tail: tail,\n\t             prev: prev, next: next, find: find, contains: contains,\n\t             all: all, sum: sum, from: from, isEmpty: isEmpty,\n\t             clusterBy: clusterBy, compact: compact, unique: unique };\n\t  })();\n\t\n\t  var isSupportAmd = \"function\" === 'function' && __webpack_require__(79);\n\t\n\t  /**\n\t   * returns whether font is installed or not.\n\t   *\n\t   * @param {String} fontName\n\t   * @return {Boolean}\n\t   */\n\t  var isFontInstalled = function (fontName) {\n\t    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n\t    var $tester = $('<div>').css({\n\t      position: 'absolute',\n\t      left: '-9999px',\n\t      top: '-9999px',\n\t      fontSize: '200px'\n\t    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\t\n\t    var originalWidth = $tester.css('fontFamily', testFontName).width();\n\t    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\t\n\t    $tester.remove();\n\t\n\t    return originalWidth !== width;\n\t  };\n\t\n\t  var userAgent = navigator.userAgent;\n\t  var isMSIE = /MSIE|Trident/i.test(userAgent);\n\t  var browserVersion;\n\t  if (isMSIE) {\n\t    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n\t    if (matches) {\n\t      browserVersion = parseFloat(matches[1]);\n\t    }\n\t    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n\t    if (matches) {\n\t      browserVersion = parseFloat(matches[1]);\n\t    }\n\t  }\n\t\n\t  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\t\n\t  var hasCodeMirror = !!window.CodeMirror;\n\t  if (!hasCodeMirror && isSupportAmd && \"function\" !== 'undefined') {\n\t    if (true) {\n\t      try {\n\t        // If CodeMirror can't be resolved, `require.resolve` will throw an\n\t        // exception and `hasCodeMirror` won't be set to `true`.\n\t        /*require.resolve*/(80);\n\t        hasCodeMirror = true;\n\t      } catch (e) {\n\t        // Do nothing.\n\t      }\n\t    } else if (typeof eval('require').specified !== 'undefined') {\n\t      hasCodeMirror = eval('require').specified('codemirror');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * @class core.agent\n\t   *\n\t   * Object which check platform and agent\n\t   *\n\t   * @singleton\n\t   * @alternateClassName agent\n\t   */\n\t  var agent = {\n\t    isMac: navigator.appVersion.indexOf('Mac') > -1,\n\t    isMSIE: isMSIE,\n\t    isEdge: isEdge,\n\t    isFF: !isEdge && /firefox/i.test(userAgent),\n\t    isPhantom: /PhantomJS/i.test(userAgent),\n\t    isWebkit: !isEdge && /webkit/i.test(userAgent),\n\t    isChrome: !isEdge && /chrome/i.test(userAgent),\n\t    isSafari: !isEdge && /safari/i.test(userAgent),\n\t    browserVersion: browserVersion,\n\t    jqueryVersion: parseFloat($.fn.jquery),\n\t    isSupportAmd: isSupportAmd,\n\t    hasCodeMirror: hasCodeMirror,\n\t    isFontInstalled: isFontInstalled,\n\t    isW3CRangeSupport: !!document.createRange\n\t  };\n\t\n\t\n\t  var NBSP_CHAR = String.fromCharCode(160);\n\t  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\t\n\t  /**\n\t   * @class core.dom\n\t   *\n\t   * Dom functions\n\t   *\n\t   * @singleton\n\t   * @alternateClassName dom\n\t   */\n\t  var dom = (function () {\n\t    /**\n\t     * @method isEditable\n\t     *\n\t     * returns whether node is `note-editable` or not.\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean}\n\t     */\n\t    var isEditable = function (node) {\n\t      return node && $(node).hasClass('note-editable');\n\t    };\n\t\n\t    /**\n\t     * @method isControlSizing\n\t     *\n\t     * returns whether node is `note-control-sizing` or not.\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean}\n\t     */\n\t    var isControlSizing = function (node) {\n\t      return node && $(node).hasClass('note-control-sizing');\n\t    };\n\t\n\t    /**\n\t     * @method makePredByNodeName\n\t     *\n\t     * returns predicate which judge whether nodeName is same\n\t     *\n\t     * @param {String} nodeName\n\t     * @return {Function}\n\t     */\n\t    var makePredByNodeName = function (nodeName) {\n\t      nodeName = nodeName.toUpperCase();\n\t      return function (node) {\n\t        return node && node.nodeName.toUpperCase() === nodeName;\n\t      };\n\t    };\n\t\n\t    /**\n\t     * @method isText\n\t     *\n\t     *\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean} true if node's type is text(3)\n\t     */\n\t    var isText = function (node) {\n\t      return node && node.nodeType === 3;\n\t    };\n\t\n\t    /**\n\t     * @method isElement\n\t     *\n\t     *\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean} true if node's type is element(1)\n\t     */\n\t    var isElement = function (node) {\n\t      return node && node.nodeType === 1;\n\t    };\n\t\n\t    /**\n\t     * ex) br, col, embed, hr, img, input, ...\n\t     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n\t     */\n\t    var isVoid = function (node) {\n\t      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isPara = function (node) {\n\t      if (isEditable(node)) {\n\t        return false;\n\t      }\n\t\n\t      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n\t      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isHeading = function (node) {\n\t      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isPre = makePredByNodeName('PRE');\n\t\n\t    var isLi = makePredByNodeName('LI');\n\t\n\t    var isPurePara = function (node) {\n\t      return isPara(node) && !isLi(node);\n\t    };\n\t\n\t    var isTable = makePredByNodeName('TABLE');\n\t\n\t    var isData = makePredByNodeName('DATA');\n\t\n\t    var isInline = function (node) {\n\t      return !isBodyContainer(node) &&\n\t             !isList(node) &&\n\t             !isHr(node) &&\n\t             !isPara(node) &&\n\t             !isTable(node) &&\n\t             !isBlockquote(node) &&\n\t             !isData(node);\n\t    };\n\t\n\t    var isList = function (node) {\n\t      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isHr = makePredByNodeName('HR');\n\t\n\t    var isCell = function (node) {\n\t      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\t\n\t    var isBodyContainer = function (node) {\n\t      return isCell(node) || isBlockquote(node) || isEditable(node);\n\t    };\n\t\n\t    var isAnchor = makePredByNodeName('A');\n\t\n\t    var isParaInline = function (node) {\n\t      return isInline(node) && !!ancestor(node, isPara);\n\t    };\n\t\n\t    var isBodyInline = function (node) {\n\t      return isInline(node) && !ancestor(node, isPara);\n\t    };\n\t\n\t    var isBody = makePredByNodeName('BODY');\n\t\n\t    /**\n\t     * returns whether nodeB is closest sibling of nodeA\n\t     *\n\t     * @param {Node} nodeA\n\t     * @param {Node} nodeB\n\t     * @return {Boolean}\n\t     */\n\t    var isClosestSibling = function (nodeA, nodeB) {\n\t      return nodeA.nextSibling === nodeB ||\n\t             nodeA.previousSibling === nodeB;\n\t    };\n\t\n\t    /**\n\t     * returns array of closest siblings with node\n\t     *\n\t     * @param {Node} node\n\t     * @param {function} [pred] - predicate function\n\t     * @return {Node[]}\n\t     */\n\t    var withClosestSiblings = function (node, pred) {\n\t      pred = pred || func.ok;\n\t\n\t      var siblings = [];\n\t      if (node.previousSibling && pred(node.previousSibling)) {\n\t        siblings.push(node.previousSibling);\n\t      }\n\t      siblings.push(node);\n\t      if (node.nextSibling && pred(node.nextSibling)) {\n\t        siblings.push(node.nextSibling);\n\t      }\n\t      return siblings;\n\t    };\n\t\n\t    /**\n\t     * blank HTML for cursor position\n\t     * - [workaround] old IE only works with &nbsp;\n\t     * - [workaround] IE11 and other browser works with bogus br\n\t     */\n\t    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\t\n\t    /**\n\t     * @method nodeLength\n\t     *\n\t     * returns #text's text size or element's childNodes size\n\t     *\n\t     * @param {Node} node\n\t     */\n\t    var nodeLength = function (node) {\n\t      if (isText(node)) {\n\t        return node.nodeValue.length;\n\t      }\n\t      \n\t      if (node) {\n\t        return node.childNodes.length;\n\t      }\n\t      \n\t      return 0;\n\t      \n\t    };\n\t\n\t    /**\n\t     * returns whether node is empty or not.\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean}\n\t     */\n\t    var isEmpty = function (node) {\n\t      var len = nodeLength(node);\n\t\n\t      if (len === 0) {\n\t        return true;\n\t      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n\t        // ex) <p><br></p>, <span><br></span>\n\t        return true;\n\t      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n\t        // ex) <p></p>, <span></span>\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    /**\n\t     * padding blankHTML if node is empty (for cursor position)\n\t     */\n\t    var paddingBlankHTML = function (node) {\n\t      if (!isVoid(node) && !nodeLength(node)) {\n\t        node.innerHTML = blankHTML;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * find nearest ancestor predicate hit\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} pred - predicate function\n\t     */\n\t    var ancestor = function (node, pred) {\n\t      while (node) {\n\t        if (pred(node)) { return node; }\n\t        if (isEditable(node)) { break; }\n\t\n\t        node = node.parentNode;\n\t      }\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * find nearest ancestor only single child blood line and predicate hit\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} pred - predicate function\n\t     */\n\t    var singleChildAncestor = function (node, pred) {\n\t      node = node.parentNode;\n\t\n\t      while (node) {\n\t        if (nodeLength(node) !== 1) { break; }\n\t        if (pred(node)) { return node; }\n\t        if (isEditable(node)) { break; }\n\t\n\t        node = node.parentNode;\n\t      }\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * returns new array of ancestor nodes (until predicate hit).\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} [optional] pred - predicate function\n\t     */\n\t    var listAncestor = function (node, pred) {\n\t      pred = pred || func.fail;\n\t\n\t      var ancestors = [];\n\t      ancestor(node, function (el) {\n\t        if (!isEditable(el)) {\n\t          ancestors.push(el);\n\t        }\n\t\n\t        return pred(el);\n\t      });\n\t      return ancestors;\n\t    };\n\t\n\t    /**\n\t     * find farthest ancestor predicate hit\n\t     */\n\t    var lastAncestor = function (node, pred) {\n\t      var ancestors = listAncestor(node);\n\t      return list.last(ancestors.filter(pred));\n\t    };\n\t\n\t    /**\n\t     * returns common ancestor node between two nodes.\n\t     *\n\t     * @param {Node} nodeA\n\t     * @param {Node} nodeB\n\t     */\n\t    var commonAncestor = function (nodeA, nodeB) {\n\t      var ancestors = listAncestor(nodeA);\n\t      for (var n = nodeB; n; n = n.parentNode) {\n\t        if ($.inArray(n, ancestors) > -1) { return n; }\n\t      }\n\t      return null; // difference document area\n\t    };\n\t\n\t    /**\n\t     * listing all previous siblings (until predicate hit).\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} [optional] pred - predicate function\n\t     */\n\t    var listPrev = function (node, pred) {\n\t      pred = pred || func.fail;\n\t\n\t      var nodes = [];\n\t      while (node) {\n\t        if (pred(node)) { break; }\n\t        nodes.push(node);\n\t        node = node.previousSibling;\n\t      }\n\t      return nodes;\n\t    };\n\t\n\t    /**\n\t     * listing next siblings (until predicate hit).\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} [pred] - predicate function\n\t     */\n\t    var listNext = function (node, pred) {\n\t      pred = pred || func.fail;\n\t\n\t      var nodes = [];\n\t      while (node) {\n\t        if (pred(node)) { break; }\n\t        nodes.push(node);\n\t        node = node.nextSibling;\n\t      }\n\t      return nodes;\n\t    };\n\t\n\t    /**\n\t     * listing descendant nodes\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} [pred] - predicate function\n\t     */\n\t    var listDescendant = function (node, pred) {\n\t      var descendants = [];\n\t      pred = pred || func.ok;\n\t\n\t      // start DFS(depth first search) with node\n\t      (function fnWalk(current) {\n\t        if (node !== current && pred(current)) {\n\t          descendants.push(current);\n\t        }\n\t        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n\t          fnWalk(current.childNodes[idx]);\n\t        }\n\t      })(node);\n\t\n\t      return descendants;\n\t    };\n\t\n\t    /**\n\t     * wrap node with new tag.\n\t     *\n\t     * @param {Node} node\n\t     * @param {Node} tagName of wrapper\n\t     * @return {Node} - wrapper\n\t     */\n\t    var wrap = function (node, wrapperName) {\n\t      var parent = node.parentNode;\n\t      var wrapper = $('<' + wrapperName + '>')[0];\n\t\n\t      parent.insertBefore(wrapper, node);\n\t      wrapper.appendChild(node);\n\t\n\t      return wrapper;\n\t    };\n\t\n\t    /**\n\t     * insert node after preceding\n\t     *\n\t     * @param {Node} node\n\t     * @param {Node} preceding - predicate function\n\t     */\n\t    var insertAfter = function (node, preceding) {\n\t      var next = preceding.nextSibling, parent = preceding.parentNode;\n\t      if (next) {\n\t        parent.insertBefore(node, next);\n\t      } else {\n\t        parent.appendChild(node);\n\t      }\n\t      return node;\n\t    };\n\t\n\t    /**\n\t     * append elements.\n\t     *\n\t     * @param {Node} node\n\t     * @param {Collection} aChild\n\t     */\n\t    var appendChildNodes = function (node, aChild) {\n\t      $.each(aChild, function (idx, child) {\n\t        node.appendChild(child);\n\t      });\n\t      return node;\n\t    };\n\t\n\t    /**\n\t     * returns whether boundaryPoint is left edge or not.\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @return {Boolean}\n\t     */\n\t    var isLeftEdgePoint = function (point) {\n\t      return point.offset === 0;\n\t    };\n\t\n\t    /**\n\t     * returns whether boundaryPoint is right edge or not.\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @return {Boolean}\n\t     */\n\t    var isRightEdgePoint = function (point) {\n\t      return point.offset === nodeLength(point.node);\n\t    };\n\t\n\t    /**\n\t     * returns whether boundaryPoint is edge or not.\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @return {Boolean}\n\t     */\n\t    var isEdgePoint = function (point) {\n\t      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n\t    };\n\t\n\t    /**\n\t     * returns whether node is left edge of ancestor or not.\n\t     *\n\t     * @param {Node} node\n\t     * @param {Node} ancestor\n\t     * @return {Boolean}\n\t     */\n\t    var isLeftEdgeOf = function (node, ancestor) {\n\t      while (node && node !== ancestor) {\n\t        if (position(node) !== 0) {\n\t          return false;\n\t        }\n\t        node = node.parentNode;\n\t      }\n\t\n\t      return true;\n\t    };\n\t\n\t    /**\n\t     * returns whether node is right edge of ancestor or not.\n\t     *\n\t     * @param {Node} node\n\t     * @param {Node} ancestor\n\t     * @return {Boolean}\n\t     */\n\t    var isRightEdgeOf = function (node, ancestor) {\n\t      if (!ancestor) {\n\t        return false;\n\t      }\n\t      while (node && node !== ancestor) {\n\t        if (position(node) !== nodeLength(node.parentNode) - 1) {\n\t          return false;\n\t        }\n\t        node = node.parentNode;\n\t      }\n\t\n\t      return true;\n\t    };\n\t\n\t    /**\n\t     * returns whether point is left edge of ancestor or not.\n\t     * @param {BoundaryPoint} point\n\t     * @param {Node} ancestor\n\t     * @return {Boolean}\n\t     */\n\t    var isLeftEdgePointOf = function (point, ancestor) {\n\t      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n\t    };\n\t\n\t    /**\n\t     * returns whether point is right edge of ancestor or not.\n\t     * @param {BoundaryPoint} point\n\t     * @param {Node} ancestor\n\t     * @return {Boolean}\n\t     */\n\t    var isRightEdgePointOf = function (point, ancestor) {\n\t      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n\t    };\n\t\n\t    /**\n\t     * returns offset from parent.\n\t     *\n\t     * @param {Node} node\n\t     */\n\t    var position = function (node) {\n\t      var offset = 0;\n\t      while ((node = node.previousSibling)) {\n\t        offset += 1;\n\t      }\n\t      return offset;\n\t    };\n\t\n\t    var hasChildren = function (node) {\n\t      return !!(node && node.childNodes && node.childNodes.length);\n\t    };\n\t\n\t    /**\n\t     * returns previous boundaryPoint\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Boolean} isSkipInnerOffset\n\t     * @return {BoundaryPoint}\n\t     */\n\t    var prevPoint = function (point, isSkipInnerOffset) {\n\t      var node, offset;\n\t\n\t      if (point.offset === 0) {\n\t        if (isEditable(point.node)) {\n\t          return null;\n\t        }\n\t\n\t        node = point.node.parentNode;\n\t        offset = position(point.node);\n\t      } else if (hasChildren(point.node)) {\n\t        node = point.node.childNodes[point.offset - 1];\n\t        offset = nodeLength(node);\n\t      } else {\n\t        node = point.node;\n\t        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n\t      }\n\t\n\t      return {\n\t        node: node,\n\t        offset: offset\n\t      };\n\t    };\n\t\n\t    /**\n\t     * returns next boundaryPoint\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Boolean} isSkipInnerOffset\n\t     * @return {BoundaryPoint}\n\t     */\n\t    var nextPoint = function (point, isSkipInnerOffset) {\n\t      var node, offset;\n\t\n\t      if (nodeLength(point.node) === point.offset) {\n\t        if (isEditable(point.node)) {\n\t          return null;\n\t        }\n\t\n\t        node = point.node.parentNode;\n\t        offset = position(point.node) + 1;\n\t      } else if (hasChildren(point.node)) {\n\t        node = point.node.childNodes[point.offset];\n\t        offset = 0;\n\t      } else {\n\t        node = point.node;\n\t        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n\t      }\n\t\n\t      return {\n\t        node: node,\n\t        offset: offset\n\t      };\n\t    };\n\t\n\t    /**\n\t     * returns whether pointA and pointB is same or not.\n\t     *\n\t     * @param {BoundaryPoint} pointA\n\t     * @param {BoundaryPoint} pointB\n\t     * @return {Boolean}\n\t     */\n\t    var isSamePoint = function (pointA, pointB) {\n\t      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n\t    };\n\t\n\t    /**\n\t     * returns whether point is visible (can set cursor) or not.\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @return {Boolean}\n\t     */\n\t    var isVisiblePoint = function (point) {\n\t      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n\t        return true;\n\t      }\n\t\n\t      var leftNode = point.node.childNodes[point.offset - 1];\n\t      var rightNode = point.node.childNodes[point.offset];\n\t      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    /**\n\t     * @method prevPointUtil\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Function} pred\n\t     * @return {BoundaryPoint}\n\t     */\n\t    var prevPointUntil = function (point, pred) {\n\t      while (point) {\n\t        if (pred(point)) {\n\t          return point;\n\t        }\n\t\n\t        point = prevPoint(point);\n\t      }\n\t\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * @method nextPointUntil\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Function} pred\n\t     * @return {BoundaryPoint}\n\t     */\n\t    var nextPointUntil = function (point, pred) {\n\t      while (point) {\n\t        if (pred(point)) {\n\t          return point;\n\t        }\n\t\n\t        point = nextPoint(point);\n\t      }\n\t\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * returns whether point has character or not.\n\t     *\n\t     * @param {Point} point\n\t     * @return {Boolean}\n\t     */\n\t    var isCharPoint = function (point) {\n\t      if (!isText(point.node)) {\n\t        return false;\n\t      }\n\t\n\t      var ch = point.node.nodeValue.charAt(point.offset - 1);\n\t      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n\t    };\n\t\n\t    /**\n\t     * @method walkPoint\n\t     *\n\t     * @param {BoundaryPoint} startPoint\n\t     * @param {BoundaryPoint} endPoint\n\t     * @param {Function} handler\n\t     * @param {Boolean} isSkipInnerOffset\n\t     */\n\t    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n\t      var point = startPoint;\n\t\n\t      while (point) {\n\t        handler(point);\n\t\n\t        if (isSamePoint(point, endPoint)) {\n\t          break;\n\t        }\n\t\n\t        var isSkipOffset = isSkipInnerOffset &&\n\t                           startPoint.node !== point.node &&\n\t                           endPoint.node !== point.node;\n\t        point = nextPoint(point, isSkipOffset);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @method makeOffsetPath\n\t     *\n\t     * return offsetPath(array of offset) from ancestor\n\t     *\n\t     * @param {Node} ancestor - ancestor node\n\t     * @param {Node} node\n\t     */\n\t    var makeOffsetPath = function (ancestor, node) {\n\t      var ancestors = listAncestor(node, func.eq(ancestor));\n\t      return ancestors.map(position).reverse();\n\t    };\n\t\n\t    /**\n\t     * @method fromOffsetPath\n\t     *\n\t     * return element from offsetPath(array of offset)\n\t     *\n\t     * @param {Node} ancestor - ancestor node\n\t     * @param {array} offsets - offsetPath\n\t     */\n\t    var fromOffsetPath = function (ancestor, offsets) {\n\t      var current = ancestor;\n\t      for (var i = 0, len = offsets.length; i < len; i++) {\n\t        if (current.childNodes.length <= offsets[i]) {\n\t          current = current.childNodes[current.childNodes.length - 1];\n\t        } else {\n\t          current = current.childNodes[offsets[i]];\n\t        }\n\t      }\n\t      return current;\n\t    };\n\t\n\t    /**\n\t     * @method splitNode\n\t     *\n\t     * split element or #text\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Object} [options]\n\t     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n\t     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n\t     * @return {Node} right node of boundaryPoint\n\t     */\n\t    var splitNode = function (point, options) {\n\t      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n\t      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\t\n\t      // edge case\n\t      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n\t        if (isLeftEdgePoint(point)) {\n\t          return point.node;\n\t        } else if (isRightEdgePoint(point)) {\n\t          return point.node.nextSibling;\n\t        }\n\t      }\n\t\n\t      // split #text\n\t      if (isText(point.node)) {\n\t        return point.node.splitText(point.offset);\n\t      } else {\n\t        var childNode = point.node.childNodes[point.offset];\n\t        var clone = insertAfter(point.node.cloneNode(false), point.node);\n\t        appendChildNodes(clone, listNext(childNode));\n\t\n\t        if (!isSkipPaddingBlankHTML) {\n\t          paddingBlankHTML(point.node);\n\t          paddingBlankHTML(clone);\n\t        }\n\t\n\t        return clone;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @method splitTree\n\t     *\n\t     * split tree by point\n\t     *\n\t     * @param {Node} root - split root\n\t     * @param {BoundaryPoint} point\n\t     * @param {Object} [options]\n\t     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n\t     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n\t     * @return {Node} right node of boundaryPoint\n\t     */\n\t    var splitTree = function (root, point, options) {\n\t      // ex) [#text, <span>, <p>]\n\t      var ancestors = listAncestor(point.node, func.eq(root));\n\t\n\t      if (!ancestors.length) {\n\t        return null;\n\t      } else if (ancestors.length === 1) {\n\t        return splitNode(point, options);\n\t      }\n\t\n\t      return ancestors.reduce(function (node, parent) {\n\t        if (node === point.node) {\n\t          node = splitNode(point, options);\n\t        }\n\t\n\t        return splitNode({\n\t          node: parent,\n\t          offset: node ? dom.position(node) : nodeLength(parent)\n\t        }, options);\n\t      });\n\t    };\n\t\n\t    /**\n\t     * split point\n\t     *\n\t     * @param {Point} point\n\t     * @param {Boolean} isInline\n\t     * @return {Object}\n\t     */\n\t    var splitPoint = function (point, isInline) {\n\t      // find splitRoot, container\n\t      //  - inline: splitRoot is a child of paragraph\n\t      //  - block: splitRoot is a child of bodyContainer\n\t      var pred = isInline ? isPara : isBodyContainer;\n\t      var ancestors = listAncestor(point.node, pred);\n\t      var topAncestor = list.last(ancestors) || point.node;\n\t\n\t      var splitRoot, container;\n\t      if (pred(topAncestor)) {\n\t        splitRoot = ancestors[ancestors.length - 2];\n\t        container = topAncestor;\n\t      } else {\n\t        splitRoot = topAncestor;\n\t        container = splitRoot.parentNode;\n\t      }\n\t\n\t      // if splitRoot is exists, split with splitTree\n\t      var pivot = splitRoot && splitTree(splitRoot, point, {\n\t        isSkipPaddingBlankHTML: isInline,\n\t        isNotSplitEdgePoint: isInline\n\t      });\n\t\n\t      // if container is point.node, find pivot with point.offset\n\t      if (!pivot && container === point.node) {\n\t        pivot = point.node.childNodes[point.offset];\n\t      }\n\t\n\t      return {\n\t        rightNode: pivot,\n\t        container: container\n\t      };\n\t    };\n\t\n\t    var create = function (nodeName) {\n\t      return document.createElement(nodeName);\n\t    };\n\t\n\t    var createText = function (text) {\n\t      return document.createTextNode(text);\n\t    };\n\t\n\t    /**\n\t     * @method remove\n\t     *\n\t     * remove node, (isRemoveChild: remove child or not)\n\t     *\n\t     * @param {Node} node\n\t     * @param {Boolean} isRemoveChild\n\t     */\n\t    var remove = function (node, isRemoveChild) {\n\t      if (!node || !node.parentNode) { return; }\n\t      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\t\n\t      var parent = node.parentNode;\n\t      if (!isRemoveChild) {\n\t        var nodes = [];\n\t        var i, len;\n\t        for (i = 0, len = node.childNodes.length; i < len; i++) {\n\t          nodes.push(node.childNodes[i]);\n\t        }\n\t\n\t        for (i = 0, len = nodes.length; i < len; i++) {\n\t          parent.insertBefore(nodes[i], node);\n\t        }\n\t      }\n\t\n\t      parent.removeChild(node);\n\t    };\n\t\n\t    /**\n\t     * @method removeWhile\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} pred\n\t     */\n\t    var removeWhile = function (node, pred) {\n\t      while (node) {\n\t        if (isEditable(node) || !pred(node)) {\n\t          break;\n\t        }\n\t\n\t        var parent = node.parentNode;\n\t        remove(node);\n\t        node = parent;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @method replace\n\t     *\n\t     * replace node with provided nodeName\n\t     *\n\t     * @param {Node} node\n\t     * @param {String} nodeName\n\t     * @return {Node} - new node\n\t     */\n\t    var replace = function (node, nodeName) {\n\t      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n\t        return node;\n\t      }\n\t\n\t      var newNode = create(nodeName);\n\t\n\t      if (node.style.cssText) {\n\t        newNode.style.cssText = node.style.cssText;\n\t      }\n\t\n\t      appendChildNodes(newNode, list.from(node.childNodes));\n\t      insertAfter(newNode, node);\n\t      remove(node);\n\t\n\t      return newNode;\n\t    };\n\t\n\t    var isTextarea = makePredByNodeName('TEXTAREA');\n\t\n\t    /**\n\t     * @param {jQuery} $node\n\t     * @param {Boolean} [stripLinebreaks] - default: false\n\t     */\n\t    var value = function ($node, stripLinebreaks) {\n\t      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n\t      if (stripLinebreaks) {\n\t        return val.replace(/[\\n\\r]/g, '');\n\t      }\n\t      return val;\n\t    };\n\t\n\t    /**\n\t     * @method html\n\t     *\n\t     * get the HTML contents of node\n\t     *\n\t     * @param {jQuery} $node\n\t     * @param {Boolean} [isNewlineOnBlock]\n\t     */\n\t    var html = function ($node, isNewlineOnBlock) {\n\t      var markup = value($node);\n\t\n\t      if (isNewlineOnBlock) {\n\t        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n\t        markup = markup.replace(regexTag, function (match, endSlash, name) {\n\t          name = name.toUpperCase();\n\t          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n\t                                       !!endSlash;\n\t          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\t\n\t          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n\t        });\n\t        markup = $.trim(markup);\n\t      }\n\t\n\t      return markup;\n\t    };\n\t\n\t    var posFromPlaceholder = function (placeholder) {\n\t      var $placeholder = $(placeholder);\n\t      var pos = $placeholder.offset();\n\t      var height = $placeholder.outerHeight(true); // include margin\n\t\n\t      return {\n\t        left: pos.left,\n\t        top: pos.top + height\n\t      };\n\t    };\n\t\n\t    var attachEvents = function ($node, events) {\n\t      Object.keys(events).forEach(function (key) {\n\t        $node.on(key, events[key]);\n\t      });\n\t    };\n\t\n\t    var detachEvents = function ($node, events) {\n\t      Object.keys(events).forEach(function (key) {\n\t        $node.off(key, events[key]);\n\t      });\n\t    };\n\t\n\t    return {\n\t      /** @property {String} NBSP_CHAR */\n\t      NBSP_CHAR: NBSP_CHAR,\n\t      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n\t      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n\t      /** @property {String} blank */\n\t      blank: blankHTML,\n\t      /** @property {String} emptyPara */\n\t      emptyPara: '<p>' + blankHTML + '</p>',\n\t      makePredByNodeName: makePredByNodeName,\n\t      isEditable: isEditable,\n\t      isControlSizing: isControlSizing,\n\t      isText: isText,\n\t      isElement: isElement,\n\t      isVoid: isVoid,\n\t      isPara: isPara,\n\t      isPurePara: isPurePara,\n\t      isHeading: isHeading,\n\t      isInline: isInline,\n\t      isBlock: func.not(isInline),\n\t      isBodyInline: isBodyInline,\n\t      isBody: isBody,\n\t      isParaInline: isParaInline,\n\t      isPre: isPre,\n\t      isList: isList,\n\t      isTable: isTable,\n\t      isData: isData,\n\t      isCell: isCell,\n\t      isBlockquote: isBlockquote,\n\t      isBodyContainer: isBodyContainer,\n\t      isAnchor: isAnchor,\n\t      isDiv: makePredByNodeName('DIV'),\n\t      isLi: isLi,\n\t      isBR: makePredByNodeName('BR'),\n\t      isSpan: makePredByNodeName('SPAN'),\n\t      isB: makePredByNodeName('B'),\n\t      isU: makePredByNodeName('U'),\n\t      isS: makePredByNodeName('S'),\n\t      isI: makePredByNodeName('I'),\n\t      isImg: makePredByNodeName('IMG'),\n\t      isTextarea: isTextarea,\n\t      isEmpty: isEmpty,\n\t      isEmptyAnchor: func.and(isAnchor, isEmpty),\n\t      isClosestSibling: isClosestSibling,\n\t      withClosestSiblings: withClosestSiblings,\n\t      nodeLength: nodeLength,\n\t      isLeftEdgePoint: isLeftEdgePoint,\n\t      isRightEdgePoint: isRightEdgePoint,\n\t      isEdgePoint: isEdgePoint,\n\t      isLeftEdgeOf: isLeftEdgeOf,\n\t      isRightEdgeOf: isRightEdgeOf,\n\t      isLeftEdgePointOf: isLeftEdgePointOf,\n\t      isRightEdgePointOf: isRightEdgePointOf,\n\t      prevPoint: prevPoint,\n\t      nextPoint: nextPoint,\n\t      isSamePoint: isSamePoint,\n\t      isVisiblePoint: isVisiblePoint,\n\t      prevPointUntil: prevPointUntil,\n\t      nextPointUntil: nextPointUntil,\n\t      isCharPoint: isCharPoint,\n\t      walkPoint: walkPoint,\n\t      ancestor: ancestor,\n\t      singleChildAncestor: singleChildAncestor,\n\t      listAncestor: listAncestor,\n\t      lastAncestor: lastAncestor,\n\t      listNext: listNext,\n\t      listPrev: listPrev,\n\t      listDescendant: listDescendant,\n\t      commonAncestor: commonAncestor,\n\t      wrap: wrap,\n\t      insertAfter: insertAfter,\n\t      appendChildNodes: appendChildNodes,\n\t      position: position,\n\t      hasChildren: hasChildren,\n\t      makeOffsetPath: makeOffsetPath,\n\t      fromOffsetPath: fromOffsetPath,\n\t      splitTree: splitTree,\n\t      splitPoint: splitPoint,\n\t      create: create,\n\t      createText: createText,\n\t      remove: remove,\n\t      removeWhile: removeWhile,\n\t      replace: replace,\n\t      html: html,\n\t      value: value,\n\t      posFromPlaceholder: posFromPlaceholder,\n\t      attachEvents: attachEvents,\n\t      detachEvents: detachEvents\n\t    };\n\t  })();\n\t\n\t  /**\n\t   * @param {jQuery} $note\n\t   * @param {Object} options\n\t   * @return {Context}\n\t   */\n\t  var Context = function ($note, options) {\n\t    var self = this;\n\t\n\t    var ui = $.summernote.ui;\n\t    this.memos = {};\n\t    this.modules = {};\n\t    this.layoutInfo = {};\n\t    this.options = options;\n\t\n\t    /**\n\t     * create layout and initialize modules and other resources\n\t     */\n\t    this.initialize = function () {\n\t      this.layoutInfo = ui.createLayout($note, options);\n\t      this._initialize();\n\t      $note.hide();\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * destroy modules and other resources and remove layout\n\t     */\n\t    this.destroy = function () {\n\t      this._destroy();\n\t      $note.removeData('summernote');\n\t      ui.removeLayout($note, this.layoutInfo);\n\t    };\n\t\n\t    /**\n\t     * destory modules and other resources and initialize it again\n\t     */\n\t    this.reset = function () {\n\t      var disabled = self.isDisabled();\n\t      this.code(dom.emptyPara);\n\t      this._destroy();\n\t      this._initialize();\n\t\n\t      if (disabled) {\n\t        self.disable();\n\t      }\n\t    };\n\t\n\t    this._initialize = function () {\n\t      // add optional buttons\n\t      var buttons = $.extend({}, this.options.buttons);\n\t      Object.keys(buttons).forEach(function (key) {\n\t        self.memo('button.' + key, buttons[key]);\n\t      });\n\t\n\t      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\t\n\t      // add and initialize modules\n\t      Object.keys(modules).forEach(function (key) {\n\t        self.module(key, modules[key], true);\n\t      });\n\t\n\t      Object.keys(this.modules).forEach(function (key) {\n\t        self.initializeModule(key);\n\t      });\n\t    };\n\t\n\t    this._destroy = function () {\n\t      // destroy modules with reversed order\n\t      Object.keys(this.modules).reverse().forEach(function (key) {\n\t        self.removeModule(key);\n\t      });\n\t\n\t      Object.keys(this.memos).forEach(function (key) {\n\t        self.removeMemo(key);\n\t      });\n\t    };\n\t\n\t    this.code = function (html) {\n\t      var isActivated = this.invoke('codeview.isActivated');\n\t\n\t      if (html === undefined) {\n\t        this.invoke('codeview.sync');\n\t        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n\t      } else {\n\t        if (isActivated) {\n\t          this.layoutInfo.codable.val(html);\n\t        } else {\n\t          this.layoutInfo.editable.html(html);\n\t        }\n\t        $note.val(html);\n\t        this.triggerEvent('change', html);\n\t      }\n\t    };\n\t\n\t    this.isDisabled = function () {\n\t      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n\t    };\n\t\n\t    this.enable = function () {\n\t      this.layoutInfo.editable.attr('contenteditable', true);\n\t      this.invoke('toolbar.activate', true);\n\t    };\n\t\n\t    this.disable = function () {\n\t      // close codeview if codeview is opend\n\t      if (this.invoke('codeview.isActivated')) {\n\t        this.invoke('codeview.deactivate');\n\t      }\n\t      this.layoutInfo.editable.attr('contenteditable', false);\n\t      this.invoke('toolbar.deactivate', true);\n\t    };\n\t\n\t    this.triggerEvent = function () {\n\t      var namespace = list.head(arguments);\n\t      var args = list.tail(list.from(arguments));\n\t\n\t      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n\t      if (callback) {\n\t        callback.apply($note[0], args);\n\t      }\n\t      $note.trigger('summernote.' + namespace, args);\n\t    };\n\t\n\t    this.initializeModule = function (key) {\n\t      var module = this.modules[key];\n\t      module.shouldInitialize = module.shouldInitialize || func.ok;\n\t      if (!module.shouldInitialize()) {\n\t        return;\n\t      }\n\t\n\t      // initialize module\n\t      if (module.initialize) {\n\t        module.initialize();\n\t      }\n\t\n\t      // attach events\n\t      if (module.events) {\n\t        dom.attachEvents($note, module.events);\n\t      }\n\t    };\n\t\n\t    this.module = function (key, ModuleClass, withoutIntialize) {\n\t      if (arguments.length === 1) {\n\t        return this.modules[key];\n\t      }\n\t\n\t      this.modules[key] = new ModuleClass(this);\n\t\n\t      if (!withoutIntialize) {\n\t        this.initializeModule(key);\n\t      }\n\t    };\n\t\n\t    this.removeModule = function (key) {\n\t      var module = this.modules[key];\n\t      if (module.shouldInitialize()) {\n\t        if (module.events) {\n\t          dom.detachEvents($note, module.events);\n\t        }\n\t\n\t        if (module.destroy) {\n\t          module.destroy();\n\t        }\n\t      }\n\t\n\t      delete this.modules[key];\n\t    };\n\t\n\t    this.memo = function (key, obj) {\n\t      if (arguments.length === 1) {\n\t        return this.memos[key];\n\t      }\n\t      this.memos[key] = obj;\n\t    };\n\t\n\t    this.removeMemo = function (key) {\n\t      if (this.memos[key] && this.memos[key].destroy) {\n\t        this.memos[key].destroy();\n\t      }\n\t\n\t      delete this.memos[key];\n\t    };\n\t\n\t    this.createInvokeHandler = function (namespace, value) {\n\t      return function (event) {\n\t        event.preventDefault();\n\t        self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));\n\t      };\n\t    };\n\t\n\t    this.invoke = function () {\n\t      var namespace = list.head(arguments);\n\t      var args = list.tail(list.from(arguments));\n\t\n\t      var splits = namespace.split('.');\n\t      var hasSeparator = splits.length > 1;\n\t      var moduleName = hasSeparator && list.head(splits);\n\t      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\t\n\t      var module = this.modules[moduleName || 'editor'];\n\t      if (!moduleName && this[methodName]) {\n\t        return this[methodName].apply(this, args);\n\t      } else if (module && module[methodName] && module.shouldInitialize()) {\n\t        return module[methodName].apply(module, args);\n\t      }\n\t    };\n\t\n\t    return this.initialize();\n\t  };\n\t\n\t  $.fn.extend({\n\t    /**\n\t     * Summernote API\n\t     *\n\t     * @param {Object|String}\n\t     * @return {this}\n\t     */\n\t    summernote: function () {\n\t      var type = $.type(list.head(arguments));\n\t      var isExternalAPICalled = type === 'string';\n\t      var hasInitOptions = type === 'object';\n\t\n\t      var options = hasInitOptions ? list.head(arguments) : {};\n\t\n\t      options = $.extend({}, $.summernote.options, options);\n\t      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n\t      options.icons = $.extend(true, {}, $.summernote.options.icons, options.icons);\n\t\n\t      this.each(function (idx, note) {\n\t        var $note = $(note);\n\t        if (!$note.data('summernote')) {\n\t          var context = new Context($note, options);\n\t          $note.data('summernote', context);\n\t          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n\t        }\n\t      });\n\t\n\t      var $note = this.first();\n\t      if ($note.length) {\n\t        var context = $note.data('summernote');\n\t        if (isExternalAPICalled) {\n\t          return context.invoke.apply(context, list.from(arguments));\n\t        } else if (options.focus) {\n\t          context.invoke('editor.focus');\n\t        }\n\t      }\n\t\n\t      return this;\n\t    }\n\t  });\n\t\n\t\n\t  var Renderer = function (markup, children, options, callback) {\n\t    this.render = function ($parent) {\n\t      var $node = $(markup);\n\t\n\t      if (options && options.contents) {\n\t        $node.html(options.contents);\n\t      }\n\t\n\t      if (options && options.className) {\n\t        $node.addClass(options.className);\n\t      }\n\t\n\t      if (options && options.data) {\n\t        $.each(options.data, function (k, v) {\n\t          $node.attr('data-' + k, v);\n\t        });\n\t      }\n\t\n\t      if (options && options.click) {\n\t        $node.on('click', options.click);\n\t      }\n\t\n\t      if (children) {\n\t        var $container = $node.find('.note-children-container');\n\t        children.forEach(function (child) {\n\t          child.render($container.length ? $container : $node);\n\t        });\n\t      }\n\t\n\t      if (callback) {\n\t        callback($node, options);\n\t      }\n\t\n\t      if (options && options.callback) {\n\t        options.callback($node);\n\t      }\n\t\n\t      if ($parent) {\n\t        $parent.append($node);\n\t      }\n\t\n\t      return $node;\n\t    };\n\t  };\n\t\n\t  var renderer = {\n\t    create: function (markup, callback) {\n\t      return function () {\n\t        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n\t        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n\t        if (options && options.children) {\n\t          children = options.children;\n\t        }\n\t        return new Renderer(markup, children, options, callback);\n\t      };\n\t    }\n\t  };\n\t\n\t  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n\t  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n\t  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n\t  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n\t  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n\t  var statusbar = renderer.create([\n\t    '<div class=\"note-statusbar\">',\n\t    '  <div class=\"note-resizebar\">',\n\t    '    <div class=\"note-icon-bar\"/>',\n\t    '    <div class=\"note-icon-bar\"/>',\n\t    '    <div class=\"note-icon-bar\"/>',\n\t    '  </div>',\n\t    '</div>'\n\t  ].join(''));\n\t\n\t  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n\t  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\t\n\t  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n\t  var button = renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\" tabindex=\"-1\">', function ($node, options) {\n\t    if (options && options.tooltip) {\n\t      $node.attr({\n\t        title: options.tooltip\n\t      }).tooltip({\n\t        container: 'body',\n\t        trigger: 'hover',\n\t        placement: 'bottom'\n\t      });\n\t    }\n\t  });\n\t\n\t  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n\t    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n\t      var value = (typeof item === 'string') ? item : (item.value || '');\n\t      var content = options.template ? options.template(item) : item;\n\t      return '<li><a href=\"#\" data-value=\"' + value + '\">' + content + '</a></li>';\n\t    }).join('') : options.items;\n\t\n\t    $node.html(markup);\n\t  });\n\t\n\t  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n\t    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n\t      var value = (typeof item === 'string') ? item : (item.value || '');\n\t      var content = options.template ? options.template(item) : item;\n\t      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n\t    }).join('') : options.items;\n\t    $node.html(markup);\n\t  });\n\t\n\t  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n\t    var contents = [];\n\t    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n\t      var eventName = options.eventName;\n\t      var colors = options.colors[row];\n\t      var buttons = [];\n\t      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n\t        var color = colors[col];\n\t        buttons.push([\n\t          '<button type=\"button\" class=\"note-color-btn\"',\n\t          'style=\"background-color:', color, '\" ',\n\t          'data-event=\"', eventName, '\" ',\n\t          'data-value=\"', color, '\" ',\n\t          'title=\"', color, '\" ',\n\t          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n\t        ].join(''));\n\t      }\n\t      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n\t    }\n\t    $node.html(contents.join(''));\n\t\n\t    $node.find('.note-color-btn').tooltip({\n\t      container: 'body',\n\t      trigger: 'hover',\n\t      placement: 'bottom'\n\t    });\n\t  });\n\t\n\t  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n\t    if (options.fade) {\n\t      $node.addClass('fade');\n\t    }\n\t    $node.html([\n\t      '<div class=\"modal-dialog\">',\n\t      '  <div class=\"modal-content\">',\n\t      (options.title ?\n\t      '    <div class=\"modal-header\">' +\n\t      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n\t      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n\t      '    </div>' : ''\n\t      ),\n\t      '    <div class=\"modal-body\">' + options.body + '</div>',\n\t      (options.footer ?\n\t      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n\t      ),\n\t      '  </div>',\n\t      '</div>'\n\t    ].join(''));\n\t  });\n\t\n\t  var popover = renderer.create([\n\t    '<div class=\"note-popover popover in\">',\n\t    '  <div class=\"arrow\"/>',\n\t    '  <div class=\"popover-content note-children-container\"/>',\n\t    '</div>'\n\t  ].join(''), function ($node, options) {\n\t    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\t\n\t    $node.addClass(direction);\n\t\n\t    if (options.hideArrow) {\n\t      $node.find('.arrow').hide();\n\t    }\n\t  });\n\t\n\t  var icon = function (iconClassName, tagName) {\n\t    tagName = tagName || 'i';\n\t    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n\t  };\n\t\n\t  var ui = {\n\t    editor: editor,\n\t    toolbar: toolbar,\n\t    editingArea: editingArea,\n\t    codable: codable,\n\t    editable: editable,\n\t    statusbar: statusbar,\n\t    airEditor: airEditor,\n\t    airEditable: airEditable,\n\t    buttonGroup: buttonGroup,\n\t    button: button,\n\t    dropdown: dropdown,\n\t    dropdownCheck: dropdownCheck,\n\t    palette: palette,\n\t    dialog: dialog,\n\t    popover: popover,\n\t    icon: icon,\n\t\n\t    toggleBtn: function ($btn, isEnable) {\n\t      $btn.toggleClass('disabled', !isEnable);\n\t      $btn.attr('disabled', !isEnable);\n\t    },\n\t\n\t    toggleBtnActive: function ($btn, isActive) {\n\t      $btn.toggleClass('active', isActive);\n\t    },\n\t\n\t    onDialogShown: function ($dialog, handler) {\n\t      $dialog.one('shown.bs.modal', handler);\n\t    },\n\t\n\t    onDialogHidden: function ($dialog, handler) {\n\t      $dialog.one('hidden.bs.modal', handler);\n\t    },\n\t\n\t    showDialog: function ($dialog) {\n\t      $dialog.modal('show');\n\t    },\n\t\n\t    hideDialog: function ($dialog) {\n\t      $dialog.modal('hide');\n\t    },\n\t\n\t    createLayout: function ($note, options) {\n\t      var $editor = (options.airMode ? ui.airEditor([\n\t        ui.editingArea([\n\t          ui.airEditable()\n\t        ])\n\t      ]) : ui.editor([\n\t        ui.toolbar(),\n\t        ui.editingArea([\n\t          ui.codable(),\n\t          ui.editable()\n\t        ]),\n\t        ui.statusbar()\n\t      ])).render();\n\t\n\t      $editor.insertAfter($note);\n\t\n\t      return {\n\t        note: $note,\n\t        editor: $editor,\n\t        toolbar: $editor.find('.note-toolbar'),\n\t        editingArea: $editor.find('.note-editing-area'),\n\t        editable: $editor.find('.note-editable'),\n\t        codable: $editor.find('.note-codable'),\n\t        statusbar: $editor.find('.note-statusbar')\n\t      };\n\t    },\n\t\n\t    removeLayout: function ($note, layoutInfo) {\n\t      $note.html(layoutInfo.editable.html());\n\t      layoutInfo.editor.remove();\n\t      $note.show();\n\t    }\n\t  };\n\t\n\t  $.summernote = $.summernote || {\n\t    lang: {}\n\t  };\n\t\n\t  $.extend($.summernote.lang, {\n\t    'en-US': {\n\t      font: {\n\t        bold: 'Bold',\n\t        italic: 'Italic',\n\t        underline: 'Underline',\n\t        clear: 'Remove Font Style',\n\t        height: 'Line Height',\n\t        name: 'Font Family',\n\t        strikethrough: 'Strikethrough',\n\t        subscript: 'Subscript',\n\t        superscript: 'Superscript',\n\t        size: 'Font Size'\n\t      },\n\t      image: {\n\t        image: 'Picture',\n\t        insert: 'Insert Image',\n\t        resizeFull: 'Resize Full',\n\t        resizeHalf: 'Resize Half',\n\t        resizeQuarter: 'Resize Quarter',\n\t        floatLeft: 'Float Left',\n\t        floatRight: 'Float Right',\n\t        floatNone: 'Float None',\n\t        shapeRounded: 'Shape: Rounded',\n\t        shapeCircle: 'Shape: Circle',\n\t        shapeThumbnail: 'Shape: Thumbnail',\n\t        shapeNone: 'Shape: None',\n\t        dragImageHere: 'Drag image or text here',\n\t        dropImage: 'Drop image or Text',\n\t        selectFromFiles: 'Select from files',\n\t        maximumFileSize: 'Maximum file size',\n\t        maximumFileSizeError: 'Maximum file size exceeded.',\n\t        url: 'Image URL',\n\t        remove: 'Remove Image'\n\t      },\n\t      video: {\n\t        video: 'Video',\n\t        videoLink: 'Video Link',\n\t        insert: 'Insert Video',\n\t        url: 'Video URL?',\n\t        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n\t      },\n\t      link: {\n\t        link: 'Link',\n\t        insert: 'Insert Link',\n\t        unlink: 'Unlink',\n\t        edit: 'Edit',\n\t        textToDisplay: 'Text to display',\n\t        url: 'To what URL should this link go?',\n\t        openInNewWindow: 'Open in new window'\n\t      },\n\t      table: {\n\t        table: 'Table'\n\t      },\n\t      hr: {\n\t        insert: 'Insert Horizontal Rule'\n\t      },\n\t      style: {\n\t        style: 'Style',\n\t        normal: 'Normal',\n\t        blockquote: 'Quote',\n\t        pre: 'Code',\n\t        h1: 'Header 1',\n\t        h2: 'Header 2',\n\t        h3: 'Header 3',\n\t        h4: 'Header 4',\n\t        h5: 'Header 5',\n\t        h6: 'Header 6'\n\t      },\n\t      lists: {\n\t        unordered: 'Unordered list',\n\t        ordered: 'Ordered list'\n\t      },\n\t      options: {\n\t        help: 'Help',\n\t        fullscreen: 'Full Screen',\n\t        codeview: 'Code View'\n\t      },\n\t      paragraph: {\n\t        paragraph: 'Paragraph',\n\t        outdent: 'Outdent',\n\t        indent: 'Indent',\n\t        left: 'Align left',\n\t        center: 'Align center',\n\t        right: 'Align right',\n\t        justify: 'Justify full'\n\t      },\n\t      color: {\n\t        recent: 'Recent Color',\n\t        more: 'More Color',\n\t        background: 'Background Color',\n\t        foreground: 'Foreground Color',\n\t        transparent: 'Transparent',\n\t        setTransparent: 'Set transparent',\n\t        reset: 'Reset',\n\t        resetToDefault: 'Reset to default'\n\t      },\n\t      shortcut: {\n\t        shortcuts: 'Keyboard shortcuts',\n\t        close: 'Close',\n\t        textFormatting: 'Text formatting',\n\t        action: 'Action',\n\t        paragraphFormatting: 'Paragraph formatting',\n\t        documentStyle: 'Document Style',\n\t        extraKeys: 'Extra keys'\n\t      },\n\t      help: {\n\t        'insertParagraph': 'Insert Paragraph',\n\t        'undo': 'Undoes the last command',\n\t        'redo': 'Redoes the last command',\n\t        'tab': 'Tab',\n\t        'untab': 'Untab',\n\t        'bold': 'Set a bold style',\n\t        'italic': 'Set a italic style',\n\t        'underline': 'Set a underline style',\n\t        'strikethrough': 'Set a strikethrough style',\n\t        'removeFormat': 'Clean a style',\n\t        'justifyLeft': 'Set left align',\n\t        'justifyCenter': 'Set center align',\n\t        'justifyRight': 'Set right align',\n\t        'justifyFull': 'Set full align',\n\t        'insertUnorderedList': 'Toggle unordered list',\n\t        'insertOrderedList': 'Toggle ordered list',\n\t        'outdent': 'Outdent on current paragraph',\n\t        'indent': 'Indent on current paragraph',\n\t        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n\t        'formatH1': 'Change current block\\'s format as H1',\n\t        'formatH2': 'Change current block\\'s format as H2',\n\t        'formatH3': 'Change current block\\'s format as H3',\n\t        'formatH4': 'Change current block\\'s format as H4',\n\t        'formatH5': 'Change current block\\'s format as H5',\n\t        'formatH6': 'Change current block\\'s format as H6',\n\t        'insertHorizontalRule': 'Insert horizontal rule',\n\t        'linkDialog.show': 'Show Link Dialog'\n\t      },\n\t      history: {\n\t        undo: 'Undo',\n\t        redo: 'Redo'\n\t      },\n\t      specialChar: {\n\t        specialChar: 'SPECIAL CHARACTERS',\n\t        select: 'Select Special characters'\n\t      }\n\t    }\n\t  });\n\t\n\t\n\t  /**\n\t   * @class core.key\n\t   *\n\t   * Object for keycodes.\n\t   *\n\t   * @singleton\n\t   * @alternateClassName key\n\t   */\n\t  var key = (function () {\n\t    var keyMap = {\n\t      'BACKSPACE': 8,\n\t      'TAB': 9,\n\t      'ENTER': 13,\n\t      'SPACE': 32,\n\t\n\t      // Arrow\n\t      'LEFT': 37,\n\t      'UP': 38,\n\t      'RIGHT': 39,\n\t      'DOWN': 40,\n\t\n\t      // Number: 0-9\n\t      'NUM0': 48,\n\t      'NUM1': 49,\n\t      'NUM2': 50,\n\t      'NUM3': 51,\n\t      'NUM4': 52,\n\t      'NUM5': 53,\n\t      'NUM6': 54,\n\t      'NUM7': 55,\n\t      'NUM8': 56,\n\t\n\t      // Alphabet: a-z\n\t      'B': 66,\n\t      'E': 69,\n\t      'I': 73,\n\t      'J': 74,\n\t      'K': 75,\n\t      'L': 76,\n\t      'R': 82,\n\t      'S': 83,\n\t      'U': 85,\n\t      'V': 86,\n\t      'Y': 89,\n\t      'Z': 90,\n\t\n\t      'SLASH': 191,\n\t      'LEFTBRACKET': 219,\n\t      'BACKSLASH': 220,\n\t      'RIGHTBRACKET': 221\n\t    };\n\t\n\t    return {\n\t      /**\n\t       * @method isEdit\n\t       *\n\t       * @param {Number} keyCode\n\t       * @return {Boolean}\n\t       */\n\t      isEdit: function (keyCode) {\n\t        return list.contains([\n\t          keyMap.BACKSPACE,\n\t          keyMap.TAB,\n\t          keyMap.ENTER,\n\t          keyMap.SPACE\n\t        ], keyCode);\n\t      },\n\t      /**\n\t       * @method isMove\n\t       *\n\t       * @param {Number} keyCode\n\t       * @return {Boolean}\n\t       */\n\t      isMove: function (keyCode) {\n\t        return list.contains([\n\t          keyMap.LEFT,\n\t          keyMap.UP,\n\t          keyMap.RIGHT,\n\t          keyMap.DOWN\n\t        ], keyCode);\n\t      },\n\t      /**\n\t       * @property {Object} nameFromCode\n\t       * @property {String} nameFromCode.8 \"BACKSPACE\"\n\t       */\n\t      nameFromCode: func.invertObject(keyMap),\n\t      code: keyMap\n\t    };\n\t  })();\n\t\n\t  var range = (function () {\n\t\n\t    /**\n\t     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n\t     *\n\t     * @param {TextRange} textRange\n\t     * @param {Boolean} isStart\n\t     * @return {BoundaryPoint}\n\t     *\n\t     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n\t     */\n\t    var textRangeToPoint = function (textRange, isStart) {\n\t      var container = textRange.parentElement(), offset;\n\t  \n\t      var tester = document.body.createTextRange(), prevContainer;\n\t      var childNodes = list.from(container.childNodes);\n\t      for (offset = 0; offset < childNodes.length; offset++) {\n\t        if (dom.isText(childNodes[offset])) {\n\t          continue;\n\t        }\n\t        tester.moveToElementText(childNodes[offset]);\n\t        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n\t          break;\n\t        }\n\t        prevContainer = childNodes[offset];\n\t      }\n\t  \n\t      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n\t        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n\t        textRangeStart.moveToElementText(prevContainer || container);\n\t        textRangeStart.collapse(!prevContainer);\n\t        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n\t  \n\t        var pointTester = textRange.duplicate();\n\t        pointTester.setEndPoint('StartToStart', textRangeStart);\n\t        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n\t  \n\t        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n\t          textCount -= curTextNode.nodeValue.length;\n\t          curTextNode = curTextNode.nextSibling;\n\t        }\n\t  \n\t        /* jshint ignore:start */\n\t        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n\t        /* jshint ignore:end */\n\t  \n\t        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n\t            textCount === curTextNode.nodeValue.length) {\n\t          textCount -= curTextNode.nodeValue.length;\n\t          curTextNode = curTextNode.nextSibling;\n\t        }\n\t  \n\t        container = curTextNode;\n\t        offset = textCount;\n\t      }\n\t  \n\t      return {\n\t        cont: container,\n\t        offset: offset\n\t      };\n\t    };\n\t    \n\t    /**\n\t     * return TextRange from boundary point (inspired by google closure-library)\n\t     * @param {BoundaryPoint} point\n\t     * @return {TextRange}\n\t     */\n\t    var pointToTextRange = function (point) {\n\t      var textRangeInfo = function (container, offset) {\n\t        var node, isCollapseToStart;\n\t  \n\t        if (dom.isText(container)) {\n\t          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n\t          var prevContainer = list.last(prevTextNodes).previousSibling;\n\t          node =  prevContainer || container.parentNode;\n\t          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n\t          isCollapseToStart = !prevContainer;\n\t        } else {\n\t          node = container.childNodes[offset] || container;\n\t          if (dom.isText(node)) {\n\t            return textRangeInfo(node, 0);\n\t          }\n\t  \n\t          offset = 0;\n\t          isCollapseToStart = false;\n\t        }\n\t  \n\t        return {\n\t          node: node,\n\t          collapseToStart: isCollapseToStart,\n\t          offset: offset\n\t        };\n\t      };\n\t  \n\t      var textRange = document.body.createTextRange();\n\t      var info = textRangeInfo(point.node, point.offset);\n\t  \n\t      textRange.moveToElementText(info.node);\n\t      textRange.collapse(info.collapseToStart);\n\t      textRange.moveStart('character', info.offset);\n\t      return textRange;\n\t    };\n\t    \n\t    /**\n\t     * Wrapped Range\n\t     *\n\t     * @constructor\n\t     * @param {Node} sc - start container\n\t     * @param {Number} so - start offset\n\t     * @param {Node} ec - end container\n\t     * @param {Number} eo - end offset\n\t     */\n\t    var WrappedRange = function (sc, so, ec, eo) {\n\t      this.sc = sc;\n\t      this.so = so;\n\t      this.ec = ec;\n\t      this.eo = eo;\n\t  \n\t      // nativeRange: get nativeRange from sc, so, ec, eo\n\t      var nativeRange = function () {\n\t        if (agent.isW3CRangeSupport) {\n\t          var w3cRange = document.createRange();\n\t          w3cRange.setStart(sc, so);\n\t          w3cRange.setEnd(ec, eo);\n\t\n\t          return w3cRange;\n\t        } else {\n\t          var textRange = pointToTextRange({\n\t            node: sc,\n\t            offset: so\n\t          });\n\t\n\t          textRange.setEndPoint('EndToEnd', pointToTextRange({\n\t            node: ec,\n\t            offset: eo\n\t          }));\n\t\n\t          return textRange;\n\t        }\n\t      };\n\t\n\t      this.getPoints = function () {\n\t        return {\n\t          sc: sc,\n\t          so: so,\n\t          ec: ec,\n\t          eo: eo\n\t        };\n\t      };\n\t\n\t      this.getStartPoint = function () {\n\t        return {\n\t          node: sc,\n\t          offset: so\n\t        };\n\t      };\n\t\n\t      this.getEndPoint = function () {\n\t        return {\n\t          node: ec,\n\t          offset: eo\n\t        };\n\t      };\n\t\n\t      /**\n\t       * select update visible range\n\t       */\n\t      this.select = function () {\n\t        var nativeRng = nativeRange();\n\t        if (agent.isW3CRangeSupport) {\n\t          var selection = document.getSelection();\n\t          if (selection.rangeCount > 0) {\n\t            selection.removeAllRanges();\n\t          }\n\t          selection.addRange(nativeRng);\n\t        } else {\n\t          nativeRng.select();\n\t        }\n\t        \n\t        return this;\n\t      };\n\t\n\t      /**\n\t       * Moves the scrollbar to start container(sc) of current range\n\t       *\n\t       * @return {WrappedRange}\n\t       */\n\t      this.scrollIntoView = function (container) {\n\t        var height = $(container).height();\n\t        if (container.scrollTop + height < this.sc.offsetTop) {\n\t          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n\t        }\n\t\n\t        return this;\n\t      };\n\t\n\t      /**\n\t       * @return {WrappedRange}\n\t       */\n\t      this.normalize = function () {\n\t\n\t        /**\n\t         * @param {BoundaryPoint} point\n\t         * @param {Boolean} isLeftToRight\n\t         * @return {BoundaryPoint}\n\t         */\n\t        var getVisiblePoint = function (point, isLeftToRight) {\n\t          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n\t              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n\t              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n\t              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n\t            return point;\n\t          }\n\t\n\t          // point on block's edge\n\t          var block = dom.ancestor(point.node, dom.isBlock);\n\t          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n\t              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\t\n\t            // returns point already on visible point\n\t            if (dom.isVisiblePoint(point)) {\n\t              return point;\n\t            }\n\t            // reverse direction \n\t            isLeftToRight = !isLeftToRight;\n\t          }\n\t\n\t          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n\t                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n\t          return nextPoint || point;\n\t        };\n\t\n\t        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n\t        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\t\n\t        return new WrappedRange(\n\t          startPoint.node,\n\t          startPoint.offset,\n\t          endPoint.node,\n\t          endPoint.offset\n\t        );\n\t      };\n\t\n\t      /**\n\t       * returns matched nodes on range\n\t       *\n\t       * @param {Function} [pred] - predicate function\n\t       * @param {Object} [options]\n\t       * @param {Boolean} [options.includeAncestor]\n\t       * @param {Boolean} [options.fullyContains]\n\t       * @return {Node[]}\n\t       */\n\t      this.nodes = function (pred, options) {\n\t        pred = pred || func.ok;\n\t\n\t        var includeAncestor = options && options.includeAncestor;\n\t        var fullyContains = options && options.fullyContains;\n\t\n\t        // TODO compare points and sort\n\t        var startPoint = this.getStartPoint();\n\t        var endPoint = this.getEndPoint();\n\t\n\t        var nodes = [];\n\t        var leftEdgeNodes = [];\n\t\n\t        dom.walkPoint(startPoint, endPoint, function (point) {\n\t          if (dom.isEditable(point.node)) {\n\t            return;\n\t          }\n\t\n\t          var node;\n\t          if (fullyContains) {\n\t            if (dom.isLeftEdgePoint(point)) {\n\t              leftEdgeNodes.push(point.node);\n\t            }\n\t            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n\t              node = point.node;\n\t            }\n\t          } else if (includeAncestor) {\n\t            node = dom.ancestor(point.node, pred);\n\t          } else {\n\t            node = point.node;\n\t          }\n\t\n\t          if (node && pred(node)) {\n\t            nodes.push(node);\n\t          }\n\t        }, true);\n\t\n\t        return list.unique(nodes);\n\t      };\n\t\n\t      /**\n\t       * returns commonAncestor of range\n\t       * @return {Element} - commonAncestor\n\t       */\n\t      this.commonAncestor = function () {\n\t        return dom.commonAncestor(sc, ec);\n\t      };\n\t\n\t      /**\n\t       * returns expanded range by pred\n\t       *\n\t       * @param {Function} pred - predicate function\n\t       * @return {WrappedRange}\n\t       */\n\t      this.expand = function (pred) {\n\t        var startAncestor = dom.ancestor(sc, pred);\n\t        var endAncestor = dom.ancestor(ec, pred);\n\t\n\t        if (!startAncestor && !endAncestor) {\n\t          return new WrappedRange(sc, so, ec, eo);\n\t        }\n\t\n\t        var boundaryPoints = this.getPoints();\n\t\n\t        if (startAncestor) {\n\t          boundaryPoints.sc = startAncestor;\n\t          boundaryPoints.so = 0;\n\t        }\n\t\n\t        if (endAncestor) {\n\t          boundaryPoints.ec = endAncestor;\n\t          boundaryPoints.eo = dom.nodeLength(endAncestor);\n\t        }\n\t\n\t        return new WrappedRange(\n\t          boundaryPoints.sc,\n\t          boundaryPoints.so,\n\t          boundaryPoints.ec,\n\t          boundaryPoints.eo\n\t        );\n\t      };\n\t\n\t      /**\n\t       * @param {Boolean} isCollapseToStart\n\t       * @return {WrappedRange}\n\t       */\n\t      this.collapse = function (isCollapseToStart) {\n\t        if (isCollapseToStart) {\n\t          return new WrappedRange(sc, so, sc, so);\n\t        } else {\n\t          return new WrappedRange(ec, eo, ec, eo);\n\t        }\n\t      };\n\t\n\t      /**\n\t       * splitText on range\n\t       */\n\t      this.splitText = function () {\n\t        var isSameContainer = sc === ec;\n\t        var boundaryPoints = this.getPoints();\n\t\n\t        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n\t          ec.splitText(eo);\n\t        }\n\t\n\t        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n\t          boundaryPoints.sc = sc.splitText(so);\n\t          boundaryPoints.so = 0;\n\t\n\t          if (isSameContainer) {\n\t            boundaryPoints.ec = boundaryPoints.sc;\n\t            boundaryPoints.eo = eo - so;\n\t          }\n\t        }\n\t\n\t        return new WrappedRange(\n\t          boundaryPoints.sc,\n\t          boundaryPoints.so,\n\t          boundaryPoints.ec,\n\t          boundaryPoints.eo\n\t        );\n\t      };\n\t\n\t      /**\n\t       * delete contents on range\n\t       * @return {WrappedRange}\n\t       */\n\t      this.deleteContents = function () {\n\t        if (this.isCollapsed()) {\n\t          return this;\n\t        }\n\t\n\t        var rng = this.splitText();\n\t        var nodes = rng.nodes(null, {\n\t          fullyContains: true\n\t        });\n\t\n\t        // find new cursor point\n\t        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n\t          return !list.contains(nodes, point.node);\n\t        });\n\t\n\t        var emptyParents = [];\n\t        $.each(nodes, function (idx, node) {\n\t          // find empty parents\n\t          var parent = node.parentNode;\n\t          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n\t            emptyParents.push(parent);\n\t          }\n\t          dom.remove(node, false);\n\t        });\n\t\n\t        // remove empty parents\n\t        $.each(emptyParents, function (idx, node) {\n\t          dom.remove(node, false);\n\t        });\n\t\n\t        return new WrappedRange(\n\t          point.node,\n\t          point.offset,\n\t          point.node,\n\t          point.offset\n\t        ).normalize();\n\t      };\n\t      \n\t      /**\n\t       * makeIsOn: return isOn(pred) function\n\t       */\n\t      var makeIsOn = function (pred) {\n\t        return function () {\n\t          var ancestor = dom.ancestor(sc, pred);\n\t          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n\t        };\n\t      };\n\t  \n\t      // isOnEditable: judge whether range is on editable or not\n\t      this.isOnEditable = makeIsOn(dom.isEditable);\n\t      // isOnList: judge whether range is on list node or not\n\t      this.isOnList = makeIsOn(dom.isList);\n\t      // isOnAnchor: judge whether range is on anchor node or not\n\t      this.isOnAnchor = makeIsOn(dom.isAnchor);\n\t      // isOnCell: judge whether range is on cell node or not\n\t      this.isOnCell = makeIsOn(dom.isCell);\n\t      // isOnData: judge whether range is on data node or not\n\t      this.isOnData = makeIsOn(dom.isData);\n\t\n\t      /**\n\t       * @param {Function} pred\n\t       * @return {Boolean}\n\t       */\n\t      this.isLeftEdgeOf = function (pred) {\n\t        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n\t          return false;\n\t        }\n\t\n\t        var node = dom.ancestor(this.sc, pred);\n\t        return node && dom.isLeftEdgeOf(this.sc, node);\n\t      };\n\t\n\t      /**\n\t       * returns whether range was collapsed or not\n\t       */\n\t      this.isCollapsed = function () {\n\t        return sc === ec && so === eo;\n\t      };\n\t\n\t      /**\n\t       * wrap inline nodes which children of body with paragraph\n\t       *\n\t       * @return {WrappedRange}\n\t       */\n\t      this.wrapBodyInlineWithPara = function () {\n\t        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n\t          sc.innerHTML = dom.emptyPara;\n\t          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n\t        }\n\t\n\t        /**\n\t         * [workaround] firefox often create range on not visible point. so normalize here.\n\t         *  - firefox: |<p>text</p>|\n\t         *  - chrome: <p>|text|</p>\n\t         */\n\t        var rng = this.normalize();\n\t        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n\t          return rng;\n\t        }\n\t\n\t        // find inline top ancestor\n\t        var topAncestor;\n\t        if (dom.isInline(rng.sc)) {\n\t          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n\t          topAncestor = list.last(ancestors);\n\t          if (!dom.isInline(topAncestor)) {\n\t            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n\t          }\n\t        } else {\n\t          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n\t        }\n\t\n\t        // siblings not in paragraph\n\t        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n\t        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\t\n\t        // wrap with paragraph\n\t        if (inlineSiblings.length) {\n\t          var para = dom.wrap(list.head(inlineSiblings), 'p');\n\t          dom.appendChildNodes(para, list.tail(inlineSiblings));\n\t        }\n\t\n\t        return this.normalize();\n\t      };\n\t\n\t      /**\n\t       * insert node at current cursor\n\t       *\n\t       * @param {Node} node\n\t       * @return {Node}\n\t       */\n\t      this.insertNode = function (node) {\n\t        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\t        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\t\n\t        if (info.rightNode) {\n\t          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n\t        } else {\n\t          info.container.appendChild(node);\n\t        }\n\t\n\t        return node;\n\t      };\n\t\n\t      /**\n\t       * insert html at current cursor\n\t       */\n\t      this.pasteHTML = function (markup) {\n\t        var contentsContainer = $('<div></div>').html(markup)[0];\n\t        var childNodes = list.from(contentsContainer.childNodes);\n\t\n\t        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\t\n\t        return childNodes.reverse().map(function (childNode) {\n\t          return rng.insertNode(childNode);\n\t        }).reverse();\n\t      };\n\t  \n\t      /**\n\t       * returns text in range\n\t       *\n\t       * @return {String}\n\t       */\n\t      this.toString = function () {\n\t        var nativeRng = nativeRange();\n\t        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n\t      };\n\t\n\t      /**\n\t       * returns range for word before cursor\n\t       *\n\t       * @param {Boolean} [findAfter] - find after cursor, default: false\n\t       * @return {WrappedRange}\n\t       */\n\t      this.getWordRange = function (findAfter) {\n\t        var endPoint = this.getEndPoint();\n\t\n\t        if (!dom.isCharPoint(endPoint)) {\n\t          return this;\n\t        }\n\t\n\t        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n\t          return !dom.isCharPoint(point);\n\t        });\n\t\n\t        if (findAfter) {\n\t          endPoint = dom.nextPointUntil(endPoint, function (point) {\n\t            return !dom.isCharPoint(point);\n\t          });\n\t        }\n\t\n\t        return new WrappedRange(\n\t          startPoint.node,\n\t          startPoint.offset,\n\t          endPoint.node,\n\t          endPoint.offset\n\t        );\n\t      };\n\t  \n\t      /**\n\t       * create offsetPath bookmark\n\t       *\n\t       * @param {Node} editable\n\t       */\n\t      this.bookmark = function (editable) {\n\t        return {\n\t          s: {\n\t            path: dom.makeOffsetPath(editable, sc),\n\t            offset: so\n\t          },\n\t          e: {\n\t            path: dom.makeOffsetPath(editable, ec),\n\t            offset: eo\n\t          }\n\t        };\n\t      };\n\t\n\t      /**\n\t       * create offsetPath bookmark base on paragraph\n\t       *\n\t       * @param {Node[]} paras\n\t       */\n\t      this.paraBookmark = function (paras) {\n\t        return {\n\t          s: {\n\t            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n\t            offset: so\n\t          },\n\t          e: {\n\t            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n\t            offset: eo\n\t          }\n\t        };\n\t      };\n\t\n\t      /**\n\t       * getClientRects\n\t       * @return {Rect[]}\n\t       */\n\t      this.getClientRects = function () {\n\t        var nativeRng = nativeRange();\n\t        return nativeRng.getClientRects();\n\t      };\n\t    };\n\t\n\t  /**\n\t   * @class core.range\n\t   *\n\t   * Data structure\n\t   *  * BoundaryPoint: a point of dom tree\n\t   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n\t   *\n\t   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n\t   *\n\t   * @singleton\n\t   * @alternateClassName range\n\t   */\n\t    return {\n\t      /**\n\t       * create Range Object From arguments or Browser Selection\n\t       *\n\t       * @param {Node} sc - start container\n\t       * @param {Number} so - start offset\n\t       * @param {Node} ec - end container\n\t       * @param {Number} eo - end offset\n\t       * @return {WrappedRange}\n\t       */\n\t      create: function (sc, so, ec, eo) {\n\t        if (arguments.length === 4) {\n\t          return new WrappedRange(sc, so, ec, eo);\n\t        } else if (arguments.length === 2) { //collapsed\n\t          ec = sc;\n\t          eo = so;\n\t          return new WrappedRange(sc, so, ec, eo);\n\t        } else {\n\t          var wrappedRange = this.createFromSelection();\n\t          if (!wrappedRange && arguments.length === 1) {\n\t            wrappedRange = this.createFromNode(arguments[0]);\n\t            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n\t          }\n\t          return wrappedRange;\n\t        }\n\t      },\n\t\n\t      createFromSelection: function () {\n\t        var sc, so, ec, eo;\n\t        if (agent.isW3CRangeSupport) {\n\t          var selection = document.getSelection();\n\t          if (!selection || selection.rangeCount === 0) {\n\t            return null;\n\t          } else if (dom.isBody(selection.anchorNode)) {\n\t            // Firefox: returns entire body as range on initialization.\n\t            // We won't never need it.\n\t            return null;\n\t          }\n\t\n\t          var nativeRng = selection.getRangeAt(0);\n\t          sc = nativeRng.startContainer;\n\t          so = nativeRng.startOffset;\n\t          ec = nativeRng.endContainer;\n\t          eo = nativeRng.endOffset;\n\t        } else { // IE8: TextRange\n\t          var textRange = document.selection.createRange();\n\t          var textRangeEnd = textRange.duplicate();\n\t          textRangeEnd.collapse(false);\n\t          var textRangeStart = textRange;\n\t          textRangeStart.collapse(true);\n\t\n\t          var startPoint = textRangeToPoint(textRangeStart, true),\n\t          endPoint = textRangeToPoint(textRangeEnd, false);\n\t\n\t          // same visible point case: range was collapsed.\n\t          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n\t              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n\t              endPoint.node.nextSibling === startPoint.node) {\n\t            startPoint = endPoint;\n\t          }\n\t\n\t          sc = startPoint.cont;\n\t          so = startPoint.offset;\n\t          ec = endPoint.cont;\n\t          eo = endPoint.offset;\n\t        }\n\t\n\t        return new WrappedRange(sc, so, ec, eo);\n\t      },\n\t\n\t      /**\n\t       * @method \n\t       * \n\t       * create WrappedRange from node\n\t       *\n\t       * @param {Node} node\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromNode: function (node) {\n\t        var sc = node;\n\t        var so = 0;\n\t        var ec = node;\n\t        var eo = dom.nodeLength(ec);\n\t\n\t        // browsers can't target a picture or void node\n\t        if (dom.isVoid(sc)) {\n\t          so = dom.listPrev(sc).length - 1;\n\t          sc = sc.parentNode;\n\t        }\n\t        if (dom.isBR(ec)) {\n\t          eo = dom.listPrev(ec).length - 1;\n\t          ec = ec.parentNode;\n\t        } else if (dom.isVoid(ec)) {\n\t          eo = dom.listPrev(ec).length;\n\t          ec = ec.parentNode;\n\t        }\n\t\n\t        return this.create(sc, so, ec, eo);\n\t      },\n\t\n\t      /**\n\t       * create WrappedRange from node after position\n\t       *\n\t       * @param {Node} node\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromNodeBefore: function (node) {\n\t        return this.createFromNode(node).collapse(true);\n\t      },\n\t\n\t      /**\n\t       * create WrappedRange from node after position\n\t       *\n\t       * @param {Node} node\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromNodeAfter: function (node) {\n\t        return this.createFromNode(node).collapse();\n\t      },\n\t\n\t      /**\n\t       * @method \n\t       * \n\t       * create WrappedRange from bookmark\n\t       *\n\t       * @param {Node} editable\n\t       * @param {Object} bookmark\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromBookmark: function (editable, bookmark) {\n\t        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n\t        var so = bookmark.s.offset;\n\t        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n\t        var eo = bookmark.e.offset;\n\t        return new WrappedRange(sc, so, ec, eo);\n\t      },\n\t\n\t      /**\n\t       * @method \n\t       *\n\t       * create WrappedRange from paraBookmark\n\t       *\n\t       * @param {Object} bookmark\n\t       * @param {Node[]} paras\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromParaBookmark: function (bookmark, paras) {\n\t        var so = bookmark.s.offset;\n\t        var eo = bookmark.e.offset;\n\t        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n\t        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\t\n\t        return new WrappedRange(sc, so, ec, eo);\n\t      }\n\t    };\n\t  })();\n\t\n\t  /**\n\t   * @class core.async\n\t   *\n\t   * Async functions which returns `Promise`\n\t   *\n\t   * @singleton\n\t   * @alternateClassName async\n\t   */\n\t  var async = (function () {\n\t    /**\n\t     * @method readFileAsDataURL\n\t     *\n\t     * read contents of file as representing URL\n\t     *\n\t     * @param {File} file\n\t     * @return {Promise} - then: dataUrl\n\t     */\n\t    var readFileAsDataURL = function (file) {\n\t      return $.Deferred(function (deferred) {\n\t        $.extend(new FileReader(), {\n\t          onload: function (e) {\n\t            var dataURL = e.target.result;\n\t            deferred.resolve(dataURL);\n\t          },\n\t          onerror: function () {\n\t            deferred.reject(this);\n\t          }\n\t        }).readAsDataURL(file);\n\t      }).promise();\n\t    };\n\t  \n\t    /**\n\t     * @method createImage\n\t     *\n\t     * create `<image>` from url string\n\t     *\n\t     * @param {String} url\n\t     * @return {Promise} - then: $image\n\t     */\n\t    var createImage = function (url) {\n\t      return $.Deferred(function (deferred) {\n\t        var $img = $('<img>');\n\t\n\t        $img.one('load', function () {\n\t          $img.off('error abort');\n\t          deferred.resolve($img);\n\t        }).one('error abort', function () {\n\t          $img.off('load').detach();\n\t          deferred.reject($img);\n\t        }).css({\n\t          display: 'none'\n\t        }).appendTo(document.body).attr('src', url);\n\t      }).promise();\n\t    };\n\t\n\t    return {\n\t      readFileAsDataURL: readFileAsDataURL,\n\t      createImage: createImage\n\t    };\n\t  })();\n\t\n\t  /**\n\t   * @class editing.History\n\t   *\n\t   * Editor History\n\t   *\n\t   */\n\t  var History = function ($editable) {\n\t    var stack = [], stackOffset = -1;\n\t    var editable = $editable[0];\n\t\n\t    var makeSnapshot = function () {\n\t      var rng = range.create(editable);\n\t      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\t\n\t      return {\n\t        contents: $editable.html(),\n\t        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n\t      };\n\t    };\n\t\n\t    var applySnapshot = function (snapshot) {\n\t      if (snapshot.contents !== null) {\n\t        $editable.html(snapshot.contents);\n\t      }\n\t      if (snapshot.bookmark !== null) {\n\t        range.createFromBookmark(editable, snapshot.bookmark).select();\n\t      }\n\t    };\n\t\n\t    /**\n\t    * @method rewind\n\t    * Rewinds the history stack back to the first snapshot taken.\n\t    * Leaves the stack intact, so that \"Redo\" can still be used.\n\t    */\n\t    this.rewind = function () {\n\t      // Create snap shot if not yet recorded\n\t      if ($editable.html() !== stack[stackOffset].contents) {\n\t        this.recordUndo();\n\t      }\n\t\n\t      // Return to the first available snapshot.\n\t      stackOffset = 0;\n\t\n\t      // Apply that snapshot.\n\t      applySnapshot(stack[stackOffset]);\n\t    };\n\t\n\t    /**\n\t    * @method reset\n\t    * Resets the history stack completely; reverting to an empty editor.\n\t    */\n\t    this.reset = function () {\n\t      // Clear the stack.\n\t      stack = [];\n\t\n\t      // Restore stackOffset to its original value.\n\t      stackOffset = -1;\n\t\n\t      // Clear the editable area.\n\t      $editable.html('');\n\t\n\t      // Record our first snapshot (of nothing).\n\t      this.recordUndo();\n\t    };\n\t\n\t    /**\n\t     * undo\n\t     */\n\t    this.undo = function () {\n\t      // Create snap shot if not yet recorded\n\t      if ($editable.html() !== stack[stackOffset].contents) {\n\t        this.recordUndo();\n\t      }\n\t\n\t      if (0 < stackOffset) {\n\t        stackOffset--;\n\t        applySnapshot(stack[stackOffset]);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * redo\n\t     */\n\t    this.redo = function () {\n\t      if (stack.length - 1 > stackOffset) {\n\t        stackOffset++;\n\t        applySnapshot(stack[stackOffset]);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * recorded undo\n\t     */\n\t    this.recordUndo = function () {\n\t      stackOffset++;\n\t\n\t      // Wash out stack after stackOffset\n\t      if (stack.length > stackOffset) {\n\t        stack = stack.slice(0, stackOffset);\n\t      }\n\t\n\t      // Create new snapshot and push it to the end\n\t      stack.push(makeSnapshot());\n\t    };\n\t  };\n\t\n\t  /**\n\t   * @class editing.Style\n\t   *\n\t   * Style\n\t   *\n\t   */\n\t  var Style = function () {\n\t    /**\n\t     * @method jQueryCSS\n\t     *\n\t     * [workaround] for old jQuery\n\t     * passing an array of style properties to .css()\n\t     * will result in an object of property-value pairs.\n\t     * (compability with version < 1.9)\n\t     *\n\t     * @private\n\t     * @param  {jQuery} $obj\n\t     * @param  {Array} propertyNames - An array of one or more CSS properties.\n\t     * @return {Object}\n\t     */\n\t    var jQueryCSS = function ($obj, propertyNames) {\n\t      if (agent.jqueryVersion < 1.9) {\n\t        var result = {};\n\t        $.each(propertyNames, function (idx, propertyName) {\n\t          result[propertyName] = $obj.css(propertyName);\n\t        });\n\t        return result;\n\t      }\n\t      return $obj.css.call($obj, propertyNames);\n\t    };\n\t\n\t    /**\n\t     * returns style object from node\n\t     *\n\t     * @param {jQuery} $node\n\t     * @return {Object}\n\t     */\n\t    this.fromNode = function ($node) {\n\t      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n\t      var styleInfo = jQueryCSS($node, properties) || {};\n\t      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n\t      return styleInfo;\n\t    };\n\t\n\t    /**\n\t     * paragraph level style\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @param {Object} styleInfo\n\t     */\n\t    this.stylePara = function (rng, styleInfo) {\n\t      $.each(rng.nodes(dom.isPara, {\n\t        includeAncestor: true\n\t      }), function (idx, para) {\n\t        $(para).css(styleInfo);\n\t      });\n\t    };\n\t\n\t    /**\n\t     * insert and returns styleNodes on range.\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @param {Object} [options] - options for styleNodes\n\t     * @param {String} [options.nodeName] - default: `SPAN`\n\t     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n\t     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n\t     * @return {Node[]}\n\t     */\n\t    this.styleNodes = function (rng, options) {\n\t      rng = rng.splitText();\n\t\n\t      var nodeName = options && options.nodeName || 'SPAN';\n\t      var expandClosestSibling = !!(options && options.expandClosestSibling);\n\t      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\t\n\t      if (rng.isCollapsed()) {\n\t        return [rng.insertNode(dom.create(nodeName))];\n\t      }\n\t\n\t      var pred = dom.makePredByNodeName(nodeName);\n\t      var nodes = rng.nodes(dom.isText, {\n\t        fullyContains: true\n\t      }).map(function (text) {\n\t        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n\t      });\n\t\n\t      if (expandClosestSibling) {\n\t        if (onlyPartialContains) {\n\t          var nodesInRange = rng.nodes();\n\t          // compose with partial contains predication\n\t          pred = func.and(pred, function (node) {\n\t            return list.contains(nodesInRange, node);\n\t          });\n\t        }\n\t\n\t        return nodes.map(function (node) {\n\t          var siblings = dom.withClosestSiblings(node, pred);\n\t          var head = list.head(siblings);\n\t          var tails = list.tail(siblings);\n\t          $.each(tails, function (idx, elem) {\n\t            dom.appendChildNodes(head, elem.childNodes);\n\t            dom.remove(elem);\n\t          });\n\t          return list.head(siblings);\n\t        });\n\t      } else {\n\t        return nodes;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * get current style on cursor\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @return {Object} - object contains style properties.\n\t     */\n\t    this.current = function (rng) {\n\t      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n\t      var styleInfo = this.fromNode($cont);\n\t\n\t      // document.queryCommandState for toggle state\n\t      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n\t      try {\n\t        styleInfo = $.extend(styleInfo, {\n\t          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n\t          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n\t          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n\t          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n\t          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n\t          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'\n\t        });\n\t      } catch (e) {}\n\t\n\t      // list-style-type to list-style(unordered, ordered)\n\t      if (!rng.isOnList()) {\n\t        styleInfo['list-style'] = 'none';\n\t      } else {\n\t        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n\t        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n\t        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n\t      }\n\t\n\t      var para = dom.ancestor(rng.sc, dom.isPara);\n\t      if (para && para.style['line-height']) {\n\t        styleInfo['line-height'] = para.style.lineHeight;\n\t      } else {\n\t        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n\t        styleInfo['line-height'] = lineHeight.toFixed(1);\n\t      }\n\t\n\t      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n\t      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n\t      styleInfo.range = rng;\n\t\n\t      return styleInfo;\n\t    };\n\t  };\n\t\n\t\n\t  /**\n\t   * @class editing.Bullet\n\t   *\n\t   * @alternateClassName Bullet\n\t   */\n\t  var Bullet = function () {\n\t    var self = this;\n\t\n\t    /**\n\t     * toggle ordered list\n\t     */\n\t    this.insertOrderedList = function (editable) {\n\t      this.toggleList('OL', editable);\n\t    };\n\t\n\t    /**\n\t     * toggle unordered list\n\t     */\n\t    this.insertUnorderedList = function (editable) {\n\t      this.toggleList('UL', editable);\n\t    };\n\t\n\t    /**\n\t     * indent\n\t     */\n\t    this.indent = function (editable) {\n\t      var self = this;\n\t      var rng = range.create(editable).wrapBodyInlineWithPara();\n\t\n\t      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n\t      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\t\n\t      $.each(clustereds, function (idx, paras) {\n\t        var head = list.head(paras);\n\t        if (dom.isLi(head)) {\n\t          self.wrapList(paras, head.parentNode.nodeName);\n\t        } else {\n\t          $.each(paras, function (idx, para) {\n\t            $(para).css('marginLeft', function (idx, val) {\n\t              return (parseInt(val, 10) || 0) + 25;\n\t            });\n\t          });\n\t        }\n\t      });\n\t\n\t      rng.select();\n\t    };\n\t\n\t    /**\n\t     * outdent\n\t     */\n\t    this.outdent = function (editable) {\n\t      var self = this;\n\t      var rng = range.create(editable).wrapBodyInlineWithPara();\n\t\n\t      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n\t      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\t\n\t      $.each(clustereds, function (idx, paras) {\n\t        var head = list.head(paras);\n\t        if (dom.isLi(head)) {\n\t          self.releaseList([paras]);\n\t        } else {\n\t          $.each(paras, function (idx, para) {\n\t            $(para).css('marginLeft', function (idx, val) {\n\t              val = (parseInt(val, 10) || 0);\n\t              return val > 25 ? val - 25 : '';\n\t            });\n\t          });\n\t        }\n\t      });\n\t\n\t      rng.select();\n\t    };\n\t\n\t    /**\n\t     * toggle list\n\t     *\n\t     * @param {String} listName - OL or UL\n\t     */\n\t    this.toggleList = function (listName, editable) {\n\t      var rng = range.create(editable).wrapBodyInlineWithPara();\n\t\n\t      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n\t      var bookmark = rng.paraBookmark(paras);\n\t      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\t\n\t      // paragraph to list\n\t      if (list.find(paras, dom.isPurePara)) {\n\t        var wrappedParas = [];\n\t        $.each(clustereds, function (idx, paras) {\n\t          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n\t        });\n\t        paras = wrappedParas;\n\t      // list to paragraph or change list style\n\t      } else {\n\t        var diffLists = rng.nodes(dom.isList, {\n\t          includeAncestor: true\n\t        }).filter(function (listNode) {\n\t          return !$.nodeName(listNode, listName);\n\t        });\n\t\n\t        if (diffLists.length) {\n\t          $.each(diffLists, function (idx, listNode) {\n\t            dom.replace(listNode, listName);\n\t          });\n\t        } else {\n\t          paras = this.releaseList(clustereds, true);\n\t        }\n\t      }\n\t\n\t      range.createFromParaBookmark(bookmark, paras).select();\n\t    };\n\t\n\t    /**\n\t     * @param {Node[]} paras\n\t     * @param {String} listName\n\t     * @return {Node[]}\n\t     */\n\t    this.wrapList = function (paras, listName) {\n\t      var head = list.head(paras);\n\t      var last = list.last(paras);\n\t\n\t      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n\t      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\t\n\t      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\t\n\t      // P to LI\n\t      paras = paras.map(function (para) {\n\t        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n\t      });\n\t\n\t      // append to list(<ul>, <ol>)\n\t      dom.appendChildNodes(listNode, paras);\n\t\n\t      if (nextList) {\n\t        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n\t        dom.remove(nextList);\n\t      }\n\t\n\t      return paras;\n\t    };\n\t\n\t    /**\n\t     * @method releaseList\n\t     *\n\t     * @param {Array[]} clustereds\n\t     * @param {Boolean} isEscapseToBody\n\t     * @return {Node[]}\n\t     */\n\t    this.releaseList = function (clustereds, isEscapseToBody) {\n\t      var releasedParas = [];\n\t\n\t      $.each(clustereds, function (idx, paras) {\n\t        var head = list.head(paras);\n\t        var last = list.last(paras);\n\t\n\t        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n\t                                         head.parentNode;\n\t        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n\t          node: last.parentNode,\n\t          offset: dom.position(last) + 1\n\t        }, {\n\t          isSkipPaddingBlankHTML: true\n\t        }) : null;\n\t\n\t        var middleList = dom.splitTree(headList, {\n\t          node: head.parentNode,\n\t          offset: dom.position(head)\n\t        }, {\n\t          isSkipPaddingBlankHTML: true\n\t        });\n\t\n\t        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n\t                                  list.from(middleList.childNodes).filter(dom.isLi);\n\t\n\t        // LI to P\n\t        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n\t          paras = paras.map(function (para) {\n\t            return dom.replace(para, 'P');\n\t          });\n\t        }\n\t\n\t        $.each(list.from(paras).reverse(), function (idx, para) {\n\t          dom.insertAfter(para, headList);\n\t        });\n\t\n\t        // remove empty lists\n\t        var rootLists = list.compact([headList, middleList, lastList]);\n\t        $.each(rootLists, function (idx, rootList) {\n\t          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n\t          $.each(listNodes.reverse(), function (idx, listNode) {\n\t            if (!dom.nodeLength(listNode)) {\n\t              dom.remove(listNode, true);\n\t            }\n\t          });\n\t        });\n\t\n\t        releasedParas = releasedParas.concat(paras);\n\t      });\n\t\n\t      return releasedParas;\n\t    };\n\t  };\n\t\n\t\n\t  /**\n\t   * @class editing.Typing\n\t   *\n\t   * Typing\n\t   *\n\t   */\n\t  var Typing = function () {\n\t\n\t    // a Bullet instance to toggle lists off\n\t    var bullet = new Bullet();\n\t\n\t    /**\n\t     * insert tab\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @param {Number} tabsize\n\t     */\n\t    this.insertTab = function (rng, tabsize) {\n\t      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n\t      rng = rng.deleteContents();\n\t      rng.insertNode(tab, true);\n\t\n\t      rng = range.create(tab, tabsize);\n\t      rng.select();\n\t    };\n\t\n\t    /**\n\t     * insert paragraph\n\t     */\n\t    this.insertParagraph = function (editable) {\n\t      var rng = range.create(editable);\n\t\n\t      // deleteContents on range.\n\t      rng = rng.deleteContents();\n\t\n\t      // Wrap range if it needs to be wrapped by paragraph\n\t      rng = rng.wrapBodyInlineWithPara();\n\t\n\t      // finding paragraph\n\t      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\t\n\t      var nextPara;\n\t      // on paragraph: split paragraph\n\t      if (splitRoot) {\n\t        // if it is an empty line with li\n\t        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n\t          // toogle UL/OL and escape\n\t          bullet.toggleList(splitRoot.parentNode.nodeName);\n\t          return;\n\t        // if it is an empty line with para on blockquote\n\t        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n\t          // escape blockquote\n\t          dom.insertAfter(splitRoot, splitRoot.parentNode);\n\t          nextPara = splitRoot;\n\t        // if new line has content (not a line break)\n\t        } else {\n\t          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\t\n\t          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n\t          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\t\n\t          $.each(emptyAnchors, function (idx, anchor) {\n\t            dom.remove(anchor);\n\t          });\n\t\n\t          // replace empty heading or pre with P tag\n\t          if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {\n\t            nextPara = dom.replace(nextPara, 'p');\n\t          }\n\t        }\n\t      // no paragraph: insert empty paragraph\n\t      } else {\n\t        var next = rng.sc.childNodes[rng.so];\n\t        nextPara = $(dom.emptyPara)[0];\n\t        if (next) {\n\t          rng.sc.insertBefore(nextPara, next);\n\t        } else {\n\t          rng.sc.appendChild(nextPara);\n\t        }\n\t      }\n\t\n\t      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n\t    };\n\t  };\n\t\n\t  /**\n\t   * @class editing.Table\n\t   *\n\t   * Table\n\t   *\n\t   */\n\t  var Table = function () {\n\t    /**\n\t     * handle tab key\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @param {Boolean} isShift\n\t     */\n\t    this.tab = function (rng, isShift) {\n\t      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n\t      var table = dom.ancestor(cell, dom.isTable);\n\t      var cells = dom.listDescendant(table, dom.isCell);\n\t\n\t      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n\t      if (nextCell) {\n\t        range.create(nextCell, 0).select();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * create empty table element\n\t     *\n\t     * @param {Number} rowCount\n\t     * @param {Number} colCount\n\t     * @return {Node}\n\t     */\n\t    this.createTable = function (colCount, rowCount, options) {\n\t      var tds = [], tdHTML;\n\t      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n\t        tds.push('<td>' + dom.blank + '</td>');\n\t      }\n\t      tdHTML = tds.join('');\n\t\n\t      var trs = [], trHTML;\n\t      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n\t        trs.push('<tr>' + tdHTML + '</tr>');\n\t      }\n\t      trHTML = trs.join('');\n\t      var $table = $('<table>' + trHTML + '</table>');\n\t      if (options && options.tableClassName) {\n\t        $table.addClass(options.tableClassName);\n\t      }\n\t\n\t      return $table[0];\n\t    };\n\t  };\n\t\n\t\n\t  var KEY_BOGUS = 'bogus';\n\t\n\t  /**\n\t   * @class Editor\n\t   */\n\t  var Editor = function (context) {\n\t    var self = this;\n\t\n\t    var $note = context.layoutInfo.note;\n\t    var $editor = context.layoutInfo.editor;\n\t    var $editable = context.layoutInfo.editable;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    var editable = $editable[0];\n\t    var lastRange = null;\n\t\n\t    var style = new Style();\n\t    var table = new Table();\n\t    var typing = new Typing();\n\t    var bullet = new Bullet();\n\t    var history = new History($editable);\n\t\n\t    this.initialize = function () {\n\t      // bind custom events\n\t      $editable.on('keydown', function (event) {\n\t        if (event.keyCode === key.code.ENTER) {\n\t          context.triggerEvent('enter', event);\n\t        }\n\t        context.triggerEvent('keydown', event);\n\t\n\t        if (!event.isDefaultPrevented()) {\n\t          if (options.shortcuts) {\n\t            self.handleKeyMap(event);\n\t          } else {\n\t            self.preventDefaultEditableShortCuts(event);\n\t          }\n\t        }\n\t      }).on('keyup', function (event) {\n\t        context.triggerEvent('keyup', event);\n\t      }).on('focus', function (event) {\n\t        context.triggerEvent('focus', event);\n\t      }).on('blur', function (event) {\n\t        context.triggerEvent('blur', event);\n\t      }).on('mousedown', function (event) {\n\t        context.triggerEvent('mousedown', event);\n\t      }).on('mouseup', function (event) {\n\t        context.triggerEvent('mouseup', event);\n\t      }).on('scroll', function (event) {\n\t        context.triggerEvent('scroll', event);\n\t      }).on('paste', function (event) {\n\t        context.triggerEvent('paste', event);\n\t      });\n\t\n\t      // init content before set event\n\t      $editable.html(dom.html($note) || dom.emptyPara);\n\t\n\t      // [workaround] IE doesn't have input events for contentEditable\n\t      // - see: https://goo.gl/4bfIvA\n\t      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n\t      $editable.on(changeEventName, func.debounce(function () {\n\t        context.triggerEvent('change', $editable.html());\n\t      }, 250));\n\t\n\t      $editor.on('focusin', function (event) {\n\t        context.triggerEvent('focusin', event);\n\t      }).on('focusout', function (event) {\n\t        context.triggerEvent('focusout', event);\n\t      });\n\t\n\t      if (!options.airMode) {\n\t        if (options.width) {\n\t          $editor.outerWidth(options.width);\n\t        }\n\t        if (options.height) {\n\t          $editable.outerHeight(options.height);\n\t        }\n\t        if (options.maxHeight) {\n\t          $editable.css('max-height', options.maxHeight);\n\t        }\n\t        if (options.minHeight) {\n\t          $editable.css('min-height', options.minHeight);\n\t        }\n\t      }\n\t\n\t      history.recordUndo();\n\t    };\n\t\n\t    this.destroy = function () {\n\t      $editable.off();\n\t    };\n\t\n\t    this.handleKeyMap = function (event) {\n\t      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n\t      var keys = [];\n\t\n\t      if (event.metaKey) { keys.push('CMD'); }\n\t      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n\t      if (event.shiftKey) { keys.push('SHIFT'); }\n\t\n\t      var keyName = key.nameFromCode[event.keyCode];\n\t      if (keyName) {\n\t        keys.push(keyName);\n\t      }\n\t\n\t      var eventName = keyMap[keys.join('+')];\n\t      if (eventName) {\n\t        event.preventDefault();\n\t        context.invoke(eventName);\n\t      } else if (key.isEdit(event.keyCode)) {\n\t        this.afterCommand();\n\t      }\n\t    };\n\t\n\t    this.preventDefaultEditableShortCuts = function (event) {\n\t      // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)\n\t      if ((event.ctrlKey || event.metaKey) &&\n\t        list.contains([66, 73, 85], event.keyCode)) {\n\t        event.preventDefault();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * create range\n\t     * @return {WrappedRange}\n\t     */\n\t    this.createRange = function () {\n\t      this.focus();\n\t      return range.create(editable);\n\t    };\n\t\n\t    /**\n\t     * saveRange\n\t     *\n\t     * save current range\n\t     *\n\t     * @param {Boolean} [thenCollapse=false]\n\t     */\n\t    this.saveRange = function (thenCollapse) {\n\t      lastRange = this.createRange();\n\t      if (thenCollapse) {\n\t        lastRange.collapse().select();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * restoreRange\n\t     *\n\t     * restore lately range\n\t     */\n\t    this.restoreRange = function () {\n\t      if (lastRange) {\n\t        lastRange.select();\n\t        this.focus();\n\t      }\n\t    };\n\t\n\t    this.saveTarget = function (node) {\n\t      $editable.data('target', node);\n\t    };\n\t\n\t    this.clearTarget = function () {\n\t      $editable.removeData('target');\n\t    };\n\t\n\t    this.restoreTarget = function () {\n\t      return $editable.data('target');\n\t    };\n\t\n\t    /**\n\t     * currentStyle\n\t     *\n\t     * current style\n\t     * @return {Object|Boolean} unfocus\n\t     */\n\t    this.currentStyle = function () {\n\t      var rng = range.create();\n\t      if (rng) {\n\t        rng = rng.normalize();\n\t      }\n\t      return rng ? style.current(rng) : style.fromNode($editable);\n\t    };\n\t\n\t    /**\n\t     * style from node\n\t     *\n\t     * @param {jQuery} $node\n\t     * @return {Object}\n\t     */\n\t    this.styleFromNode = function ($node) {\n\t      return style.fromNode($node);\n\t    };\n\t\n\t    /**\n\t     * undo\n\t     */\n\t    this.undo = function () {\n\t      context.triggerEvent('before.command', $editable.html());\n\t      history.undo();\n\t      context.triggerEvent('change', $editable.html());\n\t    };\n\t    context.memo('help.undo', lang.help.undo);\n\t\n\t    /**\n\t     * redo\n\t     */\n\t    this.redo = function () {\n\t      context.triggerEvent('before.command', $editable.html());\n\t      history.redo();\n\t      context.triggerEvent('change', $editable.html());\n\t    };\n\t    context.memo('help.redo', lang.help.redo);\n\t\n\t    /**\n\t     * before command\n\t     */\n\t    var beforeCommand = this.beforeCommand = function () {\n\t      context.triggerEvent('before.command', $editable.html());\n\t      // keep focus on editable before command execution\n\t      self.focus();\n\t    };\n\t\n\t    /**\n\t     * after command\n\t     * @param {Boolean} isPreventTrigger\n\t     */\n\t    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n\t      history.recordUndo();\n\t      if (!isPreventTrigger) {\n\t        context.triggerEvent('change', $editable.html());\n\t      }\n\t    };\n\t\n\t    /* jshint ignore:start */\n\t    // native commands(with execCommand), generate function for execCommand\n\t    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n\t                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n\t                    'formatBlock', 'removeFormat',\n\t                    'backColor', 'foreColor', 'fontName'];\n\t\n\t    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n\t      this[commands[idx]] = (function (sCmd) {\n\t        return function (value) {\n\t          beforeCommand();\n\t          document.execCommand(sCmd, false, value);\n\t          afterCommand(true);\n\t        };\n\t      })(commands[idx]);\n\t      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n\t    }\n\t    /* jshint ignore:end */\n\t\n\t    /**\n\t     * handle tab key\n\t     */\n\t    this.tab = function () {\n\t      var rng = this.createRange();\n\t      if (rng.isCollapsed() && rng.isOnCell()) {\n\t        table.tab(rng);\n\t      } else {\n\t        beforeCommand();\n\t        typing.insertTab(rng, options.tabSize);\n\t        afterCommand();\n\t      }\n\t    };\n\t    context.memo('help.tab', lang.help.tab);\n\t\n\t    /**\n\t     * handle shift+tab key\n\t     */\n\t    this.untab = function () {\n\t      var rng = this.createRange();\n\t      if (rng.isCollapsed() && rng.isOnCell()) {\n\t        table.tab(rng, true);\n\t      }\n\t    };\n\t    context.memo('help.untab', lang.help.untab);\n\t\n\t    /**\n\t     * run given function between beforeCommand and afterCommand\n\t     */\n\t    this.wrapCommand = function (fn) {\n\t      return function () {\n\t        beforeCommand();\n\t        fn.apply(self, arguments);\n\t        afterCommand();\n\t      };\n\t    };\n\t\n\t    /**\n\t     * insert paragraph\n\t     */\n\t    this.insertParagraph = this.wrapCommand(function () {\n\t      typing.insertParagraph(editable);\n\t    });\n\t    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\t\n\t    this.insertOrderedList = this.wrapCommand(function () {\n\t      bullet.insertOrderedList(editable);\n\t    });\n\t    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\t\n\t    this.insertUnorderedList = this.wrapCommand(function () {\n\t      bullet.insertUnorderedList(editable);\n\t    });\n\t    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\t\n\t    this.indent = this.wrapCommand(function () {\n\t      bullet.indent(editable);\n\t    });\n\t    context.memo('help.indent', lang.help.indent);\n\t\n\t    this.outdent = this.wrapCommand(function () {\n\t      bullet.outdent(editable);\n\t    });\n\t    context.memo('help.outdent', lang.help.outdent);\n\t\n\t    /**\n\t     * insert image\n\t     *\n\t     * @param {String} src\n\t     * @param {String|Function} param\n\t     * @return {Promise}\n\t     */\n\t    this.insertImage = function (src, param) {\n\t      return async.createImage(src, param).then(function ($image) {\n\t        beforeCommand();\n\t\n\t        if (typeof param === 'function') {\n\t          param($image);\n\t        } else {\n\t          if (typeof param === 'string') {\n\t            $image.attr('data-filename', param);\n\t          }\n\t          $image.css('width', Math.min($editable.width(), $image.width()));\n\t        }\n\t\n\t        $image.show();\n\t        range.create(editable).insertNode($image[0]);\n\t        range.createFromNodeAfter($image[0]).select();\n\t        afterCommand();\n\t      }).fail(function (e) {\n\t        context.triggerEvent('image.upload.error', e);\n\t      });\n\t    };\n\t\n\t    /**\n\t     * insertImages\n\t     * @param {File[]} files\n\t     */\n\t    this.insertImages = function (files) {\n\t      $.each(files, function (idx, file) {\n\t        var filename = file.name;\n\t        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n\t          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n\t        } else {\n\t          async.readFileAsDataURL(file).then(function (dataURL) {\n\t            return self.insertImage(dataURL, filename);\n\t          }).fail(function () {\n\t            context.triggerEvent('image.upload.error');\n\t          });\n\t        }\n\t      });\n\t    };\n\t\n\t    /**\n\t     * insertImagesOrCallback\n\t     * @param {File[]} files\n\t     */\n\t    this.insertImagesOrCallback = function (files) {\n\t      var callbacks = options.callbacks;\n\t\n\t      // If onImageUpload options setted\n\t      if (callbacks.onImageUpload) {\n\t        context.triggerEvent('image.upload', files);\n\t      // else insert Image as dataURL\n\t      } else {\n\t        this.insertImages(files);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * insertNode\n\t     * insert node\n\t     * @param {Node} node\n\t     */\n\t    this.insertNode = this.wrapCommand(function (node) {\n\t      var rng = this.createRange();\n\t      rng.insertNode(node);\n\t      range.createFromNodeAfter(node).select();\n\t    });\n\t\n\t    /**\n\t     * insert text\n\t     * @param {String} text\n\t     */\n\t    this.insertText = this.wrapCommand(function (text) {\n\t      var rng = this.createRange();\n\t      var textNode = rng.insertNode(dom.createText(text));\n\t      range.create(textNode, dom.nodeLength(textNode)).select();\n\t    });\n\t\n\t    /**\n\t     * return selected plain text\n\t     * @return {String} text\n\t     */\n\t    this.getSelectedText = function () {\n\t      var rng = this.createRange();\n\t\n\t      // if range on anchor, expand range with anchor\n\t      if (rng.isOnAnchor()) {\n\t        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n\t      }\n\t\n\t      return rng.toString();\n\t    };\n\t\n\t    /**\n\t     * paste HTML\n\t     * @param {String} markup\n\t     */\n\t    this.pasteHTML = this.wrapCommand(function (markup) {\n\t      var contents = this.createRange().pasteHTML(markup);\n\t      range.createFromNodeAfter(list.last(contents)).select();\n\t    });\n\t\n\t    /**\n\t     * formatBlock\n\t     *\n\t     * @param {String} tagName\n\t     */\n\t    this.formatBlock = this.wrapCommand(function (tagName) {\n\t      // [workaround] for MSIE, IE need `<`\n\t      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n\t      document.execCommand('FormatBlock', false, tagName);\n\t    });\n\t\n\t    this.formatPara = function () {\n\t      this.formatBlock('P');\n\t    };\n\t    context.memo('help.formatPara', lang.help.formatPara);\n\t\n\t    /* jshint ignore:start */\n\t    for (var idx = 1; idx <= 6; idx ++) {\n\t      this['formatH' + idx] = function (idx) {\n\t        return function () {\n\t          this.formatBlock('H' + idx);\n\t        };\n\t      }(idx);\n\t      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n\t    };\n\t    /* jshint ignore:end */\n\t\n\t    /**\n\t     * fontSize\n\t     *\n\t     * @param {String} value - px\n\t     */\n\t    this.fontSize = function (value) {\n\t      var rng = this.createRange();\n\t\n\t      if (rng && rng.isCollapsed()) {\n\t        var spans = style.styleNodes(rng);\n\t        var firstSpan = list.head(spans);\n\t\n\t        $(spans).css({\n\t          'font-size': value + 'px'\n\t        });\n\t\n\t        // [workaround] added styled bogus span for style\n\t        //  - also bogus character needed for cursor position\n\t        if (firstSpan && !dom.nodeLength(firstSpan)) {\n\t          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n\t          range.createFromNodeAfter(firstSpan.firstChild).select();\n\t          $editable.data(KEY_BOGUS, firstSpan);\n\t        }\n\t      } else {\n\t        beforeCommand();\n\t        $(style.styleNodes(rng)).css({\n\t          'font-size': value + 'px'\n\t        });\n\t        afterCommand();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * insert horizontal rule\n\t     */\n\t    this.insertHorizontalRule = this.wrapCommand(function () {\n\t      var hrNode = this.createRange().insertNode(dom.create('HR'));\n\t      if (hrNode.nextSibling) {\n\t        range.create(hrNode.nextSibling, 0).normalize().select();\n\t      }\n\t    });\n\t    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\t\n\t    /**\n\t     * remove bogus node and character\n\t     */\n\t    this.removeBogus = function () {\n\t      var bogusNode = $editable.data(KEY_BOGUS);\n\t      if (!bogusNode) {\n\t        return;\n\t      }\n\t\n\t      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\t\n\t      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n\t      if (bogusCharIdx !== -1) {\n\t        textNode.deleteData(bogusCharIdx, 1);\n\t      }\n\t\n\t      if (dom.isEmpty(bogusNode)) {\n\t        dom.remove(bogusNode);\n\t      }\n\t\n\t      $editable.removeData(KEY_BOGUS);\n\t    };\n\t\n\t    /**\n\t     * lineHeight\n\t     * @param {String} value\n\t     */\n\t    this.lineHeight = this.wrapCommand(function (value) {\n\t      style.stylePara(this.createRange(), {\n\t        lineHeight: value\n\t      });\n\t    });\n\t\n\t    /**\n\t     * unlink\n\t     *\n\t     * @type command\n\t     */\n\t    this.unlink = function () {\n\t      var rng = this.createRange();\n\t      if (rng.isOnAnchor()) {\n\t        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n\t        rng = range.createFromNode(anchor);\n\t        rng.select();\n\t\n\t        beforeCommand();\n\t        document.execCommand('unlink');\n\t        afterCommand();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * create link (command)\n\t     *\n\t     * @param {Object} linkInfo\n\t     */\n\t    this.createLink = this.wrapCommand(function (linkInfo) {\n\t      var linkUrl = linkInfo.url;\n\t      var linkText = linkInfo.text;\n\t      var isNewWindow = linkInfo.isNewWindow;\n\t      var rng = linkInfo.range || this.createRange();\n\t      var isTextChanged = rng.toString() !== linkText;\n\t\n\t      // handle spaced urls from input\n\t      if (typeof linkUrl === 'string') {\n\t        linkUrl = linkUrl.trim();\n\t      }\n\t\n\t      if (options.onCreateLink) {\n\t        linkUrl = options.onCreateLink(linkUrl);\n\t      }\n\t\n\t      var anchors = [];\n\t      if (isTextChanged) {\n\t        rng = rng.deleteContents();\n\t        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n\t        anchors.push(anchor);\n\t      } else {\n\t        anchors = style.styleNodes(rng, {\n\t          nodeName: 'A',\n\t          expandClosestSibling: true,\n\t          onlyPartialContains: true\n\t        });\n\t      }\n\t\n\t      $.each(anchors, function (idx, anchor) {\n\t        // if url doesn't match an URL schema, set http:// as default\n\t        linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?/.test(linkUrl) ?\n\t          linkUrl : 'http://' + linkUrl;\n\t\n\t        $(anchor).attr('href', linkUrl);\n\t        if (isNewWindow) {\n\t          $(anchor).attr('target', '_blank');\n\t        } else {\n\t          $(anchor).removeAttr('target');\n\t        }\n\t      });\n\t\n\t      var startRange = range.createFromNodeBefore(list.head(anchors));\n\t      var startPoint = startRange.getStartPoint();\n\t      var endRange = range.createFromNodeAfter(list.last(anchors));\n\t      var endPoint = endRange.getEndPoint();\n\t\n\t      range.create(\n\t        startPoint.node,\n\t        startPoint.offset,\n\t        endPoint.node,\n\t        endPoint.offset\n\t      ).select();\n\t    });\n\t\n\t    /**\n\t     * returns link info\n\t     *\n\t     * @return {Object}\n\t     * @return {WrappedRange} return.range\n\t     * @return {String} return.text\n\t     * @return {Boolean} [return.isNewWindow=true]\n\t     * @return {String} [return.url=\"\"]\n\t     */\n\t    this.getLinkInfo = function () {\n\t      var rng = this.createRange().expand(dom.isAnchor);\n\t\n\t      // Get the first anchor on range(for edit).\n\t      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n\t\n\t      return {\n\t        range: rng,\n\t        text: rng.toString(),\n\t        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,\n\t        url: $anchor.length ? $anchor.attr('href') : ''\n\t      };\n\t    };\n\t\n\t    /**\n\t     * setting color\n\t     *\n\t     * @param {Object} sObjColor  color code\n\t     * @param {String} sObjColor.foreColor foreground color\n\t     * @param {String} sObjColor.backColor background color\n\t     */\n\t    this.color = this.wrapCommand(function (colorInfo) {\n\t      var foreColor = colorInfo.foreColor;\n\t      var backColor = colorInfo.backColor;\n\t\n\t      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n\t      if (backColor) { document.execCommand('backColor', false, backColor); }\n\t    });\n\t\n\t    /**\n\t     * insert Table\n\t     *\n\t     * @param {String} dimension of table (ex : \"5x5\")\n\t     */\n\t    this.insertTable = this.wrapCommand(function (dim) {\n\t      var dimension = dim.split('x');\n\t\n\t      var rng = this.createRange().deleteContents();\n\t      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n\t    });\n\t\n\t    /**\n\t     * float me\n\t     *\n\t     * @param {String} value\n\t     */\n\t    this.floatMe = this.wrapCommand(function (value) {\n\t      var $target = $(this.restoreTarget());\n\t      $target.css('float', value);\n\t    });\n\t\n\t    /**\n\t     * resize overlay element\n\t     * @param {String} value\n\t     */\n\t    this.resize = this.wrapCommand(function (value) {\n\t      var $target = $(this.restoreTarget());\n\t      $target.css({\n\t        width: value * 100 + '%',\n\t        height: ''\n\t      });\n\t    });\n\t\n\t    /**\n\t     * @param {Position} pos\n\t     * @param {jQuery} $target - target element\n\t     * @param {Boolean} [bKeepRatio] - keep ratio\n\t     */\n\t    this.resizeTo = function (pos, $target, bKeepRatio) {\n\t      var imageSize;\n\t      if (bKeepRatio) {\n\t        var newRatio = pos.y / pos.x;\n\t        var ratio = $target.data('ratio');\n\t        imageSize = {\n\t          width: ratio > newRatio ? pos.x : pos.y / ratio,\n\t          height: ratio > newRatio ? pos.x * ratio : pos.y\n\t        };\n\t      } else {\n\t        imageSize = {\n\t          width: pos.x,\n\t          height: pos.y\n\t        };\n\t      }\n\t\n\t      $target.css(imageSize);\n\t    };\n\t\n\t    /**\n\t     * remove media object\n\t     */\n\t    this.removeMedia = this.wrapCommand(function () {\n\t      var $target = $(this.restoreTarget()).detach();\n\t      context.triggerEvent('media.delete', $target, $editable);\n\t    });\n\t\n\t    /**\n\t     * returns whether editable area has focus or not.\n\t     */\n\t    this.hasFocus = function () {\n\t      return $editable.is(':focus');\n\t    };\n\t\n\t    /**\n\t     * set focus\n\t     */\n\t    this.focus = function () {\n\t      // [workaround] Screen will move when page is scolled in IE.\n\t      //  - do focus when not focused\n\t      if (!this.hasFocus()) {\n\t        $editable.focus();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * returns whether contents is empty or not.\n\t     * @return {Boolean}\n\t     */\n\t    this.isEmpty = function () {\n\t      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n\t    };\n\t\n\t    /**\n\t     * Removes all contents and restores the editable instance to an _emptyPara_.\n\t     */\n\t    this.empty = function () {\n\t      context.invoke('code', dom.emptyPara);\n\t    };\n\t  };\n\t\n\t  var Clipboard = function (context) {\n\t    var self = this;\n\t\n\t    var $editable = context.layoutInfo.editable;\n\t\n\t    this.events = {\n\t      'summernote.keydown': function (we, e) {\n\t        if (self.needKeydownHook()) {\n\t          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n\t            context.invoke('editor.saveRange');\n\t            self.$paste.focus();\n\t\n\t            setTimeout(function () {\n\t              self.pasteByHook();\n\t            }, 0);\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    this.needKeydownHook = function () {\n\t      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n\t    };\n\t\n\t    this.initialize = function () {\n\t      // [workaround] getting image from clipboard\n\t      //  - IE11 and Firefox: CTRL+v hook\n\t      //  - Webkit: event.clipboardData\n\t      if (this.needKeydownHook()) {\n\t        this.$paste = $('<div tabindex=\"-1\" />').attr('contenteditable', true).css({\n\t          position: 'absolute',\n\t          left: -100000,\n\t          opacity: 0\n\t        });\n\t        $editable.before(this.$paste);\n\t\n\t        this.$paste.on('paste', function (event) {\n\t          context.triggerEvent('paste', event);\n\t        });\n\t      } else {\n\t        $editable.on('paste', this.pasteByEvent);\n\t      }\n\t    };\n\t\n\t    this.destroy = function () {\n\t      if (this.needKeydownHook()) {\n\t        this.$paste.remove();\n\t        this.$paste = null;\n\t      }\n\t    };\n\t\n\t    this.pasteByHook = function () {\n\t      var node = this.$paste[0].firstChild;\n\t\n\t      if (dom.isImg(node)) {\n\t        var dataURI = node.src;\n\t        var decodedData = atob(dataURI.split(',')[1]);\n\t        var array = new Uint8Array(decodedData.length);\n\t        for (var i = 0; i < decodedData.length; i++) {\n\t          array[i] = decodedData.charCodeAt(i);\n\t        }\n\t\n\t        var blob = new Blob([array], { type: 'image/png' });\n\t        blob.name = 'clipboard.png';\n\t\n\t        context.invoke('editor.restoreRange');\n\t        context.invoke('editor.focus');\n\t        context.invoke('editor.insertImagesOrCallback', [blob]);\n\t      } else {\n\t        var pasteContent = $('<div />').html(this.$paste.html()).html();\n\t        context.invoke('editor.restoreRange');\n\t        context.invoke('editor.focus');\n\t\n\t        if (pasteContent) {\n\t          context.invoke('editor.pasteHTML', pasteContent);\n\t        }\n\t      }\n\t\n\t      this.$paste.empty();\n\t    };\n\t\n\t    /**\n\t     * paste by clipboard event\n\t     *\n\t     * @param {Event} event\n\t     */\n\t    this.pasteByEvent = function (event) {\n\t      var clipboardData = event.originalEvent.clipboardData;\n\t      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n\t        var item = list.head(clipboardData.items);\n\t        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n\t          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n\t        }\n\t        context.invoke('editor.afterCommand');\n\t      }\n\t    };\n\t  };\n\t\n\t  var Dropzone = function (context) {\n\t    var $document = $(document);\n\t    var $editor = context.layoutInfo.editor;\n\t    var $editable = context.layoutInfo.editable;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t    var documentEventHandlers = {};\n\t\n\t    var $dropzone = $([\n\t      '<div class=\"note-dropzone\">',\n\t      '  <div class=\"note-dropzone-message\"/>',\n\t      '</div>'\n\t    ].join('')).prependTo($editor);\n\t\n\t    var detachDocumentEvent = function () {\n\t      Object.keys(documentEventHandlers).forEach(function (key) {\n\t        $document.off(key.substr(2).toLowerCase(), documentEventHandlers[key]);\n\t      });\n\t      documentEventHandlers = {};\n\t    };\n\t\n\t    /**\n\t     * attach Drag and Drop Events\n\t     */\n\t    this.initialize = function () {\n\t      if (options.disableDragAndDrop) {\n\t        // prevent default drop event\n\t        documentEventHandlers.onDrop = function (e) {\n\t          e.preventDefault();\n\t        };\n\t        $document.on('drop', documentEventHandlers.onDrop);\n\t      } else {\n\t        this.attachDragAndDropEvent();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * attach Drag and Drop Events\n\t     */\n\t    this.attachDragAndDropEvent = function () {\n\t      var collection = $(),\n\t          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\t\n\t      documentEventHandlers.onDragenter = function (e) {\n\t        var isCodeview = context.invoke('codeview.isActivated');\n\t        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n\t        if (!isCodeview && !collection.length && hasEditorSize) {\n\t          $editor.addClass('dragover');\n\t          $dropzone.width($editor.width());\n\t          $dropzone.height($editor.height());\n\t          $dropzoneMessage.text(lang.image.dragImageHere);\n\t        }\n\t        collection = collection.add(e.target);\n\t      };\n\t\n\t      documentEventHandlers.onDragleave = function (e) {\n\t        collection = collection.not(e.target);\n\t        if (!collection.length) {\n\t          $editor.removeClass('dragover');\n\t        }\n\t      };\n\t\n\t      documentEventHandlers.onDrop = function () {\n\t        collection = $();\n\t        $editor.removeClass('dragover');\n\t      };\n\t\n\t      // show dropzone on dragenter when dragging a object to document\n\t      // -but only if the editor is visible, i.e. has a positive width and height\n\t      $document.on('dragenter', documentEventHandlers.onDragenter)\n\t        .on('dragleave', documentEventHandlers.onDragleave)\n\t        .on('drop', documentEventHandlers.onDrop);\n\t\n\t      // change dropzone's message on hover.\n\t      $dropzone.on('dragenter', function () {\n\t        $dropzone.addClass('hover');\n\t        $dropzoneMessage.text(lang.image.dropImage);\n\t      }).on('dragleave', function () {\n\t        $dropzone.removeClass('hover');\n\t        $dropzoneMessage.text(lang.image.dragImageHere);\n\t      });\n\t\n\t      // attach dropImage\n\t      $dropzone.on('drop', function (event) {\n\t        var dataTransfer = event.originalEvent.dataTransfer;\n\t\n\t        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n\t          event.preventDefault();\n\t          $editable.focus();\n\t          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n\t        } else {\n\t          $.each(dataTransfer.types, function (idx, type) {\n\t            var content = dataTransfer.getData(type);\n\t\n\t            if (type.toLowerCase().indexOf('text') > -1) {\n\t              context.invoke('editor.pasteHTML', content);\n\t            } else {\n\t              $(content).each(function () {\n\t                context.invoke('editor.insertNode', this);\n\t              });\n\t            }\n\t          });\n\t        }\n\t      }).on('dragover', false); // prevent default dragover event\n\t    };\n\t\n\t    this.destroy = function () {\n\t      detachDocumentEvent();\n\t    };\n\t  };\n\t\n\t\n\t  var CodeMirror;\n\t  if (agent.hasCodeMirror) {\n\t    if (agent.isSupportAmd) {\n\t      !/* require */(/* empty */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(80)]; (function (cm) {\n\t        CodeMirror = cm;\n\t      }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}());\n\t    } else {\n\t      CodeMirror = window.CodeMirror;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * @class Codeview\n\t   */\n\t  var Codeview = function (context) {\n\t    var $editor = context.layoutInfo.editor;\n\t    var $editable = context.layoutInfo.editable;\n\t    var $codable = context.layoutInfo.codable;\n\t    var options = context.options;\n\t\n\t    this.sync = function () {\n\t      var isCodeview = this.isActivated();\n\t      if (isCodeview && agent.hasCodeMirror) {\n\t        $codable.data('cmEditor').save();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @return {Boolean}\n\t     */\n\t    this.isActivated = function () {\n\t      return $editor.hasClass('codeview');\n\t    };\n\t\n\t    /**\n\t     * toggle codeview\n\t     */\n\t    this.toggle = function () {\n\t      if (this.isActivated()) {\n\t        this.deactivate();\n\t      } else {\n\t        this.activate();\n\t      }\n\t      context.triggerEvent('codeview.toggled');\n\t    };\n\t\n\t    /**\n\t     * activate code view\n\t     */\n\t    this.activate = function () {\n\t      $codable.val(dom.html($editable, options.prettifyHtml));\n\t      $codable.height($editable.height());\n\t\n\t      context.invoke('toolbar.updateCodeview', true);\n\t      $editor.addClass('codeview');\n\t      $codable.focus();\n\t\n\t      // activate CodeMirror as codable\n\t      if (agent.hasCodeMirror) {\n\t        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\t\n\t        // CodeMirror TernServer\n\t        if (options.codemirror.tern) {\n\t          var server = new CodeMirror.TernServer(options.codemirror.tern);\n\t          cmEditor.ternServer = server;\n\t          cmEditor.on('cursorActivity', function (cm) {\n\t            server.updateArgHints(cm);\n\t          });\n\t        }\n\t\n\t        // CodeMirror hasn't Padding.\n\t        cmEditor.setSize(null, $editable.outerHeight());\n\t        $codable.data('cmEditor', cmEditor);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * deactivate code view\n\t     */\n\t    this.deactivate = function () {\n\t      // deactivate CodeMirror as codable\n\t      if (agent.hasCodeMirror) {\n\t        var cmEditor = $codable.data('cmEditor');\n\t        $codable.val(cmEditor.getValue());\n\t        cmEditor.toTextArea();\n\t      }\n\t\n\t      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n\t      var isChange = $editable.html() !== value;\n\t\n\t      $editable.html(value);\n\t      $editable.height(options.height ? $codable.height() : 'auto');\n\t      $editor.removeClass('codeview');\n\t\n\t      if (isChange) {\n\t        context.triggerEvent('change', $editable.html(), $editable);\n\t      }\n\t\n\t      $editable.focus();\n\t\n\t      context.invoke('toolbar.updateCodeview', false);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      if (this.isActivated()) {\n\t        this.deactivate();\n\t      }\n\t    };\n\t  };\n\t\n\t  var EDITABLE_PADDING = 24;\n\t\n\t  var Statusbar = function (context) {\n\t    var $document = $(document);\n\t    var $statusbar = context.layoutInfo.statusbar;\n\t    var $editable = context.layoutInfo.editable;\n\t    var options = context.options;\n\t\n\t    this.initialize = function () {\n\t      if (options.airMode || options.disableResizeEditor) {\n\t        return;\n\t      }\n\t\n\t      $statusbar.on('mousedown', function (event) {\n\t        event.preventDefault();\n\t        event.stopPropagation();\n\t\n\t        var editableTop = $editable.offset().top - $document.scrollTop();\n\t\n\t        $document.on('mousemove', function (event) {\n\t          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\t\n\t          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n\t          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\t\n\t          $editable.height(height);\n\t        }).one('mouseup', function () {\n\t          $document.off('mousemove');\n\t        });\n\t      });\n\t    };\n\t\n\t    this.destroy = function () {\n\t      $statusbar.off();\n\t      $statusbar.remove();\n\t    };\n\t  };\n\t\n\t  var Fullscreen = function (context) {\n\t    var $editor = context.layoutInfo.editor;\n\t    var $toolbar = context.layoutInfo.toolbar;\n\t    var $editable = context.layoutInfo.editable;\n\t    var $codable = context.layoutInfo.codable;\n\t\n\t    var $window = $(window);\n\t    var $scrollbar = $('html, body');\n\t\n\t    /**\n\t     * toggle fullscreen\n\t     */\n\t    this.toggle = function () {\n\t      var resize = function (size) {\n\t        $editable.css('height', size.h);\n\t        $codable.css('height', size.h);\n\t        if ($codable.data('cmeditor')) {\n\t          $codable.data('cmeditor').setsize(null, size.h);\n\t        }\n\t      };\n\t\n\t      $editor.toggleClass('fullscreen');\n\t      if (this.isFullscreen()) {\n\t        $editable.data('orgHeight', $editable.css('height'));\n\t\n\t        $window.on('resize', function () {\n\t          resize({\n\t            h: $window.height() - $toolbar.outerHeight()\n\t          });\n\t        }).trigger('resize');\n\t\n\t        $scrollbar.css('overflow', 'hidden');\n\t      } else {\n\t        $window.off('resize');\n\t        resize({\n\t          h: $editable.data('orgHeight')\n\t        });\n\t        $scrollbar.css('overflow', 'visible');\n\t      }\n\t\n\t      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n\t    };\n\t\n\t    this.isFullscreen = function () {\n\t      return $editor.hasClass('fullscreen');\n\t    };\n\t  };\n\t\n\t  var Handle = function (context) {\n\t    var self = this;\n\t\n\t    var $document = $(document);\n\t    var $editingArea = context.layoutInfo.editingArea;\n\t    var options = context.options;\n\t\n\t    this.events = {\n\t      'summernote.mousedown': function (we, e) {\n\t        if (self.update(e.target)) {\n\t          e.preventDefault();\n\t        }\n\t      },\n\t      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n\t        self.update();\n\t      }\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$handle = $([\n\t        '<div class=\"note-handle\">',\n\t        '<div class=\"note-control-selection\">',\n\t        '<div class=\"note-control-selection-bg\"></div>',\n\t        '<div class=\"note-control-holder note-control-nw\"></div>',\n\t        '<div class=\"note-control-holder note-control-ne\"></div>',\n\t        '<div class=\"note-control-holder note-control-sw\"></div>',\n\t        '<div class=\"',\n\t        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n\t        ' note-control-se\"></div>',\n\t        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n\t        '</div>',\n\t        '</div>'\n\t      ].join('')).prependTo($editingArea);\n\t\n\t      this.$handle.on('mousedown', function (event) {\n\t        if (dom.isControlSizing(event.target)) {\n\t          event.preventDefault();\n\t          event.stopPropagation();\n\t\n\t          var $target = self.$handle.find('.note-control-selection').data('target'),\n\t              posStart = $target.offset(),\n\t              scrollTop = $document.scrollTop();\n\t\n\t          $document.on('mousemove', function (event) {\n\t            context.invoke('editor.resizeTo', {\n\t              x: event.clientX - posStart.left,\n\t              y: event.clientY - (posStart.top - scrollTop)\n\t            }, $target, !event.shiftKey);\n\t\n\t            self.update($target[0]);\n\t          }).one('mouseup', function (e) {\n\t            e.preventDefault();\n\t            $document.off('mousemove');\n\t            context.invoke('editor.afterCommand');\n\t          });\n\t\n\t          if (!$target.data('ratio')) { // original ratio.\n\t            $target.data('ratio', $target.height() / $target.width());\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$handle.remove();\n\t    };\n\t\n\t    this.update = function (target) {\n\t      var isImage = dom.isImg(target);\n\t      var $selection = this.$handle.find('.note-control-selection');\n\t\n\t      context.invoke('imagePopover.update', target);\n\t\n\t      if (isImage) {\n\t        var $image = $(target);\n\t        var pos = $image.position();\n\t\n\t        // include margin\n\t        var imageSize = {\n\t          w: $image.outerWidth(true),\n\t          h: $image.outerHeight(true)\n\t        };\n\t\n\t        $selection.css({\n\t          display: 'block',\n\t          left: pos.left,\n\t          top: pos.top,\n\t          width: imageSize.w,\n\t          height: imageSize.h\n\t        }).data('target', $image); // save current image element.\n\t\n\t        var sizingText = imageSize.w + 'x' + imageSize.h;\n\t        $selection.find('.note-control-selection-info').text(sizingText);\n\t        context.invoke('editor.saveTarget', target);\n\t      } else {\n\t        this.hide();\n\t      }\n\t\n\t      return isImage;\n\t    };\n\t\n\t    /**\n\t     * hide\n\t     *\n\t     * @param {jQuery} $handle\n\t     */\n\t    this.hide = function () {\n\t      context.invoke('editor.clearTarget');\n\t      this.$handle.children().hide();\n\t    };\n\t  };\n\t\n\t  var AutoLink = function (context) {\n\t    var self = this;\n\t    var defaultScheme = 'http://';\n\t    var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\t\n\t    this.events = {\n\t      'summernote.keyup': function (we, e) {\n\t        if (!e.isDefaultPrevented()) {\n\t          self.handleKeyup(e);\n\t        }\n\t      },\n\t      'summernote.keydown': function (we, e) {\n\t        self.handleKeydown(e);\n\t      }\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.lastWordRange = null;\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.lastWordRange = null;\n\t    };\n\t\n\t    this.replace = function () {\n\t      if (!this.lastWordRange) {\n\t        return;\n\t      }\n\t\n\t      var keyword = this.lastWordRange.toString();\n\t      var match = keyword.match(linkPattern);\n\t\n\t      if (match && (match[1] || match[2])) {\n\t        var link = match[1] ? keyword : defaultScheme + keyword;\n\t        var node = $('<a />').html(keyword).attr('href', link)[0];\n\t\n\t        this.lastWordRange.insertNode(node);\n\t        this.lastWordRange = null;\n\t        context.invoke('editor.focus');\n\t      }\n\t\n\t    };\n\t\n\t    this.handleKeydown = function (e) {\n\t      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n\t        var wordRange = context.invoke('editor.createRange').getWordRange();\n\t        this.lastWordRange = wordRange;\n\t      }\n\t    };\n\t\n\t    this.handleKeyup = function (e) {\n\t      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n\t        this.replace();\n\t      }\n\t    };\n\t  };\n\t\n\t  /**\n\t   * textarea auto sync.\n\t   */\n\t  var AutoSync = function (context) {\n\t    var $note = context.layoutInfo.note;\n\t\n\t    this.events = {\n\t      'summernote.change': function () {\n\t        $note.val(context.invoke('code'));\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return dom.isTextarea($note[0]);\n\t    };\n\t  };\n\t\n\t  var Placeholder = function (context) {\n\t    var self = this;\n\t    var $editingArea = context.layoutInfo.editingArea;\n\t    var options = context.options;\n\t\n\t    this.events = {\n\t      'summernote.init summernote.change': function () {\n\t        self.update();\n\t      },\n\t      'summernote.codeview.toggled': function () {\n\t        self.update();\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return !!options.placeholder;\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$placeholder = $('<div class=\"note-placeholder\">');\n\t      this.$placeholder.on('click', function () {\n\t        context.invoke('focus');\n\t      }).text(options.placeholder).prependTo($editingArea);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$placeholder.remove();\n\t    };\n\t\n\t    this.update = function () {\n\t      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n\t      this.$placeholder.toggle(isShow);\n\t    };\n\t  };\n\t\n\t  var Buttons = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $toolbar = context.layoutInfo.toolbar;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\t\n\t    var representShortcut = this.representShortcut = function (editorMethod) {\n\t      var shortcut = invertedKeyMap[editorMethod];\n\t      if (!options.shortcuts || !shortcut) {\n\t        return '';\n\t      }\n\t      \n\t      if (agent.isMac) {\n\t        shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');\n\t      }\n\t\n\t      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n\t                         .replace('SLASH', '/')\n\t                         .replace('LEFTBRACKET', '[')\n\t                         .replace('RIGHTBRACKET', ']');\n\t\n\t      return ' (' + shortcut + ')';\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.addToolbarButtons();\n\t      this.addImagePopoverButtons();\n\t      this.addLinkPopoverButtons();\n\t      this.fontInstalledMap = {};\n\t    };\n\t\n\t    this.destroy = function () {\n\t      delete this.fontInstalledMap;\n\t    };\n\t\n\t    this.isFontInstalled = function (name) {\n\t      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n\t        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n\t          list.contains(options.fontNamesIgnoreCheck, name);\n\t      }\n\t\n\t      return self.fontInstalledMap[name];\n\t    };\n\t\n\t    this.addToolbarButtons = function () {\n\t      context.memo('button.style', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.style.style,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdown({\n\t            className: 'dropdown-style',\n\t            items: context.options.styleTags,\n\t            template: function (item) {\n\t\n\t              if (typeof item === 'string') {\n\t                item = { tag: item, title: (lang.style.hasOwnProperty(item) ? lang.style[item] : item) };\n\t              }\n\t\n\t              var tag = item.tag;\n\t              var title = item.title;\n\t              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n\t              var className = item.className ? ' class=\"' + item.className + '\"' : '';\n\t\n\t              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n\t            },\n\t            click: context.createInvokeHandler('editor.formatBlock')\n\t          })\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.bold', function () {\n\t        return ui.button({\n\t          className: 'note-btn-bold',\n\t          contents: ui.icon(options.icons.bold),\n\t          tooltip: lang.font.bold + representShortcut('bold'),\n\t          click: context.createInvokeHandler('editor.bold')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.italic', function () {\n\t        return ui.button({\n\t          className: 'note-btn-italic',\n\t          contents: ui.icon(options.icons.italic),\n\t          tooltip: lang.font.italic + representShortcut('italic'),\n\t          click: context.createInvokeHandler('editor.italic')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.underline', function () {\n\t        return ui.button({\n\t          className: 'note-btn-underline',\n\t          contents: ui.icon(options.icons.underline),\n\t          tooltip: lang.font.underline + representShortcut('underline'),\n\t          click: context.createInvokeHandler('editor.underline')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.clear', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.eraser),\n\t          tooltip: lang.font.clear + representShortcut('removeFormat'),\n\t          click: context.createInvokeHandler('editor.removeFormat')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.strikethrough', function () {\n\t        return ui.button({\n\t          className: 'note-btn-strikethrough',\n\t          contents: ui.icon(options.icons.strikethrough),\n\t          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n\t          click: context.createInvokeHandler('editor.strikethrough')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.superscript', function () {\n\t        return ui.button({\n\t          className: 'note-btn-superscript',\n\t          contents: ui.icon(options.icons.superscript),\n\t          tooltip: lang.font.superscript,\n\t          click: context.createInvokeHandler('editor.superscript')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.subscript', function () {\n\t        return ui.button({\n\t          className: 'note-btn-subscript',\n\t          contents: ui.icon(options.icons.subscript),\n\t          tooltip: lang.font.subscript,\n\t          click: context.createInvokeHandler('editor.subscript')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.fontname', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: '<span class=\"note-current-fontname\"/> ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.font.name,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdownCheck({\n\t            className: 'dropdown-fontname',\n\t            checkClassName: options.icons.menuCheck,\n\t            items: options.fontNames.filter(self.isFontInstalled),\n\t            template: function (item) {\n\t              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n\t            },\n\t            click: context.createInvokeHandler('editor.fontName')\n\t          })\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.fontsize', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: '<span class=\"note-current-fontsize\"/>' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.font.size,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdownCheck({\n\t            className: 'dropdown-fontsize',\n\t            checkClassName: options.icons.menuCheck,\n\t            items: options.fontSizes,\n\t            click: context.createInvokeHandler('editor.fontSize')\n\t          })\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.color', function () {\n\t        return ui.buttonGroup({\n\t          className: 'note-color',\n\t          children: [\n\t            ui.button({\n\t              className: 'note-current-color-button',\n\t              contents: ui.icon(options.icons.font + ' note-recent-color'),\n\t              tooltip: lang.color.recent,\n\t              click: function (e) {\n\t                var $button = $(e.currentTarget);\n\t                context.invoke('editor.color', {\n\t                  backColor: $button.attr('data-backColor'),\n\t                  foreColor: $button.attr('data-foreColor')\n\t                });\n\t              },\n\t              callback: function ($button) {\n\t                var $recentColor = $button.find('.note-recent-color');\n\t                $recentColor.css('background-color', '#FFFF00');\n\t                $button.attr('data-backColor', '#FFFF00');\n\t              }\n\t            }),\n\t            ui.button({\n\t              className: 'dropdown-toggle',\n\t              contents: ui.icon(options.icons.caret, 'span'),\n\t              tooltip: lang.color.more,\n\t              data: {\n\t                toggle: 'dropdown'\n\t              }\n\t            }),\n\t            ui.dropdown({\n\t              items: [\n\t                '<li>',\n\t                '<div class=\"btn-group\">',\n\t                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n\t                '  <div>',\n\t                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"backColor\" data-value=\"inherit\">',\n\t                lang.color.transparent,\n\t                '    </button>',\n\t                '  </div>',\n\t                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n\t                '</div>',\n\t                '<div class=\"btn-group\">',\n\t                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n\t                '  <div>',\n\t                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n\t                lang.color.resetToDefault,\n\t                '    </button>',\n\t                '  </div>',\n\t                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n\t                '</div>',\n\t                '</li>'\n\t              ].join(''),\n\t              callback: function ($dropdown) {\n\t                $dropdown.find('.note-holder').each(function () {\n\t                  var $holder = $(this);\n\t                  $holder.append(ui.palette({\n\t                    colors: options.colors,\n\t                    eventName: $holder.data('event')\n\t                  }).render());\n\t                });\n\t              },\n\t              click: function (event) {\n\t                var $button = $(event.target);\n\t                var eventName = $button.data('event');\n\t                var value = $button.data('value');\n\t\n\t                if (eventName && value) {\n\t                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n\t                  var $color = $button.closest('.note-color').find('.note-recent-color');\n\t                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\t\n\t                  $color.css(key, value);\n\t                  $currentButton.attr('data-' + eventName, value);\n\t                  context.invoke('editor.' + eventName, value);\n\t                }\n\t              }\n\t            })\n\t          ]\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.ul',  function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.unorderedlist),\n\t          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n\t          click: context.createInvokeHandler('editor.insertUnorderedList')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.ol', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.orderedlist),\n\t          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n\t          click:  context.createInvokeHandler('editor.insertOrderedList')\n\t        }).render();\n\t      });\n\t\n\t      var justifyLeft = ui.button({\n\t        contents: ui.icon(options.icons.alignLeft),\n\t        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n\t        click: context.createInvokeHandler('editor.justifyLeft')\n\t      });\n\t\n\t      var justifyCenter = ui.button({\n\t        contents: ui.icon(options.icons.alignCenter),\n\t        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n\t        click: context.createInvokeHandler('editor.justifyCenter')\n\t      });\n\t\n\t      var justifyRight = ui.button({\n\t        contents: ui.icon(options.icons.alignRight),\n\t        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n\t        click: context.createInvokeHandler('editor.justifyRight')\n\t      });\n\t\n\t      var justifyFull = ui.button({\n\t        contents: ui.icon(options.icons.alignJustify),\n\t        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n\t        click: context.createInvokeHandler('editor.justifyFull')\n\t      });\n\t\n\t      var outdent = ui.button({\n\t        contents: ui.icon(options.icons.outdent),\n\t        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n\t        click: context.createInvokeHandler('editor.outdent')\n\t      });\n\t\n\t      var indent = ui.button({\n\t        contents: ui.icon(options.icons.indent),\n\t        tooltip: lang.paragraph.indent + representShortcut('indent'),\n\t        click: context.createInvokeHandler('editor.indent')\n\t      });\n\t\n\t      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n\t      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n\t      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n\t      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n\t      context.memo('button.outdent', func.invoke(outdent, 'render'));\n\t      context.memo('button.indent', func.invoke(indent, 'render'));\n\t\n\t      context.memo('button.paragraph', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.paragraph.paragraph,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdown([\n\t            ui.buttonGroup({\n\t              className: 'note-align',\n\t              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n\t            }),\n\t            ui.buttonGroup({\n\t              className: 'note-list',\n\t              children: [outdent, indent]\n\t            })\n\t          ])\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.height', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.font.height,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdownCheck({\n\t            items: options.lineHeights,\n\t            checkClassName: options.icons.menuCheck,\n\t            className: 'dropdown-line-height',\n\t            click: context.createInvokeHandler('editor.lineHeight')\n\t          })\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.table', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.table.table,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdown({\n\t            className: 'note-table',\n\t            items: [\n\t              '<div class=\"note-dimension-picker\">',\n\t              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n\t              '  <div class=\"note-dimension-picker-highlighted\"/>',\n\t              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n\t              '</div>',\n\t              '<div class=\"note-dimension-display\">1 x 1</div>'\n\t            ].join('')\n\t          })\n\t        ], {\n\t          callback: function ($node) {\n\t            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n\t            $catcher.css({\n\t              width: options.insertTableMaxSize.col + 'em',\n\t              height: options.insertTableMaxSize.row + 'em'\n\t            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n\t              .on('mousemove', self.tableMoveHandler);\n\t          }\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.link', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.link),\n\t          tooltip: lang.link.link + representShortcut('linkDialog.show'),\n\t          click: context.createInvokeHandler('linkDialog.show')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.picture', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.picture),\n\t          tooltip: lang.image.image,\n\t          click: context.createInvokeHandler('imageDialog.show')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.video', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.video),\n\t          tooltip: lang.video.video,\n\t          click: context.createInvokeHandler('videoDialog.show')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.hr', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.minus),\n\t          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n\t          click: context.createInvokeHandler('editor.insertHorizontalRule')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.fullscreen', function () {\n\t        return ui.button({\n\t          className: 'btn-fullscreen',\n\t          contents: ui.icon(options.icons.arrowsAlt),\n\t          tooltip: lang.options.fullscreen,\n\t          click: context.createInvokeHandler('fullscreen.toggle')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.codeview', function () {\n\t        return ui.button({\n\t          className: 'btn-codeview',\n\t          contents: ui.icon(options.icons.code),\n\t          tooltip: lang.options.codeview,\n\t          click: context.createInvokeHandler('codeview.toggle')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.redo', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.redo),\n\t          tooltip: lang.history.redo + representShortcut('redo'),\n\t          click: context.createInvokeHandler('editor.redo')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.undo', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.undo),\n\t          tooltip: lang.history.undo + representShortcut('undo'),\n\t          click: context.createInvokeHandler('editor.undo')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.help', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.question),\n\t          tooltip: lang.options.help,\n\t          click: context.createInvokeHandler('helpDialog.show')\n\t        }).render();\n\t      });\n\t    };\n\t\n\t    /**\n\t     * image : [\n\t     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n\t     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n\t     *   ['remove', ['removeMedia']]\n\t     * ],\n\t     */\n\t    this.addImagePopoverButtons = function () {\n\t      // Image Size Buttons\n\t      context.memo('button.imageSize100', function () {\n\t        return ui.button({\n\t          contents: '<span class=\"note-fontsize-10\">100%</span>',\n\t          tooltip: lang.image.resizeFull,\n\t          click: context.createInvokeHandler('editor.resize', '1')\n\t        }).render();\n\t      });\n\t      context.memo('button.imageSize50', function () {\n\t        return  ui.button({\n\t          contents: '<span class=\"note-fontsize-10\">50%</span>',\n\t          tooltip: lang.image.resizeHalf,\n\t          click: context.createInvokeHandler('editor.resize', '0.5')\n\t        }).render();\n\t      });\n\t      context.memo('button.imageSize25', function () {\n\t        return ui.button({\n\t          contents: '<span class=\"note-fontsize-10\">25%</span>',\n\t          tooltip: lang.image.resizeQuarter,\n\t          click: context.createInvokeHandler('editor.resize', '0.25')\n\t        }).render();\n\t      });\n\t\n\t      // Float Buttons\n\t      context.memo('button.floatLeft', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.alignLeft),\n\t          tooltip: lang.image.floatLeft,\n\t          click: context.createInvokeHandler('editor.floatMe', 'left')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.floatRight', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.alignRight),\n\t          tooltip: lang.image.floatRight,\n\t          click: context.createInvokeHandler('editor.floatMe', 'right')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.floatNone', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.alignJustify),\n\t          tooltip: lang.image.floatNone,\n\t          click: context.createInvokeHandler('editor.floatMe', 'none')\n\t        }).render();\n\t      });\n\t\n\t      // Remove Buttons\n\t      context.memo('button.removeMedia', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.trash),\n\t          tooltip: lang.image.remove,\n\t          click: context.createInvokeHandler('editor.removeMedia')\n\t        }).render();\n\t      });\n\t    };\n\t\n\t    this.addLinkPopoverButtons = function () {\n\t      context.memo('button.linkDialogShow', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.link),\n\t          tooltip: lang.link.edit,\n\t          click: context.createInvokeHandler('linkDialog.show')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.unlink', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.unlink),\n\t          tooltip: lang.link.unlink,\n\t          click: context.createInvokeHandler('editor.unlink')\n\t        }).render();\n\t      });\n\t    };\n\t\n\t    this.build = function ($container, groups) {\n\t      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n\t        var group = groups[groupIdx];\n\t        var groupName = group[0];\n\t        var buttons = group[1];\n\t\n\t        var $group = ui.buttonGroup({\n\t          className: 'note-' + groupName\n\t        }).render();\n\t\n\t        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n\t          var button = context.memo('button.' + buttons[idx]);\n\t          if (button) {\n\t            $group.append(typeof button === 'function' ? button(context) : button);\n\t          }\n\t        }\n\t        $group.appendTo($container);\n\t      }\n\t    };\n\t\n\t    this.updateCurrentStyle = function () {\n\t      var styleInfo = context.invoke('editor.currentStyle');\n\t      this.updateBtnStates({\n\t        '.note-btn-bold': function () {\n\t          return styleInfo['font-bold'] === 'bold';\n\t        },\n\t        '.note-btn-italic': function () {\n\t          return styleInfo['font-italic'] === 'italic';\n\t        },\n\t        '.note-btn-underline': function () {\n\t          return styleInfo['font-underline'] === 'underline';\n\t        },\n\t        '.note-btn-subscript': function () {\n\t          return styleInfo['font-subscript'] === 'subscript';\n\t        },\n\t        '.note-btn-superscript': function () {\n\t          return styleInfo['font-superscript'] === 'superscript';\n\t        },\n\t        '.note-btn-strikethrough': function () {\n\t          return styleInfo['font-strikethrough'] === 'strikethrough';\n\t        }\n\t      });\n\t\n\t      if (styleInfo['font-family']) {\n\t        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n\t          return name.replace(/[\\'\\\"]/g, '')\n\t            .replace(/\\s+$/, '')\n\t            .replace(/^\\s+/, '');\n\t        });\n\t        var fontName = list.find(fontNames, self.isFontInstalled);\n\t\n\t        $toolbar.find('.dropdown-fontname li a').each(function () {\n\t          // always compare string to avoid creating another func.\n\t          var isChecked = ($(this).data('value') + '') === (fontName + '');\n\t          this.className = isChecked ? 'checked' : '';\n\t        });\n\t        $toolbar.find('.note-current-fontname').text(fontName);\n\t      }\n\t\n\t      if (styleInfo['font-size']) {\n\t        var fontSize = styleInfo['font-size'];\n\t        $toolbar.find('.dropdown-fontsize li a').each(function () {\n\t          // always compare with string to avoid creating another func.\n\t          var isChecked = ($(this).data('value') + '') === (fontSize + '');\n\t          this.className = isChecked ? 'checked' : '';\n\t        });\n\t        $toolbar.find('.note-current-fontsize').text(fontSize);\n\t      }\n\t\n\t      if (styleInfo['line-height']) {\n\t        var lineHeight = styleInfo['line-height'];\n\t        $toolbar.find('.dropdown-line-height li a').each(function () {\n\t          // always compare with string to avoid creating another func.\n\t          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n\t          this.className = isChecked ? 'checked' : '';\n\t        });\n\t      }\n\t    };\n\t\n\t    this.updateBtnStates = function (infos) {\n\t      $.each(infos, function (selector, pred) {\n\t        ui.toggleBtnActive($toolbar.find(selector), pred());\n\t      });\n\t    };\n\t\n\t    this.tableMoveHandler = function (event) {\n\t      var PX_PER_EM = 18;\n\t      var $picker = $(event.target.parentNode); // target is mousecatcher\n\t      var $dimensionDisplay = $picker.next();\n\t      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n\t      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n\t      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\t\n\t      var posOffset;\n\t      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n\t      if (event.offsetX === undefined) {\n\t        var posCatcher = $(event.target).offset();\n\t        posOffset = {\n\t          x: event.pageX - posCatcher.left,\n\t          y: event.pageY - posCatcher.top\n\t        };\n\t      } else {\n\t        posOffset = {\n\t          x: event.offsetX,\n\t          y: event.offsetY\n\t        };\n\t      }\n\t\n\t      var dim = {\n\t        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n\t        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n\t      };\n\t\n\t      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n\t      $catcher.data('value', dim.c + 'x' + dim.r);\n\t\n\t      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n\t        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n\t      }\n\t\n\t      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n\t        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n\t      }\n\t\n\t      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n\t    };\n\t  };\n\t\n\t  var Toolbar = function (context) {\n\t    var ui = $.summernote.ui;\n\t\n\t    var $note = context.layoutInfo.note;\n\t    var $toolbar = context.layoutInfo.toolbar;\n\t    var options = context.options;\n\t\n\t    this.shouldInitialize = function () {\n\t      return !options.airMode;\n\t    };\n\t\n\t    this.initialize = function () {\n\t      options.toolbar = options.toolbar || [];\n\t\n\t      if (!options.toolbar.length) {\n\t        $toolbar.hide();\n\t      } else {\n\t        context.invoke('buttons.build', $toolbar, options.toolbar);\n\t      }\n\t\n\t      if (options.toolbarContainer) {\n\t        $toolbar.appendTo(options.toolbarContainer);\n\t      }\n\t\n\t      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n\t        context.invoke('buttons.updateCurrentStyle');\n\t      });\n\t\n\t      context.invoke('buttons.updateCurrentStyle');\n\t    };\n\t\n\t    this.destroy = function () {\n\t      $toolbar.children().remove();\n\t    };\n\t\n\t    this.updateFullscreen = function (isFullscreen) {\n\t      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n\t    };\n\t\n\t    this.updateCodeview = function (isCodeview) {\n\t      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n\t      if (isCodeview) {\n\t        this.deactivate();\n\t      } else {\n\t        this.activate();\n\t      }\n\t    };\n\t\n\t    this.activate = function (isIncludeCodeview) {\n\t      var $btn = $toolbar.find('button');\n\t      if (!isIncludeCodeview) {\n\t        $btn = $btn.not('.btn-codeview');\n\t      }\n\t      ui.toggleBtn($btn, true);\n\t    };\n\t\n\t    this.deactivate = function (isIncludeCodeview) {\n\t      var $btn = $toolbar.find('button');\n\t      if (!isIncludeCodeview) {\n\t        $btn = $btn.not('.btn-codeview');\n\t      }\n\t      ui.toggleBtn($btn, false);\n\t    };\n\t  };\n\t\n\t  var LinkDialog = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $editor = context.layoutInfo.editor;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t\n\t      var body = '<div class=\"form-group\">' +\n\t                   '<label>' + lang.link.textToDisplay + '</label>' +\n\t                   '<input class=\"note-link-text form-control\" type=\"text\" />' +\n\t                 '</div>' +\n\t                 '<div class=\"form-group\">' +\n\t                   '<label>' + lang.link.url + '</label>' +\n\t                   '<input class=\"note-link-url form-control\" type=\"text\" value=\"http://\" />' +\n\t                 '</div>' +\n\t                 (!options.disableLinkTarget ?\n\t                   '<div class=\"checkbox\">' +\n\t                     '<label>' + '<input type=\"checkbox\" checked> ' + lang.link.openInNewWindow + '</label>' +\n\t                   '</div>' : ''\n\t                 );\n\t      var footer = '<button href=\"#\" class=\"btn btn-primary note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\t\n\t      this.$dialog = ui.dialog({\n\t        className: 'link-dialog',\n\t        title: lang.link.insert,\n\t        fade: options.dialogsFade,\n\t        body: body,\n\t        footer: footer\n\t      }).render().appendTo($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(this.$dialog);\n\t      this.$dialog.remove();\n\t    };\n\t\n\t    this.bindEnterKey = function ($input, $btn) {\n\t      $input.on('keypress', function (event) {\n\t        if (event.keyCode === key.code.ENTER) {\n\t          $btn.trigger('click');\n\t        }\n\t      });\n\t    };\n\t\n\t    /**\n\t     * toggle update button\n\t     */\n\t    this.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {\n\t      ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n\t    };\n\t\n\t    /**\n\t     * Show link dialog and set event handlers on dialog controls.\n\t     *\n\t     * @param {Object} linkInfo\n\t     * @return {Promise}\n\t     */\n\t    this.showLinkDialog = function (linkInfo) {\n\t      return $.Deferred(function (deferred) {\n\t        var $linkText = self.$dialog.find('.note-link-text'),\n\t        $linkUrl = self.$dialog.find('.note-link-url'),\n\t        $linkBtn = self.$dialog.find('.note-link-btn'),\n\t        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\t\n\t        ui.onDialogShown(self.$dialog, function () {\n\t          context.triggerEvent('dialog.shown');\n\t\n\t          // if no url was given, copy text to url\n\t          if (!linkInfo.url) {\n\t            linkInfo.url = linkInfo.text;\n\t          }\n\t\n\t          $linkText.val(linkInfo.text);\n\t\n\t          var handleLinkTextUpdate = function () {\n\t            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n\t            // if linktext was modified by keyup,\n\t            // stop cloning text from linkUrl\n\t            linkInfo.text = $linkText.val();\n\t          };\n\t\n\t          $linkText.on('input', handleLinkTextUpdate).on('paste', function () {\n\t            setTimeout(handleLinkTextUpdate, 0);\n\t          });\n\t\n\t          var handleLinkUrlUpdate = function () {\n\t            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n\t            // display same link on `Text to display` input\n\t            // when create a new link\n\t            if (!linkInfo.text) {\n\t              $linkText.val($linkUrl.val());\n\t            }\n\t          };\n\t\n\t          $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {\n\t            setTimeout(handleLinkUrlUpdate, 0);\n\t          }).val(linkInfo.url).trigger('focus');\n\t\n\t          self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n\t          self.bindEnterKey($linkUrl, $linkBtn);\n\t          self.bindEnterKey($linkText, $linkBtn);\n\t\n\t          $openInNewWindow.prop('checked', linkInfo.isNewWindow);\n\t\n\t          $linkBtn.one('click', function (event) {\n\t            event.preventDefault();\n\t\n\t            deferred.resolve({\n\t              range: linkInfo.range,\n\t              url: $linkUrl.val(),\n\t              text: $linkText.val(),\n\t              isNewWindow: $openInNewWindow.is(':checked')\n\t            });\n\t            self.$dialog.modal('hide');\n\t          });\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function () {\n\t          // detach events\n\t          $linkText.off('input paste keypress');\n\t          $linkUrl.off('input paste keypress');\n\t          $linkBtn.off('click');\n\t\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      }).promise();\n\t    };\n\t\n\t    /**\n\t     * @param {Object} layoutInfo\n\t     */\n\t    this.show = function () {\n\t      var linkInfo = context.invoke('editor.getLinkInfo');\n\t\n\t      context.invoke('editor.saveRange');\n\t      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n\t        context.invoke('editor.restoreRange');\n\t        context.invoke('editor.createLink', linkInfo);\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n\t  };\n\t\n\t  var LinkPopover = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var options = context.options;\n\t\n\t    this.events = {\n\t      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n\t        self.update();\n\t      },\n\t      'summernote.dialog.shown': function () {\n\t        self.hide();\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return !list.isEmpty(options.popover.link);\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$popover = ui.popover({\n\t        className: 'note-link-popover',\n\t        callback: function ($node) {\n\t          var $content = $node.find('.popover-content');\n\t          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n\t        }\n\t      }).render().appendTo('body');\n\t      var $content = this.$popover.find('.popover-content');\n\t\n\t      context.invoke('buttons.build', $content, options.popover.link);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$popover.remove();\n\t    };\n\t\n\t    this.update = function () {\n\t      // Prevent focusing on editable when invoke('code') is executed\n\t      if (!context.invoke('editor.hasFocus')) {\n\t        this.hide();\n\t        return;\n\t      }\n\t\n\t      var rng = context.invoke('editor.createRange');\n\t      if (rng.isCollapsed() && rng.isOnAnchor()) {\n\t        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n\t        var href = $(anchor).attr('href');\n\t        this.$popover.find('a').attr('href', href).html(href);\n\t\n\t        var pos = dom.posFromPlaceholder(anchor);\n\t        this.$popover.css({\n\t          display: 'block',\n\t          left: pos.left,\n\t          top: pos.top\n\t        });\n\t      } else {\n\t        this.hide();\n\t      }\n\t    };\n\t\n\t    this.hide = function () {\n\t      this.$popover.hide();\n\t    };\n\t  };\n\t\n\t  var ImageDialog = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $editor = context.layoutInfo.editor;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t\n\t      var imageLimitation = '';\n\t      if (options.maximumImageFileSize) {\n\t        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n\t        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n\t                           ' ' + ' KMGTP'[unit] + 'B';\n\t        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n\t      }\n\t\n\t      var body = '<div class=\"form-group note-group-select-from-files\">' +\n\t                   '<label>' + lang.image.selectFromFiles + '</label>' +\n\t                   '<input class=\"note-image-input form-control\" type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n\t                   imageLimitation +\n\t                 '</div>' +\n\t                 '<div class=\"form-group note-group-image-url\" style=\"overflow:auto;\">' +\n\t                   '<label>' + lang.image.url + '</label>' +\n\t                   '<input class=\"note-image-url form-control col-md-12\" type=\"text\" />' +\n\t                 '</div>';\n\t      var footer = '<button href=\"#\" class=\"btn btn-primary note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\t\n\t      this.$dialog = ui.dialog({\n\t        title: lang.image.insert,\n\t        fade: options.dialogsFade,\n\t        body: body,\n\t        footer: footer\n\t      }).render().appendTo($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(this.$dialog);\n\t      this.$dialog.remove();\n\t    };\n\t\n\t    this.bindEnterKey = function ($input, $btn) {\n\t      $input.on('keypress', function (event) {\n\t        if (event.keyCode === key.code.ENTER) {\n\t          $btn.trigger('click');\n\t        }\n\t      });\n\t    };\n\t\n\t    this.show = function () {\n\t      context.invoke('editor.saveRange');\n\t      this.showImageDialog().then(function (data) {\n\t        // [workaround] hide dialog before restore range for IE range focus\n\t        ui.hideDialog(self.$dialog);\n\t        context.invoke('editor.restoreRange');\n\t\n\t        if (typeof data === 'string') { // image url\n\t          context.invoke('editor.insertImage', data);\n\t        } else { // array of files\n\t          context.invoke('editor.insertImagesOrCallback', data);\n\t        }\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t\n\t    /**\n\t     * show image dialog\n\t     *\n\t     * @param {jQuery} $dialog\n\t     * @return {Promise}\n\t     */\n\t    this.showImageDialog = function () {\n\t      return $.Deferred(function (deferred) {\n\t        var $imageInput = self.$dialog.find('.note-image-input'),\n\t            $imageUrl = self.$dialog.find('.note-image-url'),\n\t            $imageBtn = self.$dialog.find('.note-image-btn');\n\t\n\t        ui.onDialogShown(self.$dialog, function () {\n\t          context.triggerEvent('dialog.shown');\n\t\n\t          // Cloning imageInput to clear element.\n\t          $imageInput.replaceWith($imageInput.clone()\n\t            .on('change', function () {\n\t              deferred.resolve(this.files || this.value);\n\t            })\n\t            .val('')\n\t          );\n\t\n\t          $imageBtn.click(function (event) {\n\t            event.preventDefault();\n\t\n\t            deferred.resolve($imageUrl.val());\n\t          });\n\t\n\t          $imageUrl.on('keyup paste', function () {\n\t            var url = $imageUrl.val();\n\t            ui.toggleBtn($imageBtn, url);\n\t          }).val('').trigger('focus');\n\t          self.bindEnterKey($imageUrl, $imageBtn);\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function () {\n\t          $imageInput.off('change');\n\t          $imageUrl.off('keyup paste keypress');\n\t          $imageBtn.off('click');\n\t\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      });\n\t    };\n\t  };\n\t\n\t  var ImagePopover = function (context) {\n\t    var ui = $.summernote.ui;\n\t\n\t    var options = context.options;\n\t\n\t    this.shouldInitialize = function () {\n\t      return !list.isEmpty(options.popover.image);\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$popover = ui.popover({\n\t        className: 'note-image-popover'\n\t      }).render().appendTo('body');\n\t      var $content = this.$popover.find('.popover-content');\n\t\n\t      context.invoke('buttons.build', $content, options.popover.image);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$popover.remove();\n\t    };\n\t\n\t    this.update = function (target) {\n\t      if (dom.isImg(target)) {\n\t        var pos = dom.posFromPlaceholder(target);\n\t        this.$popover.css({\n\t          display: 'block',\n\t          left: pos.left,\n\t          top: pos.top\n\t        });\n\t      } else {\n\t        this.hide();\n\t      }\n\t    };\n\t\n\t    this.hide = function () {\n\t      this.$popover.hide();\n\t    };\n\t  };\n\t\n\t  var VideoDialog = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $editor = context.layoutInfo.editor;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t\n\t      var body = '<div class=\"form-group row-fluid\">' +\n\t          '<label>' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n\t          '<input class=\"note-video-url form-control span12\" type=\"text\" />' +\n\t          '</div>';\n\t      var footer = '<button href=\"#\" class=\"btn btn-primary note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\t\n\t      this.$dialog = ui.dialog({\n\t        title: lang.video.insert,\n\t        fade: options.dialogsFade,\n\t        body: body,\n\t        footer: footer\n\t      }).render().appendTo($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(this.$dialog);\n\t      this.$dialog.remove();\n\t    };\n\t\n\t    this.bindEnterKey = function ($input, $btn) {\n\t      $input.on('keypress', function (event) {\n\t        if (event.keyCode === key.code.ENTER) {\n\t          $btn.trigger('click');\n\t        }\n\t      });\n\t    };\n\t\n\t    this.createVideoNode = function (url) {\n\t      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n\t      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n\t      var ytMatch = url.match(ytRegExp);\n\t\n\t      var igRegExp = /(?:www\\.|\\/\\/)instagram\\.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n\t      var igMatch = url.match(igRegExp);\n\t\n\t      var vRegExp = /\\/\\/vine\\.co\\/v\\/([a-zA-Z0-9]+)/;\n\t      var vMatch = url.match(vRegExp);\n\t\n\t      var vimRegExp = /\\/\\/(player\\.)?vimeo\\.com\\/([a-z]*\\/)*([0-9]{6,11})[?]?.*/;\n\t      var vimMatch = url.match(vimRegExp);\n\t\n\t      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n\t      var dmMatch = url.match(dmRegExp);\n\t\n\t      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n\t      var youkuMatch = url.match(youkuRegExp);\n\t\n\t      var mp4RegExp = /^.+.(mp4|m4v)$/;\n\t      var mp4Match = url.match(mp4RegExp);\n\t\n\t      var oggRegExp = /^.+.(ogg|ogv)$/;\n\t      var oggMatch = url.match(oggRegExp);\n\t\n\t      var webmRegExp = /^.+.(webm)$/;\n\t      var webmMatch = url.match(webmRegExp);\n\t\n\t      var $video;\n\t      if (ytMatch && ytMatch[1].length === 11) {\n\t        var youtubeId = ytMatch[1];\n\t        $video = $('<iframe>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n\t            .attr('width', '640').attr('height', '360');\n\t      } else if (igMatch && igMatch[0].length) {\n\t        $video = $('<iframe>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/')\n\t            .attr('width', '612').attr('height', '710')\n\t            .attr('scrolling', 'no')\n\t            .attr('allowtransparency', 'true');\n\t      } else if (vMatch && vMatch[0].length) {\n\t        $video = $('<iframe>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', vMatch[0] + '/embed/simple')\n\t            .attr('width', '600').attr('height', '600')\n\t            .attr('class', 'vine-embed');\n\t      } else if (vimMatch && vimMatch[3].length) {\n\t        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n\t            .attr('width', '640').attr('height', '360');\n\t      } else if (dmMatch && dmMatch[2].length) {\n\t        $video = $('<iframe>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n\t            .attr('width', '640').attr('height', '360');\n\t      } else if (youkuMatch && youkuMatch[1].length) {\n\t        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n\t            .attr('frameborder', 0)\n\t            .attr('height', '498')\n\t            .attr('width', '510')\n\t            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n\t      } else if (mp4Match || oggMatch || webmMatch) {\n\t        $video = $('<video controls>')\n\t            .attr('src', url)\n\t            .attr('width', '640').attr('height', '360');\n\t      } else {\n\t        // this is not a known video link. Now what, Cat? Now what?\n\t        return false;\n\t      }\n\t\n\t      $video.addClass('note-video-clip');\n\t\n\t      return $video[0];\n\t    };\n\t\n\t    this.show = function () {\n\t      var text = context.invoke('editor.getSelectedText');\n\t      context.invoke('editor.saveRange');\n\t      this.showVideoDialog(text).then(function (url) {\n\t        // [workaround] hide dialog before restore range for IE range focus\n\t        ui.hideDialog(self.$dialog);\n\t        context.invoke('editor.restoreRange');\n\t\n\t        // build node\n\t        var $node = self.createVideoNode(url);\n\t\n\t        if ($node) {\n\t          // insert video node\n\t          context.invoke('editor.insertNode', $node);\n\t        }\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t\n\t    /**\n\t     * show image dialog\n\t     *\n\t     * @param {jQuery} $dialog\n\t     * @return {Promise}\n\t     */\n\t    this.showVideoDialog = function (text) {\n\t      return $.Deferred(function (deferred) {\n\t        var $videoUrl = self.$dialog.find('.note-video-url'),\n\t            $videoBtn = self.$dialog.find('.note-video-btn');\n\t\n\t        ui.onDialogShown(self.$dialog, function () {\n\t          context.triggerEvent('dialog.shown');\n\t\n\t          $videoUrl.val(text).on('input', function () {\n\t            ui.toggleBtn($videoBtn, $videoUrl.val());\n\t          }).trigger('focus');\n\t\n\t          $videoBtn.click(function (event) {\n\t            event.preventDefault();\n\t\n\t            deferred.resolve($videoUrl.val());\n\t          });\n\t\n\t          self.bindEnterKey($videoUrl, $videoBtn);\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function () {\n\t          $videoUrl.off('input');\n\t          $videoBtn.off('click');\n\t\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      });\n\t    };\n\t  };\n\t\n\t  var HelpDialog = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $editor = context.layoutInfo.editor;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    this.createShortCutList = function () {\n\t      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n\t      return Object.keys(keyMap).map(function (key) {\n\t        var command = keyMap[key];\n\t        var $row = $('<div><div class=\"help-list-item\"/></div>');\n\t        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n\t          'width': 180,\n\t          'margin-right': 10\n\t        })).append($('<span/>').html(context.memo('help.' + command) || command));\n\t        return $row.html();\n\t      }).join('');\n\t    };\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t\n\t      var body = [\n\t        '<p class=\"text-center\">',\n\t        '<a href=\"http://summernote.org/\" target=\"_blank\">Summernote 0.8.2</a> · ',\n\t        '<a href=\"https://github.com/summernote/summernote\" target=\"_blank\">Project</a> · ',\n\t        '<a href=\"https://github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n\t        '</p>'\n\t      ].join('');\n\t\n\t      this.$dialog = ui.dialog({\n\t        title: lang.options.help,\n\t        fade: options.dialogsFade,\n\t        body: this.createShortCutList(),\n\t        footer: body,\n\t        callback: function ($node) {\n\t          $node.find('.modal-body').css({\n\t            'max-height': 300,\n\t            'overflow': 'scroll'\n\t          });\n\t        }\n\t      }).render().appendTo($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(this.$dialog);\n\t      this.$dialog.remove();\n\t    };\n\t\n\t    /**\n\t     * show help dialog\n\t     *\n\t     * @return {Promise}\n\t     */\n\t    this.showHelpDialog = function () {\n\t      return $.Deferred(function (deferred) {\n\t        ui.onDialogShown(self.$dialog, function () {\n\t          context.triggerEvent('dialog.shown');\n\t          deferred.resolve();\n\t        });\n\t        ui.showDialog(self.$dialog);\n\t      }).promise();\n\t    };\n\t\n\t    this.show = function () {\n\t      context.invoke('editor.saveRange');\n\t      this.showHelpDialog().then(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t  };\n\t\n\t  var AirPopover = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var options = context.options;\n\t\n\t    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\t\n\t    this.events = {\n\t      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n\t        self.update();\n\t      },\n\t      'summernote.change summernote.dialog.shown': function () {\n\t        self.hide();\n\t      },\n\t      'summernote.focusout': function (we, e) {\n\t        // [workaround] Firefox doesn't support relatedTarget on focusout\n\t        //  - Ignore hide action on focus out in FF.\n\t        if (agent.isFF) {\n\t          return;\n\t        }\n\t\n\t        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n\t          self.hide();\n\t        }\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return options.airMode && !list.isEmpty(options.popover.air);\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$popover = ui.popover({\n\t        className: 'note-air-popover'\n\t      }).render().appendTo('body');\n\t      var $content = this.$popover.find('.popover-content');\n\t\n\t      context.invoke('buttons.build', $content, options.popover.air);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$popover.remove();\n\t    };\n\t\n\t    this.update = function () {\n\t      var styleInfo = context.invoke('editor.currentStyle');\n\t      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n\t        var rect = list.last(styleInfo.range.getClientRects());\n\t        if (rect) {\n\t          var bnd = func.rect2bnd(rect);\n\t          this.$popover.css({\n\t            display: 'block',\n\t            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n\t            top: bnd.top + bnd.height\n\t          });\n\t        }\n\t      } else {\n\t        this.hide();\n\t      }\n\t    };\n\t\n\t    this.hide = function () {\n\t      this.$popover.hide();\n\t    };\n\t  };\n\t\n\t  var HintPopover = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var POPOVER_DIST = 5;\n\t    var hint = context.options.hint || [];\n\t    var direction = context.options.hintDirection || 'bottom';\n\t    var hints = $.isArray(hint) ? hint : [hint];\n\t\n\t    this.events = {\n\t      'summernote.keyup': function (we, e) {\n\t        if (!e.isDefaultPrevented()) {\n\t          self.handleKeyup(e);\n\t        }\n\t      },\n\t      'summernote.keydown': function (we, e) {\n\t        self.handleKeydown(e);\n\t      },\n\t      'summernote.dialog.shown': function () {\n\t        self.hide();\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return hints.length > 0;\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.lastWordRange = null;\n\t      this.$popover = ui.popover({\n\t        className: 'note-hint-popover',\n\t        hideArrow: true,\n\t        direction: ''\n\t      }).render().appendTo('body');\n\t\n\t      this.$popover.hide();\n\t\n\t      this.$content = this.$popover.find('.popover-content');\n\t\n\t      this.$content.on('click', '.note-hint-item', function () {\n\t        self.$content.find('.active').removeClass('active');\n\t        $(this).addClass('active');\n\t        self.replace();\n\t      });\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$popover.remove();\n\t    };\n\t\n\t    this.selectItem = function ($item) {\n\t      this.$content.find('.active').removeClass('active');\n\t      $item.addClass('active');\n\t\n\t      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n\t    };\n\t\n\t    this.moveDown = function () {\n\t      var $current = this.$content.find('.note-hint-item.active');\n\t      var $next = $current.next();\n\t\n\t      if ($next.length) {\n\t        this.selectItem($next);\n\t      } else {\n\t        var $nextGroup = $current.parent().next();\n\t\n\t        if (!$nextGroup.length) {\n\t          $nextGroup = this.$content.find('.note-hint-group').first();\n\t        }\n\t\n\t        this.selectItem($nextGroup.find('.note-hint-item').first());\n\t      }\n\t    };\n\t\n\t    this.moveUp = function () {\n\t      var $current = this.$content.find('.note-hint-item.active');\n\t      var $prev = $current.prev();\n\t\n\t      if ($prev.length) {\n\t        this.selectItem($prev);\n\t      } else {\n\t        var $prevGroup = $current.parent().prev();\n\t\n\t        if (!$prevGroup.length) {\n\t          $prevGroup = this.$content.find('.note-hint-group').last();\n\t        }\n\t\n\t        this.selectItem($prevGroup.find('.note-hint-item').last());\n\t      }\n\t    };\n\t\n\t    this.replace = function () {\n\t      var $item = this.$content.find('.note-hint-item.active');\n\t\n\t      if ($item.length) {\n\t        var node = this.nodeFromItem($item);\n\t        this.lastWordRange.insertNode(node);\n\t        range.createFromNode(node).collapse().select();\n\t\n\t        this.lastWordRange = null;\n\t        this.hide();\n\t        context.invoke('editor.focus');\n\t      }\n\t\n\t    };\n\t\n\t    this.nodeFromItem = function ($item) {\n\t      var hint = hints[$item.data('index')];\n\t      var item = $item.data('item');\n\t      var node = hint.content ? hint.content(item) : item;\n\t      if (typeof node === 'string') {\n\t        node = dom.createText(node);\n\t      }\n\t      return node;\n\t    };\n\t\n\t    this.createItemTemplates = function (hintIdx, items) {\n\t      var hint = hints[hintIdx];\n\t      return items.map(function (item, idx) {\n\t        var $item = $('<div class=\"note-hint-item\"/>');\n\t        $item.append(hint.template ? hint.template(item) : item + '');\n\t        $item.data({\n\t          'index': hintIdx,\n\t          'item': item\n\t        });\n\t\n\t        if (hintIdx === 0 && idx === 0) {\n\t          $item.addClass('active');\n\t        }\n\t        return $item;\n\t      });\n\t    };\n\t\n\t    this.handleKeydown = function (e) {\n\t      if (!this.$popover.is(':visible')) {\n\t        return;\n\t      }\n\t\n\t      if (e.keyCode === key.code.ENTER) {\n\t        e.preventDefault();\n\t        this.replace();\n\t      } else if (e.keyCode === key.code.UP) {\n\t        e.preventDefault();\n\t        this.moveUp();\n\t      } else if (e.keyCode === key.code.DOWN) {\n\t        e.preventDefault();\n\t        this.moveDown();\n\t      }\n\t    };\n\t\n\t    this.searchKeyword = function (index, keyword, callback) {\n\t      var hint = hints[index];\n\t      if (hint && hint.match.test(keyword) && hint.search) {\n\t        var matches = hint.match.exec(keyword);\n\t        hint.search(matches[1], callback);\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t\n\t    this.createGroup = function (idx, keyword) {\n\t      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n\t      this.searchKeyword(idx, keyword, function (items) {\n\t        items = items || [];\n\t        if (items.length) {\n\t          $group.html(self.createItemTemplates(idx, items));\n\t          self.show();\n\t        }\n\t      });\n\t\n\t      return $group;\n\t    };\n\t\n\t    this.handleKeyup = function (e) {\n\t      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n\t        if (e.keyCode === key.code.ENTER) {\n\t          if (this.$popover.is(':visible')) {\n\t            return;\n\t          }\n\t        }\n\t      } else {\n\t        var wordRange = context.invoke('editor.createRange').getWordRange();\n\t        var keyword = wordRange.toString();\n\t        if (hints.length && keyword) {\n\t          this.$content.empty();\n\t\n\t          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n\t          if (bnd) {\n\t\n\t            this.$popover.hide();\n\t\n\t            this.lastWordRange = wordRange;\n\t\n\t            hints.forEach(function (hint, idx) {\n\t              if (hint.match.test(keyword)) {\n\t                self.createGroup(idx, keyword).appendTo(self.$content);\n\t              }\n\t            });\n\t\n\t            // set position for popover after group is created\n\t            if (direction === 'top') {\n\t              this.$popover.css({\n\t                left: bnd.left,\n\t                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n\t              });\n\t            } else {\n\t              this.$popover.css({\n\t                left: bnd.left,\n\t                top: bnd.top + bnd.height + POPOVER_DIST\n\t              });\n\t            }\n\t\n\t          }\n\t        } else {\n\t          this.hide();\n\t        }\n\t      }\n\t    };\n\t\n\t    this.show = function () {\n\t      this.$popover.show();\n\t    };\n\t\n\t    this.hide = function () {\n\t      this.$popover.hide();\n\t    };\n\t  };\n\t\n\t\n\t  $.summernote = $.extend($.summernote, {\n\t    version: '0.8.2',\n\t    ui: ui,\n\t    dom: dom,\n\t\n\t    plugins: {},\n\t\n\t    options: {\n\t      modules: {\n\t        'editor': Editor,\n\t        'clipboard': Clipboard,\n\t        'dropzone': Dropzone,\n\t        'codeview': Codeview,\n\t        'statusbar': Statusbar,\n\t        'fullscreen': Fullscreen,\n\t        'handle': Handle,\n\t        // FIXME: HintPopover must be front of autolink\n\t        //  - Script error about range when Enter key is pressed on hint popover\n\t        'hintPopover': HintPopover,\n\t        'autoLink': AutoLink,\n\t        'autoSync': AutoSync,\n\t        'placeholder': Placeholder,\n\t        'buttons': Buttons,\n\t        'toolbar': Toolbar,\n\t        'linkDialog': LinkDialog,\n\t        'linkPopover': LinkPopover,\n\t        'imageDialog': ImageDialog,\n\t        'imagePopover': ImagePopover,\n\t        'videoDialog': VideoDialog,\n\t        'helpDialog': HelpDialog,\n\t        'airPopover': AirPopover\n\t      },\n\t\n\t      buttons: {},\n\t      \n\t      lang: 'en-US',\n\t\n\t      // toolbar\n\t      toolbar: [\n\t        ['style', ['style']],\n\t        ['font', ['bold', 'underline', 'clear']],\n\t        ['fontname', ['fontname']],\n\t        ['color', ['color']],\n\t        ['para', ['ul', 'ol', 'paragraph']],\n\t        ['table', ['table']],\n\t        ['insert', ['link', 'picture', 'video']],\n\t        ['view', ['fullscreen', 'codeview', 'help']]\n\t      ],\n\t\n\t      // popover\n\t      popover: {\n\t        image: [\n\t          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n\t          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n\t          ['remove', ['removeMedia']]\n\t        ],\n\t        link: [\n\t          ['link', ['linkDialogShow', 'unlink']]\n\t        ],\n\t        air: [\n\t          ['color', ['color']],\n\t          ['font', ['bold', 'underline', 'clear']],\n\t          ['para', ['ul', 'paragraph']],\n\t          ['table', ['table']],\n\t          ['insert', ['link', 'picture']]\n\t        ]\n\t      },\n\t\n\t      // air mode: inline editor\n\t      airMode: false,\n\t\n\t      width: null,\n\t      height: null,\n\t\n\t      focus: false,\n\t      tabSize: 4,\n\t      styleWithSpan: true,\n\t      shortcuts: true,\n\t      textareaAutoSync: true,\n\t      direction: null,\n\t\n\t      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\t\n\t      fontNames: [\n\t        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n\t        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n\t        'Tahoma', 'Times New Roman', 'Verdana'\n\t      ],\n\t\n\t      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\t\n\t      // pallete colors(n x n)\n\t      colors: [\n\t        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n\t        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n\t        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n\t        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n\t        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n\t        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n\t        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n\t        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n\t      ],\n\t\n\t      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\t\n\t      tableClassName: 'table table-bordered',\n\t\n\t      insertTableMaxSize: {\n\t        col: 10,\n\t        row: 10\n\t      },\n\t\n\t      dialogsInBody: false,\n\t      dialogsFade: false,\n\t\n\t      maximumImageFileSize: null,\n\t\n\t      callbacks: {\n\t        onInit: null,\n\t        onFocus: null,\n\t        onBlur: null,\n\t        onEnter: null,\n\t        onKeyup: null,\n\t        onKeydown: null,\n\t        onImageUpload: null,\n\t        onImageUploadError: null\n\t      },\n\t\n\t      codemirror: {\n\t        mode: 'text/html',\n\t        htmlMode: true,\n\t        lineNumbers: true\n\t      },\n\t\n\t      keyMap: {\n\t        pc: {\n\t          'ENTER': 'insertParagraph',\n\t          'CTRL+Z': 'undo',\n\t          'CTRL+Y': 'redo',\n\t          'TAB': 'tab',\n\t          'SHIFT+TAB': 'untab',\n\t          'CTRL+B': 'bold',\n\t          'CTRL+I': 'italic',\n\t          'CTRL+U': 'underline',\n\t          'CTRL+SHIFT+S': 'strikethrough',\n\t          'CTRL+BACKSLASH': 'removeFormat',\n\t          'CTRL+SHIFT+L': 'justifyLeft',\n\t          'CTRL+SHIFT+E': 'justifyCenter',\n\t          'CTRL+SHIFT+R': 'justifyRight',\n\t          'CTRL+SHIFT+J': 'justifyFull',\n\t          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n\t          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n\t          'CTRL+LEFTBRACKET': 'outdent',\n\t          'CTRL+RIGHTBRACKET': 'indent',\n\t          'CTRL+NUM0': 'formatPara',\n\t          'CTRL+NUM1': 'formatH1',\n\t          'CTRL+NUM2': 'formatH2',\n\t          'CTRL+NUM3': 'formatH3',\n\t          'CTRL+NUM4': 'formatH4',\n\t          'CTRL+NUM5': 'formatH5',\n\t          'CTRL+NUM6': 'formatH6',\n\t          'CTRL+ENTER': 'insertHorizontalRule',\n\t          'CTRL+K': 'linkDialog.show'\n\t        },\n\t\n\t        mac: {\n\t          'ENTER': 'insertParagraph',\n\t          'CMD+Z': 'undo',\n\t          'CMD+SHIFT+Z': 'redo',\n\t          'TAB': 'tab',\n\t          'SHIFT+TAB': 'untab',\n\t          'CMD+B': 'bold',\n\t          'CMD+I': 'italic',\n\t          'CMD+U': 'underline',\n\t          'CMD+SHIFT+S': 'strikethrough',\n\t          'CMD+BACKSLASH': 'removeFormat',\n\t          'CMD+SHIFT+L': 'justifyLeft',\n\t          'CMD+SHIFT+E': 'justifyCenter',\n\t          'CMD+SHIFT+R': 'justifyRight',\n\t          'CMD+SHIFT+J': 'justifyFull',\n\t          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n\t          'CMD+SHIFT+NUM8': 'insertOrderedList',\n\t          'CMD+LEFTBRACKET': 'outdent',\n\t          'CMD+RIGHTBRACKET': 'indent',\n\t          'CMD+NUM0': 'formatPara',\n\t          'CMD+NUM1': 'formatH1',\n\t          'CMD+NUM2': 'formatH2',\n\t          'CMD+NUM3': 'formatH3',\n\t          'CMD+NUM4': 'formatH4',\n\t          'CMD+NUM5': 'formatH5',\n\t          'CMD+NUM6': 'formatH6',\n\t          'CMD+ENTER': 'insertHorizontalRule',\n\t          'CMD+K': 'linkDialog.show'\n\t        }\n\t      },\n\t      icons: {\n\t        'align': 'note-icon-align',\n\t        'alignCenter': 'note-icon-align-center',\n\t        'alignJustify': 'note-icon-align-justify',\n\t        'alignLeft': 'note-icon-align-left',\n\t        'alignRight': 'note-icon-align-right',\n\t        'indent': 'note-icon-align-indent',\n\t        'outdent': 'note-icon-align-outdent',\n\t        'arrowsAlt': 'note-icon-arrows-alt',\n\t        'bold': 'note-icon-bold',\n\t        'caret': 'note-icon-caret',\n\t        'circle': 'note-icon-circle',\n\t        'close': 'note-icon-close',\n\t        'code': 'note-icon-code',\n\t        'eraser': 'note-icon-eraser',\n\t        'font': 'note-icon-font',\n\t        'frame': 'note-icon-frame',\n\t        'italic': 'note-icon-italic',\n\t        'link': 'note-icon-link',\n\t        'unlink': 'note-icon-chain-broken',\n\t        'magic': 'note-icon-magic',\n\t        'menuCheck': 'note-icon-check',\n\t        'minus': 'note-icon-minus',\n\t        'orderedlist': 'note-icon-orderedlist',\n\t        'pencil': 'note-icon-pencil',\n\t        'picture': 'note-icon-picture',\n\t        'question': 'note-icon-question',\n\t        'redo': 'note-icon-redo',\n\t        'square': 'note-icon-square',\n\t        'strikethrough': 'note-icon-strikethrough',\n\t        'subscript': 'note-icon-subscript',\n\t        'superscript': 'note-icon-superscript',\n\t        'table': 'note-icon-table',\n\t        'textHeight': 'note-icon-text-height',\n\t        'trash': 'note-icon-trash',\n\t        'underline': 'note-icon-underline',\n\t        'undo': 'note-icon-undo',\n\t        'unorderedlist': 'note-icon-unorderedlist',\n\t        'video': 'note-icon-video'\n\t      }\n\t    }\n\t  });\n\t\n\t}));\n\n\n/***/ },\n\n/***/ 79:\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ },\n\n/***/ 80:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// This is CodeMirror (http://codemirror.net), a code editor\n\t// implemented in JavaScript on top of the browser's DOM.\n\t//\n\t// You can find some technical background for some of the code below\n\t// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    module.exports = mod();\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    return define([], mod);\n\t  else // Plain browser env\n\t    (this || window).CodeMirror = mod();\n\t})(function() {\n\t  \"use strict\";\n\t\n\t  // BROWSER SNIFFING\n\t\n\t  // Kludges for bugs and behavior differences that can't be feature\n\t  // detected are enabled based on userAgent etc sniffing.\n\t  var userAgent = navigator.userAgent;\n\t  var platform = navigator.platform;\n\t\n\t  var gecko = /gecko\\/\\d/i.test(userAgent);\n\t  var ie_upto10 = /MSIE \\d/.test(userAgent);\n\t  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n\t  var ie = ie_upto10 || ie_11up;\n\t  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n\t  var webkit = /WebKit\\//.test(userAgent);\n\t  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n\t  var chrome = /Chrome\\//.test(userAgent);\n\t  var presto = /Opera\\//.test(userAgent);\n\t  var safari = /Apple Computer/.test(navigator.vendor);\n\t  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n\t  var phantom = /PhantomJS/.test(userAgent);\n\t\n\t  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n\t  // This is woefully incomplete. Suggestions for alternative methods welcome.\n\t  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n\t  var mac = ios || /Mac/.test(platform);\n\t  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n\t  var windows = /win/i.test(platform);\n\t\n\t  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\t  if (presto_version) presto_version = Number(presto_version[1]);\n\t  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n\t  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\t  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n\t  var captureRightClick = gecko || (ie && ie_version >= 9);\n\t\n\t  // Optimize some code when these features are not used.\n\t  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\t\n\t  // EDITOR CONSTRUCTOR\n\t\n\t  // A CodeMirror instance represents an editor. This is the object\n\t  // that user code is usually dealing with.\n\t\n\t  function CodeMirror(place, options) {\n\t    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\t\n\t    this.options = options = options ? copyObj(options) : {};\n\t    // Determine effective options based on given values and defaults.\n\t    copyObj(defaults, options, false);\n\t    setGuttersForLineNumbers(options);\n\t\n\t    var doc = options.value;\n\t    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n\t    this.doc = doc;\n\t\n\t    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n\t    var display = this.display = new Display(place, doc, input);\n\t    display.wrapper.CodeMirror = this;\n\t    updateGutters(this);\n\t    themeChanged(this);\n\t    if (options.lineWrapping)\n\t      this.display.wrapper.className += \" CodeMirror-wrap\";\n\t    if (options.autofocus && !mobile) display.input.focus();\n\t    initScrollbars(this);\n\t\n\t    this.state = {\n\t      keyMaps: [],  // stores maps added by addKeyMap\n\t      overlays: [], // highlighting overlays, as added by addOverlay\n\t      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n\t      overwrite: false,\n\t      delayingBlurEvent: false,\n\t      focused: false,\n\t      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n\t      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n\t      selectingText: false,\n\t      draggingText: false,\n\t      highlight: new Delayed(), // stores highlight worker timeout\n\t      keySeq: null,  // Unfinished key sequence\n\t      specialChars: null\n\t    };\n\t\n\t    var cm = this;\n\t\n\t    // Override magic textarea content restore that IE sometimes does\n\t    // on our hidden textarea on reload\n\t    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\t\n\t    registerEventHandlers(this);\n\t    ensureGlobalHandlers();\n\t\n\t    startOperation(this);\n\t    this.curOp.forceUpdate = true;\n\t    attachDoc(this, doc);\n\t\n\t    if ((options.autofocus && !mobile) || cm.hasFocus())\n\t      setTimeout(bind(onFocus, this), 20);\n\t    else\n\t      onBlur(this);\n\t\n\t    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n\t      optionHandlers[opt](this, options[opt], Init);\n\t    maybeUpdateLineNumberWidth(this);\n\t    if (options.finishInit) options.finishInit(this);\n\t    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n\t    endOperation(this);\n\t    // Suppress optimizelegibility in Webkit, since it breaks text\n\t    // measuring on line wrapping boundaries.\n\t    if (webkit && options.lineWrapping &&\n\t        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n\t      display.lineDiv.style.textRendering = \"auto\";\n\t  }\n\t\n\t  // DISPLAY CONSTRUCTOR\n\t\n\t  // The display handles the DOM integration, both for input reading\n\t  // and content drawing. It holds references to DOM nodes and\n\t  // display-related state.\n\t\n\t  function Display(place, doc, input) {\n\t    var d = this;\n\t    this.input = input;\n\t\n\t    // Covers bottom-right square when both scrollbars are present.\n\t    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n\t    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n\t    // and h scrollbar is present.\n\t    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n\t    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Will contain the actual code, positioned to cover the viewport.\n\t    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n\t    // Elements are added to these to represent selection and cursors.\n\t    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n\t    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n\t    // A visibility: hidden element used to find the size of things.\n\t    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // When lines outside of the viewport are measured, they are drawn in this.\n\t    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\t    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n\t                      null, \"position: relative; outline: none\");\n\t    // Moved around its parent to cover visible view.\n\t    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n\t    // Set to the height of the document, allowing scrolling.\n\t    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n\t    d.sizerWidth = null;\n\t    // Behavior of elts with overflow: auto and padding is\n\t    // inconsistent across browsers. This is used to ensure the\n\t    // scrollable area is big enough.\n\t    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n\t    // Will contain the gutters, if any.\n\t    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n\t    d.lineGutter = null;\n\t    // Actual scrollable element.\n\t    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n\t    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n\t    // The element in which the editor lives.\n\t    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\t\n\t    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n\t    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n\t    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\t\n\t    if (place) {\n\t      if (place.appendChild) place.appendChild(d.wrapper);\n\t      else place(d.wrapper);\n\t    }\n\t\n\t    // Current rendered range (may be bigger than the view window).\n\t    d.viewFrom = d.viewTo = doc.first;\n\t    d.reportedViewFrom = d.reportedViewTo = doc.first;\n\t    // Information about the rendered lines.\n\t    d.view = [];\n\t    d.renderedView = null;\n\t    // Holds info about a single rendered line when it was rendered\n\t    // for measurement, while not in view.\n\t    d.externalMeasured = null;\n\t    // Empty space (in pixels) above the view\n\t    d.viewOffset = 0;\n\t    d.lastWrapHeight = d.lastWrapWidth = 0;\n\t    d.updateLineNumbers = null;\n\t\n\t    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n\t    d.scrollbarsClipped = false;\n\t\n\t    // Used to only resize the line number gutter when necessary (when\n\t    // the amount of lines crosses a boundary that makes its width change)\n\t    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n\t    // Set to true when a non-horizontal-scrolling line widget is\n\t    // added. As an optimization, line widget aligning is skipped when\n\t    // this is false.\n\t    d.alignWidgets = false;\n\t\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t\n\t    // Tracks the maximum line length so that the horizontal scrollbar\n\t    // can be kept static when scrolling.\n\t    d.maxLine = null;\n\t    d.maxLineLength = 0;\n\t    d.maxLineChanged = false;\n\t\n\t    // Used for measuring wheel scrolling granularity\n\t    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\t\n\t    // True when shift is held down.\n\t    d.shift = false;\n\t\n\t    // Used to track whether anything happened since the context menu\n\t    // was opened.\n\t    d.selForContextMenu = null;\n\t\n\t    d.activeTouch = null;\n\t\n\t    input.init(d);\n\t  }\n\t\n\t  // STATE UPDATES\n\t\n\t  // Used to get the editor into a consistent state again when options change.\n\t\n\t  function loadMode(cm) {\n\t    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n\t    resetModeState(cm);\n\t  }\n\t\n\t  function resetModeState(cm) {\n\t    cm.doc.iter(function(line) {\n\t      if (line.stateAfter) line.stateAfter = null;\n\t      if (line.styles) line.styles = null;\n\t    });\n\t    cm.doc.frontier = cm.doc.first;\n\t    startWorker(cm, 100);\n\t    cm.state.modeGen++;\n\t    if (cm.curOp) regChange(cm);\n\t  }\n\t\n\t  function wrappingChanged(cm) {\n\t    if (cm.options.lineWrapping) {\n\t      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      cm.display.sizer.style.minWidth = \"\";\n\t      cm.display.sizerWidth = null;\n\t    } else {\n\t      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      findMaxLine(cm);\n\t    }\n\t    estimateLineHeights(cm);\n\t    regChange(cm);\n\t    clearCaches(cm);\n\t    setTimeout(function(){updateScrollbars(cm);}, 100);\n\t  }\n\t\n\t  // Returns a function that estimates the height of a line, to use as\n\t  // first approximation until the line becomes visible (and is thus\n\t  // properly measurable).\n\t  function estimateHeight(cm) {\n\t    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n\t    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n\t    return function(line) {\n\t      if (lineIsHidden(cm.doc, line)) return 0;\n\t\n\t      var widgetsHeight = 0;\n\t      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n\t        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n\t      }\n\t\n\t      if (wrapping)\n\t        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n\t      else\n\t        return widgetsHeight + th;\n\t    };\n\t  }\n\t\n\t  function estimateLineHeights(cm) {\n\t    var doc = cm.doc, est = estimateHeight(cm);\n\t    doc.iter(function(line) {\n\t      var estHeight = est(line);\n\t      if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t    });\n\t  }\n\t\n\t  function themeChanged(cm) {\n\t    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n\t      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n\t    clearCaches(cm);\n\t  }\n\t\n\t  function guttersChanged(cm) {\n\t    updateGutters(cm);\n\t    regChange(cm);\n\t    setTimeout(function(){alignHorizontally(cm);}, 20);\n\t  }\n\t\n\t  // Rebuild the gutter elements, ensure the margin to the left of the\n\t  // code matches their width.\n\t  function updateGutters(cm) {\n\t    var gutters = cm.display.gutters, specs = cm.options.gutters;\n\t    removeChildren(gutters);\n\t    for (var i = 0; i < specs.length; ++i) {\n\t      var gutterClass = specs[i];\n\t      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n\t      if (gutterClass == \"CodeMirror-linenumbers\") {\n\t        cm.display.lineGutter = gElt;\n\t        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n\t      }\n\t    }\n\t    gutters.style.display = i ? \"\" : \"none\";\n\t    updateGutterSpace(cm);\n\t  }\n\t\n\t  function updateGutterSpace(cm) {\n\t    var width = cm.display.gutters.offsetWidth;\n\t    cm.display.sizer.style.marginLeft = width + \"px\";\n\t  }\n\t\n\t  // Compute the character length of a line, taking into account\n\t  // collapsed ranges (see markText) that might hide parts, and join\n\t  // other lines onto it.\n\t  function lineLength(line) {\n\t    if (line.height == 0) return 0;\n\t    var len = line.text.length, merged, cur = line;\n\t    while (merged = collapsedSpanAtStart(cur)) {\n\t      var found = merged.find(0, true);\n\t      cur = found.from.line;\n\t      len += found.from.ch - found.to.ch;\n\t    }\n\t    cur = line;\n\t    while (merged = collapsedSpanAtEnd(cur)) {\n\t      var found = merged.find(0, true);\n\t      len -= cur.text.length - found.from.ch;\n\t      cur = found.to.line;\n\t      len += cur.text.length - found.to.ch;\n\t    }\n\t    return len;\n\t  }\n\t\n\t  // Find the longest line in the document.\n\t  function findMaxLine(cm) {\n\t    var d = cm.display, doc = cm.doc;\n\t    d.maxLine = getLine(doc, doc.first);\n\t    d.maxLineLength = lineLength(d.maxLine);\n\t    d.maxLineChanged = true;\n\t    doc.iter(function(line) {\n\t      var len = lineLength(line);\n\t      if (len > d.maxLineLength) {\n\t        d.maxLineLength = len;\n\t        d.maxLine = line;\n\t      }\n\t    });\n\t  }\n\t\n\t  // Make sure the gutters options contains the element\n\t  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n\t  function setGuttersForLineNumbers(options) {\n\t    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n\t    if (found == -1 && options.lineNumbers) {\n\t      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n\t    } else if (found > -1 && !options.lineNumbers) {\n\t      options.gutters = options.gutters.slice(0);\n\t      options.gutters.splice(found, 1);\n\t    }\n\t  }\n\t\n\t  // SCROLLBARS\n\t\n\t  // Prepare DOM reads needed to update the scrollbars. Done in one\n\t  // shot to minimize update/measure roundtrips.\n\t  function measureForScrollbars(cm) {\n\t    var d = cm.display, gutterW = d.gutters.offsetWidth;\n\t    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n\t    return {\n\t      clientHeight: d.scroller.clientHeight,\n\t      viewHeight: d.wrapper.clientHeight,\n\t      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n\t      viewWidth: d.wrapper.clientWidth,\n\t      barLeft: cm.options.fixedGutter ? gutterW : 0,\n\t      docHeight: docH,\n\t      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n\t      nativeBarWidth: d.nativeBarWidth,\n\t      gutterWidth: gutterW\n\t    };\n\t  }\n\t\n\t  function NativeScrollbars(place, scroll, cm) {\n\t    this.cm = cm;\n\t    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n\t    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n\t    place(vert); place(horiz);\n\t\n\t    on(vert, \"scroll\", function() {\n\t      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n\t    });\n\t    on(horiz, \"scroll\", function() {\n\t      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n\t    });\n\t\n\t    this.checkedZeroWidth = false;\n\t    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\t    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n\t  }\n\t\n\t  NativeScrollbars.prototype = copyObj({\n\t    update: function(measure) {\n\t      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n\t      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n\t      var sWidth = measure.nativeBarWidth;\n\t\n\t      if (needsV) {\n\t        this.vert.style.display = \"block\";\n\t        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n\t        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n\t        // A bug in IE8 can cause this value to be negative, so guard it.\n\t        this.vert.firstChild.style.height =\n\t          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n\t      } else {\n\t        this.vert.style.display = \"\";\n\t        this.vert.firstChild.style.height = \"0\";\n\t      }\n\t\n\t      if (needsH) {\n\t        this.horiz.style.display = \"block\";\n\t        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n\t        this.horiz.style.left = measure.barLeft + \"px\";\n\t        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n\t        this.horiz.firstChild.style.width =\n\t          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n\t      } else {\n\t        this.horiz.style.display = \"\";\n\t        this.horiz.firstChild.style.width = \"0\";\n\t      }\n\t\n\t      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n\t        if (sWidth == 0) this.zeroWidthHack();\n\t        this.checkedZeroWidth = true;\n\t      }\n\t\n\t      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n\t    },\n\t    setScrollLeft: function(pos) {\n\t      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n\t      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n\t    },\n\t    setScrollTop: function(pos) {\n\t      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n\t      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n\t    },\n\t    zeroWidthHack: function() {\n\t      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n\t      this.horiz.style.height = this.vert.style.width = w;\n\t      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n\t      this.disableHoriz = new Delayed;\n\t      this.disableVert = new Delayed;\n\t    },\n\t    enableZeroWidthBar: function(bar, delay) {\n\t      bar.style.pointerEvents = \"auto\";\n\t      function maybeDisable() {\n\t        // To find out whether the scrollbar is still visible, we\n\t        // check whether the element under the pixel in the bottom\n\t        // left corner of the scrollbar box is the scrollbar box\n\t        // itself (when the bar is still visible) or its filler child\n\t        // (when the bar is hidden). If it is still visible, we keep\n\t        // it enabled, if it's hidden, we disable pointer events.\n\t        var box = bar.getBoundingClientRect();\n\t        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n\t        if (elt != bar) bar.style.pointerEvents = \"none\";\n\t        else delay.set(1000, maybeDisable);\n\t      }\n\t      delay.set(1000, maybeDisable);\n\t    },\n\t    clear: function() {\n\t      var parent = this.horiz.parentNode;\n\t      parent.removeChild(this.horiz);\n\t      parent.removeChild(this.vert);\n\t    }\n\t  }, NativeScrollbars.prototype);\n\t\n\t  function NullScrollbars() {}\n\t\n\t  NullScrollbars.prototype = copyObj({\n\t    update: function() { return {bottom: 0, right: 0}; },\n\t    setScrollLeft: function() {},\n\t    setScrollTop: function() {},\n\t    clear: function() {}\n\t  }, NullScrollbars.prototype);\n\t\n\t  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\t\n\t  function initScrollbars(cm) {\n\t    if (cm.display.scrollbars) {\n\t      cm.display.scrollbars.clear();\n\t      if (cm.display.scrollbars.addClass)\n\t        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t    }\n\t\n\t    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n\t      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n\t      // Prevent clicks in the scrollbars from killing focus\n\t      on(node, \"mousedown\", function() {\n\t        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n\t      });\n\t      node.setAttribute(\"cm-not-content\", \"true\");\n\t    }, function(pos, axis) {\n\t      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n\t      else setScrollTop(cm, pos);\n\t    }, cm);\n\t    if (cm.display.scrollbars.addClass)\n\t      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t  }\n\t\n\t  function updateScrollbars(cm, measure) {\n\t    if (!measure) measure = measureForScrollbars(cm);\n\t    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n\t    updateScrollbarsInner(cm, measure);\n\t    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n\t      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n\t        updateHeightsInViewport(cm);\n\t      updateScrollbarsInner(cm, measureForScrollbars(cm));\n\t      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n\t    }\n\t  }\n\t\n\t  // Re-synchronize the fake scrollbars with the actual size of the\n\t  // content.\n\t  function updateScrollbarsInner(cm, measure) {\n\t    var d = cm.display;\n\t    var sizes = d.scrollbars.update(measure);\n\t\n\t    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n\t    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\t    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\"\n\t\n\t    if (sizes.right && sizes.bottom) {\n\t      d.scrollbarFiller.style.display = \"block\";\n\t      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n\t      d.scrollbarFiller.style.width = sizes.right + \"px\";\n\t    } else d.scrollbarFiller.style.display = \"\";\n\t    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n\t      d.gutterFiller.style.display = \"block\";\n\t      d.gutterFiller.style.height = sizes.bottom + \"px\";\n\t      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n\t    } else d.gutterFiller.style.display = \"\";\n\t  }\n\t\n\t  // Compute the lines that are visible in a given viewport (defaults\n\t  // the the current scroll position). viewport may contain top,\n\t  // height, and ensure (see op.scrollToPos) properties.\n\t  function visibleLines(display, doc, viewport) {\n\t    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n\t    top = Math.floor(top - paddingTop(display));\n\t    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\t\n\t    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n\t    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n\t    // forces those lines into the viewport (if possible).\n\t    if (viewport && viewport.ensure) {\n\t      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n\t      if (ensureFrom < from) {\n\t        from = ensureFrom;\n\t        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n\t      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n\t        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n\t        to = ensureTo;\n\t      }\n\t    }\n\t    return {from: from, to: Math.max(to, from + 1)};\n\t  }\n\t\n\t  // LINE NUMBERS\n\t\n\t  // Re-align line numbers and gutter marks to compensate for\n\t  // horizontal scrolling.\n\t  function alignHorizontally(cm) {\n\t    var display = cm.display, view = display.view;\n\t    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n\t    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n\t    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n\t    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n\t      if (cm.options.fixedGutter && view[i].gutter)\n\t        view[i].gutter.style.left = left;\n\t      var align = view[i].alignable;\n\t      if (align) for (var j = 0; j < align.length; j++)\n\t        align[j].style.left = left;\n\t    }\n\t    if (cm.options.fixedGutter)\n\t      display.gutters.style.left = (comp + gutterW) + \"px\";\n\t  }\n\t\n\t  // Used to ensure that the line number gutter is still the right\n\t  // size for the current document size. Returns true when an update\n\t  // is needed.\n\t  function maybeUpdateLineNumberWidth(cm) {\n\t    if (!cm.options.lineNumbers) return false;\n\t    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n\t    if (last.length != display.lineNumChars) {\n\t      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n\t                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n\t      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n\t      display.lineGutter.style.width = \"\";\n\t      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n\t      display.lineNumWidth = display.lineNumInnerWidth + padding;\n\t      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n\t      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n\t      updateGutterSpace(cm);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function lineNumberFor(options, i) {\n\t    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n\t  }\n\t\n\t  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n\t  // but using getBoundingClientRect to get a sub-pixel-accurate\n\t  // result.\n\t  function compensateForHScroll(display) {\n\t    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n\t  }\n\t\n\t  // DISPLAY DRAWING\n\t\n\t  function DisplayUpdate(cm, viewport, force) {\n\t    var display = cm.display;\n\t\n\t    this.viewport = viewport;\n\t    // Store some values that we'll need later (but don't want to force a relayout for)\n\t    this.visible = visibleLines(display, cm.doc, viewport);\n\t    this.editorIsHidden = !display.wrapper.offsetWidth;\n\t    this.wrapperHeight = display.wrapper.clientHeight;\n\t    this.wrapperWidth = display.wrapper.clientWidth;\n\t    this.oldDisplayWidth = displayWidth(cm);\n\t    this.force = force;\n\t    this.dims = getDimensions(cm);\n\t    this.events = [];\n\t  }\n\t\n\t  DisplayUpdate.prototype.signal = function(emitter, type) {\n\t    if (hasHandler(emitter, type))\n\t      this.events.push(arguments);\n\t  };\n\t  DisplayUpdate.prototype.finish = function() {\n\t    for (var i = 0; i < this.events.length; i++)\n\t      signal.apply(null, this.events[i]);\n\t  };\n\t\n\t  function maybeClipScrollbars(cm) {\n\t    var display = cm.display;\n\t    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n\t      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n\t      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n\t      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n\t      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n\t      display.scrollbarsClipped = true;\n\t    }\n\t  }\n\t\n\t  // Does the actual updating of the line display. Bails out\n\t  // (returning false) when there is nothing to be done and forced is\n\t  // false.\n\t  function updateDisplayIfNeeded(cm, update) {\n\t    var display = cm.display, doc = cm.doc;\n\t\n\t    if (update.editorIsHidden) {\n\t      resetView(cm);\n\t      return false;\n\t    }\n\t\n\t    // Bail out if the visible area is already rendered and nothing changed.\n\t    if (!update.force &&\n\t        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n\t        display.renderedView == display.view && countDirtyView(cm) == 0)\n\t      return false;\n\t\n\t    if (maybeUpdateLineNumberWidth(cm)) {\n\t      resetView(cm);\n\t      update.dims = getDimensions(cm);\n\t    }\n\t\n\t    // Compute a suitable new viewport (from & to)\n\t    var end = doc.first + doc.size;\n\t    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n\t    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n\t    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n\t    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n\t    if (sawCollapsedSpans) {\n\t      from = visualLineNo(cm.doc, from);\n\t      to = visualLineEndNo(cm.doc, to);\n\t    }\n\t\n\t    var different = from != display.viewFrom || to != display.viewTo ||\n\t      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n\t    adjustView(cm, from, to);\n\t\n\t    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n\t    // Position the mover div to align with the current scroll position\n\t    cm.display.mover.style.top = display.viewOffset + \"px\";\n\t\n\t    var toUpdate = countDirtyView(cm);\n\t    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n\t      return false;\n\t\n\t    // For big changes, we hide the enclosing element during the\n\t    // update, since that speeds up the operations on most browsers.\n\t    var focused = activeElt();\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n\t    patchDisplay(cm, display.updateLineNumbers, update.dims);\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n\t    display.renderedView = display.view;\n\t    // There might have been a widget with a focused element that got\n\t    // hidden or updated, if so re-focus it.\n\t    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\t\n\t    // Prevent selection and cursors from interfering with the scroll\n\t    // width and height.\n\t    removeChildren(display.cursorDiv);\n\t    removeChildren(display.selectionDiv);\n\t    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\t\n\t    if (different) {\n\t      display.lastWrapHeight = update.wrapperHeight;\n\t      display.lastWrapWidth = update.wrapperWidth;\n\t      startWorker(cm, 400);\n\t    }\n\t\n\t    display.updateLineNumbers = null;\n\t\n\t    return true;\n\t  }\n\t\n\t  function postUpdateDisplay(cm, update) {\n\t    var viewport = update.viewport;\n\t\n\t    for (var first = true;; first = false) {\n\t      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n\t        // Clip forced viewport to actual scrollable area.\n\t        if (viewport && viewport.top != null)\n\t          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n\t        // Updated line heights might result in the drawn area not\n\t        // actually covering the viewport. Keep looping until it does.\n\t        update.visible = visibleLines(cm.display, cm.doc, viewport);\n\t        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n\t          break;\n\t      }\n\t      if (!updateDisplayIfNeeded(cm, update)) break;\n\t      updateHeightsInViewport(cm);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      updateScrollbars(cm, barMeasure);\n\t      setDocumentHeight(cm, barMeasure);\n\t    }\n\t\n\t    update.signal(cm, \"update\", cm);\n\t    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n\t      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n\t      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n\t    }\n\t  }\n\t\n\t  function updateDisplaySimple(cm, viewport) {\n\t    var update = new DisplayUpdate(cm, viewport);\n\t    if (updateDisplayIfNeeded(cm, update)) {\n\t      updateHeightsInViewport(cm);\n\t      postUpdateDisplay(cm, update);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      updateScrollbars(cm, barMeasure);\n\t      setDocumentHeight(cm, barMeasure);\n\t      update.finish();\n\t    }\n\t  }\n\t\n\t  function setDocumentHeight(cm, measure) {\n\t    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n\t    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n\t    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n\t  }\n\t\n\t  // Read the actual heights of the rendered lines, and update their\n\t  // stored heights to match.\n\t  function updateHeightsInViewport(cm) {\n\t    var display = cm.display;\n\t    var prevBottom = display.lineDiv.offsetTop;\n\t    for (var i = 0; i < display.view.length; i++) {\n\t      var cur = display.view[i], height;\n\t      if (cur.hidden) continue;\n\t      if (ie && ie_version < 8) {\n\t        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n\t        height = bot - prevBottom;\n\t        prevBottom = bot;\n\t      } else {\n\t        var box = cur.node.getBoundingClientRect();\n\t        height = box.bottom - box.top;\n\t      }\n\t      var diff = cur.line.height - height;\n\t      if (height < 2) height = textHeight(display);\n\t      if (diff > .001 || diff < -.001) {\n\t        updateLineHeight(cur.line, height);\n\t        updateWidgetHeight(cur.line);\n\t        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n\t          updateWidgetHeight(cur.rest[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Read and store the height of line widgets associated with the\n\t  // given line.\n\t  function updateWidgetHeight(line) {\n\t    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n\t      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;\n\t  }\n\t\n\t  // Do a bulk-read of the DOM positions and sizes needed to draw the\n\t  // view, so that we don't interleave reading and writing to the DOM.\n\t  function getDimensions(cm) {\n\t    var d = cm.display, left = {}, width = {};\n\t    var gutterLeft = d.gutters.clientLeft;\n\t    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n\t      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n\t      width[cm.options.gutters[i]] = n.clientWidth;\n\t    }\n\t    return {fixedPos: compensateForHScroll(d),\n\t            gutterTotalWidth: d.gutters.offsetWidth,\n\t            gutterLeft: left,\n\t            gutterWidth: width,\n\t            wrapperWidth: d.wrapper.clientWidth};\n\t  }\n\t\n\t  // Sync the actual display DOM structure with display.view, removing\n\t  // nodes for lines that are no longer in view, and creating the ones\n\t  // that are not there yet, and updating the ones that are out of\n\t  // date.\n\t  function patchDisplay(cm, updateNumbersFrom, dims) {\n\t    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n\t    var container = display.lineDiv, cur = container.firstChild;\n\t\n\t    function rm(node) {\n\t      var next = node.nextSibling;\n\t      // Works around a throw-scroll bug in OS X Webkit\n\t      if (webkit && mac && cm.display.currentWheelTarget == node)\n\t        node.style.display = \"none\";\n\t      else\n\t        node.parentNode.removeChild(node);\n\t      return next;\n\t    }\n\t\n\t    var view = display.view, lineN = display.viewFrom;\n\t    // Loop over the elements in the view, syncing cur (the DOM nodes\n\t    // in display.lineDiv) with the view as we go.\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (lineView.hidden) {\n\t      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n\t        var node = buildLineElement(cm, lineView, lineN, dims);\n\t        container.insertBefore(node, cur);\n\t      } else { // Already drawn\n\t        while (cur != lineView.node) cur = rm(cur);\n\t        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n\t          updateNumbersFrom <= lineN && lineView.lineNumber;\n\t        if (lineView.changes) {\n\t          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n\t          updateLineForChanges(cm, lineView, lineN, dims);\n\t        }\n\t        if (updateNumber) {\n\t          removeChildren(lineView.lineNumber);\n\t          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n\t        }\n\t        cur = lineView.node.nextSibling;\n\t      }\n\t      lineN += lineView.size;\n\t    }\n\t    while (cur) cur = rm(cur);\n\t  }\n\t\n\t  // When an aspect of a line changes, a string is added to\n\t  // lineView.changes. This updates the relevant part of the line's\n\t  // DOM structure.\n\t  function updateLineForChanges(cm, lineView, lineN, dims) {\n\t    for (var j = 0; j < lineView.changes.length; j++) {\n\t      var type = lineView.changes[j];\n\t      if (type == \"text\") updateLineText(cm, lineView);\n\t      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n\t      else if (type == \"class\") updateLineClasses(lineView);\n\t      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n\t    }\n\t    lineView.changes = null;\n\t  }\n\t\n\t  // Lines with gutter elements, widgets or a background class need to\n\t  // be wrapped, and have the extra elements added to the wrapper div\n\t  function ensureLineWrapped(lineView) {\n\t    if (lineView.node == lineView.text) {\n\t      lineView.node = elt(\"div\", null, null, \"position: relative\");\n\t      if (lineView.text.parentNode)\n\t        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n\t      lineView.node.appendChild(lineView.text);\n\t      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n\t    }\n\t    return lineView.node;\n\t  }\n\t\n\t  function updateLineBackground(lineView) {\n\t    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n\t    if (cls) cls += \" CodeMirror-linebackground\";\n\t    if (lineView.background) {\n\t      if (cls) lineView.background.className = cls;\n\t      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n\t    } else if (cls) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n\t    }\n\t  }\n\t\n\t  // Wrapper around buildLineContent which will reuse the structure\n\t  // in display.externalMeasured when possible.\n\t  function getLineContent(cm, lineView) {\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && ext.line == lineView.line) {\n\t      cm.display.externalMeasured = null;\n\t      lineView.measure = ext.measure;\n\t      return ext.built;\n\t    }\n\t    return buildLineContent(cm, lineView);\n\t  }\n\t\n\t  // Redraw the line's text. Interacts with the background and text\n\t  // classes because the mode may output tokens that influence these\n\t  // classes.\n\t  function updateLineText(cm, lineView) {\n\t    var cls = lineView.text.className;\n\t    var built = getLineContent(cm, lineView);\n\t    if (lineView.text == lineView.node) lineView.node = built.pre;\n\t    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n\t    lineView.text = built.pre;\n\t    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n\t      lineView.bgClass = built.bgClass;\n\t      lineView.textClass = built.textClass;\n\t      updateLineClasses(lineView);\n\t    } else if (cls) {\n\t      lineView.text.className = cls;\n\t    }\n\t  }\n\t\n\t  function updateLineClasses(lineView) {\n\t    updateLineBackground(lineView);\n\t    if (lineView.line.wrapClass)\n\t      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n\t    else if (lineView.node != lineView.text)\n\t      lineView.node.className = \"\";\n\t    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n\t    lineView.text.className = textClass || \"\";\n\t  }\n\t\n\t  function updateLineGutter(cm, lineView, lineN, dims) {\n\t    if (lineView.gutter) {\n\t      lineView.node.removeChild(lineView.gutter);\n\t      lineView.gutter = null;\n\t    }\n\t    if (lineView.gutterBackground) {\n\t      lineView.node.removeChild(lineView.gutterBackground);\n\t      lineView.gutterBackground = null;\n\t    }\n\t    if (lineView.line.gutterClass) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n\t                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n\t                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n\t      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n\t    }\n\t    var markers = lineView.line.gutterMarkers;\n\t    if (cm.options.lineNumbers || markers) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n\t                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n\t      cm.display.input.setUneditable(gutterWrap);\n\t      wrap.insertBefore(gutterWrap, lineView.text);\n\t      if (lineView.line.gutterClass)\n\t        gutterWrap.className += \" \" + lineView.line.gutterClass;\n\t      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n\t        lineView.lineNumber = gutterWrap.appendChild(\n\t          elt(\"div\", lineNumberFor(cm.options, lineN),\n\t              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n\t              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n\t              + cm.display.lineNumInnerWidth + \"px\"));\n\t      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n\t        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n\t        if (found)\n\t          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n\t                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n\t      }\n\t    }\n\t  }\n\t\n\t  function updateLineWidgets(cm, lineView, dims) {\n\t    if (lineView.alignable) lineView.alignable = null;\n\t    for (var node = lineView.node.firstChild, next; node; node = next) {\n\t      var next = node.nextSibling;\n\t      if (node.className == \"CodeMirror-linewidget\")\n\t        lineView.node.removeChild(node);\n\t    }\n\t    insertLineWidgets(cm, lineView, dims);\n\t  }\n\t\n\t  // Build a line's DOM representation from scratch\n\t  function buildLineElement(cm, lineView, lineN, dims) {\n\t    var built = getLineContent(cm, lineView);\n\t    lineView.text = lineView.node = built.pre;\n\t    if (built.bgClass) lineView.bgClass = built.bgClass;\n\t    if (built.textClass) lineView.textClass = built.textClass;\n\t\n\t    updateLineClasses(lineView);\n\t    updateLineGutter(cm, lineView, lineN, dims);\n\t    insertLineWidgets(cm, lineView, dims);\n\t    return lineView.node;\n\t  }\n\t\n\t  // A lineView may contain multiple logical lines (when merged by\n\t  // collapsed spans). The widgets for all of them need to be drawn.\n\t  function insertLineWidgets(cm, lineView, dims) {\n\t    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n\t    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n\t  }\n\t\n\t  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n\t    if (!line.widgets) return;\n\t    var wrap = ensureLineWrapped(lineView);\n\t    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n\t      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n\t      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      positionLineWidget(widget, node, lineView, dims);\n\t      cm.display.input.setUneditable(node);\n\t      if (allowAbove && widget.above)\n\t        wrap.insertBefore(node, lineView.gutter || lineView.text);\n\t      else\n\t        wrap.appendChild(node);\n\t      signalLater(widget, \"redraw\");\n\t    }\n\t  }\n\t\n\t  function positionLineWidget(widget, node, lineView, dims) {\n\t    if (widget.noHScroll) {\n\t      (lineView.alignable || (lineView.alignable = [])).push(node);\n\t      var width = dims.wrapperWidth;\n\t      node.style.left = dims.fixedPos + \"px\";\n\t      if (!widget.coverGutter) {\n\t        width -= dims.gutterTotalWidth;\n\t        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n\t      }\n\t      node.style.width = width + \"px\";\n\t    }\n\t    if (widget.coverGutter) {\n\t      node.style.zIndex = 5;\n\t      node.style.position = \"relative\";\n\t      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n\t    }\n\t  }\n\t\n\t  // POSITION OBJECT\n\t\n\t  // A Pos instance represents a position within the text.\n\t  var Pos = CodeMirror.Pos = function(line, ch) {\n\t    if (!(this instanceof Pos)) return new Pos(line, ch);\n\t    this.line = line; this.ch = ch;\n\t  };\n\t\n\t  // Compare two positions, return 0 if they are the same, a negative\n\t  // number when a is less, and a positive number otherwise.\n\t  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\t\n\t  function copyPos(x) {return Pos(x.line, x.ch);}\n\t  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n\t  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\t\n\t  // INPUT HANDLING\n\t\n\t  function ensureFocus(cm) {\n\t    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n\t  }\n\t\n\t  // This will be set to a {lineWise: bool, text: [string]} object, so\n\t  // that, when pasting, we know what kind of selections the copied\n\t  // text was made out of.\n\t  var lastCopied = null;\n\t\n\t  function applyTextInput(cm, inserted, deleted, sel, origin) {\n\t    var doc = cm.doc;\n\t    cm.display.shift = false;\n\t    if (!sel) sel = doc.sel;\n\t\n\t    var paste = cm.state.pasteIncoming || origin == \"paste\";\n\t    var textLines = doc.splitLines(inserted), multiPaste = null\n\t    // When pasing N lines into N selections, insert one line per selection\n\t    if (paste && sel.ranges.length > 1) {\n\t      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n\t        if (sel.ranges.length % lastCopied.text.length == 0) {\n\t          multiPaste = [];\n\t          for (var i = 0; i < lastCopied.text.length; i++)\n\t            multiPaste.push(doc.splitLines(lastCopied.text[i]));\n\t        }\n\t      } else if (textLines.length == sel.ranges.length) {\n\t        multiPaste = map(textLines, function(l) { return [l]; });\n\t      }\n\t    }\n\t\n\t    // Normal behavior is to insert the new text into every selection\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      var from = range.from(), to = range.to();\n\t      if (range.empty()) {\n\t        if (deleted && deleted > 0) // Handle deletion\n\t          from = Pos(from.line, from.ch - deleted);\n\t        else if (cm.state.overwrite && !paste) // Handle overwrite\n\t          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n\t        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n\t          from = to = Pos(from.line, 0)\n\t      }\n\t      var updateInput = cm.curOp.updateInput;\n\t      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n\t                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n\t      makeChange(cm.doc, changeEvent);\n\t      signalLater(cm, \"inputRead\", cm, changeEvent);\n\t    }\n\t    if (inserted && !paste)\n\t      triggerElectric(cm, inserted);\n\t\n\t    ensureCursorVisible(cm);\n\t    cm.curOp.updateInput = updateInput;\n\t    cm.curOp.typing = true;\n\t    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n\t  }\n\t\n\t  function handlePaste(e, cm) {\n\t    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n\t    if (pasted) {\n\t      e.preventDefault();\n\t      if (!cm.isReadOnly() && !cm.options.disableInput)\n\t        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n\t      return true;\n\t    }\n\t  }\n\t\n\t  function triggerElectric(cm, inserted) {\n\t    // When an 'electric' character is inserted, immediately trigger a reindent\n\t    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n\t    var sel = cm.doc.sel;\n\t\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n\t      var mode = cm.getModeAt(range.head);\n\t      var indented = false;\n\t      if (mode.electricChars) {\n\t        for (var j = 0; j < mode.electricChars.length; j++)\n\t          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n\t            indented = indentLine(cm, range.head.line, \"smart\");\n\t            break;\n\t          }\n\t      } else if (mode.electricInput) {\n\t        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n\t          indented = indentLine(cm, range.head.line, \"smart\");\n\t      }\n\t      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n\t    }\n\t  }\n\t\n\t  function copyableRanges(cm) {\n\t    var text = [], ranges = [];\n\t    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n\t      var line = cm.doc.sel.ranges[i].head.line;\n\t      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n\t      ranges.push(lineRange);\n\t      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n\t    }\n\t    return {text: text, ranges: ranges};\n\t  }\n\t\n\t  function disableBrowserMagic(field) {\n\t    field.setAttribute(\"autocorrect\", \"off\");\n\t    field.setAttribute(\"autocapitalize\", \"off\");\n\t    field.setAttribute(\"spellcheck\", \"false\");\n\t  }\n\t\n\t  // TEXTAREA INPUT STYLE\n\t\n\t  function TextareaInput(cm) {\n\t    this.cm = cm;\n\t    // See input.poll and input.reset\n\t    this.prevInput = \"\";\n\t\n\t    // Flag that indicates whether we expect input to appear real soon\n\t    // now (after some event like 'keypress' or 'input') and are\n\t    // polling intensively.\n\t    this.pollingFast = false;\n\t    // Self-resetting timeout for the poller\n\t    this.polling = new Delayed();\n\t    // Tracks when input.reset has punted to just putting a short\n\t    // string into the textarea instead of the full selection.\n\t    this.inaccurateSelection = false;\n\t    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n\t    this.hasSelection = false;\n\t    this.composing = null;\n\t  };\n\t\n\t  function hiddenTextarea() {\n\t    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n\t    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n\t    // The textarea is kept positioned near the cursor to prevent the\n\t    // fact that it'll be scrolled into view on input from scrolling\n\t    // our fake cursor out of view. On webkit, when wrap=off, paste is\n\t    // very slow. So make the area wide instead.\n\t    if (webkit) te.style.width = \"1000px\";\n\t    else te.setAttribute(\"wrap\", \"off\");\n\t    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n\t    if (ios) te.style.border = \"1px solid black\";\n\t    disableBrowserMagic(te);\n\t    return div;\n\t  }\n\t\n\t  TextareaInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = this.cm;\n\t\n\t      // Wraps and hides input textarea\n\t      var div = this.wrapper = hiddenTextarea();\n\t      // The semihidden textarea that is focused when the editor is\n\t      // focused, and receives input.\n\t      var te = this.textarea = div.firstChild;\n\t      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\t\n\t      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n\t      if (ios) te.style.width = \"0px\";\n\t\n\t      on(te, \"input\", function() {\n\t        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n\t        input.poll();\n\t      });\n\t\n\t      on(te, \"paste\", function(e) {\n\t        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n\t\n\t        cm.state.pasteIncoming = true;\n\t        input.fastPoll();\n\t      });\n\t\n\t      function prepareCopyCut(e) {\n\t        if (signalDOMEvent(cm, e)) return\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = {lineWise: false, text: cm.getSelections()};\n\t          if (input.inaccurateSelection) {\n\t            input.prevInput = \"\";\n\t            input.inaccurateSelection = false;\n\t            te.value = lastCopied.text.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = {lineWise: true, text: ranges.text};\n\t          if (e.type == \"cut\") {\n\t            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n\t          } else {\n\t            input.prevInput = \"\";\n\t            te.value = ranges.text.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        }\n\t        if (e.type == \"cut\") cm.state.cutIncoming = true;\n\t      }\n\t      on(te, \"cut\", prepareCopyCut);\n\t      on(te, \"copy\", prepareCopyCut);\n\t\n\t      on(display.scroller, \"paste\", function(e) {\n\t        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;\n\t        cm.state.pasteIncoming = true;\n\t        input.focus();\n\t      });\n\t\n\t      // Prevent normal selection in the editor (we handle our own)\n\t      on(display.lineSpace, \"selectstart\", function(e) {\n\t        if (!eventInWidget(display, e)) e_preventDefault(e);\n\t      });\n\t\n\t      on(te, \"compositionstart\", function() {\n\t        var start = cm.getCursor(\"from\");\n\t        if (input.composing) input.composing.range.clear()\n\t        input.composing = {\n\t          start: start,\n\t          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n\t        };\n\t      });\n\t      on(te, \"compositionend\", function() {\n\t        if (input.composing) {\n\t          input.poll();\n\t          input.composing.range.clear();\n\t          input.composing = null;\n\t        }\n\t      });\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      // Redraw the selection and/or cursor\n\t      var cm = this.cm, display = cm.display, doc = cm.doc;\n\t      var result = prepareSelection(cm);\n\t\n\t      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\t      if (cm.options.moveInputWithCursor) {\n\t        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n\t        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n\t        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n\t                                            headPos.top + lineOff.top - wrapOff.top));\n\t        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n\t                                             headPos.left + lineOff.left - wrapOff.left));\n\t      }\n\t\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(drawn) {\n\t      var cm = this.cm, display = cm.display;\n\t      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n\t      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n\t      if (drawn.teTop != null) {\n\t        this.wrapper.style.top = drawn.teTop + \"px\";\n\t        this.wrapper.style.left = drawn.teLeft + \"px\";\n\t      }\n\t    },\n\t\n\t    // Reset the input to correspond to the selection (or to be empty,\n\t    // when not typing and nothing is selected)\n\t    reset: function(typing) {\n\t      if (this.contextMenuPending) return;\n\t      var minimal, selected, cm = this.cm, doc = cm.doc;\n\t      if (cm.somethingSelected()) {\n\t        this.prevInput = \"\";\n\t        var range = doc.sel.primary();\n\t        minimal = hasCopyEvent &&\n\t          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n\t        var content = minimal ? \"-\" : selected || cm.getSelection();\n\t        this.textarea.value = content;\n\t        if (cm.state.focused) selectInput(this.textarea);\n\t        if (ie && ie_version >= 9) this.hasSelection = content;\n\t      } else if (!typing) {\n\t        this.prevInput = this.textarea.value = \"\";\n\t        if (ie && ie_version >= 9) this.hasSelection = null;\n\t      }\n\t      this.inaccurateSelection = minimal;\n\t    },\n\t\n\t    getField: function() { return this.textarea; },\n\t\n\t    supportsTouch: function() { return false; },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n\t        try { this.textarea.focus(); }\n\t        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n\t      }\n\t    },\n\t\n\t    blur: function() { this.textarea.blur(); },\n\t\n\t    resetPosition: function() {\n\t      this.wrapper.style.top = this.wrapper.style.left = 0;\n\t    },\n\t\n\t    receivedFocus: function() { this.slowPoll(); },\n\t\n\t    // Poll for input changes, using the normal rate of polling. This\n\t    // runs as long as the editor is focused.\n\t    slowPoll: function() {\n\t      var input = this;\n\t      if (input.pollingFast) return;\n\t      input.polling.set(this.cm.options.pollInterval, function() {\n\t        input.poll();\n\t        if (input.cm.state.focused) input.slowPoll();\n\t      });\n\t    },\n\t\n\t    // When an event has just come in that is likely to add or change\n\t    // something in the input textarea, we poll faster, to ensure that\n\t    // the change appears on the screen quickly.\n\t    fastPoll: function() {\n\t      var missed = false, input = this;\n\t      input.pollingFast = true;\n\t      function p() {\n\t        var changed = input.poll();\n\t        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n\t        else {input.pollingFast = false; input.slowPoll();}\n\t      }\n\t      input.polling.set(20, p);\n\t    },\n\t\n\t    // Read input from the textarea, and update the document to match.\n\t    // When something is selected, it is present in the textarea, and\n\t    // selected (unless it is huge, in which case a placeholder is\n\t    // used). When nothing is selected, the cursor sits after previously\n\t    // seen text (can be empty), which is stored in prevInput (we must\n\t    // not reset the textarea when typing, because that breaks IME).\n\t    poll: function() {\n\t      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n\t      // Since this is called a *lot*, try to bail out as cheaply as\n\t      // possible when it is clear that nothing happened. hasSelection\n\t      // will be the case when there is a lot of text in the textarea,\n\t      // in which case reading its value would be expensive.\n\t      if (this.contextMenuPending || !cm.state.focused ||\n\t          (hasSelection(input) && !prevInput && !this.composing) ||\n\t          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n\t        return false;\n\t\n\t      var text = input.value;\n\t      // If nothing changed, bail.\n\t      if (text == prevInput && !cm.somethingSelected()) return false;\n\t      // Work around nonsensical selection resetting in IE9/10, and\n\t      // inexplicable appearance of private area unicode characters on\n\t      // some key combos in Mac (#2689).\n\t      if (ie && ie_version >= 9 && this.hasSelection === text ||\n\t          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n\t        cm.display.input.reset();\n\t        return false;\n\t      }\n\t\n\t      if (cm.doc.sel == cm.display.selForContextMenu) {\n\t        var first = text.charCodeAt(0);\n\t        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n\t        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n\t      }\n\t      // Find the part of the input that is actually new\n\t      var same = 0, l = Math.min(prevInput.length, text.length);\n\t      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\t\n\t      var self = this;\n\t      runInOp(cm, function() {\n\t        applyTextInput(cm, text.slice(same), prevInput.length - same,\n\t                       null, self.composing ? \"*compose\" : null);\n\t\n\t        // Don't leave long text in the textarea, since it makes further polling slow\n\t        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n\t        else self.prevInput = text;\n\t\n\t        if (self.composing) {\n\t          self.composing.range.clear();\n\t          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n\t                                             {className: \"CodeMirror-composing\"});\n\t        }\n\t      });\n\t      return true;\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      if (this.pollingFast && this.poll()) this.pollingFast = false;\n\t    },\n\t\n\t    onKeyPress: function() {\n\t      if (ie && ie_version >= 9) this.hasSelection = null;\n\t      this.fastPoll();\n\t    },\n\t\n\t    onContextMenu: function(e) {\n\t      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n\t      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n\t      if (!pos || presto) return; // Opera is difficult.\n\t\n\t      // Reset the current text selection only if the click is done outside of the selection\n\t      // and 'resetSelectionOnContextMenu' option is true.\n\t      var reset = cm.options.resetSelectionOnContextMenu;\n\t      if (reset && cm.doc.sel.contains(pos) == -1)\n\t        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\t\n\t      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n\t      input.wrapper.style.cssText = \"position: absolute\"\n\t      var wrapperBox = input.wrapper.getBoundingClientRect()\n\t      te.style.cssText = \"position: absolute; width: 30px; height: 30px; top: \" + (e.clientY - wrapperBox.top - 5) +\n\t        \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px; z-index: 1000; background: \" +\n\t        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n\t        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n\t      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n\t      display.input.focus();\n\t      if (webkit) window.scrollTo(null, oldScrollY);\n\t      display.input.reset();\n\t      // Adds \"Select all\" to context menu in FF\n\t      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n\t      input.contextMenuPending = true;\n\t      display.selForContextMenu = cm.doc.sel;\n\t      clearTimeout(display.detectingSelectAll);\n\t\n\t      // Select-all will be greyed out if there's nothing to select, so\n\t      // this adds a zero-width space so that we can later check whether\n\t      // it got selected.\n\t      function prepareSelectAllHack() {\n\t        if (te.selectionStart != null) {\n\t          var selected = cm.somethingSelected();\n\t          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n\t          te.value = \"\\u21da\"; // Used to catch context-menu undo\n\t          te.value = extval;\n\t          input.prevInput = selected ? \"\" : \"\\u200b\";\n\t          te.selectionStart = 1; te.selectionEnd = extval.length;\n\t          // Re-set this, in case some other handler touched the\n\t          // selection in the meantime.\n\t          display.selForContextMenu = cm.doc.sel;\n\t        }\n\t      }\n\t      function rehide() {\n\t        input.contextMenuPending = false;\n\t        input.wrapper.style.cssText = oldWrapperCSS\n\t        te.style.cssText = oldCSS;\n\t        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\t\n\t        // Try to detect the user choosing select-all\n\t        if (te.selectionStart != null) {\n\t          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n\t          var i = 0, poll = function() {\n\t            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n\t                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n\t              operation(cm, commands.selectAll)(cm);\n\t            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n\t            else display.input.reset();\n\t          };\n\t          display.detectingSelectAll = setTimeout(poll, 200);\n\t        }\n\t      }\n\t\n\t      if (ie && ie_version >= 9) prepareSelectAllHack();\n\t      if (captureRightClick) {\n\t        e_stop(e);\n\t        var mouseup = function() {\n\t          off(window, \"mouseup\", mouseup);\n\t          setTimeout(rehide, 20);\n\t        };\n\t        on(window, \"mouseup\", mouseup);\n\t      } else {\n\t        setTimeout(rehide, 50);\n\t      }\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      if (!val) this.reset();\n\t    },\n\t\n\t    setUneditable: nothing,\n\t\n\t    needsContentAttribute: false\n\t  }, TextareaInput.prototype);\n\t\n\t  // CONTENTEDITABLE INPUT STYLE\n\t\n\t  function ContentEditableInput(cm) {\n\t    this.cm = cm;\n\t    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n\t    this.polling = new Delayed();\n\t    this.gracePeriod = false;\n\t  }\n\t\n\t  ContentEditableInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = input.cm;\n\t      var div = input.div = display.lineDiv;\n\t      disableBrowserMagic(div);\n\t\n\t      on(div, \"paste\", function(e) {\n\t        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);\n\t      })\n\t\n\t      on(div, \"compositionstart\", function(e) {\n\t        var data = e.data;\n\t        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n\t        if (!data) return;\n\t        var prim = cm.doc.sel.primary();\n\t        var line = cm.getLine(prim.head.line);\n\t        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n\t        if (found > -1 && found <= prim.head.ch)\n\t          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n\t                                                Pos(prim.head.line, found + data.length));\n\t      });\n\t      on(div, \"compositionupdate\", function(e) {\n\t        input.composing.data = e.data;\n\t      });\n\t      on(div, \"compositionend\", function(e) {\n\t        var ours = input.composing;\n\t        if (!ours) return;\n\t        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n\t          ours.data = e.data;\n\t        // Need a small delay to prevent other code (input event,\n\t        // selection polling) from doing damage when fired right after\n\t        // compositionend.\n\t        setTimeout(function() {\n\t          if (!ours.handled)\n\t            input.applyComposition(ours);\n\t          if (input.composing == ours)\n\t            input.composing = null;\n\t        }, 50);\n\t      });\n\t\n\t      on(div, \"touchstart\", function() {\n\t        input.forceCompositionEnd();\n\t      });\n\t\n\t      on(div, \"input\", function() {\n\t        if (input.composing) return;\n\t        if (cm.isReadOnly() || !input.pollContent())\n\t          runInOp(input.cm, function() {regChange(cm);});\n\t      });\n\t\n\t      function onCopyCut(e) {\n\t        if (signalDOMEvent(cm, e)) return\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = {lineWise: false, text: cm.getSelections()};\n\t          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = {lineWise: true, text: ranges.text};\n\t          if (e.type == \"cut\") {\n\t            cm.operation(function() {\n\t              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n\t              cm.replaceSelection(\"\", null, \"cut\");\n\t            });\n\t          }\n\t        }\n\t        // iOS exposes the clipboard API, but seems to discard content inserted into it\n\t        if (e.clipboardData && !ios) {\n\t          e.preventDefault();\n\t          e.clipboardData.clearData();\n\t          e.clipboardData.setData(\"text/plain\", lastCopied.text.join(\"\\n\"));\n\t        } else {\n\t          // Old-fashioned briefly-focus-a-textarea hack\n\t          var kludge = hiddenTextarea(), te = kludge.firstChild;\n\t          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n\t          te.value = lastCopied.text.join(\"\\n\");\n\t          var hadFocus = document.activeElement;\n\t          selectInput(te);\n\t          setTimeout(function() {\n\t            cm.display.lineSpace.removeChild(kludge);\n\t            hadFocus.focus();\n\t          }, 50);\n\t        }\n\t      }\n\t      on(div, \"copy\", onCopyCut);\n\t      on(div, \"cut\", onCopyCut);\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      var result = prepareSelection(this.cm, false);\n\t      result.focus = this.cm.state.focused;\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(info, takeFocus) {\n\t      if (!info || !this.cm.display.view.length) return;\n\t      if (info.focus || takeFocus) this.showPrimarySelection();\n\t      this.showMultipleSelections(info);\n\t    },\n\t\n\t    showPrimarySelection: function() {\n\t      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n\t      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n\t      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n\t      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n\t          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n\t          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n\t        return;\n\t\n\t      var start = posToDOM(this.cm, prim.from());\n\t      var end = posToDOM(this.cm, prim.to());\n\t      if (!start && !end) return;\n\t\n\t      var view = this.cm.display.view;\n\t      var old = sel.rangeCount && sel.getRangeAt(0);\n\t      if (!start) {\n\t        start = {node: view[0].measure.map[2], offset: 0};\n\t      } else if (!end) { // FIXME dangerously hacky\n\t        var measure = view[view.length - 1].measure;\n\t        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n\t        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n\t      }\n\t\n\t      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n\t      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n\t      if (rng) {\n\t        if (!gecko && this.cm.state.focused) {\n\t          sel.collapse(start.node, start.offset);\n\t          if (!rng.collapsed) sel.addRange(rng);\n\t        } else {\n\t          sel.removeAllRanges();\n\t          sel.addRange(rng);\n\t        }\n\t        if (old && sel.anchorNode == null) sel.addRange(old);\n\t        else if (gecko) this.startGracePeriod();\n\t      }\n\t      this.rememberSelection();\n\t    },\n\t\n\t    startGracePeriod: function() {\n\t      var input = this;\n\t      clearTimeout(this.gracePeriod);\n\t      this.gracePeriod = setTimeout(function() {\n\t        input.gracePeriod = false;\n\t        if (input.selectionChanged())\n\t          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n\t      }, 20);\n\t    },\n\t\n\t    showMultipleSelections: function(info) {\n\t      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n\t      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n\t    },\n\t\n\t    rememberSelection: function() {\n\t      var sel = window.getSelection();\n\t      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n\t      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n\t    },\n\t\n\t    selectionInEditor: function() {\n\t      var sel = window.getSelection();\n\t      if (!sel.rangeCount) return false;\n\t      var node = sel.getRangeAt(0).commonAncestorContainer;\n\t      return contains(this.div, node);\n\t    },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n\t    },\n\t    blur: function() { this.div.blur(); },\n\t    getField: function() { return this.div; },\n\t\n\t    supportsTouch: function() { return true; },\n\t\n\t    receivedFocus: function() {\n\t      var input = this;\n\t      if (this.selectionInEditor())\n\t        this.pollSelection();\n\t      else\n\t        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\t\n\t      function poll() {\n\t        if (input.cm.state.focused) {\n\t          input.pollSelection();\n\t          input.polling.set(input.cm.options.pollInterval, poll);\n\t        }\n\t      }\n\t      this.polling.set(this.cm.options.pollInterval, poll);\n\t    },\n\t\n\t    selectionChanged: function() {\n\t      var sel = window.getSelection();\n\t      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n\t        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n\t    },\n\t\n\t    pollSelection: function() {\n\t      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n\t        var sel = window.getSelection(), cm = this.cm;\n\t        this.rememberSelection();\n\t        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n\t        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n\t        if (anchor && head) runInOp(cm, function() {\n\t          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n\t          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n\t        });\n\t      }\n\t    },\n\t\n\t    pollContent: function() {\n\t      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n\t      var from = sel.from(), to = sel.to();\n\t      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\t\n\t      var fromIndex;\n\t      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n\t        var fromLine = lineNo(display.view[0].line);\n\t        var fromNode = display.view[0].node;\n\t      } else {\n\t        var fromLine = lineNo(display.view[fromIndex].line);\n\t        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n\t      }\n\t      var toIndex = findViewIndex(cm, to.line);\n\t      if (toIndex == display.view.length - 1) {\n\t        var toLine = display.viewTo - 1;\n\t        var toNode = display.lineDiv.lastChild;\n\t      } else {\n\t        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n\t        var toNode = display.view[toIndex + 1].node.previousSibling;\n\t      }\n\t\n\t      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n\t      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n\t      while (newText.length > 1 && oldText.length > 1) {\n\t        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n\t        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n\t        else break;\n\t      }\n\t\n\t      var cutFront = 0, cutEnd = 0;\n\t      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n\t      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n\t        ++cutFront;\n\t      var newBot = lst(newText), oldBot = lst(oldText);\n\t      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n\t                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n\t      while (cutEnd < maxCutEnd &&\n\t             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n\t        ++cutEnd;\n\t\n\t      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n\t      newText[0] = newText[0].slice(cutFront);\n\t\n\t      var chFrom = Pos(fromLine, cutFront);\n\t      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n\t      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n\t        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n\t        return true;\n\t      }\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    reset: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    forceCompositionEnd: function() {\n\t      if (!this.composing || this.composing.handled) return;\n\t      this.applyComposition(this.composing);\n\t      this.composing.handled = true;\n\t      this.div.blur();\n\t      this.div.focus();\n\t    },\n\t    applyComposition: function(composing) {\n\t      if (this.cm.isReadOnly())\n\t        operation(this.cm, regChange)(this.cm)\n\t      else if (composing.data && composing.data != composing.startData)\n\t        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n\t    },\n\t\n\t    setUneditable: function(node) {\n\t      node.contentEditable = \"false\"\n\t    },\n\t\n\t    onKeyPress: function(e) {\n\t      e.preventDefault();\n\t      if (!this.cm.isReadOnly())\n\t        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      this.div.contentEditable = String(val != \"nocursor\")\n\t    },\n\t\n\t    onContextMenu: nothing,\n\t    resetPosition: nothing,\n\t\n\t    needsContentAttribute: true\n\t  }, ContentEditableInput.prototype);\n\t\n\t  function posToDOM(cm, pos) {\n\t    var view = findViewForLine(cm, pos.line);\n\t    if (!view || view.hidden) return null;\n\t    var line = getLine(cm.doc, pos.line);\n\t    var info = mapFromLineView(view, line, pos.line);\n\t\n\t    var order = getOrder(line), side = \"left\";\n\t    if (order) {\n\t      var partPos = getBidiPartAt(order, pos.ch);\n\t      side = partPos % 2 ? \"right\" : \"left\";\n\t    }\n\t    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n\t    result.offset = result.collapse == \"right\" ? result.end : result.start;\n\t    return result;\n\t  }\n\t\n\t  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\t\n\t  function domToPos(cm, node, offset) {\n\t    var lineNode;\n\t    if (node == cm.display.lineDiv) {\n\t      lineNode = cm.display.lineDiv.childNodes[offset];\n\t      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n\t      node = null; offset = 0;\n\t    } else {\n\t      for (lineNode = node;; lineNode = lineNode.parentNode) {\n\t        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n\t        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n\t      }\n\t    }\n\t    for (var i = 0; i < cm.display.view.length; i++) {\n\t      var lineView = cm.display.view[i];\n\t      if (lineView.node == lineNode)\n\t        return locateNodeInLineView(lineView, node, offset);\n\t    }\n\t  }\n\t\n\t  function locateNodeInLineView(lineView, node, offset) {\n\t    var wrapper = lineView.text.firstChild, bad = false;\n\t    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n\t    if (node == wrapper) {\n\t      bad = true;\n\t      node = wrapper.childNodes[offset];\n\t      offset = 0;\n\t      if (!node) {\n\t        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n\t        return badPos(Pos(lineNo(line), line.text.length), bad);\n\t      }\n\t    }\n\t\n\t    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n\t    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n\t      textNode = node.firstChild;\n\t      if (offset) offset = textNode.nodeValue.length;\n\t    }\n\t    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n\t    var measure = lineView.measure, maps = measure.maps;\n\t\n\t    function find(textNode, topNode, offset) {\n\t      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n\t        var map = i < 0 ? measure.map : maps[i];\n\t        for (var j = 0; j < map.length; j += 3) {\n\t          var curNode = map[j + 2];\n\t          if (curNode == textNode || curNode == topNode) {\n\t            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n\t            var ch = map[j] + offset;\n\t            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n\t            return Pos(line, ch);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    var found = find(textNode, topNode, offset);\n\t    if (found) return badPos(found, bad);\n\t\n\t    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n\t    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n\t      found = find(after, after.firstChild, 0);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch - dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n\t      found = find(before, before.firstChild, -1);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch + dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t  }\n\t\n\t  function domTextBetween(cm, from, to, fromLine, toLine) {\n\t    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n\t    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n\t    function walk(node) {\n\t      if (node.nodeType == 1) {\n\t        var cmText = node.getAttribute(\"cm-text\");\n\t        if (cmText != null) {\n\t          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n\t          text += cmText;\n\t          return;\n\t        }\n\t        var markerID = node.getAttribute(\"cm-marker\"), range;\n\t        if (markerID) {\n\t          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n\t          if (found.length && (range = found[0].find()))\n\t            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n\t          return;\n\t        }\n\t        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n\t        for (var i = 0; i < node.childNodes.length; i++)\n\t          walk(node.childNodes[i]);\n\t        if (/^(pre|div|p)$/i.test(node.nodeName))\n\t          closing = true;\n\t      } else if (node.nodeType == 3) {\n\t        var val = node.nodeValue;\n\t        if (!val) return;\n\t        if (closing) {\n\t          text += lineSep;\n\t          closing = false;\n\t        }\n\t        text += val;\n\t      }\n\t    }\n\t    for (;;) {\n\t      walk(from);\n\t      if (from == to) break;\n\t      from = from.nextSibling;\n\t    }\n\t    return text;\n\t  }\n\t\n\t  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\t\n\t  // SELECTION / CURSOR\n\t\n\t  // Selection objects are immutable. A new one is created every time\n\t  // the selection changes. A selection is one or more non-overlapping\n\t  // (and non-touching) ranges, sorted, and an integer that indicates\n\t  // which one is the primary selection (the one that's scrolled into\n\t  // view, that getCursor returns, etc).\n\t  function Selection(ranges, primIndex) {\n\t    this.ranges = ranges;\n\t    this.primIndex = primIndex;\n\t  }\n\t\n\t  Selection.prototype = {\n\t    primary: function() { return this.ranges[this.primIndex]; },\n\t    equals: function(other) {\n\t      if (other == this) return true;\n\t      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var here = this.ranges[i], there = other.ranges[i];\n\t        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n\t      }\n\t      return true;\n\t    },\n\t    deepCopy: function() {\n\t      for (var out = [], i = 0; i < this.ranges.length; i++)\n\t        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n\t      return new Selection(out, this.primIndex);\n\t    },\n\t    somethingSelected: function() {\n\t      for (var i = 0; i < this.ranges.length; i++)\n\t        if (!this.ranges[i].empty()) return true;\n\t      return false;\n\t    },\n\t    contains: function(pos, end) {\n\t      if (!end) end = pos;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var range = this.ranges[i];\n\t        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n\t          return i;\n\t      }\n\t      return -1;\n\t    }\n\t  };\n\t\n\t  function Range(anchor, head) {\n\t    this.anchor = anchor; this.head = head;\n\t  }\n\t\n\t  Range.prototype = {\n\t    from: function() { return minPos(this.anchor, this.head); },\n\t    to: function() { return maxPos(this.anchor, this.head); },\n\t    empty: function() {\n\t      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n\t    }\n\t  };\n\t\n\t  // Take an unsorted, potentially overlapping set of ranges, and\n\t  // build a selection out of it. 'Consumes' ranges array (modifying\n\t  // it).\n\t  function normalizeSelection(ranges, primIndex) {\n\t    var prim = ranges[primIndex];\n\t    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n\t    primIndex = indexOf(ranges, prim);\n\t    for (var i = 1; i < ranges.length; i++) {\n\t      var cur = ranges[i], prev = ranges[i - 1];\n\t      if (cmp(prev.to(), cur.from()) >= 0) {\n\t        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n\t        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n\t        if (i <= primIndex) --primIndex;\n\t        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n\t      }\n\t    }\n\t    return new Selection(ranges, primIndex);\n\t  }\n\t\n\t  function simpleSelection(anchor, head) {\n\t    return new Selection([new Range(anchor, head || anchor)], 0);\n\t  }\n\t\n\t  // Most of the external API clips given positions to make sure they\n\t  // actually exist within the document.\n\t  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n\t  function clipPos(doc, pos) {\n\t    if (pos.line < doc.first) return Pos(doc.first, 0);\n\t    var last = doc.first + doc.size - 1;\n\t    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n\t    return clipToLen(pos, getLine(doc, pos.line).text.length);\n\t  }\n\t  function clipToLen(pos, linelen) {\n\t    var ch = pos.ch;\n\t    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n\t    else if (ch < 0) return Pos(pos.line, 0);\n\t    else return pos;\n\t  }\n\t  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\t  function clipPosArray(doc, array) {\n\t    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n\t    return out;\n\t  }\n\t\n\t  // SELECTION UPDATES\n\t\n\t  // The 'scroll' parameter given to many of these indicated whether\n\t  // the new cursor position should be scrolled into view after\n\t  // modifying the selection.\n\t\n\t  // If shift is held or the extend flag is set, extends a range to\n\t  // include a given position (and optionally a second position).\n\t  // Otherwise, simply returns the range between the given positions.\n\t  // Used for cursor motion and such.\n\t  function extendRange(doc, range, head, other) {\n\t    if (doc.cm && doc.cm.display.shift || doc.extend) {\n\t      var anchor = range.anchor;\n\t      if (other) {\n\t        var posBefore = cmp(head, anchor) < 0;\n\t        if (posBefore != (cmp(other, anchor) < 0)) {\n\t          anchor = head;\n\t          head = other;\n\t        } else if (posBefore != (cmp(head, other) < 0)) {\n\t          head = other;\n\t        }\n\t      }\n\t      return new Range(anchor, head);\n\t    } else {\n\t      return new Range(other || head, head);\n\t    }\n\t  }\n\t\n\t  // Extend the primary selection range, discard the rest.\n\t  function extendSelection(doc, head, other, options) {\n\t    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n\t  }\n\t\n\t  // Extend all selections (pos is an array of selections with length\n\t  // equal the number of selections)\n\t  function extendSelections(doc, heads, options) {\n\t    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n\t      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n\t    var newSel = normalizeSelection(out, doc.sel.primIndex);\n\t    setSelection(doc, newSel, options);\n\t  }\n\t\n\t  // Updates a single range in the selection.\n\t  function replaceOneSelection(doc, i, range, options) {\n\t    var ranges = doc.sel.ranges.slice(0);\n\t    ranges[i] = range;\n\t    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n\t  }\n\t\n\t  // Reset the selection to a single range.\n\t  function setSimpleSelection(doc, anchor, head, options) {\n\t    setSelection(doc, simpleSelection(anchor, head), options);\n\t  }\n\t\n\t  // Give beforeSelectionChange handlers a change to influence a\n\t  // selection update.\n\t  function filterSelectionChange(doc, sel, options) {\n\t    var obj = {\n\t      ranges: sel.ranges,\n\t      update: function(ranges) {\n\t        this.ranges = [];\n\t        for (var i = 0; i < ranges.length; i++)\n\t          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n\t                                     clipPos(doc, ranges[i].head));\n\t      },\n\t      origin: options && options.origin\n\t    };\n\t    signal(doc, \"beforeSelectionChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n\t    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n\t    else return sel;\n\t  }\n\t\n\t  function setSelectionReplaceHistory(doc, sel, options) {\n\t    var done = doc.history.done, last = lst(done);\n\t    if (last && last.ranges) {\n\t      done[done.length - 1] = sel;\n\t      setSelectionNoUndo(doc, sel, options);\n\t    } else {\n\t      setSelection(doc, sel, options);\n\t    }\n\t  }\n\t\n\t  // Set a new selection.\n\t  function setSelection(doc, sel, options) {\n\t    setSelectionNoUndo(doc, sel, options);\n\t    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n\t  }\n\t\n\t  function setSelectionNoUndo(doc, sel, options) {\n\t    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n\t      sel = filterSelectionChange(doc, sel, options);\n\t\n\t    var bias = options && options.bias ||\n\t      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\t\n\t    if (!(options && options.scroll === false) && doc.cm)\n\t      ensureCursorVisible(doc.cm);\n\t  }\n\t\n\t  function setSelectionInner(doc, sel) {\n\t    if (sel.equals(doc.sel)) return;\n\t\n\t    doc.sel = sel;\n\t\n\t    if (doc.cm) {\n\t      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n\t      signalCursorActivity(doc.cm);\n\t    }\n\t    signalLater(doc, \"cursorActivity\", doc);\n\t  }\n\t\n\t  // Verify that the selection does not partially select any atomic\n\t  // marked ranges.\n\t  function reCheckSelection(doc) {\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n\t  }\n\t\n\t  // Return a selection that does not partially select any atomic\n\t  // ranges.\n\t  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n\t    var out;\n\t    for (var i = 0; i < sel.ranges.length; i++) {\n\t      var range = sel.ranges[i];\n\t      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n\t      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n\t      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n\t      if (out || newAnchor != range.anchor || newHead != range.head) {\n\t        if (!out) out = sel.ranges.slice(0, i);\n\t        out[i] = new Range(newAnchor, newHead);\n\t      }\n\t    }\n\t    return out ? normalizeSelection(out, sel.primIndex) : sel;\n\t  }\n\t\n\t  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n\t    var line = getLine(doc, pos.line);\n\t    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t      var sp = line.markedSpans[i], m = sp.marker;\n\t      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n\t          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n\t        if (mayClear) {\n\t          signal(m, \"beforeCursorEnter\");\n\t          if (m.explicitlyCleared) {\n\t            if (!line.markedSpans) break;\n\t            else {--i; continue;}\n\t          }\n\t        }\n\t        if (!m.atomic) continue;\n\t\n\t        if (oldPos) {\n\t          var near = m.find(dir < 0 ? 1 : -1), diff;\n\t          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n\t            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n\t          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n\t            return skipAtomicInner(doc, near, pos, dir, mayClear);\n\t        }\n\t\n\t        var far = m.find(dir < 0 ? -1 : 1);\n\t        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n\t          far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n\t        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n\t      }\n\t    }\n\t    return pos;\n\t  }\n\t\n\t  // Ensure a given position is not inside an atomic range.\n\t  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n\t    var dir = bias || 1;\n\t    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n\t        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n\t        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n\t        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n\t    if (!found) {\n\t      doc.cantEdit = true;\n\t      return Pos(doc.first, 0);\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function movePos(doc, pos, dir, line) {\n\t    if (dir < 0 && pos.ch == 0) {\n\t      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));\n\t      else return null;\n\t    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n\t      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);\n\t      else return null;\n\t    } else {\n\t      return new Pos(pos.line, pos.ch + dir);\n\t    }\n\t  }\n\t\n\t  // SELECTION DRAWING\n\t\n\t  function updateSelection(cm) {\n\t    cm.display.input.showSelection(cm.display.input.prepareSelection());\n\t  }\n\t\n\t  function prepareSelection(cm, primary) {\n\t    var doc = cm.doc, result = {};\n\t    var curFragment = result.cursors = document.createDocumentFragment();\n\t    var selFragment = result.selection = document.createDocumentFragment();\n\t\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      if (primary === false && i == doc.sel.primIndex) continue;\n\t      var range = doc.sel.ranges[i];\n\t      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;\n\t      var collapsed = range.empty();\n\t      if (collapsed || cm.options.showCursorWhenSelecting)\n\t        drawSelectionCursor(cm, range.head, curFragment);\n\t      if (!collapsed)\n\t        drawSelectionRange(cm, range, selFragment);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  // Draws a cursor for the given range\n\t  function drawSelectionCursor(cm, head, output) {\n\t    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\t\n\t    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n\t    cursor.style.left = pos.left + \"px\";\n\t    cursor.style.top = pos.top + \"px\";\n\t    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\t\n\t    if (pos.other) {\n\t      // Secondary cursor, shown when on a 'jump' in bi-directional text\n\t      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n\t      otherCursor.style.display = \"\";\n\t      otherCursor.style.left = pos.other.left + \"px\";\n\t      otherCursor.style.top = pos.other.top + \"px\";\n\t      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n\t    }\n\t  }\n\t\n\t  // Draws the given range as a highlighted selection\n\t  function drawSelectionRange(cm, range, output) {\n\t    var display = cm.display, doc = cm.doc;\n\t    var fragment = document.createDocumentFragment();\n\t    var padding = paddingH(cm.display), leftSide = padding.left;\n\t    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\t\n\t    function add(left, top, width, bottom) {\n\t      if (top < 0) top = 0;\n\t      top = Math.round(top);\n\t      bottom = Math.round(bottom);\n\t      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n\t                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n\t                               \"px; height: \" + (bottom - top) + \"px\"));\n\t    }\n\t\n\t    function drawForLine(line, fromArg, toArg) {\n\t      var lineObj = getLine(doc, line);\n\t      var lineLen = lineObj.text.length;\n\t      var start, end;\n\t      function coords(ch, bias) {\n\t        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n\t      }\n\t\n\t      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n\t        var leftPos = coords(from, \"left\"), rightPos, left, right;\n\t        if (from == to) {\n\t          rightPos = leftPos;\n\t          left = right = leftPos.left;\n\t        } else {\n\t          rightPos = coords(to - 1, \"right\");\n\t          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n\t          left = leftPos.left;\n\t          right = rightPos.right;\n\t        }\n\t        if (fromArg == null && from == 0) left = leftSide;\n\t        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n\t          add(left, leftPos.top, null, leftPos.bottom);\n\t          left = leftSide;\n\t          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n\t        }\n\t        if (toArg == null && to == lineLen) right = rightSide;\n\t        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n\t          start = leftPos;\n\t        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n\t          end = rightPos;\n\t        if (left < leftSide + 1) left = leftSide;\n\t        add(left, rightPos.top, right - left, rightPos.bottom);\n\t      });\n\t      return {start: start, end: end};\n\t    }\n\t\n\t    var sFrom = range.from(), sTo = range.to();\n\t    if (sFrom.line == sTo.line) {\n\t      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n\t    } else {\n\t      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n\t      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n\t      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n\t      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n\t      if (singleVLine) {\n\t        if (leftEnd.top < rightStart.top - 2) {\n\t          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n\t          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n\t        } else {\n\t          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n\t        }\n\t      }\n\t      if (leftEnd.bottom < rightStart.top)\n\t        add(leftSide, leftEnd.bottom, null, rightStart.top);\n\t    }\n\t\n\t    output.appendChild(fragment);\n\t  }\n\t\n\t  // Cursor-blinking\n\t  function restartBlink(cm) {\n\t    if (!cm.state.focused) return;\n\t    var display = cm.display;\n\t    clearInterval(display.blinker);\n\t    var on = true;\n\t    display.cursorDiv.style.visibility = \"\";\n\t    if (cm.options.cursorBlinkRate > 0)\n\t      display.blinker = setInterval(function() {\n\t        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n\t      }, cm.options.cursorBlinkRate);\n\t    else if (cm.options.cursorBlinkRate < 0)\n\t      display.cursorDiv.style.visibility = \"hidden\";\n\t  }\n\t\n\t  // HIGHLIGHT WORKER\n\t\n\t  function startWorker(cm, time) {\n\t    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n\t      cm.state.highlight.set(time, bind(highlightWorker, cm));\n\t  }\n\t\n\t  function highlightWorker(cm) {\n\t    var doc = cm.doc;\n\t    if (doc.frontier < doc.first) doc.frontier = doc.first;\n\t    if (doc.frontier >= cm.display.viewTo) return;\n\t    var end = +new Date + cm.options.workTime;\n\t    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n\t    var changedLines = [];\n\t\n\t    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n\t      if (doc.frontier >= cm.display.viewFrom) { // Visible\n\t        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n\t        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n\t        line.styles = highlighted.styles;\n\t        var oldCls = line.styleClasses, newCls = highlighted.classes;\n\t        if (newCls) line.styleClasses = newCls;\n\t        else if (oldCls) line.styleClasses = null;\n\t        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n\t          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n\t        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n\t        if (ischange) changedLines.push(doc.frontier);\n\t        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n\t      } else {\n\t        if (line.text.length <= cm.options.maxHighlightLength)\n\t          processLine(cm, line.text, state);\n\t        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n\t      }\n\t      ++doc.frontier;\n\t      if (+new Date > end) {\n\t        startWorker(cm, cm.options.workDelay);\n\t        return true;\n\t      }\n\t    });\n\t    if (changedLines.length) runInOp(cm, function() {\n\t      for (var i = 0; i < changedLines.length; i++)\n\t        regLineChange(cm, changedLines[i], \"text\");\n\t    });\n\t  }\n\t\n\t  // Finds the line to start with when starting a parse. Tries to\n\t  // find a line with a stateAfter, so that it can start with a\n\t  // valid state. If that fails, it returns the line with the\n\t  // smallest indentation, which tends to need the least context to\n\t  // parse correctly.\n\t  function findStartLine(cm, n, precise) {\n\t    var minindent, minline, doc = cm.doc;\n\t    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\t    for (var search = n; search > lim; --search) {\n\t      if (search <= doc.first) return doc.first;\n\t      var line = getLine(doc, search - 1);\n\t      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n\t      var indented = countColumn(line.text, null, cm.options.tabSize);\n\t      if (minline == null || minindent > indented) {\n\t        minline = search - 1;\n\t        minindent = indented;\n\t      }\n\t    }\n\t    return minline;\n\t  }\n\t\n\t  function getStateBefore(cm, n, precise) {\n\t    var doc = cm.doc, display = cm.display;\n\t    if (!doc.mode.startState) return true;\n\t    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n\t    if (!state) state = startState(doc.mode);\n\t    else state = copyState(doc.mode, state);\n\t    doc.iter(pos, n, function(line) {\n\t      processLine(cm, line.text, state);\n\t      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n\t      line.stateAfter = save ? copyState(doc.mode, state) : null;\n\t      ++pos;\n\t    });\n\t    if (precise) doc.frontier = pos;\n\t    return state;\n\t  }\n\t\n\t  // POSITION MEASUREMENT\n\t\n\t  function paddingTop(display) {return display.lineSpace.offsetTop;}\n\t  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n\t  function paddingH(display) {\n\t    if (display.cachedPaddingH) return display.cachedPaddingH;\n\t    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n\t    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n\t    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n\t    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n\t    return data;\n\t  }\n\t\n\t  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n\t  function displayWidth(cm) {\n\t    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n\t  }\n\t  function displayHeight(cm) {\n\t    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n\t  }\n\t\n\t  // Ensure the lineView.wrapping.heights array is populated. This is\n\t  // an array of bottom offsets for the lines that make up a drawn\n\t  // line. When lineWrapping is on, there might be more than one\n\t  // height.\n\t  function ensureLineHeights(cm, lineView, rect) {\n\t    var wrapping = cm.options.lineWrapping;\n\t    var curWidth = wrapping && displayWidth(cm);\n\t    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n\t      var heights = lineView.measure.heights = [];\n\t      if (wrapping) {\n\t        lineView.measure.width = curWidth;\n\t        var rects = lineView.text.firstChild.getClientRects();\n\t        for (var i = 0; i < rects.length - 1; i++) {\n\t          var cur = rects[i], next = rects[i + 1];\n\t          if (Math.abs(cur.bottom - next.bottom) > 2)\n\t            heights.push((cur.bottom + next.top) / 2 - rect.top);\n\t        }\n\t      }\n\t      heights.push(rect.bottom - rect.top);\n\t    }\n\t  }\n\t\n\t  // Find a line map (mapping character offsets to text nodes) and a\n\t  // measurement cache for the given line number. (A line view might\n\t  // contain multiple lines when collapsed ranges are present.)\n\t  function mapFromLineView(lineView, line, lineN) {\n\t    if (lineView.line == line)\n\t      return {map: lineView.measure.map, cache: lineView.measure.cache};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineView.rest[i] == line)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineNo(lineView.rest[i]) > lineN)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n\t  }\n\t\n\t  // Render a line into the hidden node display.externalMeasured. Used\n\t  // when measurement is needed for a line that's not in the viewport.\n\t  function updateExternalMeasurement(cm, line) {\n\t    line = visualLine(line);\n\t    var lineN = lineNo(line);\n\t    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n\t    view.lineN = lineN;\n\t    var built = view.built = buildLineContent(cm, view);\n\t    view.text = built.pre;\n\t    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n\t    return view;\n\t  }\n\t\n\t  // Get a {top, bottom, left, right} box (in line-local coordinates)\n\t  // for a given character.\n\t  function measureChar(cm, line, ch, bias) {\n\t    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n\t  }\n\t\n\t  // Find a line view that corresponds to the given line number.\n\t  function findViewForLine(cm, lineN) {\n\t    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n\t      return cm.display.view[findViewIndex(cm, lineN)];\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n\t      return ext;\n\t  }\n\t\n\t  // Measurement can be split in two steps, the set-up work that\n\t  // applies to the whole line, and the measurement of the actual\n\t  // character. Functions like coordsChar, that need to do a lot of\n\t  // measurements in a row, can thus ensure that the set-up work is\n\t  // only done once.\n\t  function prepareMeasureForLine(cm, line) {\n\t    var lineN = lineNo(line);\n\t    var view = findViewForLine(cm, lineN);\n\t    if (view && !view.text) {\n\t      view = null;\n\t    } else if (view && view.changes) {\n\t      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n\t      cm.curOp.forceUpdate = true;\n\t    }\n\t    if (!view)\n\t      view = updateExternalMeasurement(cm, line);\n\t\n\t    var info = mapFromLineView(view, line, lineN);\n\t    return {\n\t      line: line, view: view, rect: null,\n\t      map: info.map, cache: info.cache, before: info.before,\n\t      hasHeights: false\n\t    };\n\t  }\n\t\n\t  // Given a prepared measurement object, measures the position of an\n\t  // actual character (or fetches it from the cache).\n\t  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n\t    if (prepared.before) ch = -1;\n\t    var key = ch + (bias || \"\"), found;\n\t    if (prepared.cache.hasOwnProperty(key)) {\n\t      found = prepared.cache[key];\n\t    } else {\n\t      if (!prepared.rect)\n\t        prepared.rect = prepared.view.text.getBoundingClientRect();\n\t      if (!prepared.hasHeights) {\n\t        ensureLineHeights(cm, prepared.view, prepared.rect);\n\t        prepared.hasHeights = true;\n\t      }\n\t      found = measureCharInner(cm, prepared, ch, bias);\n\t      if (!found.bogus) prepared.cache[key] = found;\n\t    }\n\t    return {left: found.left, right: found.right,\n\t            top: varHeight ? found.rtop : found.top,\n\t            bottom: varHeight ? found.rbottom : found.bottom};\n\t  }\n\t\n\t  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\t\n\t  function nodeAndOffsetInLineMap(map, ch, bias) {\n\t    var node, start, end, collapse;\n\t    // First, search the line map for the text node corresponding to,\n\t    // or closest to, the target character.\n\t    for (var i = 0; i < map.length; i += 3) {\n\t      var mStart = map[i], mEnd = map[i + 1];\n\t      if (ch < mStart) {\n\t        start = 0; end = 1;\n\t        collapse = \"left\";\n\t      } else if (ch < mEnd) {\n\t        start = ch - mStart;\n\t        end = start + 1;\n\t      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n\t        end = mEnd - mStart;\n\t        start = end - 1;\n\t        if (ch >= mEnd) collapse = \"right\";\n\t      }\n\t      if (start != null) {\n\t        node = map[i + 2];\n\t        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n\t          collapse = bias;\n\t        if (bias == \"left\" && start == 0)\n\t          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n\t            node = map[(i -= 3) + 2];\n\t            collapse = \"left\";\n\t          }\n\t        if (bias == \"right\" && start == mEnd - mStart)\n\t          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n\t            node = map[(i += 3) + 2];\n\t            collapse = \"right\";\n\t          }\n\t        break;\n\t      }\n\t    }\n\t    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n\t  }\n\t\n\t  function getUsefulRect(rects, bias) {\n\t    var rect = nullRect\n\t    if (bias == \"left\") for (var i = 0; i < rects.length; i++) {\n\t      if ((rect = rects[i]).left != rect.right) break\n\t    } else for (var i = rects.length - 1; i >= 0; i--) {\n\t      if ((rect = rects[i]).left != rect.right) break\n\t    }\n\t    return rect\n\t  }\n\t\n\t  function measureCharInner(cm, prepared, ch, bias) {\n\t    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n\t    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\t\n\t    var rect;\n\t    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n\t      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n\t        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n\t        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n\t        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n\t          rect = node.parentNode.getBoundingClientRect();\n\t        else\n\t          rect = getUsefulRect(range(node, start, end).getClientRects(), bias)\n\t        if (rect.left || rect.right || start == 0) break;\n\t        end = start;\n\t        start = start - 1;\n\t        collapse = \"right\";\n\t      }\n\t      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n\t    } else { // If it is a widget, simply get the box for the whole widget.\n\t      if (start > 0) collapse = bias = \"right\";\n\t      var rects;\n\t      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n\t        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t      else\n\t        rect = node.getBoundingClientRect();\n\t    }\n\t    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n\t      var rSpan = node.parentNode.getClientRects()[0];\n\t      if (rSpan)\n\t        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n\t      else\n\t        rect = nullRect;\n\t    }\n\t\n\t    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n\t    var mid = (rtop + rbot) / 2;\n\t    var heights = prepared.view.measure.heights;\n\t    for (var i = 0; i < heights.length - 1; i++)\n\t      if (mid < heights[i]) break;\n\t    var top = i ? heights[i - 1] : 0, bot = heights[i];\n\t    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n\t                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n\t                  top: top, bottom: bot};\n\t    if (!rect.left && !rect.right) result.bogus = true;\n\t    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\t\n\t    return result;\n\t  }\n\t\n\t  // Work around problem with bounding client rects on ranges being\n\t  // returned incorrectly when zoomed on IE10 and below.\n\t  function maybeUpdateRectForZooming(measure, rect) {\n\t    if (!window.screen || screen.logicalXDPI == null ||\n\t        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n\t      return rect;\n\t    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n\t    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n\t    return {left: rect.left * scaleX, right: rect.right * scaleX,\n\t            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n\t  }\n\t\n\t  function clearLineMeasurementCacheFor(lineView) {\n\t    if (lineView.measure) {\n\t      lineView.measure.cache = {};\n\t      lineView.measure.heights = null;\n\t      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t        lineView.measure.caches[i] = {};\n\t    }\n\t  }\n\t\n\t  function clearLineMeasurementCache(cm) {\n\t    cm.display.externalMeasure = null;\n\t    removeChildren(cm.display.lineMeasure);\n\t    for (var i = 0; i < cm.display.view.length; i++)\n\t      clearLineMeasurementCacheFor(cm.display.view[i]);\n\t  }\n\t\n\t  function clearCaches(cm) {\n\t    clearLineMeasurementCache(cm);\n\t    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\t    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n\t    cm.display.lineNumChars = null;\n\t  }\n\t\n\t  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n\t  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\t\n\t  // Converts a {top, bottom, left, right} box from line-local\n\t  // coordinates into another coordinate system. Context may be one of\n\t  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n\t  // or \"page\".\n\t  function intoCoordSystem(cm, lineObj, rect, context) {\n\t    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n\t      var size = widgetHeight(lineObj.widgets[i]);\n\t      rect.top += size; rect.bottom += size;\n\t    }\n\t    if (context == \"line\") return rect;\n\t    if (!context) context = \"local\";\n\t    var yOff = heightAtLine(lineObj);\n\t    if (context == \"local\") yOff += paddingTop(cm.display);\n\t    else yOff -= cm.display.viewOffset;\n\t    if (context == \"page\" || context == \"window\") {\n\t      var lOff = cm.display.lineSpace.getBoundingClientRect();\n\t      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n\t      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n\t      rect.left += xOff; rect.right += xOff;\n\t    }\n\t    rect.top += yOff; rect.bottom += yOff;\n\t    return rect;\n\t  }\n\t\n\t  // Coverts a box from \"div\" coords to another coordinate system.\n\t  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n\t  function fromCoordSystem(cm, coords, context) {\n\t    if (context == \"div\") return coords;\n\t    var left = coords.left, top = coords.top;\n\t    // First move into \"page\" coordinate system\n\t    if (context == \"page\") {\n\t      left -= pageScrollX();\n\t      top -= pageScrollY();\n\t    } else if (context == \"local\" || !context) {\n\t      var localBox = cm.display.sizer.getBoundingClientRect();\n\t      left += localBox.left;\n\t      top += localBox.top;\n\t    }\n\t\n\t    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n\t    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n\t  }\n\t\n\t  function charCoords(cm, pos, context, lineObj, bias) {\n\t    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n\t    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n\t  }\n\t\n\t  // Returns a box for a given cursor position, which may have an\n\t  // 'other' property containing the position of the secondary cursor\n\t  // on a bidi boundary.\n\t  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n\t    lineObj = lineObj || getLine(cm.doc, pos.line);\n\t    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t    function get(ch, right) {\n\t      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n\t      if (right) m.left = m.right; else m.right = m.left;\n\t      return intoCoordSystem(cm, lineObj, m, context);\n\t    }\n\t    function getBidi(ch, partPos) {\n\t      var part = order[partPos], right = part.level % 2;\n\t      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n\t        part = order[--partPos];\n\t        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n\t        right = true;\n\t      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n\t        part = order[++partPos];\n\t        ch = bidiLeft(part) - part.level % 2;\n\t        right = false;\n\t      }\n\t      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n\t      return get(ch, right);\n\t    }\n\t    var order = getOrder(lineObj), ch = pos.ch;\n\t    if (!order) return get(ch);\n\t    var partPos = getBidiPartAt(order, ch);\n\t    var val = getBidi(ch, partPos);\n\t    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n\t    return val;\n\t  }\n\t\n\t  // Used to cheaply estimate the coordinates for a position. Used for\n\t  // intermediate scroll updates.\n\t  function estimateCoords(cm, pos) {\n\t    var left = 0, pos = clipPos(cm.doc, pos);\n\t    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n\t    var lineObj = getLine(cm.doc, pos.line);\n\t    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n\t    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n\t  }\n\t\n\t  // Positions returned by coordsChar contain some extra information.\n\t  // xRel is the relative x position of the input coordinates compared\n\t  // to the found position (so xRel > 0 means the coordinates are to\n\t  // the right of the character position, for example). When outside\n\t  // is true, that means the coordinates lie outside the line's\n\t  // vertical range.\n\t  function PosWithInfo(line, ch, outside, xRel) {\n\t    var pos = Pos(line, ch);\n\t    pos.xRel = xRel;\n\t    if (outside) pos.outside = true;\n\t    return pos;\n\t  }\n\t\n\t  // Compute the character position closest to the given coordinates.\n\t  // Input must be lineSpace-local (\"div\" coordinate system).\n\t  function coordsChar(cm, x, y) {\n\t    var doc = cm.doc;\n\t    y += cm.display.viewOffset;\n\t    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n\t    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n\t    if (lineN > last)\n\t      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n\t    if (x < 0) x = 0;\n\t\n\t    var lineObj = getLine(doc, lineN);\n\t    for (;;) {\n\t      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n\t      var merged = collapsedSpanAtEnd(lineObj);\n\t      var mergedPos = merged && merged.find(0, true);\n\t      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n\t        lineN = lineNo(lineObj = mergedPos.to.line);\n\t      else\n\t        return found;\n\t    }\n\t  }\n\t\n\t  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n\t    var innerOff = y - heightAtLine(lineObj);\n\t    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n\t    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t\n\t    function getX(ch) {\n\t      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n\t      wrongLine = true;\n\t      if (innerOff > sp.bottom) return sp.left - adjust;\n\t      else if (innerOff < sp.top) return sp.left + adjust;\n\t      else wrongLine = false;\n\t      return sp.left;\n\t    }\n\t\n\t    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n\t    var from = lineLeft(lineObj), to = lineRight(lineObj);\n\t    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\t\n\t    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n\t    // Do a binary search between these bounds.\n\t    for (;;) {\n\t      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n\t        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n\t        var outside = ch == from ? fromOutside : toOutside\n\t        var xDiff = x - (ch == from ? fromX : toX);\n\t        // This is a kludge to handle the case where the coordinates\n\t        // are after a line-wrapped line. We should replace it with a\n\t        // more general handling of cursor positions around line\n\t        // breaks. (Issue #4078)\n\t        if (toOutside && !bidi && !/\\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&\n\t            ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {\n\t          var charSize = measureCharPrepared(cm, preparedMeasure, ch, \"right\");\n\t          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {\n\t            outside = false\n\t            ch++\n\t            xDiff = x - charSize.right\n\t          }\n\t        }\n\t        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n\t        var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n\t        return pos;\n\t      }\n\t      var step = Math.ceil(dist / 2), middle = from + step;\n\t      if (bidi) {\n\t        middle = from;\n\t        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n\t      }\n\t      var middleX = getX(middle);\n\t      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n\t      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n\t    }\n\t  }\n\t\n\t  var measureText;\n\t  // Compute the default text height.\n\t  function textHeight(display) {\n\t    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n\t    if (measureText == null) {\n\t      measureText = elt(\"pre\");\n\t      // Measure a bunch of lines, for browsers that compute\n\t      // fractional heights.\n\t      for (var i = 0; i < 49; ++i) {\n\t        measureText.appendChild(document.createTextNode(\"x\"));\n\t        measureText.appendChild(elt(\"br\"));\n\t      }\n\t      measureText.appendChild(document.createTextNode(\"x\"));\n\t    }\n\t    removeChildrenAndAdd(display.measure, measureText);\n\t    var height = measureText.offsetHeight / 50;\n\t    if (height > 3) display.cachedTextHeight = height;\n\t    removeChildren(display.measure);\n\t    return height || 1;\n\t  }\n\t\n\t  // Compute the default character width.\n\t  function charWidth(display) {\n\t    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n\t    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n\t    var pre = elt(\"pre\", [anchor]);\n\t    removeChildrenAndAdd(display.measure, pre);\n\t    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n\t    if (width > 2) display.cachedCharWidth = width;\n\t    return width || 10;\n\t  }\n\t\n\t  // OPERATIONS\n\t\n\t  // Operations are used to wrap a series of changes to the editor\n\t  // state in such a way that each change won't have to update the\n\t  // cursor and display (which would be awkward, slow, and\n\t  // error-prone). Instead, display updates are batched and then all\n\t  // combined and executed at once.\n\t\n\t  var operationGroup = null;\n\t\n\t  var nextOpId = 0;\n\t  // Start a new operation.\n\t  function startOperation(cm) {\n\t    cm.curOp = {\n\t      cm: cm,\n\t      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n\t      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n\t      forceUpdate: false,      // Used to force a redraw\n\t      updateInput: null,       // Whether to reset the input textarea\n\t      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n\t      changeObjs: null,        // Accumulated changes, for firing change events\n\t      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n\t      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n\t      selectionChanged: false, // Whether the selection needs to be redrawn\n\t      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n\t      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n\t      scrollToPos: null,       // Used to scroll to a specific position\n\t      focus: false,\n\t      id: ++nextOpId           // Unique ID\n\t    };\n\t    if (operationGroup) {\n\t      operationGroup.ops.push(cm.curOp);\n\t    } else {\n\t      cm.curOp.ownsGroup = operationGroup = {\n\t        ops: [cm.curOp],\n\t        delayedCallbacks: []\n\t      };\n\t    }\n\t  }\n\t\n\t  function fireCallbacksForOps(group) {\n\t    // Calls delayed callbacks and cursorActivity handlers until no\n\t    // new ones appear\n\t    var callbacks = group.delayedCallbacks, i = 0;\n\t    do {\n\t      for (; i < callbacks.length; i++)\n\t        callbacks[i].call(null);\n\t      for (var j = 0; j < group.ops.length; j++) {\n\t        var op = group.ops[j];\n\t        if (op.cursorActivityHandlers)\n\t          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n\t            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n\t      }\n\t    } while (i < callbacks.length);\n\t  }\n\t\n\t  // Finish an operation, updating the display and signalling delayed events\n\t  function endOperation(cm) {\n\t    var op = cm.curOp, group = op.ownsGroup;\n\t    if (!group) return;\n\t\n\t    try { fireCallbacksForOps(group); }\n\t    finally {\n\t      operationGroup = null;\n\t      for (var i = 0; i < group.ops.length; i++)\n\t        group.ops[i].cm.curOp = null;\n\t      endOperations(group);\n\t    }\n\t  }\n\t\n\t  // The DOM updates done when an operation finishes are batched so\n\t  // that the minimum number of relayouts are required.\n\t  function endOperations(group) {\n\t    var ops = group.ops;\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_finish(ops[i]);\n\t  }\n\t\n\t  function endOperation_R1(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    maybeClipScrollbars(cm);\n\t    if (op.updateMaxLine) findMaxLine(cm);\n\t\n\t    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n\t      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n\t                         op.scrollToPos.to.line >= display.viewTo) ||\n\t      display.maxLineChanged && cm.options.lineWrapping;\n\t    op.update = op.mustUpdate &&\n\t      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n\t  }\n\t\n\t  function endOperation_W1(op) {\n\t    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n\t  }\n\t\n\t  function endOperation_R2(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\t\n\t    op.barMeasure = measureForScrollbars(cm);\n\t\n\t    // If the max line changed since it was last measured, measure it,\n\t    // and ensure the document's width matches it.\n\t    // updateDisplay_W2 will use these properties to do the actual resizing\n\t    if (display.maxLineChanged && !cm.options.lineWrapping) {\n\t      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n\t      cm.display.sizerWidth = op.adjustWidthTo;\n\t      op.barMeasure.scrollWidth =\n\t        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n\t      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n\t    }\n\t\n\t    if (op.updatedDisplay || op.selectionChanged)\n\t      op.preparedSelection = display.input.prepareSelection(op.focus);\n\t  }\n\t\n\t  function endOperation_W2(op) {\n\t    var cm = op.cm;\n\t\n\t    if (op.adjustWidthTo != null) {\n\t      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n\t      if (op.maxScrollLeft < cm.doc.scrollLeft)\n\t        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n\t      cm.display.maxLineChanged = false;\n\t    }\n\t\n\t    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())\n\t    if (op.preparedSelection)\n\t      cm.display.input.showSelection(op.preparedSelection, takeFocus);\n\t    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n\t      updateScrollbars(cm, op.barMeasure);\n\t    if (op.updatedDisplay)\n\t      setDocumentHeight(cm, op.barMeasure);\n\t\n\t    if (op.selectionChanged) restartBlink(cm);\n\t\n\t    if (cm.state.focused && op.updateInput)\n\t      cm.display.input.reset(op.typing);\n\t    if (takeFocus) ensureFocus(op.cm);\n\t  }\n\t\n\t  function endOperation_finish(op) {\n\t    var cm = op.cm, display = cm.display, doc = cm.doc;\n\t\n\t    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\t\n\t    // Abort mouse wheel delta measurement, when scrolling explicitly\n\t    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n\t      display.wheelStartX = display.wheelStartY = null;\n\t\n\t    // Propagate the scroll position to the actual DOM scroller\n\t    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n\t      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n\t      display.scrollbars.setScrollTop(doc.scrollTop);\n\t      display.scroller.scrollTop = doc.scrollTop;\n\t    }\n\t    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n\t      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));\n\t      display.scrollbars.setScrollLeft(doc.scrollLeft);\n\t      display.scroller.scrollLeft = doc.scrollLeft;\n\t      alignHorizontally(cm);\n\t    }\n\t    // If we need to scroll a specific position into view, do so.\n\t    if (op.scrollToPos) {\n\t      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n\t                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n\t      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n\t    }\n\t\n\t    // Fire events for markers that are hidden/unidden by editing or\n\t    // undoing\n\t    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n\t    if (hidden) for (var i = 0; i < hidden.length; ++i)\n\t      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n\t    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n\t      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\t\n\t    if (display.wrapper.offsetHeight)\n\t      doc.scrollTop = cm.display.scroller.scrollTop;\n\t\n\t    // Fire change events, and delayed event handlers\n\t    if (op.changeObjs)\n\t      signal(cm, \"changes\", cm, op.changeObjs);\n\t    if (op.update)\n\t      op.update.finish();\n\t  }\n\t\n\t  // Run the given function in an operation\n\t  function runInOp(cm, f) {\n\t    if (cm.curOp) return f();\n\t    startOperation(cm);\n\t    try { return f(); }\n\t    finally { endOperation(cm); }\n\t  }\n\t  // Wraps a function in an operation. Returns the wrapped function.\n\t  function operation(cm, f) {\n\t    return function() {\n\t      if (cm.curOp) return f.apply(cm, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(cm, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t  // Used to add methods to editor and doc instances, wrapping them in\n\t  // operations.\n\t  function methodOp(f) {\n\t    return function() {\n\t      if (this.curOp) return f.apply(this, arguments);\n\t      startOperation(this);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(this); }\n\t    };\n\t  }\n\t  function docMethodOp(f) {\n\t    return function() {\n\t      var cm = this.cm;\n\t      if (!cm || cm.curOp) return f.apply(this, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t\n\t  // VIEW TRACKING\n\t\n\t  // These objects are used to represent the visible (currently drawn)\n\t  // part of the document. A LineView may correspond to multiple\n\t  // logical lines, if those are connected by collapsed ranges.\n\t  function LineView(doc, line, lineN) {\n\t    // The starting line\n\t    this.line = line;\n\t    // Continuing lines, if any\n\t    this.rest = visualLineContinued(line);\n\t    // Number of logical lines in this visual line\n\t    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n\t    this.node = this.text = null;\n\t    this.hidden = lineIsHidden(doc, line);\n\t  }\n\t\n\t  // Create a range of LineView objects for the given lines.\n\t  function buildViewArray(cm, from, to) {\n\t    var array = [], nextPos;\n\t    for (var pos = from; pos < to; pos = nextPos) {\n\t      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n\t      nextPos = pos + view.size;\n\t      array.push(view);\n\t    }\n\t    return array;\n\t  }\n\t\n\t  // Updates the display.view data structure for a given change to the\n\t  // document. From and to are in pre-change coordinates. Lendiff is\n\t  // the amount of lines added or subtracted by the change. This is\n\t  // used for changes that span multiple lines, or change the way\n\t  // lines are divided into visual lines. regLineChange (below)\n\t  // registers single-line changes.\n\t  function regChange(cm, from, to, lendiff) {\n\t    if (from == null) from = cm.doc.first;\n\t    if (to == null) to = cm.doc.first + cm.doc.size;\n\t    if (!lendiff) lendiff = 0;\n\t\n\t    var display = cm.display;\n\t    if (lendiff && to < display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n\t      display.updateLineNumbers = from;\n\t\n\t    cm.curOp.viewChanged = true;\n\t\n\t    if (from >= display.viewTo) { // Change after\n\t      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n\t        resetView(cm);\n\t    } else if (to <= display.viewFrom) { // Change before\n\t      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n\t        resetView(cm);\n\t      } else {\n\t        display.viewFrom += lendiff;\n\t        display.viewTo += lendiff;\n\t      }\n\t    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n\t      resetView(cm);\n\t    } else if (from <= display.viewFrom) { // Top overlap\n\t      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cut) {\n\t        display.view = display.view.slice(cut.index);\n\t        display.viewFrom = cut.lineN;\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else if (to >= display.viewTo) { // Bottom overlap\n\t      var cut = viewCuttingPoint(cm, from, from, -1);\n\t      if (cut) {\n\t        display.view = display.view.slice(0, cut.index);\n\t        display.viewTo = cut.lineN;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else { // Gap in the middle\n\t      var cutTop = viewCuttingPoint(cm, from, from, -1);\n\t      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cutTop && cutBot) {\n\t        display.view = display.view.slice(0, cutTop.index)\n\t          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n\t          .concat(display.view.slice(cutBot.index));\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    }\n\t\n\t    var ext = display.externalMeasured;\n\t    if (ext) {\n\t      if (to < ext.lineN)\n\t        ext.lineN += lendiff;\n\t      else if (from < ext.lineN + ext.size)\n\t        display.externalMeasured = null;\n\t    }\n\t  }\n\t\n\t  // Register a change to a single line. Type must be one of \"text\",\n\t  // \"gutter\", \"class\", \"widget\"\n\t  function regLineChange(cm, line, type) {\n\t    cm.curOp.viewChanged = true;\n\t    var display = cm.display, ext = cm.display.externalMeasured;\n\t    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n\t      display.externalMeasured = null;\n\t\n\t    if (line < display.viewFrom || line >= display.viewTo) return;\n\t    var lineView = display.view[findViewIndex(cm, line)];\n\t    if (lineView.node == null) return;\n\t    var arr = lineView.changes || (lineView.changes = []);\n\t    if (indexOf(arr, type) == -1) arr.push(type);\n\t  }\n\t\n\t  // Clear the view.\n\t  function resetView(cm) {\n\t    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n\t    cm.display.view = [];\n\t    cm.display.viewOffset = 0;\n\t  }\n\t\n\t  // Find the view element corresponding to a given line. Return null\n\t  // when the line isn't visible.\n\t  function findViewIndex(cm, n) {\n\t    if (n >= cm.display.viewTo) return null;\n\t    n -= cm.display.viewFrom;\n\t    if (n < 0) return null;\n\t    var view = cm.display.view;\n\t    for (var i = 0; i < view.length; i++) {\n\t      n -= view[i].size;\n\t      if (n < 0) return i;\n\t    }\n\t  }\n\t\n\t  function viewCuttingPoint(cm, oldN, newN, dir) {\n\t    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n\t    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n\t      return {index: index, lineN: newN};\n\t    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n\t      n += view[i].size;\n\t    if (n != oldN) {\n\t      if (dir > 0) {\n\t        if (index == view.length - 1) return null;\n\t        diff = (n + view[index].size) - oldN;\n\t        index++;\n\t      } else {\n\t        diff = n - oldN;\n\t      }\n\t      oldN += diff; newN += diff;\n\t    }\n\t    while (visualLineNo(cm.doc, newN) != newN) {\n\t      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n\t      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n\t      index += dir;\n\t    }\n\t    return {index: index, lineN: newN};\n\t  }\n\t\n\t  // Force the view to cover a given range, adding empty view element\n\t  // or clipping off existing ones as needed.\n\t  function adjustView(cm, from, to) {\n\t    var display = cm.display, view = display.view;\n\t    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n\t      display.view = buildViewArray(cm, from, to);\n\t      display.viewFrom = from;\n\t    } else {\n\t      if (display.viewFrom > from)\n\t        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n\t      else if (display.viewFrom < from)\n\t        display.view = display.view.slice(findViewIndex(cm, from));\n\t      display.viewFrom = from;\n\t      if (display.viewTo < to)\n\t        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n\t      else if (display.viewTo > to)\n\t        display.view = display.view.slice(0, findViewIndex(cm, to));\n\t    }\n\t    display.viewTo = to;\n\t  }\n\t\n\t  // Count the number of lines in the view whose DOM representation is\n\t  // out of date (or nonexistent).\n\t  function countDirtyView(cm) {\n\t    var view = cm.display.view, dirty = 0;\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n\t    }\n\t    return dirty;\n\t  }\n\t\n\t  // EVENT HANDLERS\n\t\n\t  // Attach the necessary event handlers when initializing the editor\n\t  function registerEventHandlers(cm) {\n\t    var d = cm.display;\n\t    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n\t    // Older IE's will not fire a second mousedown for a double click\n\t    if (ie && ie_version < 11)\n\t      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n\t        if (signalDOMEvent(cm, e)) return;\n\t        var pos = posFromMouse(cm, e);\n\t        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n\t        e_preventDefault(e);\n\t        var word = cm.findWordAt(pos);\n\t        extendSelection(cm.doc, word.anchor, word.head);\n\t      }));\n\t    else\n\t      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n\t    // Some browsers fire contextmenu *after* opening the menu, at\n\t    // which point we can't mess with it anymore. Context menu is\n\t    // handled in onMouseDown for these browsers.\n\t    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\t\n\t    // Used to suppress mouse event handling when a touch happens\n\t    var touchFinished, prevTouch = {end: 0};\n\t    function finishTouch() {\n\t      if (d.activeTouch) {\n\t        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n\t        prevTouch = d.activeTouch;\n\t        prevTouch.end = +new Date;\n\t      }\n\t    };\n\t    function isMouseLikeTouchEvent(e) {\n\t      if (e.touches.length != 1) return false;\n\t      var touch = e.touches[0];\n\t      return touch.radiusX <= 1 && touch.radiusY <= 1;\n\t    }\n\t    function farAway(touch, other) {\n\t      if (other.left == null) return true;\n\t      var dx = other.left - touch.left, dy = other.top - touch.top;\n\t      return dx * dx + dy * dy > 20 * 20;\n\t    }\n\t    on(d.scroller, \"touchstart\", function(e) {\n\t      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n\t        clearTimeout(touchFinished);\n\t        var now = +new Date;\n\t        d.activeTouch = {start: now, moved: false,\n\t                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n\t        if (e.touches.length == 1) {\n\t          d.activeTouch.left = e.touches[0].pageX;\n\t          d.activeTouch.top = e.touches[0].pageY;\n\t        }\n\t      }\n\t    });\n\t    on(d.scroller, \"touchmove\", function() {\n\t      if (d.activeTouch) d.activeTouch.moved = true;\n\t    });\n\t    on(d.scroller, \"touchend\", function(e) {\n\t      var touch = d.activeTouch;\n\t      if (touch && !eventInWidget(d, e) && touch.left != null &&\n\t          !touch.moved && new Date - touch.start < 300) {\n\t        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n\t        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n\t          range = new Range(pos, pos);\n\t        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n\t          range = cm.findWordAt(pos);\n\t        else // Triple tap\n\t          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n\t        cm.setSelection(range.anchor, range.head);\n\t        cm.focus();\n\t        e_preventDefault(e);\n\t      }\n\t      finishTouch();\n\t    });\n\t    on(d.scroller, \"touchcancel\", finishTouch);\n\t\n\t    // Sync scrolling between fake scrollbars and real scrollable\n\t    // area, ensure viewport is updated when scrolling.\n\t    on(d.scroller, \"scroll\", function() {\n\t      if (d.scroller.clientHeight) {\n\t        setScrollTop(cm, d.scroller.scrollTop);\n\t        setScrollLeft(cm, d.scroller.scrollLeft, true);\n\t        signal(cm, \"scroll\", cm);\n\t      }\n\t    });\n\t\n\t    // Listen to wheel events in order to try and update the viewport on time.\n\t    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n\t    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\t\n\t    // Prevent wrapper from ever scrolling\n\t    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\t\n\t    d.dragFunctions = {\n\t      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n\t      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n\t      start: function(e){onDragStart(cm, e);},\n\t      drop: operation(cm, onDrop),\n\t      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n\t    };\n\t\n\t    var inp = d.input.getField();\n\t    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n\t    on(inp, \"keydown\", operation(cm, onKeyDown));\n\t    on(inp, \"keypress\", operation(cm, onKeyPress));\n\t    on(inp, \"focus\", bind(onFocus, cm));\n\t    on(inp, \"blur\", bind(onBlur, cm));\n\t  }\n\t\n\t  function dragDropChanged(cm, value, old) {\n\t    var wasOn = old && old != CodeMirror.Init;\n\t    if (!value != !wasOn) {\n\t      var funcs = cm.display.dragFunctions;\n\t      var toggle = value ? on : off;\n\t      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n\t      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n\t      toggle(cm.display.scroller, \"dragover\", funcs.over);\n\t      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n\t      toggle(cm.display.scroller, \"drop\", funcs.drop);\n\t    }\n\t  }\n\t\n\t  // Called when the window resizes\n\t  function onResize(cm) {\n\t    var d = cm.display;\n\t    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n\t      return;\n\t    // Might be a text scaling operation, clear size caches.\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t    d.scrollbarsClipped = false;\n\t    cm.setSize();\n\t  }\n\t\n\t  // MOUSE EVENTS\n\t\n\t  // Return true when the given mouse event happened in a widget\n\t  function eventInWidget(display, e) {\n\t    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n\t      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n\t          (n.parentNode == display.sizer && n != display.mover))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // Given a mouse event, find the corresponding position. If liberal\n\t  // is false, it checks whether a gutter or scrollbar was clicked,\n\t  // and returns null if it was. forRect is used by rectangular\n\t  // selections, and tries to estimate a character position even for\n\t  // coordinates beyond the right of the text.\n\t  function posFromMouse(cm, e, liberal, forRect) {\n\t    var display = cm.display;\n\t    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\t\n\t    var x, y, space = display.lineSpace.getBoundingClientRect();\n\t    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\t    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n\t    catch (e) { return null; }\n\t    var coords = coordsChar(cm, x, y), line;\n\t    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n\t      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n\t      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // A mouse down can be a single click, double click, triple click,\n\t  // start of selection drag, start of text drag, new cursor\n\t  // (ctrl-click), rectangle drag (alt-drag), or xwin\n\t  // middle-click-paste. Or it might be a click on something we should\n\t  // not interfere with, such as a scrollbar or widget.\n\t  function onMouseDown(e) {\n\t    var cm = this, display = cm.display;\n\t    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;\n\t    display.shift = e.shiftKey;\n\t\n\t    if (eventInWidget(display, e)) {\n\t      if (!webkit) {\n\t        // Briefly turn off draggability, to allow widgets to do\n\t        // normal dragging things.\n\t        display.scroller.draggable = false;\n\t        setTimeout(function(){display.scroller.draggable = true;}, 100);\n\t      }\n\t      return;\n\t    }\n\t    if (clickInGutter(cm, e)) return;\n\t    var start = posFromMouse(cm, e);\n\t    window.focus();\n\t\n\t    switch (e_button(e)) {\n\t    case 1:\n\t      // #3261: make sure, that we're not starting a second selection\n\t      if (cm.state.selectingText)\n\t        cm.state.selectingText(e);\n\t      else if (start)\n\t        leftButtonDown(cm, e, start);\n\t      else if (e_target(e) == display.scroller)\n\t        e_preventDefault(e);\n\t      break;\n\t    case 2:\n\t      if (webkit) cm.state.lastMiddleDown = +new Date;\n\t      if (start) extendSelection(cm.doc, start);\n\t      setTimeout(function() {display.input.focus();}, 20);\n\t      e_preventDefault(e);\n\t      break;\n\t    case 3:\n\t      if (captureRightClick) onContextMenu(cm, e);\n\t      else delayBlurEvent(cm);\n\t      break;\n\t    }\n\t  }\n\t\n\t  var lastClick, lastDoubleClick;\n\t  function leftButtonDown(cm, e, start) {\n\t    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n\t    else cm.curOp.focus = activeElt();\n\t\n\t    var now = +new Date, type;\n\t    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n\t      type = \"triple\";\n\t    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n\t      type = \"double\";\n\t      lastDoubleClick = {time: now, pos: start};\n\t    } else {\n\t      type = \"single\";\n\t      lastClick = {time: now, pos: start};\n\t    }\n\t\n\t    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n\t    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n\t        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n\t        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n\t        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n\t      leftButtonStartDrag(cm, e, start, modifier);\n\t    else\n\t      leftButtonSelect(cm, e, start, type, modifier);\n\t  }\n\t\n\t  // Start a text drag. When it ends, see if any dragging actually\n\t  // happen, and treat as a click if it didn't.\n\t  function leftButtonStartDrag(cm, e, start, modifier) {\n\t    var display = cm.display, startTime = +new Date;\n\t    var dragEnd = operation(cm, function(e2) {\n\t      if (webkit) display.scroller.draggable = false;\n\t      cm.state.draggingText = false;\n\t      off(document, \"mouseup\", dragEnd);\n\t      off(display.scroller, \"drop\", dragEnd);\n\t      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n\t        e_preventDefault(e2);\n\t        if (!modifier && +new Date - 200 < startTime)\n\t          extendSelection(cm.doc, start);\n\t        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n\t        if (webkit || ie && ie_version == 9)\n\t          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n\t        else\n\t          display.input.focus();\n\t      }\n\t    });\n\t    // Let the drag handler handle this.\n\t    if (webkit) display.scroller.draggable = true;\n\t    cm.state.draggingText = dragEnd;\n\t    dragEnd.copy = mac ? e.altKey : e.ctrlKey\n\t    // IE's approach to draggable\n\t    if (display.scroller.dragDrop) display.scroller.dragDrop();\n\t    on(document, \"mouseup\", dragEnd);\n\t    on(display.scroller, \"drop\", dragEnd);\n\t  }\n\t\n\t  // Normal selection, as opposed to text dragging.\n\t  function leftButtonSelect(cm, e, start, type, addNew) {\n\t    var display = cm.display, doc = cm.doc;\n\t    e_preventDefault(e);\n\t\n\t    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n\t    if (addNew && !e.shiftKey) {\n\t      ourIndex = doc.sel.contains(start);\n\t      if (ourIndex > -1)\n\t        ourRange = ranges[ourIndex];\n\t      else\n\t        ourRange = new Range(start, start);\n\t    } else {\n\t      ourRange = doc.sel.primary();\n\t      ourIndex = doc.sel.primIndex;\n\t    }\n\t\n\t    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\n\t      type = \"rect\";\n\t      if (!addNew) ourRange = new Range(start, start);\n\t      start = posFromMouse(cm, e, true, true);\n\t      ourIndex = -1;\n\t    } else if (type == \"double\") {\n\t      var word = cm.findWordAt(start);\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n\t      else\n\t        ourRange = word;\n\t    } else if (type == \"triple\") {\n\t      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n\t      else\n\t        ourRange = line;\n\t    } else {\n\t      ourRange = extendRange(doc, ourRange, start);\n\t    }\n\t\n\t    if (!addNew) {\n\t      ourIndex = 0;\n\t      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n\t      startSel = doc.sel;\n\t    } else if (ourIndex == -1) {\n\t      ourIndex = ranges.length;\n\t      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n\t      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t      startSel = doc.sel;\n\t    } else {\n\t      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n\t    }\n\t\n\t    var lastPos = start;\n\t    function extendTo(pos) {\n\t      if (cmp(lastPos, pos) == 0) return;\n\t      lastPos = pos;\n\t\n\t      if (type == \"rect\") {\n\t        var ranges = [], tabSize = cm.options.tabSize;\n\t        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n\t        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n\t        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n\t        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n\t             line <= end; line++) {\n\t          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n\t          if (left == right)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n\t          else if (text.length > leftPos)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n\t        }\n\t        if (!ranges.length) ranges.push(new Range(start, start));\n\t        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n\t                     {origin: \"*mouse\", scroll: false});\n\t        cm.scrollIntoView(pos);\n\t      } else {\n\t        var oldRange = ourRange;\n\t        var anchor = oldRange.anchor, head = pos;\n\t        if (type != \"single\") {\n\t          if (type == \"double\")\n\t            var range = cm.findWordAt(pos);\n\t          else\n\t            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n\t          if (cmp(range.anchor, anchor) > 0) {\n\t            head = range.head;\n\t            anchor = minPos(oldRange.from(), range.anchor);\n\t          } else {\n\t            head = range.anchor;\n\t            anchor = maxPos(oldRange.to(), range.head);\n\t          }\n\t        }\n\t        var ranges = startSel.ranges.slice(0);\n\t        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n\t        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n\t      }\n\t    }\n\t\n\t    var editorSize = display.wrapper.getBoundingClientRect();\n\t    // Used to ensure timeout re-tries don't fire when another extend\n\t    // happened in the meantime (clearTimeout isn't reliable -- at\n\t    // least on Chrome, the timeouts still happen even when cleared,\n\t    // if the clear happens after their scheduled firing time).\n\t    var counter = 0;\n\t\n\t    function extend(e) {\n\t      var curCount = ++counter;\n\t      var cur = posFromMouse(cm, e, true, type == \"rect\");\n\t      if (!cur) return;\n\t      if (cmp(cur, lastPos) != 0) {\n\t        cm.curOp.focus = activeElt();\n\t        extendTo(cur);\n\t        var visible = visibleLines(display, doc);\n\t        if (cur.line >= visible.to || cur.line < visible.from)\n\t          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n\t      } else {\n\t        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\t        if (outside) setTimeout(operation(cm, function() {\n\t          if (counter != curCount) return;\n\t          display.scroller.scrollTop += outside;\n\t          extend(e);\n\t        }), 50);\n\t      }\n\t    }\n\t\n\t    function done(e) {\n\t      cm.state.selectingText = false;\n\t      counter = Infinity;\n\t      e_preventDefault(e);\n\t      display.input.focus();\n\t      off(document, \"mousemove\", move);\n\t      off(document, \"mouseup\", up);\n\t      doc.history.lastSelOrigin = null;\n\t    }\n\t\n\t    var move = operation(cm, function(e) {\n\t      if (!e_button(e)) done(e);\n\t      else extend(e);\n\t    });\n\t    var up = operation(cm, done);\n\t    cm.state.selectingText = up;\n\t    on(document, \"mousemove\", move);\n\t    on(document, \"mouseup\", up);\n\t  }\n\t\n\t  // Determines whether an event happened in the gutter, and fires the\n\t  // handlers for the corresponding event.\n\t  function gutterEvent(cm, e, type, prevent) {\n\t    try { var mX = e.clientX, mY = e.clientY; }\n\t    catch(e) { return false; }\n\t    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n\t    if (prevent) e_preventDefault(e);\n\t\n\t    var display = cm.display;\n\t    var lineBox = display.lineDiv.getBoundingClientRect();\n\t\n\t    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n\t    mY -= lineBox.top - display.viewOffset;\n\t\n\t    for (var i = 0; i < cm.options.gutters.length; ++i) {\n\t      var g = display.gutters.childNodes[i];\n\t      if (g && g.getBoundingClientRect().right >= mX) {\n\t        var line = lineAtHeight(cm.doc, mY);\n\t        var gutter = cm.options.gutters[i];\n\t        signal(cm, type, cm, line, gutter, e);\n\t        return e_defaultPrevented(e);\n\t      }\n\t    }\n\t  }\n\t\n\t  function clickInGutter(cm, e) {\n\t    return gutterEvent(cm, e, \"gutterClick\", true);\n\t  }\n\t\n\t  // Kludge to work around strange IE behavior where it'll sometimes\n\t  // re-fire a series of drag-related events right after the drop (#1551)\n\t  var lastDrop = 0;\n\t\n\t  function onDrop(e) {\n\t    var cm = this;\n\t    clearDragCursor(cm);\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n\t      return;\n\t    e_preventDefault(e);\n\t    if (ie) lastDrop = +new Date;\n\t    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n\t    if (!pos || cm.isReadOnly()) return;\n\t    // Might be a file drop, in which case we simply extract the text\n\t    // and insert it.\n\t    if (files && files.length && window.FileReader && window.File) {\n\t      var n = files.length, text = Array(n), read = 0;\n\t      var loadFile = function(file, i) {\n\t        if (cm.options.allowDropFileTypes &&\n\t            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n\t          return;\n\t\n\t        var reader = new FileReader;\n\t        reader.onload = operation(cm, function() {\n\t          var content = reader.result;\n\t          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n\t          text[i] = content;\n\t          if (++read == n) {\n\t            pos = clipPos(cm.doc, pos);\n\t            var change = {from: pos, to: pos,\n\t                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n\t                          origin: \"paste\"};\n\t            makeChange(cm.doc, change);\n\t            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n\t          }\n\t        });\n\t        reader.readAsText(file);\n\t      };\n\t      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n\t    } else { // Normal drop\n\t      // Don't do a replace if the drop happened inside of the selected text.\n\t      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n\t        cm.state.draggingText(e);\n\t        // Ensure the editor is re-focused\n\t        setTimeout(function() {cm.display.input.focus();}, 20);\n\t        return;\n\t      }\n\t      try {\n\t        var text = e.dataTransfer.getData(\"Text\");\n\t        if (text) {\n\t          if (cm.state.draggingText && !cm.state.draggingText.copy)\n\t            var selected = cm.listSelections();\n\t          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n\t          if (selected) for (var i = 0; i < selected.length; ++i)\n\t            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n\t          cm.replaceSelection(text, \"around\", \"paste\");\n\t          cm.display.input.focus();\n\t        }\n\t      }\n\t      catch(e){}\n\t    }\n\t  }\n\t\n\t  function onDragStart(cm, e) {\n\t    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\t\n\t    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\t    e.dataTransfer.effectAllowed = \"copyMove\"\n\t\n\t    // Use dummy image instead of default browsers image.\n\t    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\t    if (e.dataTransfer.setDragImage && !safari) {\n\t      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n\t      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\t      if (presto) {\n\t        img.width = img.height = 1;\n\t        cm.display.wrapper.appendChild(img);\n\t        // Force a relayout, or Opera won't use our image for some obscure reason\n\t        img._top = img.offsetTop;\n\t      }\n\t      e.dataTransfer.setDragImage(img, 0, 0);\n\t      if (presto) img.parentNode.removeChild(img);\n\t    }\n\t  }\n\t\n\t  function onDragOver(cm, e) {\n\t    var pos = posFromMouse(cm, e);\n\t    if (!pos) return;\n\t    var frag = document.createDocumentFragment();\n\t    drawSelectionCursor(cm, pos, frag);\n\t    if (!cm.display.dragCursor) {\n\t      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n\t      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n\t    }\n\t    removeChildrenAndAdd(cm.display.dragCursor, frag);\n\t  }\n\t\n\t  function clearDragCursor(cm) {\n\t    if (cm.display.dragCursor) {\n\t      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n\t      cm.display.dragCursor = null;\n\t    }\n\t  }\n\t\n\t  // SCROLL EVENTS\n\t\n\t  // Sync the scrollable area and scrollbars, ensure the viewport\n\t  // covers the visible area.\n\t  function setScrollTop(cm, val) {\n\t    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n\t    cm.doc.scrollTop = val;\n\t    if (!gecko) updateDisplaySimple(cm, {top: val});\n\t    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n\t    cm.display.scrollbars.setScrollTop(val);\n\t    if (gecko) updateDisplaySimple(cm);\n\t    startWorker(cm, 100);\n\t  }\n\t  // Sync scroller and scrollbar, ensure the gutter elements are\n\t  // aligned.\n\t  function setScrollLeft(cm, val, isScroller) {\n\t    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n\t    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n\t    cm.doc.scrollLeft = val;\n\t    alignHorizontally(cm);\n\t    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n\t    cm.display.scrollbars.setScrollLeft(val);\n\t  }\n\t\n\t  // Since the delta values reported on mouse wheel events are\n\t  // unstandardized between browsers and even browser versions, and\n\t  // generally horribly unpredictable, this code starts by measuring\n\t  // the scroll effect that the first few mouse wheel events have,\n\t  // and, from that, detects the way it can convert deltas to pixel\n\t  // offsets afterwards.\n\t  //\n\t  // The reason we want to know the amount a wheel event will scroll\n\t  // is that it gives us a chance to update the display before the\n\t  // actual scrolling happens, reducing flickering.\n\t\n\t  var wheelSamples = 0, wheelPixelsPerUnit = null;\n\t  // Fill in a browser-detected starting value on browsers where we\n\t  // know one. These don't have to be accurate -- the result of them\n\t  // being wrong would just be a slight flicker on the first wheel\n\t  // scroll (if it is large enough).\n\t  if (ie) wheelPixelsPerUnit = -.53;\n\t  else if (gecko) wheelPixelsPerUnit = 15;\n\t  else if (chrome) wheelPixelsPerUnit = -.7;\n\t  else if (safari) wheelPixelsPerUnit = -1/3;\n\t\n\t  var wheelEventDelta = function(e) {\n\t    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n\t    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n\t    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n\t    else if (dy == null) dy = e.wheelDelta;\n\t    return {x: dx, y: dy};\n\t  };\n\t  CodeMirror.wheelEventPixels = function(e) {\n\t    var delta = wheelEventDelta(e);\n\t    delta.x *= wheelPixelsPerUnit;\n\t    delta.y *= wheelPixelsPerUnit;\n\t    return delta;\n\t  };\n\t\n\t  function onScrollWheel(cm, e) {\n\t    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\t\n\t    var display = cm.display, scroll = display.scroller;\n\t    // Quit if there's nothing to scroll here\n\t    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n\t    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n\t    if (!(dx && canScrollX || dy && canScrollY)) return;\n\t\n\t    // Webkit browsers on OS X abort momentum scrolls when the target\n\t    // of the scroll event is removed from the scrollable element.\n\t    // This hack (see related code in patchDisplay) makes sure the\n\t    // element is kept around.\n\t    if (dy && mac && webkit) {\n\t      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n\t        for (var i = 0; i < view.length; i++) {\n\t          if (view[i].node == cur) {\n\t            cm.display.currentWheelTarget = cur;\n\t            break outer;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // On some browsers, horizontal scrolling will cause redraws to\n\t    // happen before the gutter has been realigned, causing it to\n\t    // wriggle around in a most unseemly way. When we have an\n\t    // estimated pixels/delta value, we just handle horizontal\n\t    // scrolling entirely here. It'll be slightly off from native, but\n\t    // better than glitching out.\n\t    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n\t      if (dy && canScrollY)\n\t        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n\t      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n\t      // Only prevent default scrolling if vertical scrolling is\n\t      // actually possible. Otherwise, it causes vertical scroll\n\t      // jitter on OSX trackpads when deltaX is small and deltaY\n\t      // is large (issue #3579)\n\t      if (!dy || (dy && canScrollY))\n\t        e_preventDefault(e);\n\t      display.wheelStartX = null; // Abort measurement, if in progress\n\t      return;\n\t    }\n\t\n\t    // 'Project' the visible viewport to cover the area that is being\n\t    // scrolled into view (if we know enough to estimate it).\n\t    if (dy && wheelPixelsPerUnit != null) {\n\t      var pixels = dy * wheelPixelsPerUnit;\n\t      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n\t      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n\t      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n\t      updateDisplaySimple(cm, {top: top, bottom: bot});\n\t    }\n\t\n\t    if (wheelSamples < 20) {\n\t      if (display.wheelStartX == null) {\n\t        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n\t        display.wheelDX = dx; display.wheelDY = dy;\n\t        setTimeout(function() {\n\t          if (display.wheelStartX == null) return;\n\t          var movedX = scroll.scrollLeft - display.wheelStartX;\n\t          var movedY = scroll.scrollTop - display.wheelStartY;\n\t          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n\t            (movedX && display.wheelDX && movedX / display.wheelDX);\n\t          display.wheelStartX = display.wheelStartY = null;\n\t          if (!sample) return;\n\t          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n\t          ++wheelSamples;\n\t        }, 200);\n\t      } else {\n\t        display.wheelDX += dx; display.wheelDY += dy;\n\t      }\n\t    }\n\t  }\n\t\n\t  // KEY EVENTS\n\t\n\t  // Run a handler that was bound to a key.\n\t  function doHandleBinding(cm, bound, dropShift) {\n\t    if (typeof bound == \"string\") {\n\t      bound = commands[bound];\n\t      if (!bound) return false;\n\t    }\n\t    // Ensure previous input has been read, so that the handler sees a\n\t    // consistent view of the document\n\t    cm.display.input.ensurePolled();\n\t    var prevShift = cm.display.shift, done = false;\n\t    try {\n\t      if (cm.isReadOnly()) cm.state.suppressEdits = true;\n\t      if (dropShift) cm.display.shift = false;\n\t      done = bound(cm) != Pass;\n\t    } finally {\n\t      cm.display.shift = prevShift;\n\t      cm.state.suppressEdits = false;\n\t    }\n\t    return done;\n\t  }\n\t\n\t  function lookupKeyForEditor(cm, name, handle) {\n\t    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n\t      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n\t      if (result) return result;\n\t    }\n\t    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n\t      || lookupKey(name, cm.options.keyMap, handle, cm);\n\t  }\n\t\n\t  var stopSeq = new Delayed;\n\t  function dispatchKey(cm, name, e, handle) {\n\t    var seq = cm.state.keySeq;\n\t    if (seq) {\n\t      if (isModifierKey(name)) return \"handled\";\n\t      stopSeq.set(50, function() {\n\t        if (cm.state.keySeq == seq) {\n\t          cm.state.keySeq = null;\n\t          cm.display.input.reset();\n\t        }\n\t      });\n\t      name = seq + \" \" + name;\n\t    }\n\t    var result = lookupKeyForEditor(cm, name, handle);\n\t\n\t    if (result == \"multi\")\n\t      cm.state.keySeq = name;\n\t    if (result == \"handled\")\n\t      signalLater(cm, \"keyHandled\", cm, name, e);\n\t\n\t    if (result == \"handled\" || result == \"multi\") {\n\t      e_preventDefault(e);\n\t      restartBlink(cm);\n\t    }\n\t\n\t    if (seq && !result && /\\'$/.test(name)) {\n\t      e_preventDefault(e);\n\t      return true;\n\t    }\n\t    return !!result;\n\t  }\n\t\n\t  // Handle a key from the keydown event.\n\t  function handleKeyBinding(cm, e) {\n\t    var name = keyName(e, true);\n\t    if (!name) return false;\n\t\n\t    if (e.shiftKey && !cm.state.keySeq) {\n\t      // First try to resolve full name (including 'Shift-'). Failing\n\t      // that, see if there is a cursor-motion command (starting with\n\t      // 'go') bound to the keyname without 'Shift-'.\n\t      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n\t          || dispatchKey(cm, name, e, function(b) {\n\t               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n\t                 return doHandleBinding(cm, b);\n\t             });\n\t    } else {\n\t      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n\t    }\n\t  }\n\t\n\t  // Handle a key from the keypress event\n\t  function handleCharBinding(cm, e, ch) {\n\t    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n\t                       function(b) { return doHandleBinding(cm, b, true); });\n\t  }\n\t\n\t  var lastStoppedKey = null;\n\t  function onKeyDown(e) {\n\t    var cm = this;\n\t    cm.curOp.focus = activeElt();\n\t    if (signalDOMEvent(cm, e)) return;\n\t    // IE does strange things with escape.\n\t    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n\t    var code = e.keyCode;\n\t    cm.display.shift = code == 16 || e.shiftKey;\n\t    var handled = handleKeyBinding(cm, e);\n\t    if (presto) {\n\t      lastStoppedKey = handled ? code : null;\n\t      // Opera has no cut event... we try to at least catch the key combo\n\t      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n\t        cm.replaceSelection(\"\", null, \"cut\");\n\t    }\n\t\n\t    // Turn mouse into crosshair when Alt is held on Mac.\n\t    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n\t      showCrossHair(cm);\n\t  }\n\t\n\t  function showCrossHair(cm) {\n\t    var lineDiv = cm.display.lineDiv;\n\t    addClass(lineDiv, \"CodeMirror-crosshair\");\n\t\n\t    function up(e) {\n\t      if (e.keyCode == 18 || !e.altKey) {\n\t        rmClass(lineDiv, \"CodeMirror-crosshair\");\n\t        off(document, \"keyup\", up);\n\t        off(document, \"mouseover\", up);\n\t      }\n\t    }\n\t    on(document, \"keyup\", up);\n\t    on(document, \"mouseover\", up);\n\t  }\n\t\n\t  function onKeyUp(e) {\n\t    if (e.keyCode == 16) this.doc.sel.shift = false;\n\t    signalDOMEvent(this, e);\n\t  }\n\t\n\t  function onKeyPress(e) {\n\t    var cm = this;\n\t    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n\t    var keyCode = e.keyCode, charCode = e.charCode;\n\t    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n\t    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n\t    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n\t    if (handleCharBinding(cm, e, ch)) return;\n\t    cm.display.input.onKeyPress(e);\n\t  }\n\t\n\t  // FOCUS/BLUR EVENTS\n\t\n\t  function delayBlurEvent(cm) {\n\t    cm.state.delayingBlurEvent = true;\n\t    setTimeout(function() {\n\t      if (cm.state.delayingBlurEvent) {\n\t        cm.state.delayingBlurEvent = false;\n\t        onBlur(cm);\n\t      }\n\t    }, 100);\n\t  }\n\t\n\t  function onFocus(cm) {\n\t    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\t\n\t    if (cm.options.readOnly == \"nocursor\") return;\n\t    if (!cm.state.focused) {\n\t      signal(cm, \"focus\", cm);\n\t      cm.state.focused = true;\n\t      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t      // This test prevents this from firing when a context\n\t      // menu is closed (since the input reset would kill the\n\t      // select-all detection hack)\n\t      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n\t        cm.display.input.reset();\n\t        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n\t      }\n\t      cm.display.input.receivedFocus();\n\t    }\n\t    restartBlink(cm);\n\t  }\n\t  function onBlur(cm) {\n\t    if (cm.state.delayingBlurEvent) return;\n\t\n\t    if (cm.state.focused) {\n\t      signal(cm, \"blur\", cm);\n\t      cm.state.focused = false;\n\t      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t    }\n\t    clearInterval(cm.display.blinker);\n\t    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n\t  }\n\t\n\t  // CONTEXT MENU HANDLING\n\t\n\t  // To make the context menu work, we need to briefly unhide the\n\t  // textarea (making it as unobtrusive as possible) to let the\n\t  // right-click take effect on it.\n\t  function onContextMenu(cm, e) {\n\t    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n\t    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n\t    cm.display.input.onContextMenu(e);\n\t  }\n\t\n\t  function contextMenuInGutter(cm, e) {\n\t    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n\t    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n\t  }\n\t\n\t  // UPDATING\n\t\n\t  // Compute the position of the end of a change (its 'to' property\n\t  // refers to the pre-change end).\n\t  var changeEnd = CodeMirror.changeEnd = function(change) {\n\t    if (!change.text) return change.to;\n\t    return Pos(change.from.line + change.text.length - 1,\n\t               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n\t  };\n\t\n\t  // Adjust a position to refer to the post-change position of the\n\t  // same text, or the end of the change if the change covers it.\n\t  function adjustForChange(pos, change) {\n\t    if (cmp(pos, change.from) < 0) return pos;\n\t    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\t\n\t    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n\t    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n\t    return Pos(line, ch);\n\t  }\n\t\n\t  function computeSelAfterChange(doc, change) {\n\t    var out = [];\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      var range = doc.sel.ranges[i];\n\t      out.push(new Range(adjustForChange(range.anchor, change),\n\t                         adjustForChange(range.head, change)));\n\t    }\n\t    return normalizeSelection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  function offsetPos(pos, old, nw) {\n\t    if (pos.line == old.line)\n\t      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n\t    else\n\t      return Pos(nw.line + (pos.line - old.line), pos.ch);\n\t  }\n\t\n\t  // Used by replaceSelections to allow moving the selection to the\n\t  // start or around the replaced test. Hint may be \"start\" or \"around\".\n\t  function computeReplacedSel(doc, changes, hint) {\n\t    var out = [];\n\t    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n\t    for (var i = 0; i < changes.length; i++) {\n\t      var change = changes[i];\n\t      var from = offsetPos(change.from, oldPrev, newPrev);\n\t      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n\t      oldPrev = change.to;\n\t      newPrev = to;\n\t      if (hint == \"around\") {\n\t        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n\t        out[i] = new Range(inv ? to : from, inv ? from : to);\n\t      } else {\n\t        out[i] = new Range(from, from);\n\t      }\n\t    }\n\t    return new Selection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  // Allow \"beforeChange\" event handlers to influence a change\n\t  function filterChange(doc, change, update) {\n\t    var obj = {\n\t      canceled: false,\n\t      from: change.from,\n\t      to: change.to,\n\t      text: change.text,\n\t      origin: change.origin,\n\t      cancel: function() { this.canceled = true; }\n\t    };\n\t    if (update) obj.update = function(from, to, text, origin) {\n\t      if (from) this.from = clipPos(doc, from);\n\t      if (to) this.to = clipPos(doc, to);\n\t      if (text) this.text = text;\n\t      if (origin !== undefined) this.origin = origin;\n\t    };\n\t    signal(doc, \"beforeChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\t\n\t    if (obj.canceled) return null;\n\t    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n\t  }\n\t\n\t  // Apply a change to a document, and add it to the document's\n\t  // history, and propagating it to all linked documents.\n\t  function makeChange(doc, change, ignoreReadOnly) {\n\t    if (doc.cm) {\n\t      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n\t      if (doc.cm.state.suppressEdits) return;\n\t    }\n\t\n\t    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n\t      change = filterChange(doc, change, true);\n\t      if (!change) return;\n\t    }\n\t\n\t    // Possibly split or suppress the update based on the presence\n\t    // of read-only spans in its range.\n\t    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\t    if (split) {\n\t      for (var i = split.length - 1; i >= 0; --i)\n\t        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n\t    } else {\n\t      makeChangeInner(doc, change);\n\t    }\n\t  }\n\t\n\t  function makeChangeInner(doc, change) {\n\t    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n\t    var selAfter = computeSelAfterChange(doc, change);\n\t    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\t\n\t    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n\t    var rebased = [];\n\t\n\t    linkedDocs(doc, function(doc, sharedHist) {\n\t      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t        rebaseHist(doc.history, change);\n\t        rebased.push(doc.history);\n\t      }\n\t      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n\t    });\n\t  }\n\t\n\t  // Revert a change stored in a document's history.\n\t  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n\t    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) return;\n\t\n\t    var hist = doc.history, event, selAfter = doc.sel;\n\t    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\t\n\t    // Verify that there is a useable event (so that ctrl-z won't\n\t    // needlessly clear selection events)\n\t    for (var i = 0; i < source.length; i++) {\n\t      event = source[i];\n\t      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n\t        break;\n\t    }\n\t    if (i == source.length) return;\n\t    hist.lastOrigin = hist.lastSelOrigin = null;\n\t\n\t    for (;;) {\n\t      event = source.pop();\n\t      if (event.ranges) {\n\t        pushSelectionToHistory(event, dest);\n\t        if (allowSelectionOnly && !event.equals(doc.sel)) {\n\t          setSelection(doc, event, {clearRedo: false});\n\t          return;\n\t        }\n\t        selAfter = event;\n\t      }\n\t      else break;\n\t    }\n\t\n\t    // Build up a reverse change object to add to the opposite history\n\t    // stack (redo when undoing, and vice versa).\n\t    var antiChanges = [];\n\t    pushSelectionToHistory(selAfter, dest);\n\t    dest.push({changes: antiChanges, generation: hist.generation});\n\t    hist.generation = event.generation || ++hist.maxGeneration;\n\t\n\t    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\t\n\t    for (var i = event.changes.length - 1; i >= 0; --i) {\n\t      var change = event.changes[i];\n\t      change.origin = type;\n\t      if (filter && !filterChange(doc, change, false)) {\n\t        source.length = 0;\n\t        return;\n\t      }\n\t\n\t      antiChanges.push(historyChangeFromChange(doc, change));\n\t\n\t      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n\t      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\t      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n\t      var rebased = [];\n\t\n\t      // Propagate to the linked documents\n\t      linkedDocs(doc, function(doc, sharedHist) {\n\t        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t          rebaseHist(doc.history, change);\n\t          rebased.push(doc.history);\n\t        }\n\t        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n\t      });\n\t    }\n\t  }\n\t\n\t  // Sub-views need their line numbers shifted when text is added\n\t  // above or below them in the parent document.\n\t  function shiftDoc(doc, distance) {\n\t    if (distance == 0) return;\n\t    doc.first += distance;\n\t    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n\t      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n\t                       Pos(range.head.line + distance, range.head.ch));\n\t    }), doc.sel.primIndex);\n\t    if (doc.cm) {\n\t      regChange(doc.cm, doc.first, doc.first - distance, distance);\n\t      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n\t        regLineChange(doc.cm, l, \"gutter\");\n\t    }\n\t  }\n\t\n\t  // More lower-level change function, handling only a single document\n\t  // (not linked ones).\n\t  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n\t    if (doc.cm && !doc.cm.curOp)\n\t      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\t\n\t    if (change.to.line < doc.first) {\n\t      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n\t      return;\n\t    }\n\t    if (change.from.line > doc.lastLine()) return;\n\t\n\t    // Clip the change to the size of this doc\n\t    if (change.from.line < doc.first) {\n\t      var shift = change.text.length - 1 - (doc.first - change.from.line);\n\t      shiftDoc(doc, shift);\n\t      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n\t                text: [lst(change.text)], origin: change.origin};\n\t    }\n\t    var last = doc.lastLine();\n\t    if (change.to.line > last) {\n\t      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n\t                text: [change.text[0]], origin: change.origin};\n\t    }\n\t\n\t    change.removed = getBetween(doc, change.from, change.to);\n\t\n\t    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n\t    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n\t    else updateDoc(doc, change, spans);\n\t    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\t  }\n\t\n\t  // Handle the interaction of a change to a document with the editor\n\t  // that this document is part of.\n\t  function makeChangeSingleDocInEditor(cm, change, spans) {\n\t    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\t\n\t    var recomputeMaxLength = false, checkWidthStart = from.line;\n\t    if (!cm.options.lineWrapping) {\n\t      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n\t      doc.iter(checkWidthStart, to.line + 1, function(line) {\n\t        if (line == display.maxLine) {\n\t          recomputeMaxLength = true;\n\t          return true;\n\t        }\n\t      });\n\t    }\n\t\n\t    if (doc.sel.contains(change.from, change.to) > -1)\n\t      signalCursorActivity(cm);\n\t\n\t    updateDoc(doc, change, spans, estimateHeight(cm));\n\t\n\t    if (!cm.options.lineWrapping) {\n\t      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n\t        var len = lineLength(line);\n\t        if (len > display.maxLineLength) {\n\t          display.maxLine = line;\n\t          display.maxLineLength = len;\n\t          display.maxLineChanged = true;\n\t          recomputeMaxLength = false;\n\t        }\n\t      });\n\t      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n\t    }\n\t\n\t    // Adjust frontier, schedule worker\n\t    doc.frontier = Math.min(doc.frontier, from.line);\n\t    startWorker(cm, 400);\n\t\n\t    var lendiff = change.text.length - (to.line - from.line) - 1;\n\t    // Remember that these lines changed, for updating the display\n\t    if (change.full)\n\t      regChange(cm);\n\t    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n\t      regLineChange(cm, from.line, \"text\");\n\t    else\n\t      regChange(cm, from.line, to.line + 1, lendiff);\n\t\n\t    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n\t    if (changeHandler || changesHandler) {\n\t      var obj = {\n\t        from: from, to: to,\n\t        text: change.text,\n\t        removed: change.removed,\n\t        origin: change.origin\n\t      };\n\t      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n\t      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n\t    }\n\t    cm.display.selForContextMenu = null;\n\t  }\n\t\n\t  function replaceRange(doc, code, from, to, origin) {\n\t    if (!to) to = from;\n\t    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n\t    if (typeof code == \"string\") code = doc.splitLines(code);\n\t    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n\t  }\n\t\n\t  // SCROLLING THINGS INTO VIEW\n\t\n\t  // If an editor sits on the top or bottom of the window, partially\n\t  // scrolled out of view, this ensures that the cursor is visible.\n\t  function maybeScrollWindow(cm, coords) {\n\t    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\t\n\t    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n\t    if (coords.top + box.top < 0) doScroll = true;\n\t    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n\t    if (doScroll != null && !phantom) {\n\t      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n\t                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n\t                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n\t                           coords.left + \"px; width: 2px;\");\n\t      cm.display.lineSpace.appendChild(scrollNode);\n\t      scrollNode.scrollIntoView(doScroll);\n\t      cm.display.lineSpace.removeChild(scrollNode);\n\t    }\n\t  }\n\t\n\t  // Scroll a given position into view (immediately), verifying that\n\t  // it actually became visible (as line heights are accurately\n\t  // measured, the position of something may 'drift' during drawing).\n\t  function scrollPosIntoView(cm, pos, end, margin) {\n\t    if (margin == null) margin = 0;\n\t    for (var limit = 0; limit < 5; limit++) {\n\t      var changed = false, coords = cursorCoords(cm, pos);\n\t      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n\t      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n\t                                         Math.min(coords.top, endCoords.top) - margin,\n\t                                         Math.max(coords.left, endCoords.left),\n\t                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n\t      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n\t      if (scrollPos.scrollTop != null) {\n\t        setScrollTop(cm, scrollPos.scrollTop);\n\t        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n\t      }\n\t      if (scrollPos.scrollLeft != null) {\n\t        setScrollLeft(cm, scrollPos.scrollLeft);\n\t        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n\t      }\n\t      if (!changed) break;\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // Scroll a given set of coordinates into view (immediately).\n\t  function scrollIntoView(cm, x1, y1, x2, y2) {\n\t    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n\t    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n\t    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n\t  }\n\t\n\t  // Calculate a new scroll position needed to scroll the given\n\t  // rectangle into view. Returns an object with scrollTop and\n\t  // scrollLeft properties. When these are undefined, the\n\t  // vertical/horizontal position does not need to be adjusted.\n\t  function calculateScrollPos(cm, x1, y1, x2, y2) {\n\t    var display = cm.display, snapMargin = textHeight(cm.display);\n\t    if (y1 < 0) y1 = 0;\n\t    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n\t    var screen = displayHeight(cm), result = {};\n\t    if (y2 - y1 > screen) y2 = y1 + screen;\n\t    var docBottom = cm.doc.height + paddingVert(display);\n\t    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n\t    if (y1 < screentop) {\n\t      result.scrollTop = atTop ? 0 : y1;\n\t    } else if (y2 > screentop + screen) {\n\t      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n\t      if (newTop != screentop) result.scrollTop = newTop;\n\t    }\n\t\n\t    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n\t    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n\t    var tooWide = x2 - x1 > screenw;\n\t    if (tooWide) x2 = x1 + screenw;\n\t    if (x1 < 10)\n\t      result.scrollLeft = 0;\n\t    else if (x1 < screenleft)\n\t      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n\t    else if (x2 > screenw + screenleft - 3)\n\t      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n\t    return result;\n\t  }\n\t\n\t  // Store a relative adjustment to the scroll position in the current\n\t  // operation (to be applied when the operation finishes).\n\t  function addToScrollPos(cm, left, top) {\n\t    if (left != null || top != null) resolveScrollToPos(cm);\n\t    if (left != null)\n\t      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n\t    if (top != null)\n\t      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n\t  }\n\t\n\t  // Make sure that at the end of the operation the current cursor is\n\t  // shown.\n\t  function ensureCursorVisible(cm) {\n\t    resolveScrollToPos(cm);\n\t    var cur = cm.getCursor(), from = cur, to = cur;\n\t    if (!cm.options.lineWrapping) {\n\t      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n\t      to = Pos(cur.line, cur.ch + 1);\n\t    }\n\t    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n\t  }\n\t\n\t  // When an operation has its scrollToPos property set, and another\n\t  // scroll action is applied before the end of the operation, this\n\t  // 'simulates' scrolling that position into view in a cheap way, so\n\t  // that the effect of intermediate scroll commands is not ignored.\n\t  function resolveScrollToPos(cm) {\n\t    var range = cm.curOp.scrollToPos;\n\t    if (range) {\n\t      cm.curOp.scrollToPos = null;\n\t      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n\t      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n\t                                    Math.min(from.top, to.top) - range.margin,\n\t                                    Math.max(from.right, to.right),\n\t                                    Math.max(from.bottom, to.bottom) + range.margin);\n\t      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t    }\n\t  }\n\t\n\t  // API UTILITIES\n\t\n\t  // Indent the given line. The how parameter can be \"smart\",\n\t  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n\t  // (typically set to true for forced single-line indents), empty\n\t  // lines are not indented, and places where the mode returns Pass\n\t  // are left alone.\n\t  function indentLine(cm, n, how, aggressive) {\n\t    var doc = cm.doc, state;\n\t    if (how == null) how = \"add\";\n\t    if (how == \"smart\") {\n\t      // Fall back to \"prev\" when the mode doesn't have an indentation\n\t      // method.\n\t      if (!doc.mode.indent) how = \"prev\";\n\t      else state = getStateBefore(cm, n);\n\t    }\n\t\n\t    var tabSize = cm.options.tabSize;\n\t    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n\t    if (!aggressive && !/\\S/.test(line.text)) {\n\t      indentation = 0;\n\t      how = \"not\";\n\t    } else if (how == \"smart\") {\n\t      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\t      if (indentation == Pass || indentation > 150) {\n\t        if (!aggressive) return;\n\t        how = \"prev\";\n\t      }\n\t    }\n\t    if (how == \"prev\") {\n\t      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n\t      else indentation = 0;\n\t    } else if (how == \"add\") {\n\t      indentation = curSpace + cm.options.indentUnit;\n\t    } else if (how == \"subtract\") {\n\t      indentation = curSpace - cm.options.indentUnit;\n\t    } else if (typeof how == \"number\") {\n\t      indentation = curSpace + how;\n\t    }\n\t    indentation = Math.max(0, indentation);\n\t\n\t    var indentString = \"\", pos = 0;\n\t    if (cm.options.indentWithTabs)\n\t      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n\t    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\t\n\t    if (indentString != curSpaceString) {\n\t      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\t      line.stateAfter = null;\n\t      return true;\n\t    } else {\n\t      // Ensure that, if the cursor was in the whitespace at the start\n\t      // of the line, it is moved to the end of that space.\n\t      for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t        var range = doc.sel.ranges[i];\n\t        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n\t          var pos = Pos(n, curSpaceString.length);\n\t          replaceOneSelection(doc, i, new Range(pos, pos));\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // Utility for applying a change to a line by handle or number,\n\t  // returning the number and optionally registering the line as\n\t  // changed.\n\t  function changeLine(doc, handle, changeType, op) {\n\t    var no = handle, line = handle;\n\t    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n\t    else no = lineNo(handle);\n\t    if (no == null) return null;\n\t    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n\t    return line;\n\t  }\n\t\n\t  // Helper for deleting text near the selection(s), used to implement\n\t  // backspace, delete, and similar functionality.\n\t  function deleteNearSelection(cm, compute) {\n\t    var ranges = cm.doc.sel.ranges, kill = [];\n\t    // Build up a set of ranges to kill first, merging overlapping\n\t    // ranges.\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var toKill = compute(ranges[i]);\n\t      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n\t        var replaced = kill.pop();\n\t        if (cmp(replaced.from, toKill.from) < 0) {\n\t          toKill.from = replaced.from;\n\t          break;\n\t        }\n\t      }\n\t      kill.push(toKill);\n\t    }\n\t    // Next, remove those actual ranges.\n\t    runInOp(cm, function() {\n\t      for (var i = kill.length - 1; i >= 0; i--)\n\t        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n\t      ensureCursorVisible(cm);\n\t    });\n\t  }\n\t\n\t  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n\t  // right), unit can be \"char\", \"column\" (like char, but doesn't\n\t  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n\t  // the start of next group of word or non-word-non-whitespace\n\t  // chars). The visually param controls whether, in right-to-left\n\t  // text, direction 1 means to move towards the next index in the\n\t  // string, or towards the character to the right of the current\n\t  // position. The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosH(doc, pos, dir, unit, visually) {\n\t    var line = pos.line, ch = pos.ch, origDir = dir;\n\t    var lineObj = getLine(doc, line);\n\t    function findNextLine() {\n\t      var l = line + dir;\n\t      if (l < doc.first || l >= doc.first + doc.size) return false\n\t      line = l;\n\t      return lineObj = getLine(doc, l);\n\t    }\n\t    function moveOnce(boundToLine) {\n\t      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n\t      if (next == null) {\n\t        if (!boundToLine && findNextLine()) {\n\t          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n\t          else ch = dir < 0 ? lineObj.text.length : 0;\n\t        } else return false\n\t      } else ch = next;\n\t      return true;\n\t    }\n\t\n\t    if (unit == \"char\") {\n\t      moveOnce()\n\t    } else if (unit == \"column\") {\n\t      moveOnce(true)\n\t    } else if (unit == \"word\" || unit == \"group\") {\n\t      var sawType = null, group = unit == \"group\";\n\t      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n\t      for (var first = true;; first = false) {\n\t        if (dir < 0 && !moveOnce(!first)) break;\n\t        var cur = lineObj.text.charAt(ch) || \"\\n\";\n\t        var type = isWordChar(cur, helper) ? \"w\"\n\t          : group && cur == \"\\n\" ? \"n\"\n\t          : !group || /\\s/.test(cur) ? null\n\t          : \"p\";\n\t        if (group && !first && !type) type = \"s\";\n\t        if (sawType && sawType != type) {\n\t          if (dir < 0) {dir = 1; moveOnce();}\n\t          break;\n\t        }\n\t\n\t        if (type) sawType = type;\n\t        if (dir > 0 && !moveOnce(!first)) break;\n\t      }\n\t    }\n\t    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);\n\t    if (!cmp(pos, result)) result.hitSide = true;\n\t    return result;\n\t  }\n\t\n\t  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n\t  // \"page\" or \"line\". The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosV(cm, pos, dir, unit) {\n\t    var doc = cm.doc, x = pos.left, y;\n\t    if (unit == \"page\") {\n\t      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n\t      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n\t    } else if (unit == \"line\") {\n\t      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n\t    }\n\t    for (;;) {\n\t      var target = coordsChar(cm, x, y);\n\t      if (!target.outside) break;\n\t      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n\t      y += dir * 5;\n\t    }\n\t    return target;\n\t  }\n\t\n\t  // EDITOR METHODS\n\t\n\t  // The publicly visible API. Note that methodOp(f) means\n\t  // 'wrap f in an operation, performed on its `this` parameter'.\n\t\n\t  // This is not the complete set of editor methods. Most of the\n\t  // methods defined on the Doc type are also injected into\n\t  // CodeMirror.prototype, for backwards compatibility and\n\t  // convenience.\n\t\n\t  CodeMirror.prototype = {\n\t    constructor: CodeMirror,\n\t    focus: function(){window.focus(); this.display.input.focus();},\n\t\n\t    setOption: function(option, value) {\n\t      var options = this.options, old = options[option];\n\t      if (options[option] == value && option != \"mode\") return;\n\t      options[option] = value;\n\t      if (optionHandlers.hasOwnProperty(option))\n\t        operation(this, optionHandlers[option])(this, value, old);\n\t    },\n\t\n\t    getOption: function(option) {return this.options[option];},\n\t    getDoc: function() {return this.doc;},\n\t\n\t    addKeyMap: function(map, bottom) {\n\t      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n\t    },\n\t    removeKeyMap: function(map) {\n\t      var maps = this.state.keyMaps;\n\t      for (var i = 0; i < maps.length; ++i)\n\t        if (maps[i] == map || maps[i].name == map) {\n\t          maps.splice(i, 1);\n\t          return true;\n\t        }\n\t    },\n\t\n\t    addOverlay: methodOp(function(spec, options) {\n\t      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\t      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n\t      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n\t      this.state.modeGen++;\n\t      regChange(this);\n\t    }),\n\t    removeOverlay: methodOp(function(spec) {\n\t      var overlays = this.state.overlays;\n\t      for (var i = 0; i < overlays.length; ++i) {\n\t        var cur = overlays[i].modeSpec;\n\t        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n\t          overlays.splice(i, 1);\n\t          this.state.modeGen++;\n\t          regChange(this);\n\t          return;\n\t        }\n\t      }\n\t    }),\n\t\n\t    indentLine: methodOp(function(n, dir, aggressive) {\n\t      if (typeof dir != \"string\" && typeof dir != \"number\") {\n\t        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n\t        else dir = dir ? \"add\" : \"subtract\";\n\t      }\n\t      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n\t    }),\n\t    indentSelection: methodOp(function(how) {\n\t      var ranges = this.doc.sel.ranges, end = -1;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (!range.empty()) {\n\t          var from = range.from(), to = range.to();\n\t          var start = Math.max(end, from.line);\n\t          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n\t          for (var j = start; j < end; ++j)\n\t            indentLine(this, j, how);\n\t          var newRanges = this.doc.sel.ranges;\n\t          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n\t            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n\t        } else if (range.head.line > end) {\n\t          indentLine(this, range.head.line, how, true);\n\t          end = range.head.line;\n\t          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n\t        }\n\t      }\n\t    }),\n\t\n\t    // Fetch the parser token for a given character. Useful for hacks\n\t    // that want to inspect the mode state (say, for completion).\n\t    getTokenAt: function(pos, precise) {\n\t      return takeToken(this, pos, precise);\n\t    },\n\t\n\t    getLineTokens: function(line, precise) {\n\t      return takeToken(this, Pos(line), precise, true);\n\t    },\n\t\n\t    getTokenTypeAt: function(pos) {\n\t      pos = clipPos(this.doc, pos);\n\t      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n\t      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n\t      var type;\n\t      if (ch == 0) type = styles[2];\n\t      else for (;;) {\n\t        var mid = (before + after) >> 1;\n\t        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n\t        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n\t        else { type = styles[mid * 2 + 2]; break; }\n\t      }\n\t      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n\t      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n\t    },\n\t\n\t    getModeAt: function(pos) {\n\t      var mode = this.doc.mode;\n\t      if (!mode.innerMode) return mode;\n\t      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n\t    },\n\t\n\t    getHelper: function(pos, type) {\n\t      return this.getHelpers(pos, type)[0];\n\t    },\n\t\n\t    getHelpers: function(pos, type) {\n\t      var found = [];\n\t      if (!helpers.hasOwnProperty(type)) return found;\n\t      var help = helpers[type], mode = this.getModeAt(pos);\n\t      if (typeof mode[type] == \"string\") {\n\t        if (help[mode[type]]) found.push(help[mode[type]]);\n\t      } else if (mode[type]) {\n\t        for (var i = 0; i < mode[type].length; i++) {\n\t          var val = help[mode[type][i]];\n\t          if (val) found.push(val);\n\t        }\n\t      } else if (mode.helperType && help[mode.helperType]) {\n\t        found.push(help[mode.helperType]);\n\t      } else if (help[mode.name]) {\n\t        found.push(help[mode.name]);\n\t      }\n\t      for (var i = 0; i < help._global.length; i++) {\n\t        var cur = help._global[i];\n\t        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n\t          found.push(cur.val);\n\t      }\n\t      return found;\n\t    },\n\t\n\t    getStateAfter: function(line, precise) {\n\t      var doc = this.doc;\n\t      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n\t      return getStateBefore(this, line + 1, precise);\n\t    },\n\t\n\t    cursorCoords: function(start, mode) {\n\t      var pos, range = this.doc.sel.primary();\n\t      if (start == null) pos = range.head;\n\t      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n\t      else pos = start ? range.from() : range.to();\n\t      return cursorCoords(this, pos, mode || \"page\");\n\t    },\n\t\n\t    charCoords: function(pos, mode) {\n\t      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n\t    },\n\t\n\t    coordsChar: function(coords, mode) {\n\t      coords = fromCoordSystem(this, coords, mode || \"page\");\n\t      return coordsChar(this, coords.left, coords.top);\n\t    },\n\t\n\t    lineAtHeight: function(height, mode) {\n\t      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n\t      return lineAtHeight(this.doc, height + this.display.viewOffset);\n\t    },\n\t    heightAtLine: function(line, mode) {\n\t      var end = false, lineObj;\n\t      if (typeof line == \"number\") {\n\t        var last = this.doc.first + this.doc.size - 1;\n\t        if (line < this.doc.first) line = this.doc.first;\n\t        else if (line > last) { line = last; end = true; }\n\t        lineObj = getLine(this.doc, line);\n\t      } else {\n\t        lineObj = line;\n\t      }\n\t      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n\t        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n\t    },\n\t\n\t    defaultTextHeight: function() { return textHeight(this.display); },\n\t    defaultCharWidth: function() { return charWidth(this.display); },\n\t\n\t    setGutterMarker: methodOp(function(line, gutterID, value) {\n\t      return changeLine(this.doc, line, \"gutter\", function(line) {\n\t        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n\t        markers[gutterID] = value;\n\t        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    clearGutter: methodOp(function(gutterID) {\n\t      var cm = this, doc = cm.doc, i = doc.first;\n\t      doc.iter(function(line) {\n\t        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n\t          line.gutterMarkers[gutterID] = null;\n\t          regLineChange(cm, i, \"gutter\");\n\t          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n\t        }\n\t        ++i;\n\t      });\n\t    }),\n\t\n\t    lineInfo: function(line) {\n\t      if (typeof line == \"number\") {\n\t        if (!isLine(this.doc, line)) return null;\n\t        var n = line;\n\t        line = getLine(this.doc, line);\n\t        if (!line) return null;\n\t      } else {\n\t        var n = lineNo(line);\n\t        if (n == null) return null;\n\t      }\n\t      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n\t              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n\t              widgets: line.widgets};\n\t    },\n\t\n\t    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\t\n\t    addWidget: function(pos, node, scroll, vert, horiz) {\n\t      var display = this.display;\n\t      pos = cursorCoords(this, clipPos(this.doc, pos));\n\t      var top = pos.bottom, left = pos.left;\n\t      node.style.position = \"absolute\";\n\t      node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      this.display.input.setUneditable(node);\n\t      display.sizer.appendChild(node);\n\t      if (vert == \"over\") {\n\t        top = pos.top;\n\t      } else if (vert == \"above\" || vert == \"near\") {\n\t        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n\t        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n\t        // Default to positioning above (if specified and possible); otherwise default to positioning below\n\t        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n\t          top = pos.top - node.offsetHeight;\n\t        else if (pos.bottom + node.offsetHeight <= vspace)\n\t          top = pos.bottom;\n\t        if (left + node.offsetWidth > hspace)\n\t          left = hspace - node.offsetWidth;\n\t      }\n\t      node.style.top = top + \"px\";\n\t      node.style.left = node.style.right = \"\";\n\t      if (horiz == \"right\") {\n\t        left = display.sizer.clientWidth - node.offsetWidth;\n\t        node.style.right = \"0px\";\n\t      } else {\n\t        if (horiz == \"left\") left = 0;\n\t        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n\t        node.style.left = left + \"px\";\n\t      }\n\t      if (scroll)\n\t        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n\t    },\n\t\n\t    triggerOnKeyDown: methodOp(onKeyDown),\n\t    triggerOnKeyPress: methodOp(onKeyPress),\n\t    triggerOnKeyUp: onKeyUp,\n\t\n\t    execCommand: function(cmd) {\n\t      if (commands.hasOwnProperty(cmd))\n\t        return commands[cmd].call(null, this);\n\t    },\n\t\n\t    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\t\n\t    findPosH: function(from, amount, unit, visually) {\n\t      var dir = 1;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        cur = findPosH(this.doc, cur, dir, unit, visually);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveH: methodOp(function(dir, unit) {\n\t      var cm = this;\n\t      cm.extendSelectionsBy(function(range) {\n\t        if (cm.display.shift || cm.doc.extend || range.empty())\n\t          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n\t        else\n\t          return dir < 0 ? range.from() : range.to();\n\t      }, sel_move);\n\t    }),\n\t\n\t    deleteH: methodOp(function(dir, unit) {\n\t      var sel = this.doc.sel, doc = this.doc;\n\t      if (sel.somethingSelected())\n\t        doc.replaceSelection(\"\", null, \"+delete\");\n\t      else\n\t        deleteNearSelection(this, function(range) {\n\t          var other = findPosH(doc, range.head, dir, unit, false);\n\t          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n\t        });\n\t    }),\n\t\n\t    findPosV: function(from, amount, unit, goalColumn) {\n\t      var dir = 1, x = goalColumn;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        var coords = cursorCoords(this, cur, \"div\");\n\t        if (x == null) x = coords.left;\n\t        else coords.left = x;\n\t        cur = findPosV(this, coords, dir, unit);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveV: methodOp(function(dir, unit) {\n\t      var cm = this, doc = this.doc, goals = [];\n\t      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n\t      doc.extendSelectionsBy(function(range) {\n\t        if (collapse)\n\t          return dir < 0 ? range.from() : range.to();\n\t        var headPos = cursorCoords(cm, range.head, \"div\");\n\t        if (range.goalColumn != null) headPos.left = range.goalColumn;\n\t        goals.push(headPos.left);\n\t        var pos = findPosV(cm, headPos, dir, unit);\n\t        if (unit == \"page\" && range == doc.sel.primary())\n\t          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n\t        return pos;\n\t      }, sel_move);\n\t      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n\t        doc.sel.ranges[i].goalColumn = goals[i];\n\t    }),\n\t\n\t    // Find the word at the given position (as returned by coordsChar).\n\t    findWordAt: function(pos) {\n\t      var doc = this.doc, line = getLine(doc, pos.line).text;\n\t      var start = pos.ch, end = pos.ch;\n\t      if (line) {\n\t        var helper = this.getHelper(pos, \"wordChars\");\n\t        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n\t        var startChar = line.charAt(start);\n\t        var check = isWordChar(startChar, helper)\n\t          ? function(ch) { return isWordChar(ch, helper); }\n\t          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n\t          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n\t        while (start > 0 && check(line.charAt(start - 1))) --start;\n\t        while (end < line.length && check(line.charAt(end))) ++end;\n\t      }\n\t      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n\t    },\n\t\n\t    toggleOverwrite: function(value) {\n\t      if (value != null && value == this.state.overwrite) return;\n\t      if (this.state.overwrite = !this.state.overwrite)\n\t        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t      else\n\t        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t\n\t      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n\t    },\n\t    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n\t    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },\n\t\n\t    scrollTo: methodOp(function(x, y) {\n\t      if (x != null || y != null) resolveScrollToPos(this);\n\t      if (x != null) this.curOp.scrollLeft = x;\n\t      if (y != null) this.curOp.scrollTop = y;\n\t    }),\n\t    getScrollInfo: function() {\n\t      var scroller = this.display.scroller;\n\t      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n\t              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n\t              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n\t              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n\t    },\n\t\n\t    scrollIntoView: methodOp(function(range, margin) {\n\t      if (range == null) {\n\t        range = {from: this.doc.sel.primary().head, to: null};\n\t        if (margin == null) margin = this.options.cursorScrollMargin;\n\t      } else if (typeof range == \"number\") {\n\t        range = {from: Pos(range, 0), to: null};\n\t      } else if (range.from == null) {\n\t        range = {from: range, to: null};\n\t      }\n\t      if (!range.to) range.to = range.from;\n\t      range.margin = margin || 0;\n\t\n\t      if (range.from.line != null) {\n\t        resolveScrollToPos(this);\n\t        this.curOp.scrollToPos = range;\n\t      } else {\n\t        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n\t                                      Math.min(range.from.top, range.to.top) - range.margin,\n\t                                      Math.max(range.from.right, range.to.right),\n\t                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n\t        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t      }\n\t    }),\n\t\n\t    setSize: methodOp(function(width, height) {\n\t      var cm = this;\n\t      function interpret(val) {\n\t        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n\t      }\n\t      if (width != null) cm.display.wrapper.style.width = interpret(width);\n\t      if (height != null) cm.display.wrapper.style.height = interpret(height);\n\t      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n\t      var lineNo = cm.display.viewFrom;\n\t      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n\t        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n\t          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n\t        ++lineNo;\n\t      });\n\t      cm.curOp.forceUpdate = true;\n\t      signal(cm, \"refresh\", this);\n\t    }),\n\t\n\t    operation: function(f){return runInOp(this, f);},\n\t\n\t    refresh: methodOp(function() {\n\t      var oldHeight = this.display.cachedTextHeight;\n\t      regChange(this);\n\t      this.curOp.forceUpdate = true;\n\t      clearCaches(this);\n\t      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n\t      updateGutterSpace(this);\n\t      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n\t        estimateLineHeights(this);\n\t      signal(this, \"refresh\", this);\n\t    }),\n\t\n\t    swapDoc: methodOp(function(doc) {\n\t      var old = this.doc;\n\t      old.cm = null;\n\t      attachDoc(this, doc);\n\t      clearCaches(this);\n\t      this.display.input.reset();\n\t      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n\t      this.curOp.forceScroll = true;\n\t      signalLater(this, \"swapDoc\", this, old);\n\t      return old;\n\t    }),\n\t\n\t    getInputField: function(){return this.display.input.getField();},\n\t    getWrapperElement: function(){return this.display.wrapper;},\n\t    getScrollerElement: function(){return this.display.scroller;},\n\t    getGutterElement: function(){return this.display.gutters;}\n\t  };\n\t  eventMixin(CodeMirror);\n\t\n\t  // OPTION DEFAULTS\n\t\n\t  // The default configuration options.\n\t  var defaults = CodeMirror.defaults = {};\n\t  // Functions to run when options are changed.\n\t  var optionHandlers = CodeMirror.optionHandlers = {};\n\t\n\t  function option(name, deflt, handle, notOnInit) {\n\t    CodeMirror.defaults[name] = deflt;\n\t    if (handle) optionHandlers[name] =\n\t      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n\t  }\n\t\n\t  // Passed to option handlers when there is no old value.\n\t  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\t\n\t  // These two are, on init, called from the constructor because they\n\t  // have to be initialized before the editor can start at all.\n\t  option(\"value\", \"\", function(cm, val) {\n\t    cm.setValue(val);\n\t  }, true);\n\t  option(\"mode\", null, function(cm, val) {\n\t    cm.doc.modeOption = val;\n\t    loadMode(cm);\n\t  }, true);\n\t\n\t  option(\"indentUnit\", 2, loadMode, true);\n\t  option(\"indentWithTabs\", false);\n\t  option(\"smartIndent\", true);\n\t  option(\"tabSize\", 4, function(cm) {\n\t    resetModeState(cm);\n\t    clearCaches(cm);\n\t    regChange(cm);\n\t  }, true);\n\t  option(\"lineSeparator\", null, function(cm, val) {\n\t    cm.doc.lineSep = val;\n\t    if (!val) return;\n\t    var newBreaks = [], lineNo = cm.doc.first;\n\t    cm.doc.iter(function(line) {\n\t      for (var pos = 0;;) {\n\t        var found = line.text.indexOf(val, pos);\n\t        if (found == -1) break;\n\t        pos = found + val.length;\n\t        newBreaks.push(Pos(lineNo, found));\n\t      }\n\t      lineNo++;\n\t    });\n\t    for (var i = newBreaks.length - 1; i >= 0; i--)\n\t      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n\t  });\n\t  option(\"specialChars\", /[\\u0000-\\u001f\\u007f\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n\t    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\t    if (old != CodeMirror.Init) cm.refresh();\n\t  });\n\t  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n\t  option(\"electricChars\", true);\n\t  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n\t    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n\t  }, true);\n\t  option(\"rtlMoveVisually\", !windows);\n\t  option(\"wholeLineUpdateBefore\", true);\n\t\n\t  option(\"theme\", \"default\", function(cm) {\n\t    themeChanged(cm);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"keyMap\", \"default\", function(cm, val, old) {\n\t    var next = getKeyMap(val);\n\t    var prev = old != CodeMirror.Init && getKeyMap(old);\n\t    if (prev && prev.detach) prev.detach(cm, next);\n\t    if (next.attach) next.attach(cm, prev || null);\n\t  });\n\t  option(\"extraKeys\", null);\n\t\n\t  option(\"lineWrapping\", false, wrappingChanged, true);\n\t  option(\"gutters\", [], function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"fixedGutter\", true, function(cm, val) {\n\t    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n\t    cm.refresh();\n\t  }, true);\n\t  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n\t  option(\"scrollbarStyle\", \"native\", function(cm) {\n\t    initScrollbars(cm);\n\t    updateScrollbars(cm);\n\t    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n\t    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n\t  }, true);\n\t  option(\"lineNumbers\", false, function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"firstLineNumber\", 1, guttersChanged, true);\n\t  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n\t  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\t\n\t  option(\"resetSelectionOnContextMenu\", true);\n\t  option(\"lineWiseCopyCut\", true);\n\t\n\t  option(\"readOnly\", false, function(cm, val) {\n\t    if (val == \"nocursor\") {\n\t      onBlur(cm);\n\t      cm.display.input.blur();\n\t      cm.display.disabled = true;\n\t    } else {\n\t      cm.display.disabled = false;\n\t    }\n\t    cm.display.input.readOnlyChanged(val)\n\t  });\n\t  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n\t  option(\"dragDrop\", true, dragDropChanged);\n\t  option(\"allowDropFileTypes\", null);\n\t\n\t  option(\"cursorBlinkRate\", 530);\n\t  option(\"cursorScrollMargin\", 0);\n\t  option(\"cursorHeight\", 1, updateSelection, true);\n\t  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n\t  option(\"workTime\", 100);\n\t  option(\"workDelay\", 100);\n\t  option(\"flattenSpans\", true, resetModeState, true);\n\t  option(\"addModeClass\", false, resetModeState, true);\n\t  option(\"pollInterval\", 100);\n\t  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n\t  option(\"historyEventDelay\", 1250);\n\t  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n\t  option(\"maxHighlightLength\", 10000, resetModeState, true);\n\t  option(\"moveInputWithCursor\", true, function(cm, val) {\n\t    if (!val) cm.display.input.resetPosition();\n\t  });\n\t\n\t  option(\"tabindex\", null, function(cm, val) {\n\t    cm.display.input.getField().tabIndex = val || \"\";\n\t  });\n\t  option(\"autofocus\", null);\n\t\n\t  // MODE DEFINITION AND QUERYING\n\t\n\t  // Known modes, by name and by MIME\n\t  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\t\n\t  // Extra arguments are stored as the mode's dependencies, which is\n\t  // used by (legacy) mechanisms like loadmode.js to automatically\n\t  // load a mode. (Preferred mechanism is the require/define calls.)\n\t  CodeMirror.defineMode = function(name, mode) {\n\t    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n\t    if (arguments.length > 2)\n\t      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n\t    modes[name] = mode;\n\t  };\n\t\n\t  CodeMirror.defineMIME = function(mime, spec) {\n\t    mimeModes[mime] = spec;\n\t  };\n\t\n\t  // Given a MIME type, a {name, ...options} config object, or a name\n\t  // string, return a mode config object.\n\t  CodeMirror.resolveMode = function(spec) {\n\t    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n\t      spec = mimeModes[spec];\n\t    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n\t      var found = mimeModes[spec.name];\n\t      if (typeof found == \"string\") found = {name: found};\n\t      spec = createObj(found, spec);\n\t      spec.name = found.name;\n\t    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n\t      return CodeMirror.resolveMode(\"application/xml\");\n\t    }\n\t    if (typeof spec == \"string\") return {name: spec};\n\t    else return spec || {name: \"null\"};\n\t  };\n\t\n\t  // Given a mode spec (anything that resolveMode accepts), find and\n\t  // initialize an actual mode object.\n\t  CodeMirror.getMode = function(options, spec) {\n\t    var spec = CodeMirror.resolveMode(spec);\n\t    var mfactory = modes[spec.name];\n\t    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n\t    var modeObj = mfactory(options, spec);\n\t    if (modeExtensions.hasOwnProperty(spec.name)) {\n\t      var exts = modeExtensions[spec.name];\n\t      for (var prop in exts) {\n\t        if (!exts.hasOwnProperty(prop)) continue;\n\t        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n\t        modeObj[prop] = exts[prop];\n\t      }\n\t    }\n\t    modeObj.name = spec.name;\n\t    if (spec.helperType) modeObj.helperType = spec.helperType;\n\t    if (spec.modeProps) for (var prop in spec.modeProps)\n\t      modeObj[prop] = spec.modeProps[prop];\n\t\n\t    return modeObj;\n\t  };\n\t\n\t  // Minimal default mode.\n\t  CodeMirror.defineMode(\"null\", function() {\n\t    return {token: function(stream) {stream.skipToEnd();}};\n\t  });\n\t  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\t\n\t  // This can be used to attach properties to mode objects from\n\t  // outside the actual mode definition.\n\t  var modeExtensions = CodeMirror.modeExtensions = {};\n\t  CodeMirror.extendMode = function(mode, properties) {\n\t    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n\t    copyObj(properties, exts);\n\t  };\n\t\n\t  // EXTENSIONS\n\t\n\t  CodeMirror.defineExtension = function(name, func) {\n\t    CodeMirror.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineDocExtension = function(name, func) {\n\t    Doc.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineOption = option;\n\t\n\t  var initHooks = [];\n\t  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\t\n\t  var helpers = CodeMirror.helpers = {};\n\t  CodeMirror.registerHelper = function(type, name, value) {\n\t    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n\t    helpers[type][name] = value;\n\t  };\n\t  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n\t    CodeMirror.registerHelper(type, name, value);\n\t    helpers[type]._global.push({pred: predicate, val: value});\n\t  };\n\t\n\t  // MODE STATE HANDLING\n\t\n\t  // Utility functions for working with state. Exported because nested\n\t  // modes need to do this for their inner modes.\n\t\n\t  var copyState = CodeMirror.copyState = function(mode, state) {\n\t    if (state === true) return state;\n\t    if (mode.copyState) return mode.copyState(state);\n\t    var nstate = {};\n\t    for (var n in state) {\n\t      var val = state[n];\n\t      if (val instanceof Array) val = val.concat([]);\n\t      nstate[n] = val;\n\t    }\n\t    return nstate;\n\t  };\n\t\n\t  var startState = CodeMirror.startState = function(mode, a1, a2) {\n\t    return mode.startState ? mode.startState(a1, a2) : true;\n\t  };\n\t\n\t  // Given a mode and a state (for that mode), find the inner mode and\n\t  // state at the position that the state refers to.\n\t  CodeMirror.innerMode = function(mode, state) {\n\t    while (mode.innerMode) {\n\t      var info = mode.innerMode(state);\n\t      if (!info || info.mode == mode) break;\n\t      state = info.state;\n\t      mode = info.mode;\n\t    }\n\t    return info || {mode: mode, state: state};\n\t  };\n\t\n\t  // STANDARD COMMANDS\n\t\n\t  // Commands are parameter-less actions that can be performed on an\n\t  // editor, mostly used for keybindings.\n\t  var commands = CodeMirror.commands = {\n\t    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n\t    singleSelection: function(cm) {\n\t      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n\t    },\n\t    killLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        if (range.empty()) {\n\t          var len = getLine(cm.doc, range.head.line).text.length;\n\t          if (range.head.ch == len && range.head.line < cm.lastLine())\n\t            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n\t          else\n\t            return {from: range.head, to: Pos(range.head.line, len)};\n\t        } else {\n\t          return {from: range.from(), to: range.to()};\n\t        }\n\t      });\n\t    },\n\t    deleteLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0),\n\t                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n\t      });\n\t    },\n\t    delLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0), to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        return {from: leftPos, to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineRight: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t        return {from: range.from(), to: rightPos };\n\t      });\n\t    },\n\t    undo: function(cm) {cm.undo();},\n\t    redo: function(cm) {cm.redo();},\n\t    undoSelection: function(cm) {cm.undoSelection();},\n\t    redoSelection: function(cm) {cm.redoSelection();},\n\t    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n\t    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n\t    goLineStart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineStartSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        return lineStartSmart(cm, range.head);\n\t      }, {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineEnd: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: -1});\n\t    },\n\t    goLineRight: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeft: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: 0, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeftSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n\t        return pos;\n\t      }, sel_move);\n\t    },\n\t    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n\t    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n\t    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n\t    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n\t    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n\t    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n\t    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n\t    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n\t    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n\t    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n\t    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n\t    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n\t    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n\t    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n\t    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n\t    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n\t    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n\t    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n\t    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n\t    indentMore: function(cm) {cm.indentSelection(\"add\");},\n\t    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n\t    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n\t    insertSoftTab: function(cm) {\n\t      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var pos = ranges[i].from();\n\t        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n\t        spaces.push(spaceStr(tabSize - col % tabSize));\n\t      }\n\t      cm.replaceSelections(spaces);\n\t    },\n\t    defaultTab: function(cm) {\n\t      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n\t      else cm.execCommand(\"insertTab\");\n\t    },\n\t    transposeChars: function(cm) {\n\t      runInOp(cm, function() {\n\t        var ranges = cm.listSelections(), newSel = [];\n\t        for (var i = 0; i < ranges.length; i++) {\n\t          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n\t          if (line) {\n\t            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n\t            if (cur.ch > 0) {\n\t              cur = new Pos(cur.line, cur.ch + 1);\n\t              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n\t                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n\t            } else if (cur.line > cm.doc.first) {\n\t              var prev = getLine(cm.doc, cur.line - 1).text;\n\t              if (prev)\n\t                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n\t                                prev.charAt(prev.length - 1),\n\t                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n\t            }\n\t          }\n\t          newSel.push(new Range(cur, cur));\n\t        }\n\t        cm.setSelections(newSel);\n\t      });\n\t    },\n\t    newlineAndIndent: function(cm) {\n\t      runInOp(cm, function() {\n\t        var len = cm.listSelections().length;\n\t        for (var i = 0; i < len; i++) {\n\t          var range = cm.listSelections()[i];\n\t          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n\t          cm.indentLine(range.from().line + 1, null, true);\n\t        }\n\t        ensureCursorVisible(cm);\n\t      });\n\t    },\n\t    openLine: function(cm) {cm.replaceSelection(\"\\n\", \"start\")},\n\t    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n\t  };\n\t\n\t\n\t  // STANDARD KEYMAPS\n\t\n\t  var keyMap = CodeMirror.keyMap = {};\n\t\n\t  keyMap.basic = {\n\t    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n\t    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n\t    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n\t    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n\t    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n\t    \"Esc\": \"singleSelection\"\n\t  };\n\t  // Note that the save and find-related commands aren't defined by\n\t  // default. User code or addons can define them. Unknown commands\n\t  // are simply ignored.\n\t  keyMap.pcDefault = {\n\t    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n\t    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n\t    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n\t    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n\t    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n\t    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n\t    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n\t    fallthrough: \"basic\"\n\t  };\n\t  // Very basic readline/emacs-style bindings, which are standard on Mac.\n\t  keyMap.emacsy = {\n\t    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n\t    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n\t    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n\t    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n\t    \"Ctrl-O\": \"openLine\"\n\t  };\n\t  keyMap.macDefault = {\n\t    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n\t    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n\t    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n\t    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n\t    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n\t    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n\t    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n\t    fallthrough: [\"basic\", \"emacsy\"]\n\t  };\n\t  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\t\n\t  // KEYMAP DISPATCH\n\t\n\t  function normalizeKeyName(name) {\n\t    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n\t    var alt, ctrl, shift, cmd;\n\t    for (var i = 0; i < parts.length - 1; i++) {\n\t      var mod = parts[i];\n\t      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n\t      else if (/^a(lt)?$/i.test(mod)) alt = true;\n\t      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n\t      else if (/^s(hift)$/i.test(mod)) shift = true;\n\t      else throw new Error(\"Unrecognized modifier name: \" + mod);\n\t    }\n\t    if (alt) name = \"Alt-\" + name;\n\t    if (ctrl) name = \"Ctrl-\" + name;\n\t    if (cmd) name = \"Cmd-\" + name;\n\t    if (shift) name = \"Shift-\" + name;\n\t    return name;\n\t  }\n\t\n\t  // This is a kludge to keep keymaps mostly working as raw objects\n\t  // (backwards compatibility) while at the same time support features\n\t  // like normalization and multi-stroke key bindings. It compiles a\n\t  // new normalized keymap, and then updates the old object to reflect\n\t  // this.\n\t  CodeMirror.normalizeKeyMap = function(keymap) {\n\t    var copy = {};\n\t    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n\t      var value = keymap[keyname];\n\t      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n\t      if (value == \"...\") { delete keymap[keyname]; continue; }\n\t\n\t      var keys = map(keyname.split(\" \"), normalizeKeyName);\n\t      for (var i = 0; i < keys.length; i++) {\n\t        var val, name;\n\t        if (i == keys.length - 1) {\n\t          name = keys.join(\" \");\n\t          val = value;\n\t        } else {\n\t          name = keys.slice(0, i + 1).join(\" \");\n\t          val = \"...\";\n\t        }\n\t        var prev = copy[name];\n\t        if (!prev) copy[name] = val;\n\t        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n\t      }\n\t      delete keymap[keyname];\n\t    }\n\t    for (var prop in copy) keymap[prop] = copy[prop];\n\t    return keymap;\n\t  };\n\t\n\t  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n\t    map = getKeyMap(map);\n\t    var found = map.call ? map.call(key, context) : map[key];\n\t    if (found === false) return \"nothing\";\n\t    if (found === \"...\") return \"multi\";\n\t    if (found != null && handle(found)) return \"handled\";\n\t\n\t    if (map.fallthrough) {\n\t      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n\t        return lookupKey(key, map.fallthrough, handle, context);\n\t      for (var i = 0; i < map.fallthrough.length; i++) {\n\t        var result = lookupKey(key, map.fallthrough[i], handle, context);\n\t        if (result) return result;\n\t      }\n\t    }\n\t  };\n\t\n\t  // Modifier key presses don't count as 'real' key presses for the\n\t  // purpose of keymap fallthrough.\n\t  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n\t    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n\t    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n\t  };\n\t\n\t  // Look up the name of a key as indicated by an event object.\n\t  var keyName = CodeMirror.keyName = function(event, noShift) {\n\t    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n\t    var base = keyNames[event.keyCode], name = base;\n\t    if (name == null || event.altGraphKey) return false;\n\t    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n\t    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n\t    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n\t    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n\t    return name;\n\t  };\n\t\n\t  function getKeyMap(val) {\n\t    return typeof val == \"string\" ? keyMap[val] : val;\n\t  }\n\t\n\t  // FROMTEXTAREA\n\t\n\t  CodeMirror.fromTextArea = function(textarea, options) {\n\t    options = options ? copyObj(options) : {};\n\t    options.value = textarea.value;\n\t    if (!options.tabindex && textarea.tabIndex)\n\t      options.tabindex = textarea.tabIndex;\n\t    if (!options.placeholder && textarea.placeholder)\n\t      options.placeholder = textarea.placeholder;\n\t    // Set autofocus to true if this textarea is focused, or if it has\n\t    // autofocus and no other element is focused.\n\t    if (options.autofocus == null) {\n\t      var hasFocus = activeElt();\n\t      options.autofocus = hasFocus == textarea ||\n\t        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n\t    }\n\t\n\t    function save() {textarea.value = cm.getValue();}\n\t    if (textarea.form) {\n\t      on(textarea.form, \"submit\", save);\n\t      // Deplorable hack to make the submit method do the right thing.\n\t      if (!options.leaveSubmitMethodAlone) {\n\t        var form = textarea.form, realSubmit = form.submit;\n\t        try {\n\t          var wrappedSubmit = form.submit = function() {\n\t            save();\n\t            form.submit = realSubmit;\n\t            form.submit();\n\t            form.submit = wrappedSubmit;\n\t          };\n\t        } catch(e) {}\n\t      }\n\t    }\n\t\n\t    options.finishInit = function(cm) {\n\t      cm.save = save;\n\t      cm.getTextArea = function() { return textarea; };\n\t      cm.toTextArea = function() {\n\t        cm.toTextArea = isNaN; // Prevent this from being ran twice\n\t        save();\n\t        textarea.parentNode.removeChild(cm.getWrapperElement());\n\t        textarea.style.display = \"\";\n\t        if (textarea.form) {\n\t          off(textarea.form, \"submit\", save);\n\t          if (typeof textarea.form.submit == \"function\")\n\t            textarea.form.submit = realSubmit;\n\t        }\n\t      };\n\t    };\n\t\n\t    textarea.style.display = \"none\";\n\t    var cm = CodeMirror(function(node) {\n\t      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n\t    }, options);\n\t    return cm;\n\t  };\n\t\n\t  // STRING STREAM\n\t\n\t  // Fed to the mode parsers, provides helper functions to make\n\t  // parsers more succinct.\n\t\n\t  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n\t    this.pos = this.start = 0;\n\t    this.string = string;\n\t    this.tabSize = tabSize || 8;\n\t    this.lastColumnPos = this.lastColumnValue = 0;\n\t    this.lineStart = 0;\n\t  };\n\t\n\t  StringStream.prototype = {\n\t    eol: function() {return this.pos >= this.string.length;},\n\t    sol: function() {return this.pos == this.lineStart;},\n\t    peek: function() {return this.string.charAt(this.pos) || undefined;},\n\t    next: function() {\n\t      if (this.pos < this.string.length)\n\t        return this.string.charAt(this.pos++);\n\t    },\n\t    eat: function(match) {\n\t      var ch = this.string.charAt(this.pos);\n\t      if (typeof match == \"string\") var ok = ch == match;\n\t      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\t      if (ok) {++this.pos; return ch;}\n\t    },\n\t    eatWhile: function(match) {\n\t      var start = this.pos;\n\t      while (this.eat(match)){}\n\t      return this.pos > start;\n\t    },\n\t    eatSpace: function() {\n\t      var start = this.pos;\n\t      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n\t      return this.pos > start;\n\t    },\n\t    skipToEnd: function() {this.pos = this.string.length;},\n\t    skipTo: function(ch) {\n\t      var found = this.string.indexOf(ch, this.pos);\n\t      if (found > -1) {this.pos = found; return true;}\n\t    },\n\t    backUp: function(n) {this.pos -= n;},\n\t    column: function() {\n\t      if (this.lastColumnPos < this.start) {\n\t        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n\t        this.lastColumnPos = this.start;\n\t      }\n\t      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    indentation: function() {\n\t      return countColumn(this.string, null, this.tabSize) -\n\t        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    match: function(pattern, consume, caseInsensitive) {\n\t      if (typeof pattern == \"string\") {\n\t        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n\t        var substr = this.string.substr(this.pos, pattern.length);\n\t        if (cased(substr) == cased(pattern)) {\n\t          if (consume !== false) this.pos += pattern.length;\n\t          return true;\n\t        }\n\t      } else {\n\t        var match = this.string.slice(this.pos).match(pattern);\n\t        if (match && match.index > 0) return null;\n\t        if (match && consume !== false) this.pos += match[0].length;\n\t        return match;\n\t      }\n\t    },\n\t    current: function(){return this.string.slice(this.start, this.pos);},\n\t    hideFirstChars: function(n, inner) {\n\t      this.lineStart += n;\n\t      try { return inner(); }\n\t      finally { this.lineStart -= n; }\n\t    }\n\t  };\n\t\n\t  // TEXTMARKERS\n\t\n\t  // Created with markText and setBookmark methods. A TextMarker is a\n\t  // handle that can be used to clear or find a marked position in the\n\t  // document. Line objects hold arrays (markedSpans) containing\n\t  // {from, to, marker} object pointing to such marker objects, and\n\t  // indicating that such a marker is present on that line. Multiple\n\t  // lines may point to the same marker when it spans across lines.\n\t  // The spans will have null for their from/to properties when the\n\t  // marker continues beyond the start/end of the line. Markers have\n\t  // links back to the lines they currently touch.\n\t\n\t  var nextMarkerId = 0;\n\t\n\t  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n\t    this.lines = [];\n\t    this.type = type;\n\t    this.doc = doc;\n\t    this.id = ++nextMarkerId;\n\t  };\n\t  eventMixin(TextMarker);\n\t\n\t  // Clear the marker.\n\t  TextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n\t    if (withOp) startOperation(cm);\n\t    if (hasHandler(this, \"clear\")) {\n\t      var found = this.find();\n\t      if (found) signalLater(this, \"clear\", found.from, found.to);\n\t    }\n\t    var min = null, max = null;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n\t      else if (cm) {\n\t        if (span.to != null) max = lineNo(line);\n\t        if (span.from != null) min = lineNo(line);\n\t      }\n\t      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\t      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n\t        updateLineHeight(line, textHeight(cm.display));\n\t    }\n\t    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n\t      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n\t      if (len > cm.display.maxLineLength) {\n\t        cm.display.maxLine = visual;\n\t        cm.display.maxLineLength = len;\n\t        cm.display.maxLineChanged = true;\n\t      }\n\t    }\n\t\n\t    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n\t    this.lines.length = 0;\n\t    this.explicitlyCleared = true;\n\t    if (this.atomic && this.doc.cantEdit) {\n\t      this.doc.cantEdit = false;\n\t      if (cm) reCheckSelection(cm.doc);\n\t    }\n\t    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n\t    if (withOp) endOperation(cm);\n\t    if (this.parent) this.parent.clear();\n\t  };\n\t\n\t  // Find the position of the marker in the document. Returns a {from,\n\t  // to} object by default. Side can be passed to get a specific side\n\t  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n\t  // Pos objects returned contain a line object, rather than a line\n\t  // number (used to prevent looking up the same line twice).\n\t  TextMarker.prototype.find = function(side, lineObj) {\n\t    if (side == null && this.type == \"bookmark\") side = 1;\n\t    var from, to;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (span.from != null) {\n\t        from = Pos(lineObj ? line : lineNo(line), span.from);\n\t        if (side == -1) return from;\n\t      }\n\t      if (span.to != null) {\n\t        to = Pos(lineObj ? line : lineNo(line), span.to);\n\t        if (side == 1) return to;\n\t      }\n\t    }\n\t    return from && {from: from, to: to};\n\t  };\n\t\n\t  // Signals that the marker's widget changed, and surrounding layout\n\t  // should be recomputed.\n\t  TextMarker.prototype.changed = function() {\n\t    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n\t    if (!pos || !cm) return;\n\t    runInOp(cm, function() {\n\t      var line = pos.line, lineN = lineNo(pos.line);\n\t      var view = findViewForLine(cm, lineN);\n\t      if (view) {\n\t        clearLineMeasurementCacheFor(view);\n\t        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n\t      }\n\t      cm.curOp.updateMaxLine = true;\n\t      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n\t        var oldHeight = widget.height;\n\t        widget.height = null;\n\t        var dHeight = widgetHeight(widget) - oldHeight;\n\t        if (dHeight)\n\t          updateLineHeight(line, line.height + dHeight);\n\t      }\n\t    });\n\t  };\n\t\n\t  TextMarker.prototype.attachLine = function(line) {\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n\t        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n\t    }\n\t    this.lines.push(line);\n\t  };\n\t  TextMarker.prototype.detachLine = function(line) {\n\t    this.lines.splice(indexOf(this.lines, line), 1);\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n\t    }\n\t  };\n\t\n\t  // Collapsed markers have unique ids, in order to be able to order\n\t  // them, which is needed for uniquely determining an outer marker\n\t  // when they overlap (they may nest, but not partially overlap).\n\t  var nextMarkerId = 0;\n\t\n\t  // Create a marker, wire it up to the right lines, and\n\t  function markText(doc, from, to, options, type) {\n\t    // Shared markers (across linked documents) are handled separately\n\t    // (markTextShared will call out to this again, once per\n\t    // document).\n\t    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n\t    // Ensure we are in an operation.\n\t    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\t\n\t    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n\t    if (options) copyObj(options, marker, false);\n\t    // Don't connect empty markers unless clearWhenEmpty is false\n\t    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n\t      return marker;\n\t    if (marker.replacedWith) {\n\t      // Showing up as a widget implies collapsed (widget replaces text)\n\t      marker.collapsed = true;\n\t      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\t      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n\t      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n\t    }\n\t    if (marker.collapsed) {\n\t      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n\t          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n\t        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n\t      sawCollapsedSpans = true;\n\t    }\n\t\n\t    if (marker.addToHistory)\n\t      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\t\n\t    var curLine = from.line, cm = doc.cm, updateMaxLine;\n\t    doc.iter(curLine, to.line + 1, function(line) {\n\t      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n\t        updateMaxLine = true;\n\t      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n\t      addMarkedSpan(line, new MarkedSpan(marker,\n\t                                         curLine == from.line ? from.ch : null,\n\t                                         curLine == to.line ? to.ch : null));\n\t      ++curLine;\n\t    });\n\t    // lineIsHidden depends on the presence of the spans, so needs a second pass\n\t    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n\t      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n\t    });\n\t\n\t    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\t\n\t    if (marker.readOnly) {\n\t      sawReadOnlySpans = true;\n\t      if (doc.history.done.length || doc.history.undone.length)\n\t        doc.clearHistory();\n\t    }\n\t    if (marker.collapsed) {\n\t      marker.id = ++nextMarkerId;\n\t      marker.atomic = true;\n\t    }\n\t    if (cm) {\n\t      // Sync editor state\n\t      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n\t      if (marker.collapsed)\n\t        regChange(cm, from.line, to.line + 1);\n\t      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n\t        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n\t      if (marker.atomic) reCheckSelection(cm.doc);\n\t      signalLater(cm, \"markerAdded\", cm, marker);\n\t    }\n\t    return marker;\n\t  }\n\t\n\t  // SHARED TEXTMARKERS\n\t\n\t  // A shared marker spans multiple linked documents. It is\n\t  // implemented as a meta-marker-object controlling multiple normal\n\t  // markers.\n\t  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n\t    this.markers = markers;\n\t    this.primary = primary;\n\t    for (var i = 0; i < markers.length; ++i)\n\t      markers[i].parent = this;\n\t  };\n\t  eventMixin(SharedTextMarker);\n\t\n\t  SharedTextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    this.explicitlyCleared = true;\n\t    for (var i = 0; i < this.markers.length; ++i)\n\t      this.markers[i].clear();\n\t    signalLater(this, \"clear\");\n\t  };\n\t  SharedTextMarker.prototype.find = function(side, lineObj) {\n\t    return this.primary.find(side, lineObj);\n\t  };\n\t\n\t  function markTextShared(doc, from, to, options, type) {\n\t    options = copyObj(options);\n\t    options.shared = false;\n\t    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n\t    var widget = options.widgetNode;\n\t    linkedDocs(doc, function(doc) {\n\t      if (widget) options.widgetNode = widget.cloneNode(true);\n\t      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n\t      for (var i = 0; i < doc.linked.length; ++i)\n\t        if (doc.linked[i].isParent) return;\n\t      primary = lst(markers);\n\t    });\n\t    return new SharedTextMarker(markers, primary);\n\t  }\n\t\n\t  function findSharedMarkers(doc) {\n\t    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n\t                         function(m) { return m.parent; });\n\t  }\n\t\n\t  function copySharedMarkers(doc, markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], pos = marker.find();\n\t      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n\t      if (cmp(mFrom, mTo)) {\n\t        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n\t        marker.markers.push(subMark);\n\t        subMark.parent = marker;\n\t      }\n\t    }\n\t  }\n\t\n\t  function detachSharedMarkers(markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], linked = [marker.primary.doc];;\n\t      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n\t      for (var j = 0; j < marker.markers.length; j++) {\n\t        var subMarker = marker.markers[j];\n\t        if (indexOf(linked, subMarker.doc) == -1) {\n\t          subMarker.parent = null;\n\t          marker.markers.splice(j--, 1);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // TEXTMARKER SPANS\n\t\n\t  function MarkedSpan(marker, from, to) {\n\t    this.marker = marker;\n\t    this.from = from; this.to = to;\n\t  }\n\t\n\t  // Search an array of spans for a span matching the given marker.\n\t  function getMarkedSpanFor(spans, marker) {\n\t    if (spans) for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.marker == marker) return span;\n\t    }\n\t  }\n\t  // Remove a span from an array, returning undefined if no spans are\n\t  // left (we don't store arrays for lines without spans).\n\t  function removeMarkedSpan(spans, span) {\n\t    for (var r, i = 0; i < spans.length; ++i)\n\t      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n\t    return r;\n\t  }\n\t  // Add a span to a line.\n\t  function addMarkedSpan(line, span) {\n\t    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n\t    span.marker.attachLine(line);\n\t  }\n\t\n\t  // Used for the algorithm that adjusts markers for a change in the\n\t  // document. These functions cut an array of spans at a given\n\t  // character position, returning an array of remaining chunks (or\n\t  // undefined if nothing remains).\n\t  function markedSpansBefore(old, startCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\t      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n\t        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t  function markedSpansAfter(old, endCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\t      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n\t        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n\t                                              span.to == null ? null : span.to - endCh));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t\n\t  // Given a change object, compute the new set of marker spans that\n\t  // cover the line in which the change took place. Removes spans\n\t  // entirely within the change, reconnects spans belonging to the\n\t  // same marker that appear on both sides of the change, and cuts off\n\t  // spans partially within the change. Returns an array of span\n\t  // arrays with one element for each line in (after) the change.\n\t  function stretchSpansOverChange(doc, change) {\n\t    if (change.full) return null;\n\t    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n\t    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\t    if (!oldFirst && !oldLast) return null;\n\t\n\t    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n\t    // Get the spans that 'stick out' on both sides\n\t    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n\t    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\t\n\t    // Next, merge those two ends\n\t    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n\t    if (first) {\n\t      // Fix up .to properties of first\n\t      for (var i = 0; i < first.length; ++i) {\n\t        var span = first[i];\n\t        if (span.to == null) {\n\t          var found = getMarkedSpanFor(last, span.marker);\n\t          if (!found) span.to = startCh;\n\t          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n\t        }\n\t      }\n\t    }\n\t    if (last) {\n\t      // Fix up .from in last (or move them into first in case of sameLine)\n\t      for (var i = 0; i < last.length; ++i) {\n\t        var span = last[i];\n\t        if (span.to != null) span.to += offset;\n\t        if (span.from == null) {\n\t          var found = getMarkedSpanFor(first, span.marker);\n\t          if (!found) {\n\t            span.from = offset;\n\t            if (sameLine) (first || (first = [])).push(span);\n\t          }\n\t        } else {\n\t          span.from += offset;\n\t          if (sameLine) (first || (first = [])).push(span);\n\t        }\n\t      }\n\t    }\n\t    // Make sure we didn't create any zero-length spans\n\t    if (first) first = clearEmptySpans(first);\n\t    if (last && last != first) last = clearEmptySpans(last);\n\t\n\t    var newMarkers = [first];\n\t    if (!sameLine) {\n\t      // Fill gap with whole-line-spans\n\t      var gap = change.text.length - 2, gapMarkers;\n\t      if (gap > 0 && first)\n\t        for (var i = 0; i < first.length; ++i)\n\t          if (first[i].to == null)\n\t            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n\t      for (var i = 0; i < gap; ++i)\n\t        newMarkers.push(gapMarkers);\n\t      newMarkers.push(last);\n\t    }\n\t    return newMarkers;\n\t  }\n\t\n\t  // Remove spans that are empty and don't have a clearWhenEmpty\n\t  // option of false.\n\t  function clearEmptySpans(spans) {\n\t    for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n\t        spans.splice(i--, 1);\n\t    }\n\t    if (!spans.length) return null;\n\t    return spans;\n\t  }\n\t\n\t  // Used for un/re-doing changes from the history. Combines the\n\t  // result of computing the existing spans with the set of spans that\n\t  // existed in the history (so that deleting around a span and then\n\t  // undoing brings back the span).\n\t  function mergeOldSpans(doc, change) {\n\t    var old = getOldSpans(doc, change);\n\t    var stretched = stretchSpansOverChange(doc, change);\n\t    if (!old) return stretched;\n\t    if (!stretched) return old;\n\t\n\t    for (var i = 0; i < old.length; ++i) {\n\t      var oldCur = old[i], stretchCur = stretched[i];\n\t      if (oldCur && stretchCur) {\n\t        spans: for (var j = 0; j < stretchCur.length; ++j) {\n\t          var span = stretchCur[j];\n\t          for (var k = 0; k < oldCur.length; ++k)\n\t            if (oldCur[k].marker == span.marker) continue spans;\n\t          oldCur.push(span);\n\t        }\n\t      } else if (stretchCur) {\n\t        old[i] = stretchCur;\n\t      }\n\t    }\n\t    return old;\n\t  }\n\t\n\t  // Used to 'clip' out readOnly ranges when making a change.\n\t  function removeReadOnlyRanges(doc, from, to) {\n\t    var markers = null;\n\t    doc.iter(from.line, to.line + 1, function(line) {\n\t      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t        var mark = line.markedSpans[i].marker;\n\t        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n\t          (markers || (markers = [])).push(mark);\n\t      }\n\t    });\n\t    if (!markers) return null;\n\t    var parts = [{from: from, to: to}];\n\t    for (var i = 0; i < markers.length; ++i) {\n\t      var mk = markers[i], m = mk.find(0);\n\t      for (var j = 0; j < parts.length; ++j) {\n\t        var p = parts[j];\n\t        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n\t        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n\t        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n\t          newParts.push({from: p.from, to: m.from});\n\t        if (dto > 0 || !mk.inclusiveRight && !dto)\n\t          newParts.push({from: m.to, to: p.to});\n\t        parts.splice.apply(parts, newParts);\n\t        j += newParts.length - 1;\n\t      }\n\t    }\n\t    return parts;\n\t  }\n\t\n\t  // Connect or disconnect spans from a line.\n\t  function detachMarkedSpans(line) {\n\t    var spans = line.markedSpans;\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.detachLine(line);\n\t    line.markedSpans = null;\n\t  }\n\t  function attachMarkedSpans(line, spans) {\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.attachLine(line);\n\t    line.markedSpans = spans;\n\t  }\n\t\n\t  // Helpers used when computing which overlapping collapsed span\n\t  // counts as the larger one.\n\t  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n\t  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\t\n\t  // Returns a number indicating which of two overlapping collapsed\n\t  // spans is larger (and thus includes the other). Falls back to\n\t  // comparing ids when the spans cover exactly the same range.\n\t  function compareCollapsedMarkers(a, b) {\n\t    var lenDiff = a.lines.length - b.lines.length;\n\t    if (lenDiff != 0) return lenDiff;\n\t    var aPos = a.find(), bPos = b.find();\n\t    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\t    if (fromCmp) return -fromCmp;\n\t    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\t    if (toCmp) return toCmp;\n\t    return b.id - a.id;\n\t  }\n\t\n\t  // Find out whether a line ends or starts in a collapsed span. If\n\t  // so, return the marker for that span.\n\t  function collapsedSpanAtSide(line, start) {\n\t    var sps = sawCollapsedSpans && line.markedSpans, found;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n\t          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n\t        found = sp.marker;\n\t    }\n\t    return found;\n\t  }\n\t  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n\t  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\t\n\t  // Test whether there exists a collapsed span that partially\n\t  // overlaps (covers the start or end, but not both) of a new span.\n\t  // Such overlap is not allowed.\n\t  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n\t    var line = getLine(doc, lineNo);\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var i = 0; i < sps.length; ++i) {\n\t      var sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      var found = sp.marker.find(0);\n\t      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n\t      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\t      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n\t      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n\t          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // A visual line is a line as drawn on the screen. Folding, for\n\t  // example, can cause multiple logical lines to appear on the same\n\t  // visual line. This finds the start of the visual line that the\n\t  // given line is part of (usually that is the line itself).\n\t  function visualLine(line) {\n\t    var merged;\n\t    while (merged = collapsedSpanAtStart(line))\n\t      line = merged.find(-1, true).line;\n\t    return line;\n\t  }\n\t\n\t  // Returns an array of logical lines that continue the visual line\n\t  // started by the argument, or undefined if there are no such lines.\n\t  function visualLineContinued(line) {\n\t    var merged, lines;\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      (lines || (lines = [])).push(line);\n\t    }\n\t    return lines;\n\t  }\n\t\n\t  // Get the line number of the start of the visual line that the\n\t  // given line number is part of.\n\t  function visualLineNo(doc, lineN) {\n\t    var line = getLine(doc, lineN), vis = visualLine(line);\n\t    if (line == vis) return lineN;\n\t    return lineNo(vis);\n\t  }\n\t  // Get the line number of the start of the next visual line after\n\t  // the given line.\n\t  function visualLineEndNo(doc, lineN) {\n\t    if (lineN > doc.lastLine()) return lineN;\n\t    var line = getLine(doc, lineN), merged;\n\t    if (!lineIsHidden(doc, line)) return lineN;\n\t    while (merged = collapsedSpanAtEnd(line))\n\t      line = merged.find(1, true).line;\n\t    return lineNo(line) + 1;\n\t  }\n\t\n\t  // Compute whether a line is hidden. Lines count as hidden when they\n\t  // are part of a visual line that starts with another line, or when\n\t  // they are entirely covered by collapsed, non-widget span.\n\t  function lineIsHidden(doc, line) {\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      if (sp.from == null) return true;\n\t      if (sp.marker.widgetNode) continue;\n\t      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n\t        return true;\n\t    }\n\t  }\n\t  function lineIsHiddenInner(doc, line, span) {\n\t    if (span.to == null) {\n\t      var end = span.marker.find(1, true);\n\t      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n\t    }\n\t    if (span.marker.inclusiveRight && span.to == line.text.length)\n\t      return true;\n\t    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n\t      sp = line.markedSpans[i];\n\t      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n\t          (sp.to == null || sp.to != span.from) &&\n\t          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n\t          lineIsHiddenInner(doc, line, sp)) return true;\n\t    }\n\t  }\n\t\n\t  // LINE WIDGETS\n\t\n\t  // Line widgets are block elements displayed above or below a line.\n\t\n\t  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n\t    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n\t      this[opt] = options[opt];\n\t    this.doc = doc;\n\t    this.node = node;\n\t  };\n\t  eventMixin(LineWidget);\n\t\n\t  function adjustScrollWhenAboveVisible(cm, line, diff) {\n\t    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n\t      addToScrollPos(cm, null, diff);\n\t  }\n\t\n\t  LineWidget.prototype.clear = function() {\n\t    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n\t    if (no == null || !ws) return;\n\t    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n\t    if (!ws.length) line.widgets = null;\n\t    var height = widgetHeight(this);\n\t    updateLineHeight(line, Math.max(0, line.height - height));\n\t    if (cm) runInOp(cm, function() {\n\t      adjustScrollWhenAboveVisible(cm, line, -height);\n\t      regLineChange(cm, no, \"widget\");\n\t    });\n\t  };\n\t  LineWidget.prototype.changed = function() {\n\t    var oldH = this.height, cm = this.doc.cm, line = this.line;\n\t    this.height = null;\n\t    var diff = widgetHeight(this) - oldH;\n\t    if (!diff) return;\n\t    updateLineHeight(line, line.height + diff);\n\t    if (cm) runInOp(cm, function() {\n\t      cm.curOp.forceUpdate = true;\n\t      adjustScrollWhenAboveVisible(cm, line, diff);\n\t    });\n\t  };\n\t\n\t  function widgetHeight(widget) {\n\t    if (widget.height != null) return widget.height;\n\t    var cm = widget.doc.cm;\n\t    if (!cm) return 0;\n\t    if (!contains(document.body, widget.node)) {\n\t      var parentStyle = \"position: relative;\";\n\t      if (widget.coverGutter)\n\t        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n\t      if (widget.noHScroll)\n\t        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n\t      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n\t    }\n\t    return widget.height = widget.node.parentNode.offsetHeight;\n\t  }\n\t\n\t  function addLineWidget(doc, handle, node, options) {\n\t    var widget = new LineWidget(doc, node, options);\n\t    var cm = doc.cm;\n\t    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n\t    changeLine(doc, handle, \"widget\", function(line) {\n\t      var widgets = line.widgets || (line.widgets = []);\n\t      if (widget.insertAt == null) widgets.push(widget);\n\t      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n\t      widget.line = line;\n\t      if (cm && !lineIsHidden(doc, line)) {\n\t        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n\t        updateLineHeight(line, line.height + widgetHeight(widget));\n\t        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n\t        cm.curOp.forceUpdate = true;\n\t      }\n\t      return true;\n\t    });\n\t    return widget;\n\t  }\n\t\n\t  // LINE DATA STRUCTURE\n\t\n\t  // Line objects. These hold state related to a line, including\n\t  // highlighting info (the styles array).\n\t  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n\t    this.text = text;\n\t    attachMarkedSpans(this, markedSpans);\n\t    this.height = estimateHeight ? estimateHeight(this) : 1;\n\t  };\n\t  eventMixin(Line);\n\t  Line.prototype.lineNo = function() { return lineNo(this); };\n\t\n\t  // Change the content (text, markers) of a line. Automatically\n\t  // invalidates cached information and tries to re-estimate the\n\t  // line's height.\n\t  function updateLine(line, text, markedSpans, estimateHeight) {\n\t    line.text = text;\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    if (line.styles) line.styles = null;\n\t    if (line.order != null) line.order = null;\n\t    detachMarkedSpans(line);\n\t    attachMarkedSpans(line, markedSpans);\n\t    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\t    if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t  }\n\t\n\t  // Detach a line from the document tree and its markers.\n\t  function cleanUpLine(line) {\n\t    line.parent = null;\n\t    detachMarkedSpans(line);\n\t  }\n\t\n\t  function extractLineClasses(type, output) {\n\t    if (type) for (;;) {\n\t      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\t      if (!lineClass) break;\n\t      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n\t      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\t      if (output[prop] == null)\n\t        output[prop] = lineClass[2];\n\t      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n\t        output[prop] += \" \" + lineClass[2];\n\t    }\n\t    return type;\n\t  }\n\t\n\t  function callBlankLine(mode, state) {\n\t    if (mode.blankLine) return mode.blankLine(state);\n\t    if (!mode.innerMode) return;\n\t    var inner = CodeMirror.innerMode(mode, state);\n\t    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n\t  }\n\t\n\t  function readToken(mode, stream, state, inner) {\n\t    for (var i = 0; i < 10; i++) {\n\t      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n\t      var style = mode.token(stream, state);\n\t      if (stream.pos > stream.start) return style;\n\t    }\n\t    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n\t  }\n\t\n\t  // Utility for getTokenAt and getLineTokens\n\t  function takeToken(cm, pos, precise, asArray) {\n\t    function getObj(copy) {\n\t      return {start: stream.start, end: stream.pos,\n\t              string: stream.current(),\n\t              type: style || null,\n\t              state: copy ? copyState(doc.mode, state) : state};\n\t    }\n\t\n\t    var doc = cm.doc, mode = doc.mode, style;\n\t    pos = clipPos(doc, pos);\n\t    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n\t    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n\t    if (asArray) tokens = [];\n\t    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n\t      stream.start = stream.pos;\n\t      style = readToken(mode, stream, state);\n\t      if (asArray) tokens.push(getObj(true));\n\t    }\n\t    return asArray ? tokens : getObj();\n\t  }\n\t\n\t  // Run the given mode's parser over a line, calling f for each token.\n\t  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n\t    var flattenSpans = mode.flattenSpans;\n\t    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n\t    var curStart = 0, curStyle = null;\n\t    var stream = new StringStream(text, cm.options.tabSize), style;\n\t    var inner = cm.options.addModeClass && [null];\n\t    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n\t    while (!stream.eol()) {\n\t      if (stream.pos > cm.options.maxHighlightLength) {\n\t        flattenSpans = false;\n\t        if (forceToEnd) processLine(cm, text, state, stream.pos);\n\t        stream.pos = text.length;\n\t        style = null;\n\t      } else {\n\t        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n\t      }\n\t      if (inner) {\n\t        var mName = inner[0].name;\n\t        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n\t      }\n\t      if (!flattenSpans || curStyle != style) {\n\t        while (curStart < stream.start) {\n\t          curStart = Math.min(stream.start, curStart + 50000);\n\t          f(curStart, curStyle);\n\t        }\n\t        curStyle = style;\n\t      }\n\t      stream.start = stream.pos;\n\t    }\n\t    while (curStart < stream.pos) {\n\t      // Webkit seems to refuse to render text nodes longer than 57444 characters\n\t      var pos = Math.min(stream.pos, curStart + 50000);\n\t      f(pos, curStyle);\n\t      curStart = pos;\n\t    }\n\t  }\n\t\n\t  // Compute a style array (an array starting with a mode generation\n\t  // -- for invalidation -- followed by pairs of end positions and\n\t  // style strings), which is used to highlight the tokens on the\n\t  // line.\n\t  function highlightLine(cm, line, state, forceToEnd) {\n\t    // A styles array always starts with a number identifying the\n\t    // mode/overlays that it is based on (for easy invalidation).\n\t    var st = [cm.state.modeGen], lineClasses = {};\n\t    // Compute the base array of styles\n\t    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n\t      st.push(end, style);\n\t    }, lineClasses, forceToEnd);\n\t\n\t    // Run overlays, adjust style array.\n\t    for (var o = 0; o < cm.state.overlays.length; ++o) {\n\t      var overlay = cm.state.overlays[o], i = 1, at = 0;\n\t      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n\t        var start = i;\n\t        // Ensure there's a token end at the current position, and that i points at it\n\t        while (at < end) {\n\t          var i_end = st[i];\n\t          if (i_end > end)\n\t            st.splice(i, 1, end, st[i+1], i_end);\n\t          i += 2;\n\t          at = Math.min(end, i_end);\n\t        }\n\t        if (!style) return;\n\t        if (overlay.opaque) {\n\t          st.splice(start, i - start, end, \"cm-overlay \" + style);\n\t          i = start + 2;\n\t        } else {\n\t          for (; start < i; start += 2) {\n\t            var cur = st[start+1];\n\t            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n\t          }\n\t        }\n\t      }, lineClasses);\n\t    }\n\t\n\t    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n\t  }\n\t\n\t  function getLineStyles(cm, line, updateFrontier) {\n\t    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n\t      var state = getStateBefore(cm, lineNo(line));\n\t      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n\t      line.stateAfter = state;\n\t      line.styles = result.styles;\n\t      if (result.classes) line.styleClasses = result.classes;\n\t      else if (line.styleClasses) line.styleClasses = null;\n\t      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n\t    }\n\t    return line.styles;\n\t  }\n\t\n\t  // Lightweight form of highlight -- proceed over this line and\n\t  // update state, but don't save a style array. Used for lines that\n\t  // aren't currently visible.\n\t  function processLine(cm, text, state, startAt) {\n\t    var mode = cm.doc.mode;\n\t    var stream = new StringStream(text, cm.options.tabSize);\n\t    stream.start = stream.pos = startAt || 0;\n\t    if (text == \"\") callBlankLine(mode, state);\n\t    while (!stream.eol()) {\n\t      readToken(mode, stream, state);\n\t      stream.start = stream.pos;\n\t    }\n\t  }\n\t\n\t  // Convert a style as returned by a mode (either null, or a string\n\t  // containing one or more styles) to a CSS style. This is cached,\n\t  // and also looks for line-wide styles.\n\t  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n\t  function interpretTokenStyle(style, options) {\n\t    if (!style || /^\\s*$/.test(style)) return null;\n\t    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n\t    return cache[style] ||\n\t      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n\t  }\n\t\n\t  // Render the DOM representation of the text of a line. Also builds\n\t  // up a 'line map', which points at the DOM nodes that represent\n\t  // specific stretches of text, and is used by the measuring code.\n\t  // The returned object contains the DOM node, this map, and\n\t  // information about line-wide styles that were set by the mode.\n\t  function buildLineContent(cm, lineView) {\n\t    // The padding-right forces the element to have a 'border', which\n\t    // is needed on Webkit to be able to get line-level bounding\n\t    // rectangles for it (in measureChar).\n\t    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n\t    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n\t                   col: 0, pos: 0, cm: cm,\n\t                   trailingSpace: false,\n\t                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n\t    lineView.measure = {};\n\t\n\t    // Iterate over the logical lines that make up this visual line.\n\t    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n\t      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n\t      builder.pos = 0;\n\t      builder.addToken = buildToken;\n\t      // Optionally wire in some hacks into the token-rendering\n\t      // algorithm, to deal with browser quirks.\n\t      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n\t        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n\t      builder.map = [];\n\t      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n\t      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n\t      if (line.styleClasses) {\n\t        if (line.styleClasses.bgClass)\n\t          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n\t        if (line.styleClasses.textClass)\n\t          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n\t      }\n\t\n\t      // Ensure at least a single node is present, for measuring.\n\t      if (builder.map.length == 0)\n\t        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\t\n\t      // Store the map and a cache object for the current logical line\n\t      if (i == 0) {\n\t        lineView.measure.map = builder.map;\n\t        lineView.measure.cache = {};\n\t      } else {\n\t        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n\t        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n\t      }\n\t    }\n\t\n\t    // See issue #2901\n\t    if (webkit) {\n\t      var last = builder.content.lastChild\n\t      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n\t        builder.content.className = \"cm-tab-wrap-hack\";\n\t    }\n\t\n\t    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n\t    if (builder.pre.className)\n\t      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\t\n\t    return builder;\n\t  }\n\t\n\t  function defaultSpecialCharPlaceholder(ch) {\n\t    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n\t    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n\t    token.setAttribute(\"aria-label\", token.title);\n\t    return token;\n\t  }\n\t\n\t  // Build up the DOM representation for a single token, and add it to\n\t  // the line map. Takes care to render special characters separately.\n\t  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n\t    if (!text) return;\n\t    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text\n\t    var special = builder.cm.state.specialChars, mustWrap = false;\n\t    if (!special.test(text)) {\n\t      builder.col += text.length;\n\t      var content = document.createTextNode(displayText);\n\t      builder.map.push(builder.pos, builder.pos + text.length, content);\n\t      if (ie && ie_version < 9) mustWrap = true;\n\t      builder.pos += text.length;\n\t    } else {\n\t      var content = document.createDocumentFragment(), pos = 0;\n\t      while (true) {\n\t        special.lastIndex = pos;\n\t        var m = special.exec(text);\n\t        var skipped = m ? m.index - pos : text.length - pos;\n\t        if (skipped) {\n\t          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.map.push(builder.pos, builder.pos + skipped, txt);\n\t          builder.col += skipped;\n\t          builder.pos += skipped;\n\t        }\n\t        if (!m) break;\n\t        pos += skipped + 1;\n\t        if (m[0] == \"\\t\") {\n\t          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n\t          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n\t          txt.setAttribute(\"role\", \"presentation\");\n\t          txt.setAttribute(\"cm-text\", \"\\t\");\n\t          builder.col += tabWidth;\n\t        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n\t          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          builder.col += 1;\n\t        } else {\n\t          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.col += 1;\n\t        }\n\t        builder.map.push(builder.pos, builder.pos + 1, txt);\n\t        builder.pos++;\n\t      }\n\t    }\n\t    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32\n\t    if (style || startStyle || endStyle || mustWrap || css) {\n\t      var fullStyle = style || \"\";\n\t      if (startStyle) fullStyle += startStyle;\n\t      if (endStyle) fullStyle += endStyle;\n\t      var token = elt(\"span\", [content], fullStyle, css);\n\t      if (title) token.title = title;\n\t      return builder.content.appendChild(token);\n\t    }\n\t    builder.content.appendChild(content);\n\t  }\n\t\n\t  function splitSpaces(text, trailingBefore) {\n\t    if (text.length > 1 && !/  /.test(text)) return text\n\t    var spaceBefore = trailingBefore, result = \"\"\n\t    for (var i = 0; i < text.length; i++) {\n\t      var ch = text.charAt(i)\n\t      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n\t        ch = \"\\u00a0\"\n\t      result += ch\n\t      spaceBefore = ch == \" \"\n\t    }\n\t    return result\n\t  }\n\t\n\t  // Work around nonsense dimensions being reported for stretches of\n\t  // right-to-left text.\n\t  function buildTokenBadBidi(inner, order) {\n\t    return function(builder, text, style, startStyle, endStyle, title, css) {\n\t      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n\t      var start = builder.pos, end = start + text.length;\n\t      for (;;) {\n\t        // Find the part that overlaps with the start of this text\n\t        for (var i = 0; i < order.length; i++) {\n\t          var part = order[i];\n\t          if (part.to > start && part.from <= start) break;\n\t        }\n\t        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n\t        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n\t        startStyle = null;\n\t        text = text.slice(part.to - start);\n\t        start = part.to;\n\t      }\n\t    };\n\t  }\n\t\n\t  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n\t    var widget = !ignoreWidget && marker.widgetNode;\n\t    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n\t    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n\t      if (!widget)\n\t        widget = builder.content.appendChild(document.createElement(\"span\"));\n\t      widget.setAttribute(\"cm-marker\", marker.id);\n\t    }\n\t    if (widget) {\n\t      builder.cm.display.input.setUneditable(widget);\n\t      builder.content.appendChild(widget);\n\t    }\n\t    builder.pos += size;\n\t    builder.trailingSpace = false\n\t  }\n\t\n\t  // Outputs a number of spans to make up a line, taking highlighting\n\t  // and marked text into account.\n\t  function insertLineContent(line, builder, styles) {\n\t    var spans = line.markedSpans, allText = line.text, at = 0;\n\t    if (!spans) {\n\t      for (var i = 1; i < styles.length; i+=2)\n\t        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n\t      return;\n\t    }\n\t\n\t    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n\t    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n\t    for (;;) {\n\t      if (nextChange == pos) { // Update current marker set\n\t        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n\t        collapsed = null; nextChange = Infinity;\n\t        var foundBookmarks = [], endStyles\n\t        for (var j = 0; j < spans.length; ++j) {\n\t          var sp = spans[j], m = sp.marker;\n\t          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n\t            foundBookmarks.push(m);\n\t          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n\t            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n\t              nextChange = sp.to;\n\t              spanEndStyle = \"\";\n\t            }\n\t            if (m.className) spanStyle += \" \" + m.className;\n\t            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n\t            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n\t            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\n\t            if (m.title && !title) title = m.title;\n\t            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n\t              collapsed = sp;\n\t          } else if (sp.from > pos && nextChange > sp.from) {\n\t            nextChange = sp.from;\n\t          }\n\t        }\n\t        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\n\t          if (endStyles[j + 1] == nextChange) spanEndStyle += \" \" + endStyles[j]\n\t\n\t        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\n\t          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n\t        if (collapsed && (collapsed.from || 0) == pos) {\n\t          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n\t                             collapsed.marker, collapsed.from == null);\n\t          if (collapsed.to == null) return;\n\t          if (collapsed.to == pos) collapsed = false;\n\t        }\n\t      }\n\t      if (pos >= len) break;\n\t\n\t      var upto = Math.min(len, nextChange);\n\t      while (true) {\n\t        if (text) {\n\t          var end = pos + text.length;\n\t          if (!collapsed) {\n\t            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n\t            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n\t                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n\t          }\n\t          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n\t          pos = end;\n\t          spanStartStyle = \"\";\n\t        }\n\t        text = allText.slice(at, at = styles[i++]);\n\t        style = interpretTokenStyle(styles[i++], builder.cm.options);\n\t      }\n\t    }\n\t  }\n\t\n\t  // DOCUMENT DATA STRUCTURE\n\t\n\t  // By default, updates that start and end at the beginning of a line\n\t  // are treated specially, in order to make the association of line\n\t  // widgets and marker elements with the text behave more intuitive.\n\t  function isWholeLineUpdate(doc, change) {\n\t    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n\t      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n\t  }\n\t\n\t  // Perform a change on the document data structure.\n\t  function updateDoc(doc, change, markedSpans, estimateHeight) {\n\t    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n\t    function update(line, text, spans) {\n\t      updateLine(line, text, spans, estimateHeight);\n\t      signalLater(line, \"change\", line, change);\n\t    }\n\t    function linesFor(start, end) {\n\t      for (var i = start, result = []; i < end; ++i)\n\t        result.push(new Line(text[i], spansFor(i), estimateHeight));\n\t      return result;\n\t    }\n\t\n\t    var from = change.from, to = change.to, text = change.text;\n\t    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n\t    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\t\n\t    // Adjust the line structure\n\t    if (change.full) {\n\t      doc.insert(0, linesFor(0, text.length));\n\t      doc.remove(text.length, doc.size - text.length);\n\t    } else if (isWholeLineUpdate(doc, change)) {\n\t      // This is a whole-line replace. Treated specially to make\n\t      // sure line objects move the way they are supposed to.\n\t      var added = linesFor(0, text.length - 1);\n\t      update(lastLine, lastLine.text, lastSpans);\n\t      if (nlines) doc.remove(from.line, nlines);\n\t      if (added.length) doc.insert(from.line, added);\n\t    } else if (firstLine == lastLine) {\n\t      if (text.length == 1) {\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n\t      } else {\n\t        var added = linesFor(1, text.length - 1);\n\t        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t        doc.insert(from.line + 1, added);\n\t      }\n\t    } else if (text.length == 1) {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n\t      doc.remove(from.line + 1, nlines);\n\t    } else {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n\t      var added = linesFor(1, text.length - 1);\n\t      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n\t      doc.insert(from.line + 1, added);\n\t    }\n\t\n\t    signalLater(doc, \"change\", doc, change);\n\t  }\n\t\n\t  // The document is represented as a BTree consisting of leaves, with\n\t  // chunk of lines in them, and branches, with up to ten leaves or\n\t  // other branch nodes below them. The top node is always a branch\n\t  // node, and is the document object itself (meaning it has\n\t  // additional methods and properties).\n\t  //\n\t  // All nodes have parent links. The tree is used both to go from\n\t  // line numbers to line objects, and to go from objects to numbers.\n\t  // It also indexes by height, and is used to convert between height\n\t  // and line object, and to find the total height of the document.\n\t  //\n\t  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\t\n\t  function LeafChunk(lines) {\n\t    this.lines = lines;\n\t    this.parent = null;\n\t    for (var i = 0, height = 0; i < lines.length; ++i) {\n\t      lines[i].parent = this;\n\t      height += lines[i].height;\n\t    }\n\t    this.height = height;\n\t  }\n\t\n\t  LeafChunk.prototype = {\n\t    chunkSize: function() { return this.lines.length; },\n\t    // Remove the n lines at offset 'at'.\n\t    removeInner: function(at, n) {\n\t      for (var i = at, e = at + n; i < e; ++i) {\n\t        var line = this.lines[i];\n\t        this.height -= line.height;\n\t        cleanUpLine(line);\n\t        signalLater(line, \"delete\");\n\t      }\n\t      this.lines.splice(at, n);\n\t    },\n\t    // Helper used to collapse a small branch into a single leaf.\n\t    collapse: function(lines) {\n\t      lines.push.apply(lines, this.lines);\n\t    },\n\t    // Insert the given array of lines at offset 'at', count them as\n\t    // having the given height.\n\t    insertInner: function(at, lines, height) {\n\t      this.height += height;\n\t      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\t      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n\t    },\n\t    // Used to iterate over a part of the tree.\n\t    iterN: function(at, n, op) {\n\t      for (var e = at + n; at < e; ++at)\n\t        if (op(this.lines[at])) return true;\n\t    }\n\t  };\n\t\n\t  function BranchChunk(children) {\n\t    this.children = children;\n\t    var size = 0, height = 0;\n\t    for (var i = 0; i < children.length; ++i) {\n\t      var ch = children[i];\n\t      size += ch.chunkSize(); height += ch.height;\n\t      ch.parent = this;\n\t    }\n\t    this.size = size;\n\t    this.height = height;\n\t    this.parent = null;\n\t  }\n\t\n\t  BranchChunk.prototype = {\n\t    chunkSize: function() { return this.size; },\n\t    removeInner: function(at, n) {\n\t      this.size -= n;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var rm = Math.min(n, sz - at), oldHeight = child.height;\n\t          child.removeInner(at, rm);\n\t          this.height -= oldHeight - child.height;\n\t          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n\t          if ((n -= rm) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t      // If the result is smaller than 25 lines, ensure that it is a\n\t      // single leaf node.\n\t      if (this.size - n < 25 &&\n\t          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n\t        var lines = [];\n\t        this.collapse(lines);\n\t        this.children = [new LeafChunk(lines)];\n\t        this.children[0].parent = this;\n\t      }\n\t    },\n\t    collapse: function(lines) {\n\t      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n\t    },\n\t    insertInner: function(at, lines, height) {\n\t      this.size += lines.length;\n\t      this.height += height;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at <= sz) {\n\t          child.insertInner(at, lines, height);\n\t          if (child.lines && child.lines.length > 50) {\n\t            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n\t            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n\t            var remaining = child.lines.length % 25 + 25\n\t            for (var pos = remaining; pos < child.lines.length;) {\n\t              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n\t              child.height -= leaf.height;\n\t              this.children.splice(++i, 0, leaf);\n\t              leaf.parent = this;\n\t            }\n\t            child.lines = child.lines.slice(0, remaining);\n\t            this.maybeSpill();\n\t          }\n\t          break;\n\t        }\n\t        at -= sz;\n\t      }\n\t    },\n\t    // When a node has grown, check whether it should be split.\n\t    maybeSpill: function() {\n\t      if (this.children.length <= 10) return;\n\t      var me = this;\n\t      do {\n\t        var spilled = me.children.splice(me.children.length - 5, 5);\n\t        var sibling = new BranchChunk(spilled);\n\t        if (!me.parent) { // Become the parent node\n\t          var copy = new BranchChunk(me.children);\n\t          copy.parent = me;\n\t          me.children = [copy, sibling];\n\t          me = copy;\n\t       } else {\n\t          me.size -= sibling.size;\n\t          me.height -= sibling.height;\n\t          var myIndex = indexOf(me.parent.children, me);\n\t          me.parent.children.splice(myIndex + 1, 0, sibling);\n\t        }\n\t        sibling.parent = me.parent;\n\t      } while (me.children.length > 10);\n\t      me.parent.maybeSpill();\n\t    },\n\t    iterN: function(at, n, op) {\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var used = Math.min(n, sz - at);\n\t          if (child.iterN(at, used, op)) return true;\n\t          if ((n -= used) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t    }\n\t  };\n\t\n\t  var nextDocId = 0;\n\t  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n\t    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n\t    if (firstLine == null) firstLine = 0;\n\t\n\t    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n\t    this.first = firstLine;\n\t    this.scrollTop = this.scrollLeft = 0;\n\t    this.cantEdit = false;\n\t    this.cleanGeneration = 1;\n\t    this.frontier = firstLine;\n\t    var start = Pos(firstLine, 0);\n\t    this.sel = simpleSelection(start);\n\t    this.history = new History(null);\n\t    this.id = ++nextDocId;\n\t    this.modeOption = mode;\n\t    this.lineSep = lineSep;\n\t    this.extend = false;\n\t\n\t    if (typeof text == \"string\") text = this.splitLines(text);\n\t    updateDoc(this, {from: start, to: start, text: text});\n\t    setSelection(this, simpleSelection(start), sel_dontScroll);\n\t  };\n\t\n\t  Doc.prototype = createObj(BranchChunk.prototype, {\n\t    constructor: Doc,\n\t    // Iterate over the document. Supports two forms -- with only one\n\t    // argument, it calls that for each line in the document. With\n\t    // three, it iterates over the range given by the first two (with\n\t    // the second being non-inclusive).\n\t    iter: function(from, to, op) {\n\t      if (op) this.iterN(from - this.first, to - from, op);\n\t      else this.iterN(this.first, this.first + this.size, from);\n\t    },\n\t\n\t    // Non-public interface for adding and removing lines.\n\t    insert: function(at, lines) {\n\t      var height = 0;\n\t      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n\t      this.insertInner(at - this.first, lines, height);\n\t    },\n\t    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\t\n\t    // From here, the methods are part of the public interface. Most\n\t    // are also available from CodeMirror (editor) instances.\n\t\n\t    getValue: function(lineSep) {\n\t      var lines = getLines(this, this.first, this.first + this.size);\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    setValue: docMethodOp(function(code) {\n\t      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n\t      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n\t                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n\t      setSelection(this, simpleSelection(top));\n\t    }),\n\t    replaceRange: function(code, from, to, origin) {\n\t      from = clipPos(this, from);\n\t      to = to ? clipPos(this, to) : from;\n\t      replaceRange(this, code, from, to, origin);\n\t    },\n\t    getRange: function(from, to, lineSep) {\n\t      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t\n\t    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\t\n\t    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n\t    getLineNumber: function(line) {return lineNo(line);},\n\t\n\t    getLineHandleVisualStart: function(line) {\n\t      if (typeof line == \"number\") line = getLine(this, line);\n\t      return visualLine(line);\n\t    },\n\t\n\t    lineCount: function() {return this.size;},\n\t    firstLine: function() {return this.first;},\n\t    lastLine: function() {return this.first + this.size - 1;},\n\t\n\t    clipPos: function(pos) {return clipPos(this, pos);},\n\t\n\t    getCursor: function(start) {\n\t      var range = this.sel.primary(), pos;\n\t      if (start == null || start == \"head\") pos = range.head;\n\t      else if (start == \"anchor\") pos = range.anchor;\n\t      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n\t      else pos = range.from();\n\t      return pos;\n\t    },\n\t    listSelections: function() { return this.sel.ranges; },\n\t    somethingSelected: function() {return this.sel.somethingSelected();},\n\t\n\t    setCursor: docMethodOp(function(line, ch, options) {\n\t      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n\t    }),\n\t    setSelection: docMethodOp(function(anchor, head, options) {\n\t      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n\t    }),\n\t    extendSelection: docMethodOp(function(head, other, options) {\n\t      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n\t    }),\n\t    extendSelections: docMethodOp(function(heads, options) {\n\t      extendSelections(this, clipPosArray(this, heads), options);\n\t    }),\n\t    extendSelectionsBy: docMethodOp(function(f, options) {\n\t      var heads = map(this.sel.ranges, f);\n\t      extendSelections(this, clipPosArray(this, heads), options);\n\t    }),\n\t    setSelections: docMethodOp(function(ranges, primary, options) {\n\t      if (!ranges.length) return;\n\t      for (var i = 0, out = []; i < ranges.length; i++)\n\t        out[i] = new Range(clipPos(this, ranges[i].anchor),\n\t                           clipPos(this, ranges[i].head));\n\t      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n\t      setSelection(this, normalizeSelection(out, primary), options);\n\t    }),\n\t    addSelection: docMethodOp(function(anchor, head, options) {\n\t      var ranges = this.sel.ranges.slice(0);\n\t      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n\t      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n\t    }),\n\t\n\t    getSelection: function(lineSep) {\n\t      var ranges = this.sel.ranges, lines;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        lines = lines ? lines.concat(sel) : sel;\n\t      }\n\t      if (lineSep === false) return lines;\n\t      else return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    getSelections: function(lineSep) {\n\t      var parts = [], ranges = this.sel.ranges;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n\t        parts[i] = sel;\n\t      }\n\t      return parts;\n\t    },\n\t    replaceSelection: function(code, collapse, origin) {\n\t      var dup = [];\n\t      for (var i = 0; i < this.sel.ranges.length; i++)\n\t        dup[i] = code;\n\t      this.replaceSelections(dup, collapse, origin || \"+input\");\n\t    },\n\t    replaceSelections: docMethodOp(function(code, collapse, origin) {\n\t      var changes = [], sel = this.sel;\n\t      for (var i = 0; i < sel.ranges.length; i++) {\n\t        var range = sel.ranges[i];\n\t        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n\t      }\n\t      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n\t      for (var i = changes.length - 1; i >= 0; i--)\n\t        makeChange(this, changes[i]);\n\t      if (newSel) setSelectionReplaceHistory(this, newSel);\n\t      else if (this.cm) ensureCursorVisible(this.cm);\n\t    }),\n\t    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n\t    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n\t    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n\t    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\t\n\t    setExtending: function(val) {this.extend = val;},\n\t    getExtending: function() {return this.extend;},\n\t\n\t    historySize: function() {\n\t      var hist = this.history, done = 0, undone = 0;\n\t      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n\t      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n\t      return {undo: done, redo: undone};\n\t    },\n\t    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\t\n\t    markClean: function() {\n\t      this.cleanGeneration = this.changeGeneration(true);\n\t    },\n\t    changeGeneration: function(forceSplit) {\n\t      if (forceSplit)\n\t        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n\t      return this.history.generation;\n\t    },\n\t    isClean: function (gen) {\n\t      return this.history.generation == (gen || this.cleanGeneration);\n\t    },\n\t\n\t    getHistory: function() {\n\t      return {done: copyHistoryArray(this.history.done),\n\t              undone: copyHistoryArray(this.history.undone)};\n\t    },\n\t    setHistory: function(histData) {\n\t      var hist = this.history = new History(this.history.maxGeneration);\n\t      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n\t      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n\t    },\n\t\n\t    addLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        if (!line[prop]) line[prop] = cls;\n\t        else if (classTest(cls).test(line[prop])) return false;\n\t        else line[prop] += \" \" + cls;\n\t        return true;\n\t      });\n\t    }),\n\t    removeLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        var cur = line[prop];\n\t        if (!cur) return false;\n\t        else if (cls == null) line[prop] = null;\n\t        else {\n\t          var found = cur.match(classTest(cls));\n\t          if (!found) return false;\n\t          var end = found.index + found[0].length;\n\t          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n\t        }\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    addLineWidget: docMethodOp(function(handle, node, options) {\n\t      return addLineWidget(this, handle, node, options);\n\t    }),\n\t    removeLineWidget: function(widget) { widget.clear(); },\n\t\n\t    markText: function(from, to, options) {\n\t      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n\t    },\n\t    setBookmark: function(pos, options) {\n\t      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n\t                      insertLeft: options && options.insertLeft,\n\t                      clearWhenEmpty: false, shared: options && options.shared,\n\t                      handleMouseEvents: options && options.handleMouseEvents};\n\t      pos = clipPos(this, pos);\n\t      return markText(this, pos, pos, realOpts, \"bookmark\");\n\t    },\n\t    findMarksAt: function(pos) {\n\t      pos = clipPos(this, pos);\n\t      var markers = [], spans = getLine(this, pos.line).markedSpans;\n\t      if (spans) for (var i = 0; i < spans.length; ++i) {\n\t        var span = spans[i];\n\t        if ((span.from == null || span.from <= pos.ch) &&\n\t            (span.to == null || span.to >= pos.ch))\n\t          markers.push(span.marker.parent || span.marker);\n\t      }\n\t      return markers;\n\t    },\n\t    findMarks: function(from, to, filter) {\n\t      from = clipPos(this, from); to = clipPos(this, to);\n\t      var found = [], lineNo = from.line;\n\t      this.iter(from.line, to.line + 1, function(line) {\n\t        var spans = line.markedSpans;\n\t        if (spans) for (var i = 0; i < spans.length; i++) {\n\t          var span = spans[i];\n\t          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n\t                span.from == null && lineNo != from.line ||\n\t                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n\t              (!filter || filter(span.marker)))\n\t            found.push(span.marker.parent || span.marker);\n\t        }\n\t        ++lineNo;\n\t      });\n\t      return found;\n\t    },\n\t    getAllMarks: function() {\n\t      var markers = [];\n\t      this.iter(function(line) {\n\t        var sps = line.markedSpans;\n\t        if (sps) for (var i = 0; i < sps.length; ++i)\n\t          if (sps[i].from != null) markers.push(sps[i].marker);\n\t      });\n\t      return markers;\n\t    },\n\t\n\t    posFromIndex: function(off) {\n\t      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n\t      this.iter(function(line) {\n\t        var sz = line.text.length + sepSize;\n\t        if (sz > off) { ch = off; return true; }\n\t        off -= sz;\n\t        ++lineNo;\n\t      });\n\t      return clipPos(this, Pos(lineNo, ch));\n\t    },\n\t    indexFromPos: function (coords) {\n\t      coords = clipPos(this, coords);\n\t      var index = coords.ch;\n\t      if (coords.line < this.first || coords.ch < 0) return 0;\n\t      var sepSize = this.lineSeparator().length;\n\t      this.iter(this.first, coords.line, function (line) {\n\t        index += line.text.length + sepSize;\n\t      });\n\t      return index;\n\t    },\n\t\n\t    copy: function(copyHistory) {\n\t      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n\t                        this.modeOption, this.first, this.lineSep);\n\t      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n\t      doc.sel = this.sel;\n\t      doc.extend = false;\n\t      if (copyHistory) {\n\t        doc.history.undoDepth = this.history.undoDepth;\n\t        doc.setHistory(this.getHistory());\n\t      }\n\t      return doc;\n\t    },\n\t\n\t    linkedDoc: function(options) {\n\t      if (!options) options = {};\n\t      var from = this.first, to = this.first + this.size;\n\t      if (options.from != null && options.from > from) from = options.from;\n\t      if (options.to != null && options.to < to) to = options.to;\n\t      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n\t      if (options.sharedHist) copy.history = this.history;\n\t      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n\t      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n\t      copySharedMarkers(copy, findSharedMarkers(this));\n\t      return copy;\n\t    },\n\t    unlinkDoc: function(other) {\n\t      if (other instanceof CodeMirror) other = other.doc;\n\t      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n\t        var link = this.linked[i];\n\t        if (link.doc != other) continue;\n\t        this.linked.splice(i, 1);\n\t        other.unlinkDoc(this);\n\t        detachSharedMarkers(findSharedMarkers(this));\n\t        break;\n\t      }\n\t      // If the histories were shared, split them again\n\t      if (other.history == this.history) {\n\t        var splitIds = [other.id];\n\t        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n\t        other.history = new History(null);\n\t        other.history.done = copyHistoryArray(this.history.done, splitIds);\n\t        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n\t      }\n\t    },\n\t    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\t\n\t    getMode: function() {return this.mode;},\n\t    getEditor: function() {return this.cm;},\n\t\n\t    splitLines: function(str) {\n\t      if (this.lineSep) return str.split(this.lineSep);\n\t      return splitLinesAuto(str);\n\t    },\n\t    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n\t  });\n\t\n\t  // Public alias.\n\t  Doc.prototype.eachLine = Doc.prototype.iter;\n\t\n\t  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n\t  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n\t  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n\t    CodeMirror.prototype[prop] = (function(method) {\n\t      return function() {return method.apply(this.doc, arguments);};\n\t    })(Doc.prototype[prop]);\n\t\n\t  eventMixin(Doc);\n\t\n\t  // Call f for all linked documents.\n\t  function linkedDocs(doc, f, sharedHistOnly) {\n\t    function propagate(doc, skip, sharedHist) {\n\t      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n\t        var rel = doc.linked[i];\n\t        if (rel.doc == skip) continue;\n\t        var shared = sharedHist && rel.sharedHist;\n\t        if (sharedHistOnly && !shared) continue;\n\t        f(rel.doc, shared);\n\t        propagate(rel.doc, doc, shared);\n\t      }\n\t    }\n\t    propagate(doc, null, true);\n\t  }\n\t\n\t  // Attach a document to an editor.\n\t  function attachDoc(cm, doc) {\n\t    if (doc.cm) throw new Error(\"This document is already in use.\");\n\t    cm.doc = doc;\n\t    doc.cm = cm;\n\t    estimateLineHeights(cm);\n\t    loadMode(cm);\n\t    if (!cm.options.lineWrapping) findMaxLine(cm);\n\t    cm.options.mode = doc.modeOption;\n\t    regChange(cm);\n\t  }\n\t\n\t  // LINE UTILITIES\n\t\n\t  // Find the line object corresponding to the given line number.\n\t  function getLine(doc, n) {\n\t    n -= doc.first;\n\t    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n\t    for (var chunk = doc; !chunk.lines;) {\n\t      for (var i = 0;; ++i) {\n\t        var child = chunk.children[i], sz = child.chunkSize();\n\t        if (n < sz) { chunk = child; break; }\n\t        n -= sz;\n\t      }\n\t    }\n\t    return chunk.lines[n];\n\t  }\n\t\n\t  // Get the part of a document between two positions, as an array of\n\t  // strings.\n\t  function getBetween(doc, start, end) {\n\t    var out = [], n = start.line;\n\t    doc.iter(start.line, end.line + 1, function(line) {\n\t      var text = line.text;\n\t      if (n == end.line) text = text.slice(0, end.ch);\n\t      if (n == start.line) text = text.slice(start.ch);\n\t      out.push(text);\n\t      ++n;\n\t    });\n\t    return out;\n\t  }\n\t  // Get the lines between from and to, as array of strings.\n\t  function getLines(doc, from, to) {\n\t    var out = [];\n\t    doc.iter(from, to, function(line) { out.push(line.text); });\n\t    return out;\n\t  }\n\t\n\t  // Update the height of a line, propagating the height change\n\t  // upwards to parent nodes.\n\t  function updateLineHeight(line, height) {\n\t    var diff = height - line.height;\n\t    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n\t  }\n\t\n\t  // Given a line object, find its line number by walking up through\n\t  // its parent links.\n\t  function lineNo(line) {\n\t    if (line.parent == null) return null;\n\t    var cur = line.parent, no = indexOf(cur.lines, line);\n\t    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n\t      for (var i = 0;; ++i) {\n\t        if (chunk.children[i] == cur) break;\n\t        no += chunk.children[i].chunkSize();\n\t      }\n\t    }\n\t    return no + cur.first;\n\t  }\n\t\n\t  // Find the line at the given vertical position, using the height\n\t  // information in the document tree.\n\t  function lineAtHeight(chunk, h) {\n\t    var n = chunk.first;\n\t    outer: do {\n\t      for (var i = 0; i < chunk.children.length; ++i) {\n\t        var child = chunk.children[i], ch = child.height;\n\t        if (h < ch) { chunk = child; continue outer; }\n\t        h -= ch;\n\t        n += child.chunkSize();\n\t      }\n\t      return n;\n\t    } while (!chunk.lines);\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i], lh = line.height;\n\t      if (h < lh) break;\n\t      h -= lh;\n\t    }\n\t    return n + i;\n\t  }\n\t\n\t\n\t  // Find the height above the given line.\n\t  function heightAtLine(lineObj) {\n\t    lineObj = visualLine(lineObj);\n\t\n\t    var h = 0, chunk = lineObj.parent;\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i];\n\t      if (line == lineObj) break;\n\t      else h += line.height;\n\t    }\n\t    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n\t      for (var i = 0; i < p.children.length; ++i) {\n\t        var cur = p.children[i];\n\t        if (cur == chunk) break;\n\t        else h += cur.height;\n\t      }\n\t    }\n\t    return h;\n\t  }\n\t\n\t  // Get the bidi ordering for the given line (and cache it). Returns\n\t  // false for lines that are fully left-to-right, and an array of\n\t  // BidiSpan objects otherwise.\n\t  function getOrder(line) {\n\t    var order = line.order;\n\t    if (order == null) order = line.order = bidiOrdering(line.text);\n\t    return order;\n\t  }\n\t\n\t  // HISTORY\n\t\n\t  function History(startGen) {\n\t    // Arrays of change events and selections. Doing something adds an\n\t    // event to done and clears undo. Undoing moves events from done\n\t    // to undone, redoing moves them in the other direction.\n\t    this.done = []; this.undone = [];\n\t    this.undoDepth = Infinity;\n\t    // Used to track when changes can be merged into a single undo\n\t    // event\n\t    this.lastModTime = this.lastSelTime = 0;\n\t    this.lastOp = this.lastSelOp = null;\n\t    this.lastOrigin = this.lastSelOrigin = null;\n\t    // Used by the isClean() method\n\t    this.generation = this.maxGeneration = startGen || 1;\n\t  }\n\t\n\t  // Create a history change event from an updateDoc-style change\n\t  // object.\n\t  function historyChangeFromChange(doc, change) {\n\t    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n\t    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n\t    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n\t    return histChange;\n\t  }\n\t\n\t  // Pop all selection events off the end of a history array. Stop at\n\t  // a change event.\n\t  function clearSelectionEvents(array) {\n\t    while (array.length) {\n\t      var last = lst(array);\n\t      if (last.ranges) array.pop();\n\t      else break;\n\t    }\n\t  }\n\t\n\t  // Find the top change event in the history. Pop off selection\n\t  // events that are in the way.\n\t  function lastChangeEvent(hist, force) {\n\t    if (force) {\n\t      clearSelectionEvents(hist.done);\n\t      return lst(hist.done);\n\t    } else if (hist.done.length && !lst(hist.done).ranges) {\n\t      return lst(hist.done);\n\t    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n\t      hist.done.pop();\n\t      return lst(hist.done);\n\t    }\n\t  }\n\t\n\t  // Register a change in the history. Merges changes that are within\n\t  // a single operation, ore are close together with an origin that\n\t  // allows merging (starting with \"+\") into a single event.\n\t  function addChangeToHistory(doc, change, selAfter, opId) {\n\t    var hist = doc.history;\n\t    hist.undone.length = 0;\n\t    var time = +new Date, cur;\n\t\n\t    if ((hist.lastOp == opId ||\n\t         hist.lastOrigin == change.origin && change.origin &&\n\t         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n\t          change.origin.charAt(0) == \"*\")) &&\n\t        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n\t      // Merge this change into the last event\n\t      var last = lst(cur.changes);\n\t      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n\t        // Optimized case for simple insertion -- don't want to add\n\t        // new changesets for every character typed\n\t        last.to = changeEnd(change);\n\t      } else {\n\t        // Add new sub-event\n\t        cur.changes.push(historyChangeFromChange(doc, change));\n\t      }\n\t    } else {\n\t      // Can not be merged, start a new event.\n\t      var before = lst(hist.done);\n\t      if (!before || !before.ranges)\n\t        pushSelectionToHistory(doc.sel, hist.done);\n\t      cur = {changes: [historyChangeFromChange(doc, change)],\n\t             generation: hist.generation};\n\t      hist.done.push(cur);\n\t      while (hist.done.length > hist.undoDepth) {\n\t        hist.done.shift();\n\t        if (!hist.done[0].ranges) hist.done.shift();\n\t      }\n\t    }\n\t    hist.done.push(selAfter);\n\t    hist.generation = ++hist.maxGeneration;\n\t    hist.lastModTime = hist.lastSelTime = time;\n\t    hist.lastOp = hist.lastSelOp = opId;\n\t    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\t\n\t    if (!last) signal(doc, \"historyAdded\");\n\t  }\n\t\n\t  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n\t    var ch = origin.charAt(0);\n\t    return ch == \"*\" ||\n\t      ch == \"+\" &&\n\t      prev.ranges.length == sel.ranges.length &&\n\t      prev.somethingSelected() == sel.somethingSelected() &&\n\t      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n\t  }\n\t\n\t  // Called whenever the selection changes, sets the new selection as\n\t  // the pending selection in the history, and pushes the old pending\n\t  // selection into the 'done' array when it was significantly\n\t  // different (in number of selected ranges, emptiness, or time).\n\t  function addSelectionToHistory(doc, sel, opId, options) {\n\t    var hist = doc.history, origin = options && options.origin;\n\t\n\t    // A new event is started when the previous origin does not match\n\t    // the current, or the origins don't allow matching. Origins\n\t    // starting with * are always merged, those starting with + are\n\t    // merged when similar and close together in time.\n\t    if (opId == hist.lastSelOp ||\n\t        (origin && hist.lastSelOrigin == origin &&\n\t         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n\t          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n\t      hist.done[hist.done.length - 1] = sel;\n\t    else\n\t      pushSelectionToHistory(sel, hist.done);\n\t\n\t    hist.lastSelTime = +new Date;\n\t    hist.lastSelOrigin = origin;\n\t    hist.lastSelOp = opId;\n\t    if (options && options.clearRedo !== false)\n\t      clearSelectionEvents(hist.undone);\n\t  }\n\t\n\t  function pushSelectionToHistory(sel, dest) {\n\t    var top = lst(dest);\n\t    if (!(top && top.ranges && top.equals(sel)))\n\t      dest.push(sel);\n\t  }\n\t\n\t  // Used to store marked span information in the history.\n\t  function attachLocalSpans(doc, change, from, to) {\n\t    var existing = change[\"spans_\" + doc.id], n = 0;\n\t    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n\t      if (line.markedSpans)\n\t        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n\t      ++n;\n\t    });\n\t  }\n\t\n\t  // When un/re-doing restores text containing marked spans, those\n\t  // that have been explicitly cleared should not be restored.\n\t  function removeClearedSpans(spans) {\n\t    if (!spans) return null;\n\t    for (var i = 0, out; i < spans.length; ++i) {\n\t      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n\t      else if (out) out.push(spans[i]);\n\t    }\n\t    return !out ? spans : out.length ? out : null;\n\t  }\n\t\n\t  // Retrieve and filter the old marked spans stored in a change event.\n\t  function getOldSpans(doc, change) {\n\t    var found = change[\"spans_\" + doc.id];\n\t    if (!found) return null;\n\t    for (var i = 0, nw = []; i < change.text.length; ++i)\n\t      nw.push(removeClearedSpans(found[i]));\n\t    return nw;\n\t  }\n\t\n\t  // Used both to provide a JSON-safe object in .getHistory, and, when\n\t  // detaching a document, to split the history in two\n\t  function copyHistoryArray(events, newGroup, instantiateSel) {\n\t    for (var i = 0, copy = []; i < events.length; ++i) {\n\t      var event = events[i];\n\t      if (event.ranges) {\n\t        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n\t        continue;\n\t      }\n\t      var changes = event.changes, newChanges = [];\n\t      copy.push({changes: newChanges});\n\t      for (var j = 0; j < changes.length; ++j) {\n\t        var change = changes[j], m;\n\t        newChanges.push({from: change.from, to: change.to, text: change.text});\n\t        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n\t          if (indexOf(newGroup, Number(m[1])) > -1) {\n\t            lst(newChanges)[prop] = change[prop];\n\t            delete change[prop];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return copy;\n\t  }\n\t\n\t  // Rebasing/resetting history to deal with externally-sourced changes\n\t\n\t  function rebaseHistSelSingle(pos, from, to, diff) {\n\t    if (to < pos.line) {\n\t      pos.line += diff;\n\t    } else if (from < pos.line) {\n\t      pos.line = from;\n\t      pos.ch = 0;\n\t    }\n\t  }\n\t\n\t  // Tries to rebase an array of history events given a change in the\n\t  // document. If the change touches the same lines as the event, the\n\t  // event, and everything 'behind' it, is discarded. If the change is\n\t  // before the event, the event's positions are updated. Uses a\n\t  // copy-on-write scheme for the positions, to avoid having to\n\t  // reallocate them all on every rebase, but also avoid problems with\n\t  // shared position objects being unsafely updated.\n\t  function rebaseHistArray(array, from, to, diff) {\n\t    for (var i = 0; i < array.length; ++i) {\n\t      var sub = array[i], ok = true;\n\t      if (sub.ranges) {\n\t        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n\t        for (var j = 0; j < sub.ranges.length; j++) {\n\t          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n\t          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n\t        }\n\t        continue;\n\t      }\n\t      for (var j = 0; j < sub.changes.length; ++j) {\n\t        var cur = sub.changes[j];\n\t        if (to < cur.from.line) {\n\t          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n\t          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n\t        } else if (from <= cur.to.line) {\n\t          ok = false;\n\t          break;\n\t        }\n\t      }\n\t      if (!ok) {\n\t        array.splice(0, i + 1);\n\t        i = 0;\n\t      }\n\t    }\n\t  }\n\t\n\t  function rebaseHist(hist, change) {\n\t    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n\t    rebaseHistArray(hist.done, from, to, diff);\n\t    rebaseHistArray(hist.undone, from, to, diff);\n\t  }\n\t\n\t  // EVENT UTILITIES\n\t\n\t  // Due to the fact that we still support jurassic IE versions, some\n\t  // compatibility wrappers are needed.\n\t\n\t  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n\t    if (e.preventDefault) e.preventDefault();\n\t    else e.returnValue = false;\n\t  };\n\t  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n\t    if (e.stopPropagation) e.stopPropagation();\n\t    else e.cancelBubble = true;\n\t  };\n\t  function e_defaultPrevented(e) {\n\t    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n\t  }\n\t  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\t\n\t  function e_target(e) {return e.target || e.srcElement;}\n\t  function e_button(e) {\n\t    var b = e.which;\n\t    if (b == null) {\n\t      if (e.button & 1) b = 1;\n\t      else if (e.button & 2) b = 3;\n\t      else if (e.button & 4) b = 2;\n\t    }\n\t    if (mac && e.ctrlKey && b == 1) b = 3;\n\t    return b;\n\t  }\n\t\n\t  // EVENT HANDLING\n\t\n\t  // Lightweight event framework. on/off also work on DOM nodes,\n\t  // registering native DOM handlers.\n\t\n\t  var on = CodeMirror.on = function(emitter, type, f) {\n\t    if (emitter.addEventListener)\n\t      emitter.addEventListener(type, f, false);\n\t    else if (emitter.attachEvent)\n\t      emitter.attachEvent(\"on\" + type, f);\n\t    else {\n\t      var map = emitter._handlers || (emitter._handlers = {});\n\t      var arr = map[type] || (map[type] = []);\n\t      arr.push(f);\n\t    }\n\t  };\n\t\n\t  var noHandlers = []\n\t  function getHandlers(emitter, type, copy) {\n\t    var arr = emitter._handlers && emitter._handlers[type]\n\t    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n\t    else return arr || noHandlers\n\t  }\n\t\n\t  var off = CodeMirror.off = function(emitter, type, f) {\n\t    if (emitter.removeEventListener)\n\t      emitter.removeEventListener(type, f, false);\n\t    else if (emitter.detachEvent)\n\t      emitter.detachEvent(\"on\" + type, f);\n\t    else {\n\t      var handlers = getHandlers(emitter, type, false)\n\t      for (var i = 0; i < handlers.length; ++i)\n\t        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n\t    }\n\t  };\n\t\n\t  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n\t    var handlers = getHandlers(emitter, type, true)\n\t    if (!handlers.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n\t  };\n\t\n\t  var orphanDelayedCallbacks = null;\n\t\n\t  // Often, we want to signal events at a point where we are in the\n\t  // middle of some work, but don't want the handler to start calling\n\t  // other methods on the editor, which might be in an inconsistent\n\t  // state or simply not expect any other events to happen.\n\t  // signalLater looks whether there are any handlers, and schedules\n\t  // them to be executed when the last operation ends, or, if no\n\t  // operation is active, when a timeout fires.\n\t  function signalLater(emitter, type /*, values...*/) {\n\t    var arr = getHandlers(emitter, type, false)\n\t    if (!arr.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2), list;\n\t    if (operationGroup) {\n\t      list = operationGroup.delayedCallbacks;\n\t    } else if (orphanDelayedCallbacks) {\n\t      list = orphanDelayedCallbacks;\n\t    } else {\n\t      list = orphanDelayedCallbacks = [];\n\t      setTimeout(fireOrphanDelayed, 0);\n\t    }\n\t    function bnd(f) {return function(){f.apply(null, args);};};\n\t    for (var i = 0; i < arr.length; ++i)\n\t      list.push(bnd(arr[i]));\n\t  }\n\t\n\t  function fireOrphanDelayed() {\n\t    var delayed = orphanDelayedCallbacks;\n\t    orphanDelayedCallbacks = null;\n\t    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n\t  }\n\t\n\t  // The DOM events that CodeMirror handles can be overridden by\n\t  // registering a (non-DOM) handler on the editor for the event name,\n\t  // and preventDefault-ing the event in that handler.\n\t  function signalDOMEvent(cm, e, override) {\n\t    if (typeof e == \"string\")\n\t      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n\t    signal(cm, override || e.type, cm, e);\n\t    return e_defaultPrevented(e) || e.codemirrorIgnore;\n\t  }\n\t\n\t  function signalCursorActivity(cm) {\n\t    var arr = cm._handlers && cm._handlers.cursorActivity;\n\t    if (!arr) return;\n\t    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n\t    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n\t      set.push(arr[i]);\n\t  }\n\t\n\t  function hasHandler(emitter, type) {\n\t    return getHandlers(emitter, type).length > 0\n\t  }\n\t\n\t  // Add on and off methods to a constructor's prototype, to make\n\t  // registering events on such objects more convenient.\n\t  function eventMixin(ctor) {\n\t    ctor.prototype.on = function(type, f) {on(this, type, f);};\n\t    ctor.prototype.off = function(type, f) {off(this, type, f);};\n\t  }\n\t\n\t  // MISC UTILITIES\n\t\n\t  // Number of pixels added to scroller and sizer to hide scrollbar\n\t  var scrollerGap = 30;\n\t\n\t  // Returned or thrown by various protocols to signal 'I'm not\n\t  // handling this'.\n\t  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\t\n\t  // Reused option objects for setSelection & friends\n\t  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\t\n\t  function Delayed() {this.id = null;}\n\t  Delayed.prototype.set = function(ms, f) {\n\t    clearTimeout(this.id);\n\t    this.id = setTimeout(f, ms);\n\t  };\n\t\n\t  // Counts the column offset in a string, taking tabs into account.\n\t  // Used mostly to find indentation.\n\t  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n\t    if (end == null) {\n\t      end = string.search(/[^\\s\\u00a0]/);\n\t      if (end == -1) end = string.length;\n\t    }\n\t    for (var i = startIndex || 0, n = startValue || 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", i);\n\t      if (nextTab < 0 || nextTab >= end)\n\t        return n + (end - i);\n\t      n += nextTab - i;\n\t      n += tabSize - (n % tabSize);\n\t      i = nextTab + 1;\n\t    }\n\t  };\n\t\n\t  // The inverse of countColumn -- find the offset that corresponds to\n\t  // a particular column.\n\t  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n\t    for (var pos = 0, col = 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", pos);\n\t      if (nextTab == -1) nextTab = string.length;\n\t      var skipped = nextTab - pos;\n\t      if (nextTab == string.length || col + skipped >= goal)\n\t        return pos + Math.min(skipped, goal - col);\n\t      col += nextTab - pos;\n\t      col += tabSize - (col % tabSize);\n\t      pos = nextTab + 1;\n\t      if (col >= goal) return pos;\n\t    }\n\t  }\n\t\n\t  var spaceStrs = [\"\"];\n\t  function spaceStr(n) {\n\t    while (spaceStrs.length <= n)\n\t      spaceStrs.push(lst(spaceStrs) + \" \");\n\t    return spaceStrs[n];\n\t  }\n\t\n\t  function lst(arr) { return arr[arr.length-1]; }\n\t\n\t  var selectInput = function(node) { node.select(); };\n\t  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n\t    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n\t  else if (ie) // Suppress mysterious IE10 errors\n\t    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\t\n\t  function indexOf(array, elt) {\n\t    for (var i = 0; i < array.length; ++i)\n\t      if (array[i] == elt) return i;\n\t    return -1;\n\t  }\n\t  function map(array, f) {\n\t    var out = [];\n\t    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n\t    return out;\n\t  }\n\t\n\t  function nothing() {}\n\t\n\t  function createObj(base, props) {\n\t    var inst;\n\t    if (Object.create) {\n\t      inst = Object.create(base);\n\t    } else {\n\t      nothing.prototype = base;\n\t      inst = new nothing();\n\t    }\n\t    if (props) copyObj(props, inst);\n\t    return inst;\n\t  };\n\t\n\t  function copyObj(obj, target, overwrite) {\n\t    if (!target) target = {};\n\t    for (var prop in obj)\n\t      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n\t        target[prop] = obj[prop];\n\t    return target;\n\t  }\n\t\n\t  function bind(f) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    return function(){return f.apply(null, args);};\n\t  }\n\t\n\t  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\t  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n\t    return /\\w/.test(ch) || ch > \"\\x80\" &&\n\t      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n\t  };\n\t  function isWordChar(ch, helper) {\n\t    if (!helper) return isWordCharBasic(ch);\n\t    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n\t    return helper.test(ch);\n\t  }\n\t\n\t  function isEmpty(obj) {\n\t    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n\t    return true;\n\t  }\n\t\n\t  // Extending unicode characters. A series of a non-extending char +\n\t  // any number of extending chars is treated as a single unit as far\n\t  // as editing and measuring is concerned. This is not fully correct,\n\t  // since some scripts/fonts/browsers also treat other configurations\n\t  // of code points as a group.\n\t  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\t  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\t\n\t  // DOM UTILITIES\n\t\n\t  function elt(tag, content, className, style) {\n\t    var e = document.createElement(tag);\n\t    if (className) e.className = className;\n\t    if (style) e.style.cssText = style;\n\t    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n\t    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n\t    return e;\n\t  }\n\t\n\t  var range;\n\t  if (document.createRange) range = function(node, start, end, endNode) {\n\t    var r = document.createRange();\n\t    r.setEnd(endNode || node, end);\n\t    r.setStart(node, start);\n\t    return r;\n\t  };\n\t  else range = function(node, start, end) {\n\t    var r = document.body.createTextRange();\n\t    try { r.moveToElementText(node.parentNode); }\n\t    catch(e) { return r; }\n\t    r.collapse(true);\n\t    r.moveEnd(\"character\", end);\n\t    r.moveStart(\"character\", start);\n\t    return r;\n\t  };\n\t\n\t  function removeChildren(e) {\n\t    for (var count = e.childNodes.length; count > 0; --count)\n\t      e.removeChild(e.firstChild);\n\t    return e;\n\t  }\n\t\n\t  function removeChildrenAndAdd(parent, e) {\n\t    return removeChildren(parent).appendChild(e);\n\t  }\n\t\n\t  var contains = CodeMirror.contains = function(parent, child) {\n\t    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n\t      child = child.parentNode;\n\t    if (parent.contains)\n\t      return parent.contains(child);\n\t    do {\n\t      if (child.nodeType == 11) child = child.host;\n\t      if (child == parent) return true;\n\t    } while (child = child.parentNode);\n\t  };\n\t\n\t  function activeElt() {\n\t    var activeElement = document.activeElement;\n\t    while (activeElement && activeElement.root && activeElement.root.activeElement)\n\t      activeElement = activeElement.root.activeElement;\n\t    return activeElement;\n\t  }\n\t  // Older versions of IE throws unspecified error when touching\n\t  // document.activeElement in some cases (during loading, in iframe)\n\t  if (ie && ie_version < 11) activeElt = function() {\n\t    try { return document.activeElement; }\n\t    catch(e) { return document.body; }\n\t  };\n\t\n\t  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n\t  var rmClass = CodeMirror.rmClass = function(node, cls) {\n\t    var current = node.className;\n\t    var match = classTest(cls).exec(current);\n\t    if (match) {\n\t      var after = current.slice(match.index + match[0].length);\n\t      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n\t    }\n\t  };\n\t  var addClass = CodeMirror.addClass = function(node, cls) {\n\t    var current = node.className;\n\t    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n\t  };\n\t  function joinClasses(a, b) {\n\t    var as = a.split(\" \");\n\t    for (var i = 0; i < as.length; i++)\n\t      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n\t    return b;\n\t  }\n\t\n\t  // WINDOW-WIDE EVENTS\n\t\n\t  // These must be handled carefully, because naively registering a\n\t  // handler for each editor will cause the editors to never be\n\t  // garbage collected.\n\t\n\t  function forEachCodeMirror(f) {\n\t    if (!document.body.getElementsByClassName) return;\n\t    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n\t    for (var i = 0; i < byClass.length; i++) {\n\t      var cm = byClass[i].CodeMirror;\n\t      if (cm) f(cm);\n\t    }\n\t  }\n\t\n\t  var globalsRegistered = false;\n\t  function ensureGlobalHandlers() {\n\t    if (globalsRegistered) return;\n\t    registerGlobalHandlers();\n\t    globalsRegistered = true;\n\t  }\n\t  function registerGlobalHandlers() {\n\t    // When the window resizes, we need to refresh active editors.\n\t    var resizeTimer;\n\t    on(window, \"resize\", function() {\n\t      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n\t        resizeTimer = null;\n\t        forEachCodeMirror(onResize);\n\t      }, 100);\n\t    });\n\t    // When the window loses focus, we want to show the editor as blurred\n\t    on(window, \"blur\", function() {\n\t      forEachCodeMirror(onBlur);\n\t    });\n\t  }\n\t\n\t  // FEATURE DETECTION\n\t\n\t  // Detect drag-and-drop\n\t  var dragAndDrop = function() {\n\t    // There is *some* kind of drag-and-drop support in IE6-8, but I\n\t    // couldn't get it to work yet.\n\t    if (ie && ie_version < 9) return false;\n\t    var div = elt('div');\n\t    return \"draggable\" in div || \"dragDrop\" in div;\n\t  }();\n\t\n\t  var zwspSupported;\n\t  function zeroWidthElement(measure) {\n\t    if (zwspSupported == null) {\n\t      var test = elt(\"span\", \"\\u200b\");\n\t      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\t      if (measure.firstChild.offsetHeight != 0)\n\t        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n\t    }\n\t    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n\t      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n\t    node.setAttribute(\"cm-text\", \"\");\n\t    return node;\n\t  }\n\t\n\t  // Feature-detect IE's crummy client rect reporting for bidi text\n\t  var badBidiRects;\n\t  function hasBadBidiRects(measure) {\n\t    if (badBidiRects != null) return badBidiRects;\n\t    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n\t    var r0 = range(txt, 0, 1).getBoundingClientRect();\n\t    var r1 = range(txt, 1, 2).getBoundingClientRect();\n\t    removeChildren(measure);\n\t    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n\t    return badBidiRects = (r1.right - r0.right < 3);\n\t  }\n\t\n\t  // See if \"\".split is the broken IE version, if so, provide an\n\t  // alternative way to split lines.\n\t  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n\t    var pos = 0, result = [], l = string.length;\n\t    while (pos <= l) {\n\t      var nl = string.indexOf(\"\\n\", pos);\n\t      if (nl == -1) nl = string.length;\n\t      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n\t      var rt = line.indexOf(\"\\r\");\n\t      if (rt != -1) {\n\t        result.push(line.slice(0, rt));\n\t        pos += rt + 1;\n\t      } else {\n\t        result.push(line);\n\t        pos = nl + 1;\n\t      }\n\t    }\n\t    return result;\n\t  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\t\n\t  var hasSelection = window.getSelection ? function(te) {\n\t    try { return te.selectionStart != te.selectionEnd; }\n\t    catch(e) { return false; }\n\t  } : function(te) {\n\t    try {var range = te.ownerDocument.selection.createRange();}\n\t    catch(e) {}\n\t    if (!range || range.parentElement() != te) return false;\n\t    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n\t  };\n\t\n\t  var hasCopyEvent = (function() {\n\t    var e = elt(\"div\");\n\t    if (\"oncopy\" in e) return true;\n\t    e.setAttribute(\"oncopy\", \"return;\");\n\t    return typeof e.oncopy == \"function\";\n\t  })();\n\t\n\t  var badZoomedRects = null;\n\t  function hasBadZoomedRects(measure) {\n\t    if (badZoomedRects != null) return badZoomedRects;\n\t    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n\t    var normal = node.getBoundingClientRect();\n\t    var fromRange = range(node, 0, 1).getBoundingClientRect();\n\t    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n\t  }\n\t\n\t  // KEY NAMES\n\t\n\t  var keyNames = CodeMirror.keyNames = {\n\t    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n\t    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n\t    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n\t    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n\t    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n\t    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n\t    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n\t    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n\t  };\n\t  (function() {\n\t    // Number keys\n\t    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n\t    // Alphabetic keys\n\t    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n\t    // Function keys\n\t    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n\t  })();\n\t\n\t  // BIDI HELPERS\n\t\n\t  function iterateBidiSections(order, from, to, f) {\n\t    if (!order) return f(from, to, \"ltr\");\n\t    var found = false;\n\t    for (var i = 0; i < order.length; ++i) {\n\t      var part = order[i];\n\t      if (part.from < to && part.to > from || from == to && part.to == from) {\n\t        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n\t        found = true;\n\t      }\n\t    }\n\t    if (!found) f(from, to, \"ltr\");\n\t  }\n\t\n\t  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n\t  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\t\n\t  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n\t  function lineRight(line) {\n\t    var order = getOrder(line);\n\t    if (!order) return line.text.length;\n\t    return bidiRight(lst(order));\n\t  }\n\t\n\t  function lineStart(cm, lineN) {\n\t    var line = getLine(cm.doc, lineN);\n\t    var visual = visualLine(line);\n\t    if (visual != line) lineN = lineNo(visual);\n\t    var order = getOrder(visual);\n\t    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n\t    return Pos(lineN, ch);\n\t  }\n\t  function lineEnd(cm, lineN) {\n\t    var merged, line = getLine(cm.doc, lineN);\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      lineN = null;\n\t    }\n\t    var order = getOrder(line);\n\t    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n\t    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n\t  }\n\t  function lineStartSmart(cm, pos) {\n\t    var start = lineStart(cm, pos.line);\n\t    var line = getLine(cm.doc, start.line);\n\t    var order = getOrder(line);\n\t    if (!order || order[0].level == 0) {\n\t      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n\t      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n\t      return Pos(start.line, inWS ? 0 : firstNonWS);\n\t    }\n\t    return start;\n\t  }\n\t\n\t  function compareBidiLevel(order, a, b) {\n\t    var linedir = order[0].level;\n\t    if (a == linedir) return true;\n\t    if (b == linedir) return false;\n\t    return a < b;\n\t  }\n\t  var bidiOther;\n\t  function getBidiPartAt(order, pos) {\n\t    bidiOther = null;\n\t    for (var i = 0, found; i < order.length; ++i) {\n\t      var cur = order[i];\n\t      if (cur.from < pos && cur.to > pos) return i;\n\t      if ((cur.from == pos || cur.to == pos)) {\n\t        if (found == null) {\n\t          found = i;\n\t        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n\t          if (cur.from != cur.to) bidiOther = found;\n\t          return i;\n\t        } else {\n\t          if (cur.from != cur.to) bidiOther = i;\n\t          return found;\n\t        }\n\t      }\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function moveInLine(line, pos, dir, byUnit) {\n\t    if (!byUnit) return pos + dir;\n\t    do pos += dir;\n\t    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n\t    return pos;\n\t  }\n\t\n\t  // This is needed in order to move 'visually' through bi-directional\n\t  // text -- i.e., pressing left should make the cursor go left, even\n\t  // when in RTL text. The tricky part is the 'jumps', where RTL and\n\t  // LTR text touch each other. This often requires the cursor offset\n\t  // to move more than one unit, in order to visually move one unit.\n\t  function moveVisually(line, start, dir, byUnit) {\n\t    var bidi = getOrder(line);\n\t    if (!bidi) return moveLogically(line, start, dir, byUnit);\n\t    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n\t    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\t\n\t    for (;;) {\n\t      if (target > part.from && target < part.to) return target;\n\t      if (target == part.from || target == part.to) {\n\t        if (getBidiPartAt(bidi, target) == pos) return target;\n\t        part = bidi[pos += dir];\n\t        return (dir > 0) == part.level % 2 ? part.to : part.from;\n\t      } else {\n\t        part = bidi[pos += dir];\n\t        if (!part) return null;\n\t        if ((dir > 0) == part.level % 2)\n\t          target = moveInLine(line, part.to, -1, byUnit);\n\t        else\n\t          target = moveInLine(line, part.from, 1, byUnit);\n\t      }\n\t    }\n\t  }\n\t\n\t  function moveLogically(line, start, dir, byUnit) {\n\t    var target = start + dir;\n\t    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n\t    return target < 0 || target > line.text.length ? null : target;\n\t  }\n\t\n\t  // Bidirectional ordering algorithm\n\t  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n\t  // that this (partially) implements.\n\t\n\t  // One-char codes used for character types:\n\t  // L (L):   Left-to-Right\n\t  // R (R):   Right-to-Left\n\t  // r (AL):  Right-to-Left Arabic\n\t  // 1 (EN):  European Number\n\t  // + (ES):  European Number Separator\n\t  // % (ET):  European Number Terminator\n\t  // n (AN):  Arabic Number\n\t  // , (CS):  Common Number Separator\n\t  // m (NSM): Non-Spacing Mark\n\t  // b (BN):  Boundary Neutral\n\t  // s (B):   Paragraph Separator\n\t  // t (S):   Segment Separator\n\t  // w (WS):  Whitespace\n\t  // N (ON):  Other Neutrals\n\t\n\t  // Returns null if characters are ordered as they appear\n\t  // (left-to-right), or an array of sections ({from, to, level}\n\t  // objects) in the order in which they occur visually.\n\t  var bidiOrdering = (function() {\n\t    // Character types for codepoints 0 to 0xff\n\t    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n\t    // Character types for codepoints 0x600 to 0x6ff\n\t    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n\t    function charType(code) {\n\t      if (code <= 0xf7) return lowTypes.charAt(code);\n\t      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n\t      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n\t      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n\t      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n\t      else if (code == 0x200c) return \"b\";\n\t      else return \"L\";\n\t    }\n\t\n\t    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\t    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\t    // Browsers seem to always treat the boundaries of block elements as being L.\n\t    var outerType = \"L\";\n\t\n\t    function BidiSpan(level, from, to) {\n\t      this.level = level;\n\t      this.from = from; this.to = to;\n\t    }\n\t\n\t    return function(str) {\n\t      if (!bidiRE.test(str)) return false;\n\t      var len = str.length, types = [];\n\t      for (var i = 0, type; i < len; ++i)\n\t        types.push(type = charType(str.charCodeAt(i)));\n\t\n\t      // W1. Examine each non-spacing mark (NSM) in the level run, and\n\t      // change the type of the NSM to the type of the previous\n\t      // character. If the NSM is at the start of the level run, it will\n\t      // get the type of sor.\n\t      for (var i = 0, prev = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"m\") types[i] = prev;\n\t        else prev = type;\n\t      }\n\t\n\t      // W2. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, AL, or sor) is found. If an\n\t      // AL is found, change the type of the European number to Arabic\n\t      // number.\n\t      // W3. Change all ALs to R.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n\t        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n\t      }\n\t\n\t      // W4. A single European separator between two European numbers\n\t      // changes to a European number. A single common separator between\n\t      // two numbers of the same type changes to that type.\n\t      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n\t        var type = types[i];\n\t        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n\t        else if (type == \",\" && prev == types[i+1] &&\n\t                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n\t        prev = type;\n\t      }\n\t\n\t      // W5. A sequence of European terminators adjacent to European\n\t      // numbers changes to all European numbers.\n\t      // W6. Otherwise, separators and terminators change to Other\n\t      // Neutral.\n\t      for (var i = 0; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \",\") types[i] = \"N\";\n\t        else if (type == \"%\") {\n\t          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n\t          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // W7. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, or sor) is found. If an L is\n\t      // found, then change the type of the European number to L.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n\t        else if (isStrong.test(type)) cur = type;\n\t      }\n\t\n\t      // N1. A sequence of neutrals takes the direction of the\n\t      // surrounding strong text if the text on both sides has the same\n\t      // direction. European and Arabic numbers act as if they were R in\n\t      // terms of their influence on neutrals. Start-of-level-run (sor)\n\t      // and end-of-level-run (eor) are used at level run boundaries.\n\t      // N2. Any remaining neutrals take the embedding direction.\n\t      for (var i = 0; i < len; ++i) {\n\t        if (isNeutral.test(types[i])) {\n\t          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n\t          var before = (i ? types[i-1] : outerType) == \"L\";\n\t          var after = (end < len ? types[end] : outerType) == \"L\";\n\t          var replace = before || after ? \"L\" : \"R\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // Here we depart from the documented algorithm, in order to avoid\n\t      // building up an actual levels array. Since there are only three\n\t      // levels (0, 1, 2) in an implementation that doesn't take\n\t      // explicit embedding into account, we can build up the order on\n\t      // the fly, without following the level-based algorithm.\n\t      var order = [], m;\n\t      for (var i = 0; i < len;) {\n\t        if (countsAsLeft.test(types[i])) {\n\t          var start = i;\n\t          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n\t          order.push(new BidiSpan(0, start, i));\n\t        } else {\n\t          var pos = i, at = order.length;\n\t          for (++i; i < len && types[i] != \"L\"; ++i) {}\n\t          for (var j = pos; j < i;) {\n\t            if (countsAsNum.test(types[j])) {\n\t              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n\t              var nstart = j;\n\t              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n\t              order.splice(at, 0, new BidiSpan(2, nstart, j));\n\t              pos = j;\n\t            } else ++j;\n\t          }\n\t          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n\t        }\n\t      }\n\t      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n\t        order[0].from = m[0].length;\n\t        order.unshift(new BidiSpan(0, 0, m[0].length));\n\t      }\n\t      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n\t        lst(order).to -= m[0].length;\n\t        order.push(new BidiSpan(0, len - m[0].length, len));\n\t      }\n\t      if (order[0].level == 2)\n\t        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n\t      if (order[0].level != lst(order).level)\n\t        order.push(new BidiSpan(order[0].level, len, len));\n\t\n\t      return order;\n\t    };\n\t  })();\n\t\n\t  // THE END\n\t\n\t  CodeMirror.version = \"5.17.0\";\n\t\n\t  return CodeMirror;\n\t});\n\n\n/***/ },\n\n/***/ 81:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {\n\t  $.extend($.summernote.lang, {\n\t    'pt-BR': {\n\t      font: {\n\t        bold: 'Negrito',\n\t        italic: 'Itálico',\n\t        underline: 'Sublinhado',\n\t        clear: 'Remover estilo da fonte',\n\t        height: 'Altura da linha',\n\t        name: 'Fonte',\n\t        strikethrough: 'Riscado',\n\t        size: 'Tamanho da fonte'\n\t      },\n\t      image: {\n\t        image: 'Imagem',\n\t        insert: 'Inserir imagem',\n\t        resizeFull: 'Redimensionar Completamente',\n\t        resizeHalf: 'Redimensionar pela Metade',\n\t        resizeQuarter: 'Redimensionar um Quarto',\n\t        floatLeft: 'Flutuar para Esquerda',\n\t        floatRight: 'Flutuar para Direira',\n\t        floatNone: 'Não Flutuar',\n\t        dragImageHere: 'Arraste uma imagem para cá',\n\t        selectFromFiles: 'Selecione a partir dos arquivos',\n\t        url: 'URL da imagem'\n\t      },\n\t      video: {\n\t        video: 'Vídeo',\n\t        videoLink: 'Link para vídeo',\n\t        insert: 'Inserir vídeo',\n\t        url: 'URL do vídeo?',\n\t        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion ou Youku)'\n\t      },\n\t      link: {\n\t        link: 'Link',\n\t        insert: 'Inserir link',\n\t        unlink: 'Remover link',\n\t        edit: 'Editar',\n\t        textToDisplay: 'Texto para exibir',\n\t        url: 'Para qual URL esse link leva?',\n\t        openInNewWindow: 'Abrir em uma nova janela'\n\t      },\n\t      table: {\n\t        table: 'Tabela'\n\t      },\n\t      hr: {\n\t        insert: 'Inserir linha horizontal'\n\t      },\n\t      style: {\n\t        style: 'Estilo',\n\t        normal: 'Normal',\n\t        blockquote: 'Citação',\n\t        pre: 'Código',\n\t        h1: 'Título 1',\n\t        h2: 'Título 2',\n\t        h3: 'Título 3',\n\t        h4: 'Título 4',\n\t        h5: 'Título 5',\n\t        h6: 'Título 6'\n\t      },\n\t      lists: {\n\t        unordered: 'Lista com marcadores',\n\t        ordered: 'Lista numerada'\n\t      },\n\t      options: {\n\t        help: 'Ajuda',\n\t        fullscreen: 'Tela cheia',\n\t        codeview: 'Ver código-fonte'\n\t      },\n\t      paragraph: {\n\t        paragraph: 'Parágrafo',\n\t        outdent: 'Menor tabulação',\n\t        indent: 'Maior tabulação',\n\t        left: 'Alinhar à esquerda',\n\t        center: 'Alinhar ao centro',\n\t        right: 'Alinha à direita',\n\t        justify: 'Justificado'\n\t      },\n\t      color: {\n\t        recent: 'Cor recente',\n\t        more: 'Mais cores',\n\t        background: 'Fundo',\n\t        foreground: 'Fonte',\n\t        transparent: 'Transparente',\n\t        setTransparent: 'Fundo transparente',\n\t        reset: 'Restaurar',\n\t        resetToDefault: 'Restaurar padrão'\n\t      },\n\t      shortcut: {\n\t        shortcuts: 'Atalhos do teclado',\n\t        close: 'Fechar',\n\t        textFormatting: 'Formatação de texto',\n\t        action: 'Ação',\n\t        paragraphFormatting: 'Formatação de parágrafo',\n\t        documentStyle: 'Estilo de documento'\n\t      },\n\t      history: {\n\t        undo: 'Desfazer',\n\t        redo: 'Refazer'\n\t      },\n\t      help: {\n\t        'insertParagraph': 'Inserir Parágrafo',\n\t        'undo': 'Desfazer o último comando',\n\t        'redo': 'Refazer o último comando',\n\t        'tab': 'Tab',\n\t        'untab': 'Desfazer tab',\n\t        'bold': 'Colocar em negrito',\n\t        'italic': 'Colocar em itálico',\n\t        'underline': 'Sublinhado',\n\t        'strikethrough': 'Tachado',\n\t        'removeFormat': 'Remover estilo',\n\t        'justifyLeft': 'Alinhar à esquerda',\n\t        'justifyCenter': 'Centralizar',\n\t        'justifyRight': 'Alinhar à esquerda',\n\t        'justifyFull': 'Justificar',\n\t        'insertUnorderedList': 'Lista não ordenada',\n\t        'insertOrderedList': 'Lista ordenada',\n\t        'outdent': 'Recuar parágrafo atual',\n\t        'indent': 'Avançar parágrafo atual',\n\t        'formatPara': 'Alterar formato do bloco para parágrafo(tag P)',\n\t        'formatH1': 'Alterar formato do bloco para H1',\n\t        'formatH2': 'Alterar formato do bloco para H2',\n\t        'formatH3': 'Alterar formato do bloco para H3',\n\t        'formatH4': 'Alterar formato do bloco para H4',\n\t        'formatH5': 'Alterar formato do bloco para H5',\n\t        'formatH6': 'Alterar formato do bloco para H6',\n\t        'insertHorizontalRule': 'Inserir régua horizontal',\n\t        'linkDialog.show': 'Inserir um Hiperlink'\n\t      }\n\t    }\n\t  });\n\t})(jQuery);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n\n/***/ 82:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\t(function (factory) {\n\t  /* global define */\n\t  if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof module === 'object' && module.exports) {\n\t    // Node/CommonJS\n\t    module.exports = factory(require('jquery'));\n\t  } else {\n\t    // Browser globals\n\t    factory(window.jQuery);\n\t  }\n\t})(function ($) {\n\t  var embedToSummernote = function embedToSummernote(context) {\n\t    var self = this;\n\t\n\t    var options = context.options;\n\t    var inToolbar = false;\n\t\n\t    for (var idx in options.toolbar) {\n\t      // toolbar => [groupName, [list of button]]\n\t      var buttons = options.toolbar[idx][1];\n\t      if ($.inArray('oembed', buttons) > -1) {\n\t        inToolbar = true;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!inToolbar) {\n\t      return;\n\t    }\n\t\n\t    var ui = $.summernote.ui;\n\t    var $editor = context.layoutInfo.editor;\n\t    var lang = options.langInfo;\n\t\n\t    var oEmbedOptions = {\n\t      service: 'https://noembed.com/'\n\t    };\n\t\n\t    options.oEmbed = $.extend(oEmbedOptions, options.oEmbed);\n\t\n\t    context.memo('button.oembed', function () {\n\t      var button = ui.button({\n\t        contents: '<i class=\"note-icon-frame\">',\n\t        tooltip: lang.oEmbedButton.tooltip,\n\t        click: function click(event) {\n\t          self.show();\n\t        }\n\t      });\n\t\n\t      return button.render();\n\t    });\n\t\n\t    this.show = function () {\n\t      context.invoke('editor.saveRange');\n\t\n\t      self.showEmbedDialog().then(function showEmbedDialogCb(data) {\n\t        context.invoke('editor.restoreRange');\n\t        self.insertEmbedToEditor(data.uri);\n\t        ui.hideDialog(self.$dialog);\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t\n\t    this.showEmbedDialog = function () {\n\t      self.disableAddButton();\n\t      self.$embedInput.value = '';\n\t\n\t      return $.Deferred(function (deferred) {\n\t        ui.onDialogShown(self.$dialog, function dialogShownCb() {\n\t          context.triggerEvent('dialog.shown');\n\t          self.$embedInput.focus();\n\t\n\t          self.$addBtn.on('click', function addEmbedCb(event) {\n\t            event.preventDefault();\n\t            deferred.resolve({\n\t              uri: self.$embedInput.value\n\t            });\n\t          });\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function dialogHiddenCb() {\n\t          self.$addBtn.off('click');\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      });\n\t    };\n\t\n\t    this.createDialog = function ($container) {\n\t      var dialogOption = {\n\t        title: lang.oEmbedDialog.title,\n\t        body: '<div class=\"form-group\">' + '<label>' + lang.oEmbedDialog.label + '</label>' + '<input id=\"input-autocomplete\" class=\"form-control\" type=\"text\" placeholder=\"' + lang.oEmbedDialog.placeholder + '\" />' + '</div>' + '<div id=\"embed-in-dialog\"></div>',\n\t        footer: '<button href=\"#\" id=\"btn-add\" class=\"btn btn-primary\">' + lang.oEmbedDialog.button + '</button>',\n\t        closeOnEscape: true\n\t      };\n\t\n\t      self.$dialog = ui.dialog(dialogOption).render().appendTo($container);\n\t      self.$addBtn = self.$dialog.find('#btn-add');\n\t      self.$embedInput = self.$dialog.find('#input-autocomplete')[0];\n\t      self.$embedContainer = self.$dialog.find('#embed-in-dialog')[0];\n\t    };\n\t\n\t    this.enableAddButton = function () {\n\t      if (self.$embedInput.value && self.$embedInput.value.length > 0) {\n\t        self.$addBtn.attr(\"disabled\", false);\n\t      }\n\t    };\n\t\n\t    this.disableAddButton = function () {\n\t      self.$addBtn.attr(\"disabled\", true);\n\t    };\n\t\n\t    this.insertEmbedToEditor = function (iframe) {\n\t      var $div = $('<div>');\n\t\n\t      $.getJSON(options.oEmbed.service + '?url=' + iframe).done(function (data) {\n\t        $div.html(self.normalizeEmbed(data.html));\n\t\n\t        context.invoke('editor.insertNode', $div[0]);\n\t        self.$embedContainer.innerHTML = '';\n\t      });\n\t    };\n\t\n\t    this.normalizeEmbed = function (data) {\n\t\n\t      if (data) {\n\t        var $div = $('<div>');\n\t        var $iframe = $(data).find(\"iframe\");\n\t\n\t        $div.css({\n\t          'position': 'relative',\n\t          'padding-top': '25px',\n\t          'padding-bottom': '56.25%',\n\t          'height': '0'\n\t        });\n\t        $iframe.css({\n\t          'position': 'absolute',\n\t          'top': '0',\n\t          'left': '0',\n\t          'width': '100%',\n\t          'height': '100%'\n\t        });\n\t        $iframe.removeAttr(\"width\");\n\t        $iframe.removeAttr(\"height\");\n\t\n\t        $div.html($iframe);\n\t\n\t        return $div;\n\t      } else {\n\t        console.log(lang);\n\t        throw new Error(lang.errorMessage.invalid_provider);\n\t      }\n\t    };\n\t\n\t    this.initOembed = function () {\n\t\n\t      self.$embedInput.addEventListener('input', function (event) {\n\t\n\t        var url = this.value;\n\t\n\t        setTimeout(function () {\n\t          if (options.oEmbed.spinner) {\n\t            self.$embedContainer.innerHTML = options.oEmbed.spinner;\n\t          }\n\t\n\t          $.getJSON(options.oEmbed.service + '?url=' + url).done(function (data) {\n\t\n\t            var content;\n\t            try {\n\t              content = self.normalizeEmbed(data.html);\n\t            } catch (e) {\n\t\n\t              content = e.message;\n\t            }\n\t\n\t            $(self.$embedContainer).html(content);\n\t\n\t            self.enableAddButton();\n\t          });\n\t        }, 1000);\n\t      });\n\t    };\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t      self.createDialog($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(self.$dialog);\n\t      self.$dialog.remove();\n\t    };\n\t\n\t    this.events = {\n\t      // This will be called after modules are initialized.\n\t      'summernote.init': function summernoteInit(we, e) {\n\t        self.initOembed();\n\t      }\n\t    };\n\t  };\n\t\n\t  $.extend(true, $.summernote, {\n\t    lang: {\n\t      'en-US': {\n\t        oEmbedButton: {\n\t          tooltip: \"Embed\"\n\t        },\n\t        oEmbedDialog: {\n\t          title: \"Insert Embed\",\n\t          label: \"Place your embed url link\",\n\t          placeholder: \"E.g. https://www.youtube.com/watch?v=sJ9HR-kcZHg\",\n\t          button: \"Insert\"\n\t        },\n\t        errorMessage: {\n\t          invalid_provider: 'Invalid Provider!'\n\t        }\n\t      },\n\t      'pt-BR': {\n\t        oEmbedButton: {\n\t          tooltip: \"Adicionar Embed\"\n\t        },\n\t        oEmbedDialog: {\n\t          title: \"Inserir Embed\",\n\t          label: \"Coloque a url do seu embed\",\n\t          placeholder: \"Ex.: https://www.youtube.com/watch?v=sJ9HR-kcZHg\",\n\t          button: \"Inserir\"\n\t        },\n\t        errorMessage: {\n\t          invalid_provider: 'Provedor inválido'\n\t        }\n\t      }\n\t    },\n\t    plugins: {\n\t      'oembed': embedToSummernote\n\t    }\n\t  });\n\t});\n\n/***/ },\n\n/***/ 83:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\t(function (factory) {\n\t  /* global define */\n\t  if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof module === 'object' && module.exports) {\n\t    // Node/CommonJS\n\t    module.exports = factory(require('jquery'));\n\t  } else {\n\t    // Browser globals\n\t    factory(window.jQuery);\n\t  }\n\t})(function ($) {\n\t  'use strict';\n\t\n\t  var summernotePrettyprint = function summernotePrettyprint(context) {\n\t    var self = this;\n\t    var options = context.options;\n\t    var inToolbar = false;\n\t\n\t    for (var idx in options.toolbar) {\n\t      var buttons = options.toolbar[idx][1];\n\t      if ($.inArray('prettyprint', buttons) > -1) {\n\t        inToolbar = true;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!inToolbar) {\n\t      return;\n\t    }\n\t\n\t    var ui = $.summernote.ui;\n\t    var $editor = context.layoutInfo.editor;\n\t    var lang = options.langInfo;\n\t\n\t    var prettyprintOpitions = {};\n\t\n\t    options.prettyprint = $.extend(prettyprintOpitions, options.prettyprint);\n\t\n\t    context.memo('button.prettyprint', function () {\n\t      var button = ui.button({\n\t        contents: '{}',\n\t        tooltip: lang.button.tooltip,\n\t        click: function click(event) {\n\t          self.show();\n\t        }\n\t      });\n\t\n\t      return button.render();\n\t    });\n\t\n\t    this.show = function () {\n\t      context.invoke('editor.saveRange');\n\t\n\t      self.showDialog().then(function showDialogCb(data) {\n\t        context.invoke('editor.restoreRange');\n\t        // Insert code prettyprinted into editor\n\t        // [function here]\n\t        self.insertToEditor(data);\n\t        ui.hideDialog(self.$dialog);\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t\n\t    this.showDialog = function () {\n\t      self.disableAddButton();\n\t      self.$code.value = '';\n\t\n\t      return $.Deferred(function (deferred) {\n\t        ui.onDialogShown(self.$dialog, function dialogShownCb() {\n\t          context.triggerEvent('dialog.shown');\n\t          self.$codeLanguage.focus();\n\t\n\t          self.$addBtn.on('click', function addEmbedCb(event) {\n\t            event.preventDefault();\n\t            deferred.resolve({\n\t              language: self.$codeLanguage.value,\n\t              code: self.$code.value\n\t            });\n\t          });\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function dialogHiddenCb() {\n\t          self.$addBtn.off('click');\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      });\n\t    };\n\t\n\t    this.createDialog = function ($container) {\n\t\n\t      var languages = ['bsh', 'c', 'cc', 'cpp', 'cs', 'csh', 'cyc', 'cv', 'htm', 'html', 'java', 'js', 'm', 'mxml', 'perl', 'pl', 'pm', 'py', 'php', 'rb', 'sh', 'xhtml', 'xml', 'xsl'];\n\t\n\t      var select = '<select class=\"form-control\" id=\"code-language\"><option>' + languages.join('</option><option>') + '</option></select>';\n\t\n\t      var dialogOption = {\n\t        title: lang.dialogPrettyfi.title,\n\t        body: '<div class=\"form-group\">' + '<label>' + lang.dialogPrettyfi.selectLabel + '</label>' + select + '</div>' + '<div class=\"form-group\">' + '<label>' + lang.dialogPrettyfi.codeLabel + '</label>' + '<textarea class=\"form-control\" id=\"code\" rows=\"7\"></textarea>' + '</div>',\n\t        footer: '<button href=\"#\" id=\"btn-add\" class=\"btn btn-primary\">' + lang.dialogPrettyfi.button + '</button>',\n\t        closeOnEscape: true\n\t      };\n\t\n\t      self.$dialog = ui.dialog(dialogOption).render().appendTo($container);\n\t      self.$addBtn = self.$dialog.find('#btn-add');\n\t      self.$codeLanguage = self.$dialog.find('#code-language')[0];\n\t      self.$code = self.$dialog.find('#code')[0];\n\t    };\n\t\n\t    this.insertToEditor = function (options) {\n\t      var innerOptions = {\n\t        code: '',\n\t        language: ''\n\t      };\n\t\n\t      var _options = $.extend(innerOptions, options);\n\t\n\t      var $node = $('<pre>', {\n\t        'class': 'prettyprint linenums'\n\t      });\n\t      var $code = $('<code>');\n\t      $code.html(_options.code.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\"));\n\t      $code.addClass('language-' + _options.language);\n\t\n\t      $node.html($code);\n\t\n\t      context.invoke('editor.insertNode', $node[0]);\n\t      self.$code.innerHTML = '';\n\t    };\n\t\n\t    this.enableAddButton = function () {\n\t      if (!!self.$codeLanguage.value && self.$code.value.length > 0) {\n\t        self.$addBtn.attr(\"disabled\", false);\n\t      }\n\t    };\n\t\n\t    this.disableAddButton = function () {\n\t      self.$addBtn.attr(\"disabled\", true);\n\t    };\n\t\n\t    this.init = function () {\n\t      self.$code.addEventListener('input', function (event) {\n\t        self.enableAddButton();\n\t      }, false);\n\t      self.$codeLanguage.addEventListener('change', function (event) {\n\t        self.enableAddButton();\n\t      }, false);\n\t    };\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t      self.createDialog($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(self.$dialog);\n\t      self.$dialog.remove();\n\t    };\n\t\n\t    this.events = {\n\t      'summernote.init': function summernoteInit(we, e) {\n\t        self.init();\n\t      },\n\t      'summernote.change': function summernoteChange(we, contents) {\n\t        if (window.PR) {\n\t          PR.prettyPrint(contents);\n\t        } else {\n\t          prettyPrint(contents);\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  $.extend(true, $.summernote, {\n\t    lang: {\n\t      'en-US': {\n\t        dialogPrettyfi: {\n\t          title: 'Insert fragment code into editor',\n\t          selectLabel: 'Choose your language',\n\t          codeLabel: 'Type your code',\n\t          button: 'Insert code'\n\t        },\n\t        button: {\n\t          tooltip: 'Insert code'\n\t        }\n\t      },\n\t      'pt-BR': {\n\t        dialogPrettyfi: {\n\t          title: 'Adicionar fragmento de código ao editor',\n\t          selectLabel: 'Escolha a linguagem',\n\t          codeLabel: 'Digite o seu código aqui',\n\t          button: 'Inserir código'\n\t        },\n\t        button: {\n\t          tooltip: 'Adicionar código'\n\t        }\n\t      }\n\t    },\n\t    plugins: {\n\t      'prettyprint': summernotePrettyprint\n\t    }\n\t  });\n\t});\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** vendor.js\n **/","require('./vendor/code-prettify/prettify');\nrequire('summernote');\nrequire('summernote/lang/summernote-pt-BR');\nrequire('./vendor/summernote/plugins/summernote-oembed-plugin');\nrequire('./vendor/summernote/plugins/summernote-prettyprint-plugin');\n\nPR.prettyPrint();\n\n\n\n/** WEBPACK FOOTER **\n ** ./vendor.js\n **/","/**\n * @license\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window, define */\n\n\n/**\n * {@type !{\n *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n *   'registerLangHandler': function (function (JobT), Array.<string>),\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_VALUE': string,\n *   'PR_COMMENT': string,\n *   'PR_DECLARATION': string,\n *   'PR_KEYWORD': string,\n *   'PR_LITERAL': string,\n *   'PR_NOCODE': string,\n *   'PR_PLAIN': string,\n *   'PR_PUNCTUATION': string,\n *   'PR_SOURCE': string,\n *   'PR_STRING': string,\n *   'PR_TAG': string,\n *   'PR_TYPE': string,\n *   'prettyPrintOne': function (string, string, number|boolean),\n *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n * }}\n * @const\n */\n/**\n* @typedef {!Array.<number|string>}\n* Alternating indices and the decorations that should be inserted there.\n* The indices are monotonically increasing.\n*/\nvar DecorationsT;\n\n/**\n* @typedef {!{\n*   sourceNode: !Element,\n*   pre: !(number|boolean),\n*   langExtension: ?string,\n*   numberLines: ?(number|boolean),\n*   sourceCode: ?string,\n*   spans: ?(Array.<number|Node>),\n*   basePos: ?number,\n*   decorations: ?DecorationsT\n* }}\n* <dl>\n*  <dt>sourceNode<dd>the element containing the source\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>pre<dd>truthy if white-space in text nodes\n*     should be considered significant.\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n*  <dt>decorations<dd>an array of style classes preceded\n*     by the position at which they start in job.sourceCode in order\n*  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n*     source.\n* </dl>\n*/\nvar JobT;\n\n/**\n* @typedef {!{\n*   sourceCode: string,\n*   spans: !(Array.<number|Node>)\n* }}\n* <dl>\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n* </dl>\n*/\nvar SourceSpansT;\n\n/** @define {boolean} */\nvar IN_GLOBAL_SCOPE = false;\n\nvar PR;\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\n/**\n * Pretty print a chunk of code.\n * @param {string} sourceCodeHtml The HTML to pretty print.\n * @param {string} opt_langExtension The language name to use.\n *     Typically, a filename extension like 'cpp' or 'java'.\n * @param {number|boolean} opt_numberLines True to number lines,\n *     or the 1-indexed number of the first line in sourceCodeHtml.\n * @return {string} code as html, but prettier\n */\nvar prettyPrintOne;\n/**\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n * {@code class=prettyprint} and prettify them.\n *\n * @param {Function} opt_whenDone called when prettifying is done.\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\n *   containing all the elements to pretty print.\n *   Defaults to {@code document.body}.\n */\nvar prettyPrint;\n\n\n(function () {\n  var win = window;\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n      \"double,enum,extern,float,goto,inline,int,long,register,short,signed,\" +\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n      \"mutable,namespace,nullptr,property,reinterpret_cast,static_assert,\" +\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n      \"throws,transient\"];\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n      \"dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,\" +\n      \"internal,into,is,let,lock,null,object,out,override,orderby,params,\" +\n      \"partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,\" +\n      \"unchecked,unsafe,ushort,var,virtual,where\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"throw,true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" +\n      \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" +\n      \"yield,Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n      PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for plain text.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n\n\n  /**\n   * A set of tokens that can precede a regular expression literal in\n   * javascript\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n   * has the full list, but I've removed ones that might be problematic when\n   * seen in languages that don't support regular expression literals.\n   *\n   * <p>Specifically, I've removed any keywords that can't precede a regexp\n   * literal in a syntactically legal javascript program, and I've removed the\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\n   * as a count of inches.\n   *\n   * <p>The link above does not accurately describe EcmaScript rules since\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n   * very well in practice.\n   *\n   * @private\n   * @const\n   */\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n\n  // CAVEAT: this does not properly handle the case where a regular\n  // expression immediately follows another since a regular expression may\n  // have flags for case-sensitivity and the like.  Having regexp tokens\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\n  // TODO: maybe style special characters inside a regexp as punctuation.\n\n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n\n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n\n    var escapeCharToCodeUnit = {\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    };\n\n    function decodeEscape(charsetPart) {\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) {\n        return cc0;\n      }\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) {\n        return cc0;\n      } else if ('0' <= c1 && c1 <= '7') {\n        return parseInt(charsetPart.substring(1), 8);\n      } else if (c1 === 'u' || c1 === 'x') {\n        return parseInt(charsetPart.substring(2), 16);\n      } else {\n        return charsetPart.charCodeAt(1);\n      }\n    }\n\n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n          ? \"\\\\\" + ch : ch;\n    }\n\n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n\n      var out = ['['];\n      if (inverse) { out.push('^'); }\n\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n          out.push(p);\n        } else {\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          } else {\n            end = start;\n          }\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) {\n            if (!(end < 65 || start > 90)) {\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            }\n            if (!(end < 97 || start > 122)) {\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            }\n          }\n        }\n      }\n\n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n\n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n\n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n\n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue) {\n            if (decimalValue <= groupIndex) {\n              capturedGroups[decimalValue] = -1;\n            } else {\n              // Replace with an unambiguous escape sequence so that\n              // an octal escape sequence does not turn into a backreference\n              // to a capturing group from an earlier regex.\n              parts[i] = encodeEscape(decimalValue);\n            }\n          }\n        }\n      }\n\n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (!capturedGroups[groupIndex]) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\n          }\n        }\n      }\n\n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n\n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n\n      return parts.join('');\n    }\n\n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n\n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                     1          2\n   *   //           012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @param {boolean|number} isPreformatted truthy if white-space in\n   *    text nodes should be considered significant.\n   * @return {SourceSpansT} source code and the nodes in which they occur.\n   */\n  function extractSourceSpans(node, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1) {  // Element\n        if (nocode.test(node.className)) { return; }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          walk(child);\n        }\n        var nodeName = node.nodeName.toLowerCase();\n        if ('br' === nodeName || 'li' === nodeName) {\n          chunks[k] = '\\n';\n          spans[k << 1] = length++;\n          spans[(k++ << 1) | 1] = node;\n        }\n      } else if (type == 3 || type == 4) {  // Text\n        var text = node.nodeValue;\n        if (text.length) {\n          if (!isPreformatted) {\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n          } else {\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n          }\n          // TODO: handle tabs here?\n          chunks[k] = text;\n          spans[k << 1] = length;\n          length += text.length;\n          spans[(k++ << 1) | 1] = node;\n        }\n      }\n    }\n\n    walk(node);\n\n    return {\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {!Element} sourceNode\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   * @param {string} sourceCode\n   * @param {function(JobT)} langHandler\n   * @param {DecorationsT} out\n   */\n  function appendDecorations(\n      sourceNode, basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    /** @type {JobT} */\n    var job = {\n      sourceNode: sourceNode,\n      pre: 1,\n      langExtension: null,\n      numberLines: null,\n      sourceCode: sourceCode,\n      spans: null,\n      basePos: basePos,\n      decorations: null\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (JobT)} a function that takes an undecorated job and\n    *   attaches a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and attaches an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @type{function (JobT)}\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      var sourceNode = job.sourceNode;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {DecorationsT}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (JobT)} a function that examines the source code\n    *     in the input job and builds a decoration list which it attaches to\n    *     the job.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        // #include <stdio.h>\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    var regexLiterals = options['regexLiterals'];\n    if (regexLiterals) {\n      /**\n       * @const\n       */\n      var regexExcls = regexLiterals > 1\n        ? ''  // Multiline regex literals\n        : '\\n\\r';\n      /**\n       * @const\n       */\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*' + regexExcls + '])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C' + regexAny\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\n    var punctuation =\n      // The Bash man page says\n\n      // A word is a sequence of characters considered as a single\n      // unit by GRUB. Words are separated by metacharacters,\n      // which are the following plus space, tab, and newline: { }\n      // | & $ ; < >\n      // ...\n\n      // A word beginning with # causes that word and all remaining\n      // characters on that line to be ignored.\n\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n      // comment but empirically\n      // $ echo {#}\n      // {#}\n      // $ echo \\$#\n      // $#\n      // $ echo }#\n      // }#\n\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n      // suggests that this definition is compatible with a\n      // default mode that tries to use a single token definition\n      // to recognize both bash/python style comments and C\n      // preprocessor directives.\n\n      // This definition of punctuation does not include # in the list of\n      // follow-on exclusions, so # will not be broken before if preceeded\n      // by a punctuation character.  We could try to exclude # after\n      // [|&;<>] but that doesn't seem to cause many major problems.\n      // If that does turn out to be a problem, we should change the below\n      // when hc is truthy to include # in the run of punctuation characters\n      // only when not followint [|&;<>].\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n    if (options['regexLiterals']) {\n      punctuation += '(?!\\s*\\/)';\n    }\n\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.\n        // See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   * @param {number|null|boolean} startLineNum\n   *     If truthy, coerced to an integer which is the 1-indexed line number\n   *     of the first line of code.  The number of the first line will be\n   *     attached to the list.\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\n   *     be treated as significant.\n   */\n  function numberLines(node, startLineNum, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n\n    var document = node.ownerDocument;\n\n    var li = document.createElement('li');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1 && !nocode.test(node.className)) {  // Element\n        if ('br' === node.nodeName) {\n          breakAfter(node);\n          // Discard the <BR> since it is now flush against a </LI>.\n          if (node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        } else {\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n        }\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n        var text = node.nodeValue;\n        var match = text.match(lineBreak);\n        if (match) {\n          var firstLine = text.substring(0, match.index);\n          node.nodeValue = firstLine;\n          var tail = text.substring(match.index + match[0].length);\n          if (tail) {\n            var parent = node.parentNode;\n            parent.insertBefore(\n              document.createTextNode(tail), node.nextSibling);\n          }\n          breakAfter(node);\n          if (!firstLine) {\n            // Don't leave blank text nodes in the DOM.\n            node.parentNode.removeChild(node);\n          }\n        }\n      }\n    }\n\n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n\n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n\n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n\n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n\n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n\n    // Make sure numeric indices show correctly.\n    if (startLineNum === (startLineNum|0)) {\n      listItems[0].setAttribute('value', startLineNum);\n    }\n\n    var ol = document.createElement('ol');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n\n    node.appendChild(ol);\n  }\n\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {JobT} job\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n    var newlineRe = /\\n/g;\n\n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n\n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n\n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n\n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n\n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n\n    nDecorations = decorations.length = decPos;\n\n    var sourceNode = job.sourceNode;\n    var oldDisplay = \"\";\n    if (sourceNode) {\n      oldDisplay = sourceNode.style.display;\n      sourceNode.style.display = 'none';\n    }\n    try {\n      var decoration = null;\n      while (spanIndex < nSpans) {\n        var spanStart = spans[spanIndex];\n        var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n            || sourceLength;\n\n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n\n        var end = Math.min(spanEnd, decEnd);\n\n        var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n        var styledText;\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n            // Don't introduce spans around empty text nodes.\n            && (styledText = source.substring(sourceIndex, end))) {\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n          // code to display with spaces instead of line breaks.\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n          // space to appear at the beginning of every line but the first.\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n          if (isIE8OrEarlier) {\n            styledText = styledText.replace(newlineRe, '\\r');\n          }\n          textNode.nodeValue = styledText;\n          var document = textNode.ownerDocument;\n          var span = document.createElement('span');\n          span.className = decorations[decorationIndex + 1];\n          var parentNode = textNode.parentNode;\n          parentNode.replaceChild(span, textNode);\n          span.appendChild(textNode);\n          if (sourceIndex < spanEnd) {  // Split off a text node.\n            spans[spanIndex + 1] = textNode\n                // TODO: Possibly optimize by using '' if there's no flicker.\n                = document.createTextNode(source.substring(end, spanEnd));\n            parentNode.insertBefore(textNode, span.nextSibling);\n          }\n        }\n\n        sourceIndex = end;\n\n        if (sourceIndex >= spanEnd) {\n          spanIndex += 2;\n        }\n        if (sourceIndex >= decEnd) {\n          decorationIndex += 2;\n        }\n      }\n    } finally {\n      if (sourceNode) {\n        sourceNode.style.display = oldDisplay;\n      }\n    }\n  }\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (JobT)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation and attaches the decorations to it.\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (win['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bash', 'bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py', 'python']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': 2  // multiline regex literals\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb', 'ruby']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['javascript', 'js', 'ts', 'typescript']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  /** @param {JobT} job */\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if (win['console']) {\n        console['log'](e && e['stack'] || e);\n      }\n    }\n  }\n\n  /**\n   * Pretty print a chunk of code.\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    /** @type{number|boolean} */\n    var nl = opt_numberLines || false;\n    /** @type{string|null} */\n    var langExtension = opt_langExtension || null;\n    /** @type{!Element} */\n    var container = document.createElement('div');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\n    // when it is injected into a <pre> tag.\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n    container = /** @type{!Element} */(container.firstChild);\n    if (nl) {\n      numberLines(container, nl, true);\n    }\n\n    /** @type{JobT} */\n    var job = {\n      langExtension: langExtension,\n      numberLines: nl,\n      sourceNode: container,\n      pre: 1,\n      sourceCode: null,\n      basePos: null,\n      spans: null,\n      decorations: null\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function} opt_whenDone called when prettifying is done.\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\n    *   containing all the elements to pretty print.\n    *   Defaults to {@code document.body}.\n    */\n  function $prettyPrint(opt_whenDone, opt_root) {\n    var root = opt_root || document.body;\n    var doc = root.ownerDocument || document;\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\n    var preformattedTagNameRe = /pre|xmp/i;\n    var codeRe = /^code$/i;\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n    var EMPTY = {};\n\n    function doWork() {\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n\n        // Look for a preceding comment like\n        // <?prettify lang=\"...\" linenums=\"...\"?>\n        var attrs = EMPTY;\n        {\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\n            var nt = preceder.nodeType;\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\n            // like <!--?foo?-->, but in XML is a processing instruction\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n            if (value\n                ? !/^\\??prettify\\b/.test(value)\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n              // Skip over white-space text nodes but not others.\n              break;\n            }\n            if (value) {\n              attrs = {};\n              value.replace(\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\n                function (_, name, value) { attrs[name] = value; });\n              break;\n            }\n          }\n        }\n\n        var className = cs.className;\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\n            // Don't redo this if we've already done it.\n            // This allows recalling pretty print to just prettyprint elements\n            // that have been added to the page since last call.\n            && !prettyPrintedRe.test(className)) {\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            var tn = p.tagName;\n            if (preCodeXmpRe.test(tn)\n                && p.className && prettyPrintRe.test(p.className)) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Mark done.  If we fail to prettyprint for whatever reason,\n            // we shouldn't try again.\n            cs.className += ' prettyprinted';\n\n            // If the classes includes a language extensions, use it.\n            // Language extensions can be specified like\n            //     <pre class=\"prettyprint lang-cpp\">\n            // the language extension \"cpp\" is used to find a language handler\n            // as passed to PR.registerLangHandler.\n            // HTML5 recommends that a language be specified using \"language-\"\n            // as the prefix instead.  Google Code Prettify supports both.\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n            var langExtension = attrs['lang'];\n            if (!langExtension) {\n              langExtension = className.match(langExtensionRe);\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n              var wrapper;\n              if (!langExtension && (wrapper = childContentWrapper(cs))\n                  && codeRe.test(wrapper.tagName)) {\n                langExtension = wrapper.className.match(langExtensionRe);\n              }\n\n              if (langExtension) { langExtension = langExtension[1]; }\n            }\n\n            var preformatted;\n            if (preformattedTagNameRe.test(cs.tagName)) {\n              preformatted = 1;\n            } else {\n              var currentStyle = cs['currentStyle'];\n              var defaultView = doc.defaultView;\n              var whitespace = (\n                  currentStyle\n                  ? currentStyle['whiteSpace']\n                  : (defaultView\n                     && defaultView.getComputedStyle)\n                  ? defaultView.getComputedStyle(cs, null)\n                  .getPropertyValue('white-space')\n                  : 0);\n              preformatted = whitespace\n                  && 'pre' === whitespace.substring(0, 3);\n            }\n\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = attrs['linenums'];\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n              lineNums =\n                lineNums\n                ? lineNums[1] && lineNums[1].length\n                  ? +lineNums[1] : true\n                : false;\n            }\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\n\n            // do the pretty printing\n            var prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums,\n              pre: preformatted,\n              sourceCode: null,\n              basePos: null,\n              spans: null,\n              decorations: null\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        win.setTimeout(doWork, 250);\n      } else if ('function' === typeof opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  /**\n   * Contains functions for creating and registering new language handlers.\n   * @type {Object}\n   */\n  var PR = win['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE,\n        'prettyPrintOne':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\n             : (prettyPrintOne = $prettyPrintOne),\n        'prettyPrint': prettyPrint =\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrint'] = $prettyPrint)\n             : (prettyPrint = $prettyPrint)\n      };\n\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n  // The Asynchronous Module Definition (AMD) API specifies a\n  // mechanism for defining modules such that the module and its\n  // dependencies can be asynchronously loaded.\n  // ...\n  // To allow a clear indicator that a global define function (as\n  // needed for script src browser loading) conforms to the AMD API,\n  // any global define function SHOULD have a property called \"amd\"\n  // whose value is an object. This helps avoid conflict with any\n  // other existing JavaScript code that could have defined a define()\n  // function that does not conform to the AMD API.\n  var define = win['define'];\n  if (typeof define === \"function\" && define['amd']) {\n    define(\"google-code-prettify\", [], function () {\n      return PR;\n    });\n  }\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./vendor/code-prettify/prettify.js\n **/","/**\n * Super simple wysiwyg editor v0.8.2\n * http://summernote.org/\n *\n * summernote.js\n * Copyright 2013-2016 Alan Hong. and other contributors\n * summernote may be freely distributed under the MIT license./\n *\n * Date: 2016-08-07T05:11Z\n */\n(function (factory) {\n  /* global define */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals\n    factory(window.jQuery);\n  }\n}(function ($) {\n  'use strict';\n\n  /**\n   * @class core.func\n   *\n   * func utils (for high-order func's arg)\n   *\n   * @singleton\n   * @alternateClassName func\n   */\n  var func = (function () {\n    var eq = function (itemA) {\n      return function (itemB) {\n        return itemA === itemB;\n      };\n    };\n\n    var eq2 = function (itemA, itemB) {\n      return itemA === itemB;\n    };\n\n    var peq2 = function (propName) {\n      return function (itemA, itemB) {\n        return itemA[propName] === itemB[propName];\n      };\n    };\n\n    var ok = function () {\n      return true;\n    };\n\n    var fail = function () {\n      return false;\n    };\n\n    var not = function (f) {\n      return function () {\n        return !f.apply(f, arguments);\n      };\n    };\n\n    var and = function (fA, fB) {\n      return function (item) {\n        return fA(item) && fB(item);\n      };\n    };\n\n    var self = function (a) {\n      return a;\n    };\n\n    var invoke = function (obj, method) {\n      return function () {\n        return obj[method].apply(obj, arguments);\n      };\n    };\n\n    var idCounter = 0;\n\n    /**\n     * generate a globally-unique id\n     *\n     * @param {String} [prefix]\n     */\n    var uniqueId = function (prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n\n    /**\n     * returns bnd (bounds) from rect\n     *\n     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n     * - Scroll Issue: http://goo.gl/sNjUc\n     *\n     * @param {Rect} rect\n     * @return {Object} bounds\n     * @return {Number} bounds.top\n     * @return {Number} bounds.left\n     * @return {Number} bounds.width\n     * @return {Number} bounds.height\n     */\n    var rect2bnd = function (rect) {\n      var $document = $(document);\n      return {\n        top: rect.top + $document.scrollTop(),\n        left: rect.left + $document.scrollLeft(),\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    };\n\n    /**\n     * returns a copy of the object where the keys have become the values and the values the keys.\n     * @param {Object} obj\n     * @return {Object}\n     */\n    var invertObject = function (obj) {\n      var inverted = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          inverted[obj[key]] = key;\n        }\n      }\n      return inverted;\n    };\n\n    /**\n     * @param {String} namespace\n     * @param {String} [prefix]\n     * @return {String}\n     */\n    var namespaceToCamel = function (namespace, prefix) {\n      prefix = prefix || '';\n      return prefix + namespace.split('.').map(function (name) {\n        return name.substring(0, 1).toUpperCase() + name.substring(1);\n      }).join('');\n    };\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     * @param {Function} func\n     * @param {Number} wait\n     * @param {Boolean} immediate\n     * @return {Function}\n     */\n    var debounce = function (func, wait, immediate) {\n      var timeout;\n      return function () {\n        var context = this, args = arguments;\n        var later = function () {\n          timeout = null;\n          if (!immediate) {\n            func.apply(context, args);\n          }\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n          func.apply(context, args);\n        }\n      };\n    };\n\n    return {\n      eq: eq,\n      eq2: eq2,\n      peq2: peq2,\n      ok: ok,\n      fail: fail,\n      self: self,\n      not: not,\n      and: and,\n      invoke: invoke,\n      uniqueId: uniqueId,\n      rect2bnd: rect2bnd,\n      invertObject: invertObject,\n      namespaceToCamel: namespaceToCamel,\n      debounce: debounce\n    };\n  })();\n\n  /**\n   * @class core.list\n   *\n   * list utils\n   *\n   * @singleton\n   * @alternateClassName list\n   */\n  var list = (function () {\n    /**\n     * returns the first item of an array.\n     *\n     * @param {Array} array\n     */\n    var head = function (array) {\n      return array[0];\n    };\n\n    /**\n     * returns the last item of an array.\n     *\n     * @param {Array} array\n     */\n    var last = function (array) {\n      return array[array.length - 1];\n    };\n\n    /**\n     * returns everything but the last entry of the array.\n     *\n     * @param {Array} array\n     */\n    var initial = function (array) {\n      return array.slice(0, array.length - 1);\n    };\n\n    /**\n     * returns the rest of the items in an array.\n     *\n     * @param {Array} array\n     */\n    var tail = function (array) {\n      return array.slice(1);\n    };\n\n    /**\n     * returns item of array\n     */\n    var find = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        var item = array[idx];\n        if (pred(item)) {\n          return item;\n        }\n      }\n    };\n\n    /**\n     * returns true if all of the values in the array pass the predicate truth test.\n     */\n    var all = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!pred(array[idx])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /**\n     * returns index of item\n     */\n    var indexOf = function (array, item) {\n      return $.inArray(item, array);\n    };\n\n    /**\n     * returns true if the value is present in the list.\n     */\n    var contains = function (array, item) {\n      return indexOf(array, item) !== -1;\n    };\n\n    /**\n     * get sum from a list\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - iterator\n     */\n    var sum = function (array, fn) {\n      fn = fn || func.self;\n      return array.reduce(function (memo, v) {\n        return memo + fn(v);\n      }, 0);\n    };\n  \n    /**\n     * returns a copy of the collection with array type.\n     * @param {Collection} collection - collection eg) node.childNodes, ...\n     */\n    var from = function (collection) {\n      var result = [], idx = -1, length = collection.length;\n      while (++idx < length) {\n        result[idx] = collection[idx];\n      }\n      return result;\n    };\n\n    /**\n     * returns whether list is empty or not\n     */\n    var isEmpty = function (array) {\n      return !array || !array.length;\n    };\n  \n    /**\n     * cluster elements by predicate function.\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     * @param {Array[]}\n     */\n    var clusterBy = function (array, fn) {\n      if (!array.length) { return []; }\n      var aTail = tail(array);\n      return aTail.reduce(function (memo, v) {\n        var aLast = last(memo);\n        if (fn(last(aLast), v)) {\n          aLast[aLast.length] = v;\n        } else {\n          memo[memo.length] = [v];\n        }\n        return memo;\n      }, [[head(array)]]);\n    };\n  \n    /**\n     * returns a copy of the array with all false values removed\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     */\n    var compact = function (array) {\n      var aResult = [];\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (array[idx]) { aResult.push(array[idx]); }\n      }\n      return aResult;\n    };\n\n    /**\n     * produces a duplicate-free version of the array\n     *\n     * @param {Array} array\n     */\n    var unique = function (array) {\n      var results = [];\n\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!contains(results, array[idx])) {\n          results.push(array[idx]);\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * returns next item.\n     * @param {Array} array\n     */\n    var next = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx + 1];\n    };\n\n    /**\n     * returns prev item.\n     * @param {Array} array\n     */\n    var prev = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx - 1];\n    };\n\n    return { head: head, last: last, initial: initial, tail: tail,\n             prev: prev, next: next, find: find, contains: contains,\n             all: all, sum: sum, from: from, isEmpty: isEmpty,\n             clusterBy: clusterBy, compact: compact, unique: unique };\n  })();\n\n  var isSupportAmd = typeof define === 'function' && define.amd;\n\n  /**\n   * returns whether font is installed or not.\n   *\n   * @param {String} fontName\n   * @return {Boolean}\n   */\n  var isFontInstalled = function (fontName) {\n    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n    var $tester = $('<div>').css({\n      position: 'absolute',\n      left: '-9999px',\n      top: '-9999px',\n      fontSize: '200px'\n    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\n    var originalWidth = $tester.css('fontFamily', testFontName).width();\n    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\n    $tester.remove();\n\n    return originalWidth !== width;\n  };\n\n  var userAgent = navigator.userAgent;\n  var isMSIE = /MSIE|Trident/i.test(userAgent);\n  var browserVersion;\n  if (isMSIE) {\n    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n  }\n\n  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\n  var hasCodeMirror = !!window.CodeMirror;\n  if (!hasCodeMirror && isSupportAmd && typeof require !== 'undefined') {\n    if (typeof require.resolve !== 'undefined') {\n      try {\n        // If CodeMirror can't be resolved, `require.resolve` will throw an\n        // exception and `hasCodeMirror` won't be set to `true`.\n        require.resolve('codemirror');\n        hasCodeMirror = true;\n      } catch (e) {\n        // Do nothing.\n      }\n    } else if (typeof eval('require').specified !== 'undefined') {\n      hasCodeMirror = eval('require').specified('codemirror');\n    }\n  }\n\n  /**\n   * @class core.agent\n   *\n   * Object which check platform and agent\n   *\n   * @singleton\n   * @alternateClassName agent\n   */\n  var agent = {\n    isMac: navigator.appVersion.indexOf('Mac') > -1,\n    isMSIE: isMSIE,\n    isEdge: isEdge,\n    isFF: !isEdge && /firefox/i.test(userAgent),\n    isPhantom: /PhantomJS/i.test(userAgent),\n    isWebkit: !isEdge && /webkit/i.test(userAgent),\n    isChrome: !isEdge && /chrome/i.test(userAgent),\n    isSafari: !isEdge && /safari/i.test(userAgent),\n    browserVersion: browserVersion,\n    jqueryVersion: parseFloat($.fn.jquery),\n    isSupportAmd: isSupportAmd,\n    hasCodeMirror: hasCodeMirror,\n    isFontInstalled: isFontInstalled,\n    isW3CRangeSupport: !!document.createRange\n  };\n\n\n  var NBSP_CHAR = String.fromCharCode(160);\n  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\n  /**\n   * @class core.dom\n   *\n   * Dom functions\n   *\n   * @singleton\n   * @alternateClassName dom\n   */\n  var dom = (function () {\n    /**\n     * @method isEditable\n     *\n     * returns whether node is `note-editable` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEditable = function (node) {\n      return node && $(node).hasClass('note-editable');\n    };\n\n    /**\n     * @method isControlSizing\n     *\n     * returns whether node is `note-control-sizing` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isControlSizing = function (node) {\n      return node && $(node).hasClass('note-control-sizing');\n    };\n\n    /**\n     * @method makePredByNodeName\n     *\n     * returns predicate which judge whether nodeName is same\n     *\n     * @param {String} nodeName\n     * @return {Function}\n     */\n    var makePredByNodeName = function (nodeName) {\n      nodeName = nodeName.toUpperCase();\n      return function (node) {\n        return node && node.nodeName.toUpperCase() === nodeName;\n      };\n    };\n\n    /**\n     * @method isText\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is text(3)\n     */\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n\n    /**\n     * @method isElement\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is element(1)\n     */\n    var isElement = function (node) {\n      return node && node.nodeType === 1;\n    };\n\n    /**\n     * ex) br, col, embed, hr, img, input, ...\n     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var isVoid = function (node) {\n      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPara = function (node) {\n      if (isEditable(node)) {\n        return false;\n      }\n\n      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHeading = function (node) {\n      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPre = makePredByNodeName('PRE');\n\n    var isLi = makePredByNodeName('LI');\n\n    var isPurePara = function (node) {\n      return isPara(node) && !isLi(node);\n    };\n\n    var isTable = makePredByNodeName('TABLE');\n\n    var isData = makePredByNodeName('DATA');\n\n    var isInline = function (node) {\n      return !isBodyContainer(node) &&\n             !isList(node) &&\n             !isHr(node) &&\n             !isPara(node) &&\n             !isTable(node) &&\n             !isBlockquote(node) &&\n             !isData(node);\n    };\n\n    var isList = function (node) {\n      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHr = makePredByNodeName('HR');\n\n    var isCell = function (node) {\n      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n    };\n\n    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\n    var isBodyContainer = function (node) {\n      return isCell(node) || isBlockquote(node) || isEditable(node);\n    };\n\n    var isAnchor = makePredByNodeName('A');\n\n    var isParaInline = function (node) {\n      return isInline(node) && !!ancestor(node, isPara);\n    };\n\n    var isBodyInline = function (node) {\n      return isInline(node) && !ancestor(node, isPara);\n    };\n\n    var isBody = makePredByNodeName('BODY');\n\n    /**\n     * returns whether nodeB is closest sibling of nodeA\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     * @return {Boolean}\n     */\n    var isClosestSibling = function (nodeA, nodeB) {\n      return nodeA.nextSibling === nodeB ||\n             nodeA.previousSibling === nodeB;\n    };\n\n    /**\n     * returns array of closest siblings with node\n     *\n     * @param {Node} node\n     * @param {function} [pred] - predicate function\n     * @return {Node[]}\n     */\n    var withClosestSiblings = function (node, pred) {\n      pred = pred || func.ok;\n\n      var siblings = [];\n      if (node.previousSibling && pred(node.previousSibling)) {\n        siblings.push(node.previousSibling);\n      }\n      siblings.push(node);\n      if (node.nextSibling && pred(node.nextSibling)) {\n        siblings.push(node.nextSibling);\n      }\n      return siblings;\n    };\n\n    /**\n     * blank HTML for cursor position\n     * - [workaround] old IE only works with &nbsp;\n     * - [workaround] IE11 and other browser works with bogus br\n     */\n    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\n    /**\n     * @method nodeLength\n     *\n     * returns #text's text size or element's childNodes size\n     *\n     * @param {Node} node\n     */\n    var nodeLength = function (node) {\n      if (isText(node)) {\n        return node.nodeValue.length;\n      }\n      \n      if (node) {\n        return node.childNodes.length;\n      }\n      \n      return 0;\n      \n    };\n\n    /**\n     * returns whether node is empty or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEmpty = function (node) {\n      var len = nodeLength(node);\n\n      if (len === 0) {\n        return true;\n      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n        // ex) <p><br></p>, <span><br></span>\n        return true;\n      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n        // ex) <p></p>, <span></span>\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * padding blankHTML if node is empty (for cursor position)\n     */\n    var paddingBlankHTML = function (node) {\n      if (!isVoid(node) && !nodeLength(node)) {\n        node.innerHTML = blankHTML;\n      }\n    };\n\n    /**\n     * find nearest ancestor predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var ancestor = function (node, pred) {\n      while (node) {\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * find nearest ancestor only single child blood line and predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var singleChildAncestor = function (node, pred) {\n      node = node.parentNode;\n\n      while (node) {\n        if (nodeLength(node) !== 1) { break; }\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * returns new array of ancestor nodes (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listAncestor = function (node, pred) {\n      pred = pred || func.fail;\n\n      var ancestors = [];\n      ancestor(node, function (el) {\n        if (!isEditable(el)) {\n          ancestors.push(el);\n        }\n\n        return pred(el);\n      });\n      return ancestors;\n    };\n\n    /**\n     * find farthest ancestor predicate hit\n     */\n    var lastAncestor = function (node, pred) {\n      var ancestors = listAncestor(node);\n      return list.last(ancestors.filter(pred));\n    };\n\n    /**\n     * returns common ancestor node between two nodes.\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n    var commonAncestor = function (nodeA, nodeB) {\n      var ancestors = listAncestor(nodeA);\n      for (var n = nodeB; n; n = n.parentNode) {\n        if ($.inArray(n, ancestors) > -1) { return n; }\n      }\n      return null; // difference document area\n    };\n\n    /**\n     * listing all previous siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listPrev = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.previousSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing next siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listNext = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.nextSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing descendant nodes\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listDescendant = function (node, pred) {\n      var descendants = [];\n      pred = pred || func.ok;\n\n      // start DFS(depth first search) with node\n      (function fnWalk(current) {\n        if (node !== current && pred(current)) {\n          descendants.push(current);\n        }\n        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n          fnWalk(current.childNodes[idx]);\n        }\n      })(node);\n\n      return descendants;\n    };\n\n    /**\n     * wrap node with new tag.\n     *\n     * @param {Node} node\n     * @param {Node} tagName of wrapper\n     * @return {Node} - wrapper\n     */\n    var wrap = function (node, wrapperName) {\n      var parent = node.parentNode;\n      var wrapper = $('<' + wrapperName + '>')[0];\n\n      parent.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n\n      return wrapper;\n    };\n\n    /**\n     * insert node after preceding\n     *\n     * @param {Node} node\n     * @param {Node} preceding - predicate function\n     */\n    var insertAfter = function (node, preceding) {\n      var next = preceding.nextSibling, parent = preceding.parentNode;\n      if (next) {\n        parent.insertBefore(node, next);\n      } else {\n        parent.appendChild(node);\n      }\n      return node;\n    };\n\n    /**\n     * append elements.\n     *\n     * @param {Node} node\n     * @param {Collection} aChild\n     */\n    var appendChildNodes = function (node, aChild) {\n      $.each(aChild, function (idx, child) {\n        node.appendChild(child);\n      });\n      return node;\n    };\n\n    /**\n     * returns whether boundaryPoint is left edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isLeftEdgePoint = function (point) {\n      return point.offset === 0;\n    };\n\n    /**\n     * returns whether boundaryPoint is right edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isRightEdgePoint = function (point) {\n      return point.offset === nodeLength(point.node);\n    };\n\n    /**\n     * returns whether boundaryPoint is edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isEdgePoint = function (point) {\n      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n    };\n\n    /**\n     * returns whether node is left edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== 0) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether node is right edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgeOf = function (node, ancestor) {\n      if (!ancestor) {\n        return false;\n      }\n      while (node && node !== ancestor) {\n        if (position(node) !== nodeLength(node.parentNode) - 1) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether point is left edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgePointOf = function (point, ancestor) {\n      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns whether point is right edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgePointOf = function (point, ancestor) {\n      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns offset from parent.\n     *\n     * @param {Node} node\n     */\n    var position = function (node) {\n      var offset = 0;\n      while ((node = node.previousSibling)) {\n        offset += 1;\n      }\n      return offset;\n    };\n\n    var hasChildren = function (node) {\n      return !!(node && node.childNodes && node.childNodes.length);\n    };\n\n    /**\n     * returns previous boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var prevPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (point.offset === 0) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node);\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset - 1];\n        offset = nodeLength(node);\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns next boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var nextPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (nodeLength(point.node) === point.offset) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node) + 1;\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset];\n        offset = 0;\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns whether pointA and pointB is same or not.\n     *\n     * @param {BoundaryPoint} pointA\n     * @param {BoundaryPoint} pointB\n     * @return {Boolean}\n     */\n    var isSamePoint = function (pointA, pointB) {\n      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n    };\n\n    /**\n     * returns whether point is visible (can set cursor) or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isVisiblePoint = function (point) {\n      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n        return true;\n      }\n\n      var leftNode = point.node.childNodes[point.offset - 1];\n      var rightNode = point.node.childNodes[point.offset];\n      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @method prevPointUtil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var prevPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = prevPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * @method nextPointUntil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var nextPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = nextPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * returns whether point has character or not.\n     *\n     * @param {Point} point\n     * @return {Boolean}\n     */\n    var isCharPoint = function (point) {\n      if (!isText(point.node)) {\n        return false;\n      }\n\n      var ch = point.node.nodeValue.charAt(point.offset - 1);\n      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n    };\n\n    /**\n     * @method walkPoint\n     *\n     * @param {BoundaryPoint} startPoint\n     * @param {BoundaryPoint} endPoint\n     * @param {Function} handler\n     * @param {Boolean} isSkipInnerOffset\n     */\n    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n      var point = startPoint;\n\n      while (point) {\n        handler(point);\n\n        if (isSamePoint(point, endPoint)) {\n          break;\n        }\n\n        var isSkipOffset = isSkipInnerOffset &&\n                           startPoint.node !== point.node &&\n                           endPoint.node !== point.node;\n        point = nextPoint(point, isSkipOffset);\n      }\n    };\n\n    /**\n     * @method makeOffsetPath\n     *\n     * return offsetPath(array of offset) from ancestor\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {Node} node\n     */\n    var makeOffsetPath = function (ancestor, node) {\n      var ancestors = listAncestor(node, func.eq(ancestor));\n      return ancestors.map(position).reverse();\n    };\n\n    /**\n     * @method fromOffsetPath\n     *\n     * return element from offsetPath(array of offset)\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {array} offsets - offsetPath\n     */\n    var fromOffsetPath = function (ancestor, offsets) {\n      var current = ancestor;\n      for (var i = 0, len = offsets.length; i < len; i++) {\n        if (current.childNodes.length <= offsets[i]) {\n          current = current.childNodes[current.childNodes.length - 1];\n        } else {\n          current = current.childNodes[offsets[i]];\n        }\n      }\n      return current;\n    };\n\n    /**\n     * @method splitNode\n     *\n     * split element or #text\n     *\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitNode = function (point, options) {\n      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\n      // edge case\n      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n        if (isLeftEdgePoint(point)) {\n          return point.node;\n        } else if (isRightEdgePoint(point)) {\n          return point.node.nextSibling;\n        }\n      }\n\n      // split #text\n      if (isText(point.node)) {\n        return point.node.splitText(point.offset);\n      } else {\n        var childNode = point.node.childNodes[point.offset];\n        var clone = insertAfter(point.node.cloneNode(false), point.node);\n        appendChildNodes(clone, listNext(childNode));\n\n        if (!isSkipPaddingBlankHTML) {\n          paddingBlankHTML(point.node);\n          paddingBlankHTML(clone);\n        }\n\n        return clone;\n      }\n    };\n\n    /**\n     * @method splitTree\n     *\n     * split tree by point\n     *\n     * @param {Node} root - split root\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitTree = function (root, point, options) {\n      // ex) [#text, <span>, <p>]\n      var ancestors = listAncestor(point.node, func.eq(root));\n\n      if (!ancestors.length) {\n        return null;\n      } else if (ancestors.length === 1) {\n        return splitNode(point, options);\n      }\n\n      return ancestors.reduce(function (node, parent) {\n        if (node === point.node) {\n          node = splitNode(point, options);\n        }\n\n        return splitNode({\n          node: parent,\n          offset: node ? dom.position(node) : nodeLength(parent)\n        }, options);\n      });\n    };\n\n    /**\n     * split point\n     *\n     * @param {Point} point\n     * @param {Boolean} isInline\n     * @return {Object}\n     */\n    var splitPoint = function (point, isInline) {\n      // find splitRoot, container\n      //  - inline: splitRoot is a child of paragraph\n      //  - block: splitRoot is a child of bodyContainer\n      var pred = isInline ? isPara : isBodyContainer;\n      var ancestors = listAncestor(point.node, pred);\n      var topAncestor = list.last(ancestors) || point.node;\n\n      var splitRoot, container;\n      if (pred(topAncestor)) {\n        splitRoot = ancestors[ancestors.length - 2];\n        container = topAncestor;\n      } else {\n        splitRoot = topAncestor;\n        container = splitRoot.parentNode;\n      }\n\n      // if splitRoot is exists, split with splitTree\n      var pivot = splitRoot && splitTree(splitRoot, point, {\n        isSkipPaddingBlankHTML: isInline,\n        isNotSplitEdgePoint: isInline\n      });\n\n      // if container is point.node, find pivot with point.offset\n      if (!pivot && container === point.node) {\n        pivot = point.node.childNodes[point.offset];\n      }\n\n      return {\n        rightNode: pivot,\n        container: container\n      };\n    };\n\n    var create = function (nodeName) {\n      return document.createElement(nodeName);\n    };\n\n    var createText = function (text) {\n      return document.createTextNode(text);\n    };\n\n    /**\n     * @method remove\n     *\n     * remove node, (isRemoveChild: remove child or not)\n     *\n     * @param {Node} node\n     * @param {Boolean} isRemoveChild\n     */\n    var remove = function (node, isRemoveChild) {\n      if (!node || !node.parentNode) { return; }\n      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\n      var parent = node.parentNode;\n      if (!isRemoveChild) {\n        var nodes = [];\n        var i, len;\n        for (i = 0, len = node.childNodes.length; i < len; i++) {\n          nodes.push(node.childNodes[i]);\n        }\n\n        for (i = 0, len = nodes.length; i < len; i++) {\n          parent.insertBefore(nodes[i], node);\n        }\n      }\n\n      parent.removeChild(node);\n    };\n\n    /**\n     * @method removeWhile\n     *\n     * @param {Node} node\n     * @param {Function} pred\n     */\n    var removeWhile = function (node, pred) {\n      while (node) {\n        if (isEditable(node) || !pred(node)) {\n          break;\n        }\n\n        var parent = node.parentNode;\n        remove(node);\n        node = parent;\n      }\n    };\n\n    /**\n     * @method replace\n     *\n     * replace node with provided nodeName\n     *\n     * @param {Node} node\n     * @param {String} nodeName\n     * @return {Node} - new node\n     */\n    var replace = function (node, nodeName) {\n      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n        return node;\n      }\n\n      var newNode = create(nodeName);\n\n      if (node.style.cssText) {\n        newNode.style.cssText = node.style.cssText;\n      }\n\n      appendChildNodes(newNode, list.from(node.childNodes));\n      insertAfter(newNode, node);\n      remove(node);\n\n      return newNode;\n    };\n\n    var isTextarea = makePredByNodeName('TEXTAREA');\n\n    /**\n     * @param {jQuery} $node\n     * @param {Boolean} [stripLinebreaks] - default: false\n     */\n    var value = function ($node, stripLinebreaks) {\n      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n      if (stripLinebreaks) {\n        return val.replace(/[\\n\\r]/g, '');\n      }\n      return val;\n    };\n\n    /**\n     * @method html\n     *\n     * get the HTML contents of node\n     *\n     * @param {jQuery} $node\n     * @param {Boolean} [isNewlineOnBlock]\n     */\n    var html = function ($node, isNewlineOnBlock) {\n      var markup = value($node);\n\n      if (isNewlineOnBlock) {\n        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n        markup = markup.replace(regexTag, function (match, endSlash, name) {\n          name = name.toUpperCase();\n          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n                                       !!endSlash;\n          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\n          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n        });\n        markup = $.trim(markup);\n      }\n\n      return markup;\n    };\n\n    var posFromPlaceholder = function (placeholder) {\n      var $placeholder = $(placeholder);\n      var pos = $placeholder.offset();\n      var height = $placeholder.outerHeight(true); // include margin\n\n      return {\n        left: pos.left,\n        top: pos.top + height\n      };\n    };\n\n    var attachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.on(key, events[key]);\n      });\n    };\n\n    var detachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.off(key, events[key]);\n      });\n    };\n\n    return {\n      /** @property {String} NBSP_CHAR */\n      NBSP_CHAR: NBSP_CHAR,\n      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n      /** @property {String} blank */\n      blank: blankHTML,\n      /** @property {String} emptyPara */\n      emptyPara: '<p>' + blankHTML + '</p>',\n      makePredByNodeName: makePredByNodeName,\n      isEditable: isEditable,\n      isControlSizing: isControlSizing,\n      isText: isText,\n      isElement: isElement,\n      isVoid: isVoid,\n      isPara: isPara,\n      isPurePara: isPurePara,\n      isHeading: isHeading,\n      isInline: isInline,\n      isBlock: func.not(isInline),\n      isBodyInline: isBodyInline,\n      isBody: isBody,\n      isParaInline: isParaInline,\n      isPre: isPre,\n      isList: isList,\n      isTable: isTable,\n      isData: isData,\n      isCell: isCell,\n      isBlockquote: isBlockquote,\n      isBodyContainer: isBodyContainer,\n      isAnchor: isAnchor,\n      isDiv: makePredByNodeName('DIV'),\n      isLi: isLi,\n      isBR: makePredByNodeName('BR'),\n      isSpan: makePredByNodeName('SPAN'),\n      isB: makePredByNodeName('B'),\n      isU: makePredByNodeName('U'),\n      isS: makePredByNodeName('S'),\n      isI: makePredByNodeName('I'),\n      isImg: makePredByNodeName('IMG'),\n      isTextarea: isTextarea,\n      isEmpty: isEmpty,\n      isEmptyAnchor: func.and(isAnchor, isEmpty),\n      isClosestSibling: isClosestSibling,\n      withClosestSiblings: withClosestSiblings,\n      nodeLength: nodeLength,\n      isLeftEdgePoint: isLeftEdgePoint,\n      isRightEdgePoint: isRightEdgePoint,\n      isEdgePoint: isEdgePoint,\n      isLeftEdgeOf: isLeftEdgeOf,\n      isRightEdgeOf: isRightEdgeOf,\n      isLeftEdgePointOf: isLeftEdgePointOf,\n      isRightEdgePointOf: isRightEdgePointOf,\n      prevPoint: prevPoint,\n      nextPoint: nextPoint,\n      isSamePoint: isSamePoint,\n      isVisiblePoint: isVisiblePoint,\n      prevPointUntil: prevPointUntil,\n      nextPointUntil: nextPointUntil,\n      isCharPoint: isCharPoint,\n      walkPoint: walkPoint,\n      ancestor: ancestor,\n      singleChildAncestor: singleChildAncestor,\n      listAncestor: listAncestor,\n      lastAncestor: lastAncestor,\n      listNext: listNext,\n      listPrev: listPrev,\n      listDescendant: listDescendant,\n      commonAncestor: commonAncestor,\n      wrap: wrap,\n      insertAfter: insertAfter,\n      appendChildNodes: appendChildNodes,\n      position: position,\n      hasChildren: hasChildren,\n      makeOffsetPath: makeOffsetPath,\n      fromOffsetPath: fromOffsetPath,\n      splitTree: splitTree,\n      splitPoint: splitPoint,\n      create: create,\n      createText: createText,\n      remove: remove,\n      removeWhile: removeWhile,\n      replace: replace,\n      html: html,\n      value: value,\n      posFromPlaceholder: posFromPlaceholder,\n      attachEvents: attachEvents,\n      detachEvents: detachEvents\n    };\n  })();\n\n  /**\n   * @param {jQuery} $note\n   * @param {Object} options\n   * @return {Context}\n   */\n  var Context = function ($note, options) {\n    var self = this;\n\n    var ui = $.summernote.ui;\n    this.memos = {};\n    this.modules = {};\n    this.layoutInfo = {};\n    this.options = options;\n\n    /**\n     * create layout and initialize modules and other resources\n     */\n    this.initialize = function () {\n      this.layoutInfo = ui.createLayout($note, options);\n      this._initialize();\n      $note.hide();\n      return this;\n    };\n\n    /**\n     * destroy modules and other resources and remove layout\n     */\n    this.destroy = function () {\n      this._destroy();\n      $note.removeData('summernote');\n      ui.removeLayout($note, this.layoutInfo);\n    };\n\n    /**\n     * destory modules and other resources and initialize it again\n     */\n    this.reset = function () {\n      var disabled = self.isDisabled();\n      this.code(dom.emptyPara);\n      this._destroy();\n      this._initialize();\n\n      if (disabled) {\n        self.disable();\n      }\n    };\n\n    this._initialize = function () {\n      // add optional buttons\n      var buttons = $.extend({}, this.options.buttons);\n      Object.keys(buttons).forEach(function (key) {\n        self.memo('button.' + key, buttons[key]);\n      });\n\n      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\n      // add and initialize modules\n      Object.keys(modules).forEach(function (key) {\n        self.module(key, modules[key], true);\n      });\n\n      Object.keys(this.modules).forEach(function (key) {\n        self.initializeModule(key);\n      });\n    };\n\n    this._destroy = function () {\n      // destroy modules with reversed order\n      Object.keys(this.modules).reverse().forEach(function (key) {\n        self.removeModule(key);\n      });\n\n      Object.keys(this.memos).forEach(function (key) {\n        self.removeMemo(key);\n      });\n    };\n\n    this.code = function (html) {\n      var isActivated = this.invoke('codeview.isActivated');\n\n      if (html === undefined) {\n        this.invoke('codeview.sync');\n        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n      } else {\n        if (isActivated) {\n          this.layoutInfo.codable.val(html);\n        } else {\n          this.layoutInfo.editable.html(html);\n        }\n        $note.val(html);\n        this.triggerEvent('change', html);\n      }\n    };\n\n    this.isDisabled = function () {\n      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n    };\n\n    this.enable = function () {\n      this.layoutInfo.editable.attr('contenteditable', true);\n      this.invoke('toolbar.activate', true);\n    };\n\n    this.disable = function () {\n      // close codeview if codeview is opend\n      if (this.invoke('codeview.isActivated')) {\n        this.invoke('codeview.deactivate');\n      }\n      this.layoutInfo.editable.attr('contenteditable', false);\n      this.invoke('toolbar.deactivate', true);\n    };\n\n    this.triggerEvent = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n      if (callback) {\n        callback.apply($note[0], args);\n      }\n      $note.trigger('summernote.' + namespace, args);\n    };\n\n    this.initializeModule = function (key) {\n      var module = this.modules[key];\n      module.shouldInitialize = module.shouldInitialize || func.ok;\n      if (!module.shouldInitialize()) {\n        return;\n      }\n\n      // initialize module\n      if (module.initialize) {\n        module.initialize();\n      }\n\n      // attach events\n      if (module.events) {\n        dom.attachEvents($note, module.events);\n      }\n    };\n\n    this.module = function (key, ModuleClass, withoutIntialize) {\n      if (arguments.length === 1) {\n        return this.modules[key];\n      }\n\n      this.modules[key] = new ModuleClass(this);\n\n      if (!withoutIntialize) {\n        this.initializeModule(key);\n      }\n    };\n\n    this.removeModule = function (key) {\n      var module = this.modules[key];\n      if (module.shouldInitialize()) {\n        if (module.events) {\n          dom.detachEvents($note, module.events);\n        }\n\n        if (module.destroy) {\n          module.destroy();\n        }\n      }\n\n      delete this.modules[key];\n    };\n\n    this.memo = function (key, obj) {\n      if (arguments.length === 1) {\n        return this.memos[key];\n      }\n      this.memos[key] = obj;\n    };\n\n    this.removeMemo = function (key) {\n      if (this.memos[key] && this.memos[key].destroy) {\n        this.memos[key].destroy();\n      }\n\n      delete this.memos[key];\n    };\n\n    this.createInvokeHandler = function (namespace, value) {\n      return function (event) {\n        event.preventDefault();\n        self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));\n      };\n    };\n\n    this.invoke = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var splits = namespace.split('.');\n      var hasSeparator = splits.length > 1;\n      var moduleName = hasSeparator && list.head(splits);\n      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\n      var module = this.modules[moduleName || 'editor'];\n      if (!moduleName && this[methodName]) {\n        return this[methodName].apply(this, args);\n      } else if (module && module[methodName] && module.shouldInitialize()) {\n        return module[methodName].apply(module, args);\n      }\n    };\n\n    return this.initialize();\n  };\n\n  $.fn.extend({\n    /**\n     * Summernote API\n     *\n     * @param {Object|String}\n     * @return {this}\n     */\n    summernote: function () {\n      var type = $.type(list.head(arguments));\n      var isExternalAPICalled = type === 'string';\n      var hasInitOptions = type === 'object';\n\n      var options = hasInitOptions ? list.head(arguments) : {};\n\n      options = $.extend({}, $.summernote.options, options);\n      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n      options.icons = $.extend(true, {}, $.summernote.options.icons, options.icons);\n\n      this.each(function (idx, note) {\n        var $note = $(note);\n        if (!$note.data('summernote')) {\n          var context = new Context($note, options);\n          $note.data('summernote', context);\n          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n        }\n      });\n\n      var $note = this.first();\n      if ($note.length) {\n        var context = $note.data('summernote');\n        if (isExternalAPICalled) {\n          return context.invoke.apply(context, list.from(arguments));\n        } else if (options.focus) {\n          context.invoke('editor.focus');\n        }\n      }\n\n      return this;\n    }\n  });\n\n\n  var Renderer = function (markup, children, options, callback) {\n    this.render = function ($parent) {\n      var $node = $(markup);\n\n      if (options && options.contents) {\n        $node.html(options.contents);\n      }\n\n      if (options && options.className) {\n        $node.addClass(options.className);\n      }\n\n      if (options && options.data) {\n        $.each(options.data, function (k, v) {\n          $node.attr('data-' + k, v);\n        });\n      }\n\n      if (options && options.click) {\n        $node.on('click', options.click);\n      }\n\n      if (children) {\n        var $container = $node.find('.note-children-container');\n        children.forEach(function (child) {\n          child.render($container.length ? $container : $node);\n        });\n      }\n\n      if (callback) {\n        callback($node, options);\n      }\n\n      if (options && options.callback) {\n        options.callback($node);\n      }\n\n      if ($parent) {\n        $parent.append($node);\n      }\n\n      return $node;\n    };\n  };\n\n  var renderer = {\n    create: function (markup, callback) {\n      return function () {\n        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n        if (options && options.children) {\n          children = options.children;\n        }\n        return new Renderer(markup, children, options, callback);\n      };\n    }\n  };\n\n  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n  var statusbar = renderer.create([\n    '<div class=\"note-statusbar\">',\n    '  <div class=\"note-resizebar\">',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '  </div>',\n    '</div>'\n  ].join(''));\n\n  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\n  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n  var button = renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\" tabindex=\"-1\">', function ($node, options) {\n    if (options && options.tooltip) {\n      $node.attr({\n        title: options.tooltip\n      }).tooltip({\n        container: 'body',\n        trigger: 'hover',\n        placement: 'bottom'\n      });\n    }\n  });\n\n  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + content + '</a></li>';\n    }).join('') : options.items;\n\n    $node.html(markup);\n  });\n\n  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n    }).join('') : options.items;\n    $node.html(markup);\n  });\n\n  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n    var contents = [];\n    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n      var eventName = options.eventName;\n      var colors = options.colors[row];\n      var buttons = [];\n      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n        var color = colors[col];\n        buttons.push([\n          '<button type=\"button\" class=\"note-color-btn\"',\n          'style=\"background-color:', color, '\" ',\n          'data-event=\"', eventName, '\" ',\n          'data-value=\"', color, '\" ',\n          'title=\"', color, '\" ',\n          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n        ].join(''));\n      }\n      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n    }\n    $node.html(contents.join(''));\n\n    $node.find('.note-color-btn').tooltip({\n      container: 'body',\n      trigger: 'hover',\n      placement: 'bottom'\n    });\n  });\n\n  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n    if (options.fade) {\n      $node.addClass('fade');\n    }\n    $node.html([\n      '<div class=\"modal-dialog\">',\n      '  <div class=\"modal-content\">',\n      (options.title ?\n      '    <div class=\"modal-header\">' +\n      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n      '    </div>' : ''\n      ),\n      '    <div class=\"modal-body\">' + options.body + '</div>',\n      (options.footer ?\n      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n      ),\n      '  </div>',\n      '</div>'\n    ].join(''));\n  });\n\n  var popover = renderer.create([\n    '<div class=\"note-popover popover in\">',\n    '  <div class=\"arrow\"/>',\n    '  <div class=\"popover-content note-children-container\"/>',\n    '</div>'\n  ].join(''), function ($node, options) {\n    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\n    $node.addClass(direction);\n\n    if (options.hideArrow) {\n      $node.find('.arrow').hide();\n    }\n  });\n\n  var icon = function (iconClassName, tagName) {\n    tagName = tagName || 'i';\n    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n  };\n\n  var ui = {\n    editor: editor,\n    toolbar: toolbar,\n    editingArea: editingArea,\n    codable: codable,\n    editable: editable,\n    statusbar: statusbar,\n    airEditor: airEditor,\n    airEditable: airEditable,\n    buttonGroup: buttonGroup,\n    button: button,\n    dropdown: dropdown,\n    dropdownCheck: dropdownCheck,\n    palette: palette,\n    dialog: dialog,\n    popover: popover,\n    icon: icon,\n\n    toggleBtn: function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    },\n\n    toggleBtnActive: function ($btn, isActive) {\n      $btn.toggleClass('active', isActive);\n    },\n\n    onDialogShown: function ($dialog, handler) {\n      $dialog.one('shown.bs.modal', handler);\n    },\n\n    onDialogHidden: function ($dialog, handler) {\n      $dialog.one('hidden.bs.modal', handler);\n    },\n\n    showDialog: function ($dialog) {\n      $dialog.modal('show');\n    },\n\n    hideDialog: function ($dialog) {\n      $dialog.modal('hide');\n    },\n\n    createLayout: function ($note, options) {\n      var $editor = (options.airMode ? ui.airEditor([\n        ui.editingArea([\n          ui.airEditable()\n        ])\n      ]) : ui.editor([\n        ui.toolbar(),\n        ui.editingArea([\n          ui.codable(),\n          ui.editable()\n        ]),\n        ui.statusbar()\n      ])).render();\n\n      $editor.insertAfter($note);\n\n      return {\n        note: $note,\n        editor: $editor,\n        toolbar: $editor.find('.note-toolbar'),\n        editingArea: $editor.find('.note-editing-area'),\n        editable: $editor.find('.note-editable'),\n        codable: $editor.find('.note-codable'),\n        statusbar: $editor.find('.note-statusbar')\n      };\n    },\n\n    removeLayout: function ($note, layoutInfo) {\n      $note.html(layoutInfo.editable.html());\n      layoutInfo.editor.remove();\n      $note.show();\n    }\n  };\n\n  $.summernote = $.summernote || {\n    lang: {}\n  };\n\n  $.extend($.summernote.lang, {\n    'en-US': {\n      font: {\n        bold: 'Bold',\n        italic: 'Italic',\n        underline: 'Underline',\n        clear: 'Remove Font Style',\n        height: 'Line Height',\n        name: 'Font Family',\n        strikethrough: 'Strikethrough',\n        subscript: 'Subscript',\n        superscript: 'Superscript',\n        size: 'Font Size'\n      },\n      image: {\n        image: 'Picture',\n        insert: 'Insert Image',\n        resizeFull: 'Resize Full',\n        resizeHalf: 'Resize Half',\n        resizeQuarter: 'Resize Quarter',\n        floatLeft: 'Float Left',\n        floatRight: 'Float Right',\n        floatNone: 'Float None',\n        shapeRounded: 'Shape: Rounded',\n        shapeCircle: 'Shape: Circle',\n        shapeThumbnail: 'Shape: Thumbnail',\n        shapeNone: 'Shape: None',\n        dragImageHere: 'Drag image or text here',\n        dropImage: 'Drop image or Text',\n        selectFromFiles: 'Select from files',\n        maximumFileSize: 'Maximum file size',\n        maximumFileSizeError: 'Maximum file size exceeded.',\n        url: 'Image URL',\n        remove: 'Remove Image'\n      },\n      video: {\n        video: 'Video',\n        videoLink: 'Video Link',\n        insert: 'Insert Video',\n        url: 'Video URL?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Insert Link',\n        unlink: 'Unlink',\n        edit: 'Edit',\n        textToDisplay: 'Text to display',\n        url: 'To what URL should this link go?',\n        openInNewWindow: 'Open in new window'\n      },\n      table: {\n        table: 'Table'\n      },\n      hr: {\n        insert: 'Insert Horizontal Rule'\n      },\n      style: {\n        style: 'Style',\n        normal: 'Normal',\n        blockquote: 'Quote',\n        pre: 'Code',\n        h1: 'Header 1',\n        h2: 'Header 2',\n        h3: 'Header 3',\n        h4: 'Header 4',\n        h5: 'Header 5',\n        h6: 'Header 6'\n      },\n      lists: {\n        unordered: 'Unordered list',\n        ordered: 'Ordered list'\n      },\n      options: {\n        help: 'Help',\n        fullscreen: 'Full Screen',\n        codeview: 'Code View'\n      },\n      paragraph: {\n        paragraph: 'Paragraph',\n        outdent: 'Outdent',\n        indent: 'Indent',\n        left: 'Align left',\n        center: 'Align center',\n        right: 'Align right',\n        justify: 'Justify full'\n      },\n      color: {\n        recent: 'Recent Color',\n        more: 'More Color',\n        background: 'Background Color',\n        foreground: 'Foreground Color',\n        transparent: 'Transparent',\n        setTransparent: 'Set transparent',\n        reset: 'Reset',\n        resetToDefault: 'Reset to default'\n      },\n      shortcut: {\n        shortcuts: 'Keyboard shortcuts',\n        close: 'Close',\n        textFormatting: 'Text formatting',\n        action: 'Action',\n        paragraphFormatting: 'Paragraph formatting',\n        documentStyle: 'Document Style',\n        extraKeys: 'Extra keys'\n      },\n      help: {\n        'insertParagraph': 'Insert Paragraph',\n        'undo': 'Undoes the last command',\n        'redo': 'Redoes the last command',\n        'tab': 'Tab',\n        'untab': 'Untab',\n        'bold': 'Set a bold style',\n        'italic': 'Set a italic style',\n        'underline': 'Set a underline style',\n        'strikethrough': 'Set a strikethrough style',\n        'removeFormat': 'Clean a style',\n        'justifyLeft': 'Set left align',\n        'justifyCenter': 'Set center align',\n        'justifyRight': 'Set right align',\n        'justifyFull': 'Set full align',\n        'insertUnorderedList': 'Toggle unordered list',\n        'insertOrderedList': 'Toggle ordered list',\n        'outdent': 'Outdent on current paragraph',\n        'indent': 'Indent on current paragraph',\n        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n        'formatH1': 'Change current block\\'s format as H1',\n        'formatH2': 'Change current block\\'s format as H2',\n        'formatH3': 'Change current block\\'s format as H3',\n        'formatH4': 'Change current block\\'s format as H4',\n        'formatH5': 'Change current block\\'s format as H5',\n        'formatH6': 'Change current block\\'s format as H6',\n        'insertHorizontalRule': 'Insert horizontal rule',\n        'linkDialog.show': 'Show Link Dialog'\n      },\n      history: {\n        undo: 'Undo',\n        redo: 'Redo'\n      },\n      specialChar: {\n        specialChar: 'SPECIAL CHARACTERS',\n        select: 'Select Special characters'\n      }\n    }\n  });\n\n\n  /**\n   * @class core.key\n   *\n   * Object for keycodes.\n   *\n   * @singleton\n   * @alternateClassName key\n   */\n  var key = (function () {\n    var keyMap = {\n      'BACKSPACE': 8,\n      'TAB': 9,\n      'ENTER': 13,\n      'SPACE': 32,\n\n      // Arrow\n      'LEFT': 37,\n      'UP': 38,\n      'RIGHT': 39,\n      'DOWN': 40,\n\n      // Number: 0-9\n      'NUM0': 48,\n      'NUM1': 49,\n      'NUM2': 50,\n      'NUM3': 51,\n      'NUM4': 52,\n      'NUM5': 53,\n      'NUM6': 54,\n      'NUM7': 55,\n      'NUM8': 56,\n\n      // Alphabet: a-z\n      'B': 66,\n      'E': 69,\n      'I': 73,\n      'J': 74,\n      'K': 75,\n      'L': 76,\n      'R': 82,\n      'S': 83,\n      'U': 85,\n      'V': 86,\n      'Y': 89,\n      'Z': 90,\n\n      'SLASH': 191,\n      'LEFTBRACKET': 219,\n      'BACKSLASH': 220,\n      'RIGHTBRACKET': 221\n    };\n\n    return {\n      /**\n       * @method isEdit\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isEdit: function (keyCode) {\n        return list.contains([\n          keyMap.BACKSPACE,\n          keyMap.TAB,\n          keyMap.ENTER,\n          keyMap.SPACE\n        ], keyCode);\n      },\n      /**\n       * @method isMove\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isMove: function (keyCode) {\n        return list.contains([\n          keyMap.LEFT,\n          keyMap.UP,\n          keyMap.RIGHT,\n          keyMap.DOWN\n        ], keyCode);\n      },\n      /**\n       * @property {Object} nameFromCode\n       * @property {String} nameFromCode.8 \"BACKSPACE\"\n       */\n      nameFromCode: func.invertObject(keyMap),\n      code: keyMap\n    };\n  })();\n\n  var range = (function () {\n\n    /**\n     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n     *\n     * @param {TextRange} textRange\n     * @param {Boolean} isStart\n     * @return {BoundaryPoint}\n     *\n     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n     */\n    var textRangeToPoint = function (textRange, isStart) {\n      var container = textRange.parentElement(), offset;\n  \n      var tester = document.body.createTextRange(), prevContainer;\n      var childNodes = list.from(container.childNodes);\n      for (offset = 0; offset < childNodes.length; offset++) {\n        if (dom.isText(childNodes[offset])) {\n          continue;\n        }\n        tester.moveToElementText(childNodes[offset]);\n        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n          break;\n        }\n        prevContainer = childNodes[offset];\n      }\n  \n      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n        textRangeStart.moveToElementText(prevContainer || container);\n        textRangeStart.collapse(!prevContainer);\n        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n  \n        var pointTester = textRange.duplicate();\n        pointTester.setEndPoint('StartToStart', textRangeStart);\n        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n  \n        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        /* jshint ignore:start */\n        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n        /* jshint ignore:end */\n  \n        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n            textCount === curTextNode.nodeValue.length) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        container = curTextNode;\n        offset = textCount;\n      }\n  \n      return {\n        cont: container,\n        offset: offset\n      };\n    };\n    \n    /**\n     * return TextRange from boundary point (inspired by google closure-library)\n     * @param {BoundaryPoint} point\n     * @return {TextRange}\n     */\n    var pointToTextRange = function (point) {\n      var textRangeInfo = function (container, offset) {\n        var node, isCollapseToStart;\n  \n        if (dom.isText(container)) {\n          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n          var prevContainer = list.last(prevTextNodes).previousSibling;\n          node =  prevContainer || container.parentNode;\n          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n          isCollapseToStart = !prevContainer;\n        } else {\n          node = container.childNodes[offset] || container;\n          if (dom.isText(node)) {\n            return textRangeInfo(node, 0);\n          }\n  \n          offset = 0;\n          isCollapseToStart = false;\n        }\n  \n        return {\n          node: node,\n          collapseToStart: isCollapseToStart,\n          offset: offset\n        };\n      };\n  \n      var textRange = document.body.createTextRange();\n      var info = textRangeInfo(point.node, point.offset);\n  \n      textRange.moveToElementText(info.node);\n      textRange.collapse(info.collapseToStart);\n      textRange.moveStart('character', info.offset);\n      return textRange;\n    };\n    \n    /**\n     * Wrapped Range\n     *\n     * @constructor\n     * @param {Node} sc - start container\n     * @param {Number} so - start offset\n     * @param {Node} ec - end container\n     * @param {Number} eo - end offset\n     */\n    var WrappedRange = function (sc, so, ec, eo) {\n      this.sc = sc;\n      this.so = so;\n      this.ec = ec;\n      this.eo = eo;\n  \n      // nativeRange: get nativeRange from sc, so, ec, eo\n      var nativeRange = function () {\n        if (agent.isW3CRangeSupport) {\n          var w3cRange = document.createRange();\n          w3cRange.setStart(sc, so);\n          w3cRange.setEnd(ec, eo);\n\n          return w3cRange;\n        } else {\n          var textRange = pointToTextRange({\n            node: sc,\n            offset: so\n          });\n\n          textRange.setEndPoint('EndToEnd', pointToTextRange({\n            node: ec,\n            offset: eo\n          }));\n\n          return textRange;\n        }\n      };\n\n      this.getPoints = function () {\n        return {\n          sc: sc,\n          so: so,\n          ec: ec,\n          eo: eo\n        };\n      };\n\n      this.getStartPoint = function () {\n        return {\n          node: sc,\n          offset: so\n        };\n      };\n\n      this.getEndPoint = function () {\n        return {\n          node: ec,\n          offset: eo\n        };\n      };\n\n      /**\n       * select update visible range\n       */\n      this.select = function () {\n        var nativeRng = nativeRange();\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(nativeRng);\n        } else {\n          nativeRng.select();\n        }\n        \n        return this;\n      };\n\n      /**\n       * Moves the scrollbar to start container(sc) of current range\n       *\n       * @return {WrappedRange}\n       */\n      this.scrollIntoView = function (container) {\n        var height = $(container).height();\n        if (container.scrollTop + height < this.sc.offsetTop) {\n          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n        }\n\n        return this;\n      };\n\n      /**\n       * @return {WrappedRange}\n       */\n      this.normalize = function () {\n\n        /**\n         * @param {BoundaryPoint} point\n         * @param {Boolean} isLeftToRight\n         * @return {BoundaryPoint}\n         */\n        var getVisiblePoint = function (point, isLeftToRight) {\n          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n            return point;\n          }\n\n          // point on block's edge\n          var block = dom.ancestor(point.node, dom.isBlock);\n          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\n            // returns point already on visible point\n            if (dom.isVisiblePoint(point)) {\n              return point;\n            }\n            // reverse direction \n            isLeftToRight = !isLeftToRight;\n          }\n\n          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n          return nextPoint || point;\n        };\n\n        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n\n      /**\n       * returns matched nodes on range\n       *\n       * @param {Function} [pred] - predicate function\n       * @param {Object} [options]\n       * @param {Boolean} [options.includeAncestor]\n       * @param {Boolean} [options.fullyContains]\n       * @return {Node[]}\n       */\n      this.nodes = function (pred, options) {\n        pred = pred || func.ok;\n\n        var includeAncestor = options && options.includeAncestor;\n        var fullyContains = options && options.fullyContains;\n\n        // TODO compare points and sort\n        var startPoint = this.getStartPoint();\n        var endPoint = this.getEndPoint();\n\n        var nodes = [];\n        var leftEdgeNodes = [];\n\n        dom.walkPoint(startPoint, endPoint, function (point) {\n          if (dom.isEditable(point.node)) {\n            return;\n          }\n\n          var node;\n          if (fullyContains) {\n            if (dom.isLeftEdgePoint(point)) {\n              leftEdgeNodes.push(point.node);\n            }\n            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n              node = point.node;\n            }\n          } else if (includeAncestor) {\n            node = dom.ancestor(point.node, pred);\n          } else {\n            node = point.node;\n          }\n\n          if (node && pred(node)) {\n            nodes.push(node);\n          }\n        }, true);\n\n        return list.unique(nodes);\n      };\n\n      /**\n       * returns commonAncestor of range\n       * @return {Element} - commonAncestor\n       */\n      this.commonAncestor = function () {\n        return dom.commonAncestor(sc, ec);\n      };\n\n      /**\n       * returns expanded range by pred\n       *\n       * @param {Function} pred - predicate function\n       * @return {WrappedRange}\n       */\n      this.expand = function (pred) {\n        var startAncestor = dom.ancestor(sc, pred);\n        var endAncestor = dom.ancestor(ec, pred);\n\n        if (!startAncestor && !endAncestor) {\n          return new WrappedRange(sc, so, ec, eo);\n        }\n\n        var boundaryPoints = this.getPoints();\n\n        if (startAncestor) {\n          boundaryPoints.sc = startAncestor;\n          boundaryPoints.so = 0;\n        }\n\n        if (endAncestor) {\n          boundaryPoints.ec = endAncestor;\n          boundaryPoints.eo = dom.nodeLength(endAncestor);\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * @param {Boolean} isCollapseToStart\n       * @return {WrappedRange}\n       */\n      this.collapse = function (isCollapseToStart) {\n        if (isCollapseToStart) {\n          return new WrappedRange(sc, so, sc, so);\n        } else {\n          return new WrappedRange(ec, eo, ec, eo);\n        }\n      };\n\n      /**\n       * splitText on range\n       */\n      this.splitText = function () {\n        var isSameContainer = sc === ec;\n        var boundaryPoints = this.getPoints();\n\n        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n          ec.splitText(eo);\n        }\n\n        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n          boundaryPoints.sc = sc.splitText(so);\n          boundaryPoints.so = 0;\n\n          if (isSameContainer) {\n            boundaryPoints.ec = boundaryPoints.sc;\n            boundaryPoints.eo = eo - so;\n          }\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * delete contents on range\n       * @return {WrappedRange}\n       */\n      this.deleteContents = function () {\n        if (this.isCollapsed()) {\n          return this;\n        }\n\n        var rng = this.splitText();\n        var nodes = rng.nodes(null, {\n          fullyContains: true\n        });\n\n        // find new cursor point\n        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n          return !list.contains(nodes, point.node);\n        });\n\n        var emptyParents = [];\n        $.each(nodes, function (idx, node) {\n          // find empty parents\n          var parent = node.parentNode;\n          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n            emptyParents.push(parent);\n          }\n          dom.remove(node, false);\n        });\n\n        // remove empty parents\n        $.each(emptyParents, function (idx, node) {\n          dom.remove(node, false);\n        });\n\n        return new WrappedRange(\n          point.node,\n          point.offset,\n          point.node,\n          point.offset\n        ).normalize();\n      };\n      \n      /**\n       * makeIsOn: return isOn(pred) function\n       */\n      var makeIsOn = function (pred) {\n        return function () {\n          var ancestor = dom.ancestor(sc, pred);\n          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n        };\n      };\n  \n      // isOnEditable: judge whether range is on editable or not\n      this.isOnEditable = makeIsOn(dom.isEditable);\n      // isOnList: judge whether range is on list node or not\n      this.isOnList = makeIsOn(dom.isList);\n      // isOnAnchor: judge whether range is on anchor node or not\n      this.isOnAnchor = makeIsOn(dom.isAnchor);\n      // isOnCell: judge whether range is on cell node or not\n      this.isOnCell = makeIsOn(dom.isCell);\n      // isOnData: judge whether range is on data node or not\n      this.isOnData = makeIsOn(dom.isData);\n\n      /**\n       * @param {Function} pred\n       * @return {Boolean}\n       */\n      this.isLeftEdgeOf = function (pred) {\n        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n          return false;\n        }\n\n        var node = dom.ancestor(this.sc, pred);\n        return node && dom.isLeftEdgeOf(this.sc, node);\n      };\n\n      /**\n       * returns whether range was collapsed or not\n       */\n      this.isCollapsed = function () {\n        return sc === ec && so === eo;\n      };\n\n      /**\n       * wrap inline nodes which children of body with paragraph\n       *\n       * @return {WrappedRange}\n       */\n      this.wrapBodyInlineWithPara = function () {\n        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n          sc.innerHTML = dom.emptyPara;\n          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n        }\n\n        /**\n         * [workaround] firefox often create range on not visible point. so normalize here.\n         *  - firefox: |<p>text</p>|\n         *  - chrome: <p>|text|</p>\n         */\n        var rng = this.normalize();\n        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n          return rng;\n        }\n\n        // find inline top ancestor\n        var topAncestor;\n        if (dom.isInline(rng.sc)) {\n          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n          topAncestor = list.last(ancestors);\n          if (!dom.isInline(topAncestor)) {\n            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n          }\n        } else {\n          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n        }\n\n        // siblings not in paragraph\n        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\n        // wrap with paragraph\n        if (inlineSiblings.length) {\n          var para = dom.wrap(list.head(inlineSiblings), 'p');\n          dom.appendChildNodes(para, list.tail(inlineSiblings));\n        }\n\n        return this.normalize();\n      };\n\n      /**\n       * insert node at current cursor\n       *\n       * @param {Node} node\n       * @return {Node}\n       */\n      this.insertNode = function (node) {\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\n        if (info.rightNode) {\n          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n        } else {\n          info.container.appendChild(node);\n        }\n\n        return node;\n      };\n\n      /**\n       * insert html at current cursor\n       */\n      this.pasteHTML = function (markup) {\n        var contentsContainer = $('<div></div>').html(markup)[0];\n        var childNodes = list.from(contentsContainer.childNodes);\n\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\n        return childNodes.reverse().map(function (childNode) {\n          return rng.insertNode(childNode);\n        }).reverse();\n      };\n  \n      /**\n       * returns text in range\n       *\n       * @return {String}\n       */\n      this.toString = function () {\n        var nativeRng = nativeRange();\n        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n      };\n\n      /**\n       * returns range for word before cursor\n       *\n       * @param {Boolean} [findAfter] - find after cursor, default: false\n       * @return {WrappedRange}\n       */\n      this.getWordRange = function (findAfter) {\n        var endPoint = this.getEndPoint();\n\n        if (!dom.isCharPoint(endPoint)) {\n          return this;\n        }\n\n        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n          return !dom.isCharPoint(point);\n        });\n\n        if (findAfter) {\n          endPoint = dom.nextPointUntil(endPoint, function (point) {\n            return !dom.isCharPoint(point);\n          });\n        }\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n  \n      /**\n       * create offsetPath bookmark\n       *\n       * @param {Node} editable\n       */\n      this.bookmark = function (editable) {\n        return {\n          s: {\n            path: dom.makeOffsetPath(editable, sc),\n            offset: so\n          },\n          e: {\n            path: dom.makeOffsetPath(editable, ec),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * create offsetPath bookmark base on paragraph\n       *\n       * @param {Node[]} paras\n       */\n      this.paraBookmark = function (paras) {\n        return {\n          s: {\n            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n            offset: so\n          },\n          e: {\n            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * getClientRects\n       * @return {Rect[]}\n       */\n      this.getClientRects = function () {\n        var nativeRng = nativeRange();\n        return nativeRng.getClientRects();\n      };\n    };\n\n  /**\n   * @class core.range\n   *\n   * Data structure\n   *  * BoundaryPoint: a point of dom tree\n   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n   *\n   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n   *\n   * @singleton\n   * @alternateClassName range\n   */\n    return {\n      /**\n       * create Range Object From arguments or Browser Selection\n       *\n       * @param {Node} sc - start container\n       * @param {Number} so - start offset\n       * @param {Node} ec - end container\n       * @param {Number} eo - end offset\n       * @return {WrappedRange}\n       */\n      create: function (sc, so, ec, eo) {\n        if (arguments.length === 4) {\n          return new WrappedRange(sc, so, ec, eo);\n        } else if (arguments.length === 2) { //collapsed\n          ec = sc;\n          eo = so;\n          return new WrappedRange(sc, so, ec, eo);\n        } else {\n          var wrappedRange = this.createFromSelection();\n          if (!wrappedRange && arguments.length === 1) {\n            wrappedRange = this.createFromNode(arguments[0]);\n            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n          }\n          return wrappedRange;\n        }\n      },\n\n      createFromSelection: function () {\n        var sc, so, ec, eo;\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          } else if (dom.isBody(selection.anchorNode)) {\n            // Firefox: returns entire body as range on initialization.\n            // We won't never need it.\n            return null;\n          }\n\n          var nativeRng = selection.getRangeAt(0);\n          sc = nativeRng.startContainer;\n          so = nativeRng.startOffset;\n          ec = nativeRng.endContainer;\n          eo = nativeRng.endOffset;\n        } else { // IE8: TextRange\n          var textRange = document.selection.createRange();\n          var textRangeEnd = textRange.duplicate();\n          textRangeEnd.collapse(false);\n          var textRangeStart = textRange;\n          textRangeStart.collapse(true);\n\n          var startPoint = textRangeToPoint(textRangeStart, true),\n          endPoint = textRangeToPoint(textRangeEnd, false);\n\n          // same visible point case: range was collapsed.\n          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n              endPoint.node.nextSibling === startPoint.node) {\n            startPoint = endPoint;\n          }\n\n          sc = startPoint.cont;\n          so = startPoint.offset;\n          ec = endPoint.cont;\n          eo = endPoint.offset;\n        }\n\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from node\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNode: function (node) {\n        var sc = node;\n        var so = 0;\n        var ec = node;\n        var eo = dom.nodeLength(ec);\n\n        // browsers can't target a picture or void node\n        if (dom.isVoid(sc)) {\n          so = dom.listPrev(sc).length - 1;\n          sc = sc.parentNode;\n        }\n        if (dom.isBR(ec)) {\n          eo = dom.listPrev(ec).length - 1;\n          ec = ec.parentNode;\n        } else if (dom.isVoid(ec)) {\n          eo = dom.listPrev(ec).length;\n          ec = ec.parentNode;\n        }\n\n        return this.create(sc, so, ec, eo);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeBefore: function (node) {\n        return this.createFromNode(node).collapse(true);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeAfter: function (node) {\n        return this.createFromNode(node).collapse();\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from bookmark\n       *\n       * @param {Node} editable\n       * @param {Object} bookmark\n       * @return {WrappedRange}\n       */\n      createFromBookmark: function (editable, bookmark) {\n        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n        var so = bookmark.s.offset;\n        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n        var eo = bookmark.e.offset;\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       *\n       * create WrappedRange from paraBookmark\n       *\n       * @param {Object} bookmark\n       * @param {Node[]} paras\n       * @return {WrappedRange}\n       */\n      createFromParaBookmark: function (bookmark, paras) {\n        var so = bookmark.s.offset;\n        var eo = bookmark.e.offset;\n        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\n        return new WrappedRange(sc, so, ec, eo);\n      }\n    };\n  })();\n\n  /**\n   * @class core.async\n   *\n   * Async functions which returns `Promise`\n   *\n   * @singleton\n   * @alternateClassName async\n   */\n  var async = (function () {\n    /**\n     * @method readFileAsDataURL\n     *\n     * read contents of file as representing URL\n     *\n     * @param {File} file\n     * @return {Promise} - then: dataUrl\n     */\n    var readFileAsDataURL = function (file) {\n      return $.Deferred(function (deferred) {\n        $.extend(new FileReader(), {\n          onload: function (e) {\n            var dataURL = e.target.result;\n            deferred.resolve(dataURL);\n          },\n          onerror: function () {\n            deferred.reject(this);\n          }\n        }).readAsDataURL(file);\n      }).promise();\n    };\n  \n    /**\n     * @method createImage\n     *\n     * create `<image>` from url string\n     *\n     * @param {String} url\n     * @return {Promise} - then: $image\n     */\n    var createImage = function (url) {\n      return $.Deferred(function (deferred) {\n        var $img = $('<img>');\n\n        $img.one('load', function () {\n          $img.off('error abort');\n          deferred.resolve($img);\n        }).one('error abort', function () {\n          $img.off('load').detach();\n          deferred.reject($img);\n        }).css({\n          display: 'none'\n        }).appendTo(document.body).attr('src', url);\n      }).promise();\n    };\n\n    return {\n      readFileAsDataURL: readFileAsDataURL,\n      createImage: createImage\n    };\n  })();\n\n  /**\n   * @class editing.History\n   *\n   * Editor History\n   *\n   */\n  var History = function ($editable) {\n    var stack = [], stackOffset = -1;\n    var editable = $editable[0];\n\n    var makeSnapshot = function () {\n      var rng = range.create(editable);\n      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\n      return {\n        contents: $editable.html(),\n        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n      };\n    };\n\n    var applySnapshot = function (snapshot) {\n      if (snapshot.contents !== null) {\n        $editable.html(snapshot.contents);\n      }\n      if (snapshot.bookmark !== null) {\n        range.createFromBookmark(editable, snapshot.bookmark).select();\n      }\n    };\n\n    /**\n    * @method rewind\n    * Rewinds the history stack back to the first snapshot taken.\n    * Leaves the stack intact, so that \"Redo\" can still be used.\n    */\n    this.rewind = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      // Return to the first available snapshot.\n      stackOffset = 0;\n\n      // Apply that snapshot.\n      applySnapshot(stack[stackOffset]);\n    };\n\n    /**\n    * @method reset\n    * Resets the history stack completely; reverting to an empty editor.\n    */\n    this.reset = function () {\n      // Clear the stack.\n      stack = [];\n\n      // Restore stackOffset to its original value.\n      stackOffset = -1;\n\n      // Clear the editable area.\n      $editable.html('');\n\n      // Record our first snapshot (of nothing).\n      this.recordUndo();\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      if (0 < stackOffset) {\n        stackOffset--;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      if (stack.length - 1 > stackOffset) {\n        stackOffset++;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * recorded undo\n     */\n    this.recordUndo = function () {\n      stackOffset++;\n\n      // Wash out stack after stackOffset\n      if (stack.length > stackOffset) {\n        stack = stack.slice(0, stackOffset);\n      }\n\n      // Create new snapshot and push it to the end\n      stack.push(makeSnapshot());\n    };\n  };\n\n  /**\n   * @class editing.Style\n   *\n   * Style\n   *\n   */\n  var Style = function () {\n    /**\n     * @method jQueryCSS\n     *\n     * [workaround] for old jQuery\n     * passing an array of style properties to .css()\n     * will result in an object of property-value pairs.\n     * (compability with version < 1.9)\n     *\n     * @private\n     * @param  {jQuery} $obj\n     * @param  {Array} propertyNames - An array of one or more CSS properties.\n     * @return {Object}\n     */\n    var jQueryCSS = function ($obj, propertyNames) {\n      if (agent.jqueryVersion < 1.9) {\n        var result = {};\n        $.each(propertyNames, function (idx, propertyName) {\n          result[propertyName] = $obj.css(propertyName);\n        });\n        return result;\n      }\n      return $obj.css.call($obj, propertyNames);\n    };\n\n    /**\n     * returns style object from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.fromNode = function ($node) {\n      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n      var styleInfo = jQueryCSS($node, properties) || {};\n      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n      return styleInfo;\n    };\n\n    /**\n     * paragraph level style\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} styleInfo\n     */\n    this.stylePara = function (rng, styleInfo) {\n      $.each(rng.nodes(dom.isPara, {\n        includeAncestor: true\n      }), function (idx, para) {\n        $(para).css(styleInfo);\n      });\n    };\n\n    /**\n     * insert and returns styleNodes on range.\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} [options] - options for styleNodes\n     * @param {String} [options.nodeName] - default: `SPAN`\n     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n     * @return {Node[]}\n     */\n    this.styleNodes = function (rng, options) {\n      rng = rng.splitText();\n\n      var nodeName = options && options.nodeName || 'SPAN';\n      var expandClosestSibling = !!(options && options.expandClosestSibling);\n      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\n      if (rng.isCollapsed()) {\n        return [rng.insertNode(dom.create(nodeName))];\n      }\n\n      var pred = dom.makePredByNodeName(nodeName);\n      var nodes = rng.nodes(dom.isText, {\n        fullyContains: true\n      }).map(function (text) {\n        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n      });\n\n      if (expandClosestSibling) {\n        if (onlyPartialContains) {\n          var nodesInRange = rng.nodes();\n          // compose with partial contains predication\n          pred = func.and(pred, function (node) {\n            return list.contains(nodesInRange, node);\n          });\n        }\n\n        return nodes.map(function (node) {\n          var siblings = dom.withClosestSiblings(node, pred);\n          var head = list.head(siblings);\n          var tails = list.tail(siblings);\n          $.each(tails, function (idx, elem) {\n            dom.appendChildNodes(head, elem.childNodes);\n            dom.remove(elem);\n          });\n          return list.head(siblings);\n        });\n      } else {\n        return nodes;\n      }\n    };\n\n    /**\n     * get current style on cursor\n     *\n     * @param {WrappedRange} rng\n     * @return {Object} - object contains style properties.\n     */\n    this.current = function (rng) {\n      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n      var styleInfo = this.fromNode($cont);\n\n      // document.queryCommandState for toggle state\n      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n      try {\n        styleInfo = $.extend(styleInfo, {\n          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'\n        });\n      } catch (e) {}\n\n      // list-style-type to list-style(unordered, ordered)\n      if (!rng.isOnList()) {\n        styleInfo['list-style'] = 'none';\n      } else {\n        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n      }\n\n      var para = dom.ancestor(rng.sc, dom.isPara);\n      if (para && para.style['line-height']) {\n        styleInfo['line-height'] = para.style.lineHeight;\n      } else {\n        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n        styleInfo['line-height'] = lineHeight.toFixed(1);\n      }\n\n      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n      styleInfo.range = rng;\n\n      return styleInfo;\n    };\n  };\n\n\n  /**\n   * @class editing.Bullet\n   *\n   * @alternateClassName Bullet\n   */\n  var Bullet = function () {\n    var self = this;\n\n    /**\n     * toggle ordered list\n     */\n    this.insertOrderedList = function (editable) {\n      this.toggleList('OL', editable);\n    };\n\n    /**\n     * toggle unordered list\n     */\n    this.insertUnorderedList = function (editable) {\n      this.toggleList('UL', editable);\n    };\n\n    /**\n     * indent\n     */\n    this.indent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.wrapList(paras, head.parentNode.nodeName);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              return (parseInt(val, 10) || 0) + 25;\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * outdent\n     */\n    this.outdent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.releaseList([paras]);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              val = (parseInt(val, 10) || 0);\n              return val > 25 ? val - 25 : '';\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * toggle list\n     *\n     * @param {String} listName - OL or UL\n     */\n    this.toggleList = function (listName, editable) {\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var bookmark = rng.paraBookmark(paras);\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      // paragraph to list\n      if (list.find(paras, dom.isPurePara)) {\n        var wrappedParas = [];\n        $.each(clustereds, function (idx, paras) {\n          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n        });\n        paras = wrappedParas;\n      // list to paragraph or change list style\n      } else {\n        var diffLists = rng.nodes(dom.isList, {\n          includeAncestor: true\n        }).filter(function (listNode) {\n          return !$.nodeName(listNode, listName);\n        });\n\n        if (diffLists.length) {\n          $.each(diffLists, function (idx, listNode) {\n            dom.replace(listNode, listName);\n          });\n        } else {\n          paras = this.releaseList(clustereds, true);\n        }\n      }\n\n      range.createFromParaBookmark(bookmark, paras).select();\n    };\n\n    /**\n     * @param {Node[]} paras\n     * @param {String} listName\n     * @return {Node[]}\n     */\n    this.wrapList = function (paras, listName) {\n      var head = list.head(paras);\n      var last = list.last(paras);\n\n      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\n      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\n      // P to LI\n      paras = paras.map(function (para) {\n        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n      });\n\n      // append to list(<ul>, <ol>)\n      dom.appendChildNodes(listNode, paras);\n\n      if (nextList) {\n        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n        dom.remove(nextList);\n      }\n\n      return paras;\n    };\n\n    /**\n     * @method releaseList\n     *\n     * @param {Array[]} clustereds\n     * @param {Boolean} isEscapseToBody\n     * @return {Node[]}\n     */\n    this.releaseList = function (clustereds, isEscapseToBody) {\n      var releasedParas = [];\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        var last = list.last(paras);\n\n        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n                                         head.parentNode;\n        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n          node: last.parentNode,\n          offset: dom.position(last) + 1\n        }, {\n          isSkipPaddingBlankHTML: true\n        }) : null;\n\n        var middleList = dom.splitTree(headList, {\n          node: head.parentNode,\n          offset: dom.position(head)\n        }, {\n          isSkipPaddingBlankHTML: true\n        });\n\n        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n                                  list.from(middleList.childNodes).filter(dom.isLi);\n\n        // LI to P\n        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n          paras = paras.map(function (para) {\n            return dom.replace(para, 'P');\n          });\n        }\n\n        $.each(list.from(paras).reverse(), function (idx, para) {\n          dom.insertAfter(para, headList);\n        });\n\n        // remove empty lists\n        var rootLists = list.compact([headList, middleList, lastList]);\n        $.each(rootLists, function (idx, rootList) {\n          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n          $.each(listNodes.reverse(), function (idx, listNode) {\n            if (!dom.nodeLength(listNode)) {\n              dom.remove(listNode, true);\n            }\n          });\n        });\n\n        releasedParas = releasedParas.concat(paras);\n      });\n\n      return releasedParas;\n    };\n  };\n\n\n  /**\n   * @class editing.Typing\n   *\n   * Typing\n   *\n   */\n  var Typing = function () {\n\n    // a Bullet instance to toggle lists off\n    var bullet = new Bullet();\n\n    /**\n     * insert tab\n     *\n     * @param {WrappedRange} rng\n     * @param {Number} tabsize\n     */\n    this.insertTab = function (rng, tabsize) {\n      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n      rng = rng.deleteContents();\n      rng.insertNode(tab, true);\n\n      rng = range.create(tab, tabsize);\n      rng.select();\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = function (editable) {\n      var rng = range.create(editable);\n\n      // deleteContents on range.\n      rng = rng.deleteContents();\n\n      // Wrap range if it needs to be wrapped by paragraph\n      rng = rng.wrapBodyInlineWithPara();\n\n      // finding paragraph\n      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\n      var nextPara;\n      // on paragraph: split paragraph\n      if (splitRoot) {\n        // if it is an empty line with li\n        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n          // toogle UL/OL and escape\n          bullet.toggleList(splitRoot.parentNode.nodeName);\n          return;\n        // if it is an empty line with para on blockquote\n        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n          // escape blockquote\n          dom.insertAfter(splitRoot, splitRoot.parentNode);\n          nextPara = splitRoot;\n        // if new line has content (not a line break)\n        } else {\n          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\n          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\n          $.each(emptyAnchors, function (idx, anchor) {\n            dom.remove(anchor);\n          });\n\n          // replace empty heading or pre with P tag\n          if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {\n            nextPara = dom.replace(nextPara, 'p');\n          }\n        }\n      // no paragraph: insert empty paragraph\n      } else {\n        var next = rng.sc.childNodes[rng.so];\n        nextPara = $(dom.emptyPara)[0];\n        if (next) {\n          rng.sc.insertBefore(nextPara, next);\n        } else {\n          rng.sc.appendChild(nextPara);\n        }\n      }\n\n      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n    };\n  };\n\n  /**\n   * @class editing.Table\n   *\n   * Table\n   *\n   */\n  var Table = function () {\n    /**\n     * handle tab key\n     *\n     * @param {WrappedRange} rng\n     * @param {Boolean} isShift\n     */\n    this.tab = function (rng, isShift) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var table = dom.ancestor(cell, dom.isTable);\n      var cells = dom.listDescendant(table, dom.isCell);\n\n      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n      if (nextCell) {\n        range.create(nextCell, 0).select();\n      }\n    };\n\n    /**\n     * create empty table element\n     *\n     * @param {Number} rowCount\n     * @param {Number} colCount\n     * @return {Node}\n     */\n    this.createTable = function (colCount, rowCount, options) {\n      var tds = [], tdHTML;\n      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n        tds.push('<td>' + dom.blank + '</td>');\n      }\n      tdHTML = tds.join('');\n\n      var trs = [], trHTML;\n      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n        trs.push('<tr>' + tdHTML + '</tr>');\n      }\n      trHTML = trs.join('');\n      var $table = $('<table>' + trHTML + '</table>');\n      if (options && options.tableClassName) {\n        $table.addClass(options.tableClassName);\n      }\n\n      return $table[0];\n    };\n  };\n\n\n  var KEY_BOGUS = 'bogus';\n\n  /**\n   * @class Editor\n   */\n  var Editor = function (context) {\n    var self = this;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var editable = $editable[0];\n    var lastRange = null;\n\n    var style = new Style();\n    var table = new Table();\n    var typing = new Typing();\n    var bullet = new Bullet();\n    var history = new History($editable);\n\n    this.initialize = function () {\n      // bind custom events\n      $editable.on('keydown', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          context.triggerEvent('enter', event);\n        }\n        context.triggerEvent('keydown', event);\n\n        if (!event.isDefaultPrevented()) {\n          if (options.shortcuts) {\n            self.handleKeyMap(event);\n          } else {\n            self.preventDefaultEditableShortCuts(event);\n          }\n        }\n      }).on('keyup', function (event) {\n        context.triggerEvent('keyup', event);\n      }).on('focus', function (event) {\n        context.triggerEvent('focus', event);\n      }).on('blur', function (event) {\n        context.triggerEvent('blur', event);\n      }).on('mousedown', function (event) {\n        context.triggerEvent('mousedown', event);\n      }).on('mouseup', function (event) {\n        context.triggerEvent('mouseup', event);\n      }).on('scroll', function (event) {\n        context.triggerEvent('scroll', event);\n      }).on('paste', function (event) {\n        context.triggerEvent('paste', event);\n      });\n\n      // init content before set event\n      $editable.html(dom.html($note) || dom.emptyPara);\n\n      // [workaround] IE doesn't have input events for contentEditable\n      // - see: https://goo.gl/4bfIvA\n      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n      $editable.on(changeEventName, func.debounce(function () {\n        context.triggerEvent('change', $editable.html());\n      }, 250));\n\n      $editor.on('focusin', function (event) {\n        context.triggerEvent('focusin', event);\n      }).on('focusout', function (event) {\n        context.triggerEvent('focusout', event);\n      });\n\n      if (!options.airMode) {\n        if (options.width) {\n          $editor.outerWidth(options.width);\n        }\n        if (options.height) {\n          $editable.outerHeight(options.height);\n        }\n        if (options.maxHeight) {\n          $editable.css('max-height', options.maxHeight);\n        }\n        if (options.minHeight) {\n          $editable.css('min-height', options.minHeight);\n        }\n      }\n\n      history.recordUndo();\n    };\n\n    this.destroy = function () {\n      $editable.off();\n    };\n\n    this.handleKeyMap = function (event) {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      var keys = [];\n\n      if (event.metaKey) { keys.push('CMD'); }\n      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n      if (event.shiftKey) { keys.push('SHIFT'); }\n\n      var keyName = key.nameFromCode[event.keyCode];\n      if (keyName) {\n        keys.push(keyName);\n      }\n\n      var eventName = keyMap[keys.join('+')];\n      if (eventName) {\n        event.preventDefault();\n        context.invoke(eventName);\n      } else if (key.isEdit(event.keyCode)) {\n        this.afterCommand();\n      }\n    };\n\n    this.preventDefaultEditableShortCuts = function (event) {\n      // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)\n      if ((event.ctrlKey || event.metaKey) &&\n        list.contains([66, 73, 85], event.keyCode)) {\n        event.preventDefault();\n      }\n    };\n\n    /**\n     * create range\n     * @return {WrappedRange}\n     */\n    this.createRange = function () {\n      this.focus();\n      return range.create(editable);\n    };\n\n    /**\n     * saveRange\n     *\n     * save current range\n     *\n     * @param {Boolean} [thenCollapse=false]\n     */\n    this.saveRange = function (thenCollapse) {\n      lastRange = this.createRange();\n      if (thenCollapse) {\n        lastRange.collapse().select();\n      }\n    };\n\n    /**\n     * restoreRange\n     *\n     * restore lately range\n     */\n    this.restoreRange = function () {\n      if (lastRange) {\n        lastRange.select();\n        this.focus();\n      }\n    };\n\n    this.saveTarget = function (node) {\n      $editable.data('target', node);\n    };\n\n    this.clearTarget = function () {\n      $editable.removeData('target');\n    };\n\n    this.restoreTarget = function () {\n      return $editable.data('target');\n    };\n\n    /**\n     * currentStyle\n     *\n     * current style\n     * @return {Object|Boolean} unfocus\n     */\n    this.currentStyle = function () {\n      var rng = range.create();\n      if (rng) {\n        rng = rng.normalize();\n      }\n      return rng ? style.current(rng) : style.fromNode($editable);\n    };\n\n    /**\n     * style from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.styleFromNode = function ($node) {\n      return style.fromNode($node);\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.undo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.undo', lang.help.undo);\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.redo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.redo', lang.help.redo);\n\n    /**\n     * before command\n     */\n    var beforeCommand = this.beforeCommand = function () {\n      context.triggerEvent('before.command', $editable.html());\n      // keep focus on editable before command execution\n      self.focus();\n    };\n\n    /**\n     * after command\n     * @param {Boolean} isPreventTrigger\n     */\n    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n      history.recordUndo();\n      if (!isPreventTrigger) {\n        context.triggerEvent('change', $editable.html());\n      }\n    };\n\n    /* jshint ignore:start */\n    // native commands(with execCommand), generate function for execCommand\n    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n                    'formatBlock', 'removeFormat',\n                    'backColor', 'foreColor', 'fontName'];\n\n    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n      this[commands[idx]] = (function (sCmd) {\n        return function (value) {\n          beforeCommand();\n          document.execCommand(sCmd, false, value);\n          afterCommand(true);\n        };\n      })(commands[idx]);\n      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n    }\n    /* jshint ignore:end */\n\n    /**\n     * handle tab key\n     */\n    this.tab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng);\n      } else {\n        beforeCommand();\n        typing.insertTab(rng, options.tabSize);\n        afterCommand();\n      }\n    };\n    context.memo('help.tab', lang.help.tab);\n\n    /**\n     * handle shift+tab key\n     */\n    this.untab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng, true);\n      }\n    };\n    context.memo('help.untab', lang.help.untab);\n\n    /**\n     * run given function between beforeCommand and afterCommand\n     */\n    this.wrapCommand = function (fn) {\n      return function () {\n        beforeCommand();\n        fn.apply(self, arguments);\n        afterCommand();\n      };\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = this.wrapCommand(function () {\n      typing.insertParagraph(editable);\n    });\n    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\n    this.insertOrderedList = this.wrapCommand(function () {\n      bullet.insertOrderedList(editable);\n    });\n    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\n    this.insertUnorderedList = this.wrapCommand(function () {\n      bullet.insertUnorderedList(editable);\n    });\n    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\n    this.indent = this.wrapCommand(function () {\n      bullet.indent(editable);\n    });\n    context.memo('help.indent', lang.help.indent);\n\n    this.outdent = this.wrapCommand(function () {\n      bullet.outdent(editable);\n    });\n    context.memo('help.outdent', lang.help.outdent);\n\n    /**\n     * insert image\n     *\n     * @param {String} src\n     * @param {String|Function} param\n     * @return {Promise}\n     */\n    this.insertImage = function (src, param) {\n      return async.createImage(src, param).then(function ($image) {\n        beforeCommand();\n\n        if (typeof param === 'function') {\n          param($image);\n        } else {\n          if (typeof param === 'string') {\n            $image.attr('data-filename', param);\n          }\n          $image.css('width', Math.min($editable.width(), $image.width()));\n        }\n\n        $image.show();\n        range.create(editable).insertNode($image[0]);\n        range.createFromNodeAfter($image[0]).select();\n        afterCommand();\n      }).fail(function (e) {\n        context.triggerEvent('image.upload.error', e);\n      });\n    };\n\n    /**\n     * insertImages\n     * @param {File[]} files\n     */\n    this.insertImages = function (files) {\n      $.each(files, function (idx, file) {\n        var filename = file.name;\n        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n        } else {\n          async.readFileAsDataURL(file).then(function (dataURL) {\n            return self.insertImage(dataURL, filename);\n          }).fail(function () {\n            context.triggerEvent('image.upload.error');\n          });\n        }\n      });\n    };\n\n    /**\n     * insertImagesOrCallback\n     * @param {File[]} files\n     */\n    this.insertImagesOrCallback = function (files) {\n      var callbacks = options.callbacks;\n\n      // If onImageUpload options setted\n      if (callbacks.onImageUpload) {\n        context.triggerEvent('image.upload', files);\n      // else insert Image as dataURL\n      } else {\n        this.insertImages(files);\n      }\n    };\n\n    /**\n     * insertNode\n     * insert node\n     * @param {Node} node\n     */\n    this.insertNode = this.wrapCommand(function (node) {\n      var rng = this.createRange();\n      rng.insertNode(node);\n      range.createFromNodeAfter(node).select();\n    });\n\n    /**\n     * insert text\n     * @param {String} text\n     */\n    this.insertText = this.wrapCommand(function (text) {\n      var rng = this.createRange();\n      var textNode = rng.insertNode(dom.createText(text));\n      range.create(textNode, dom.nodeLength(textNode)).select();\n    });\n\n    /**\n     * return selected plain text\n     * @return {String} text\n     */\n    this.getSelectedText = function () {\n      var rng = this.createRange();\n\n      // if range on anchor, expand range with anchor\n      if (rng.isOnAnchor()) {\n        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n      }\n\n      return rng.toString();\n    };\n\n    /**\n     * paste HTML\n     * @param {String} markup\n     */\n    this.pasteHTML = this.wrapCommand(function (markup) {\n      var contents = this.createRange().pasteHTML(markup);\n      range.createFromNodeAfter(list.last(contents)).select();\n    });\n\n    /**\n     * formatBlock\n     *\n     * @param {String} tagName\n     */\n    this.formatBlock = this.wrapCommand(function (tagName) {\n      // [workaround] for MSIE, IE need `<`\n      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n      document.execCommand('FormatBlock', false, tagName);\n    });\n\n    this.formatPara = function () {\n      this.formatBlock('P');\n    };\n    context.memo('help.formatPara', lang.help.formatPara);\n\n    /* jshint ignore:start */\n    for (var idx = 1; idx <= 6; idx ++) {\n      this['formatH' + idx] = function (idx) {\n        return function () {\n          this.formatBlock('H' + idx);\n        };\n      }(idx);\n      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n    };\n    /* jshint ignore:end */\n\n    /**\n     * fontSize\n     *\n     * @param {String} value - px\n     */\n    this.fontSize = function (value) {\n      var rng = this.createRange();\n\n      if (rng && rng.isCollapsed()) {\n        var spans = style.styleNodes(rng);\n        var firstSpan = list.head(spans);\n\n        $(spans).css({\n          'font-size': value + 'px'\n        });\n\n        // [workaround] added styled bogus span for style\n        //  - also bogus character needed for cursor position\n        if (firstSpan && !dom.nodeLength(firstSpan)) {\n          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n          range.createFromNodeAfter(firstSpan.firstChild).select();\n          $editable.data(KEY_BOGUS, firstSpan);\n        }\n      } else {\n        beforeCommand();\n        $(style.styleNodes(rng)).css({\n          'font-size': value + 'px'\n        });\n        afterCommand();\n      }\n    };\n\n    /**\n     * insert horizontal rule\n     */\n    this.insertHorizontalRule = this.wrapCommand(function () {\n      var hrNode = this.createRange().insertNode(dom.create('HR'));\n      if (hrNode.nextSibling) {\n        range.create(hrNode.nextSibling, 0).normalize().select();\n      }\n    });\n    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\n    /**\n     * remove bogus node and character\n     */\n    this.removeBogus = function () {\n      var bogusNode = $editable.data(KEY_BOGUS);\n      if (!bogusNode) {\n        return;\n      }\n\n      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\n      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n      if (bogusCharIdx !== -1) {\n        textNode.deleteData(bogusCharIdx, 1);\n      }\n\n      if (dom.isEmpty(bogusNode)) {\n        dom.remove(bogusNode);\n      }\n\n      $editable.removeData(KEY_BOGUS);\n    };\n\n    /**\n     * lineHeight\n     * @param {String} value\n     */\n    this.lineHeight = this.wrapCommand(function (value) {\n      style.stylePara(this.createRange(), {\n        lineHeight: value\n      });\n    });\n\n    /**\n     * unlink\n     *\n     * @type command\n     */\n    this.unlink = function () {\n      var rng = this.createRange();\n      if (rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        rng = range.createFromNode(anchor);\n        rng.select();\n\n        beforeCommand();\n        document.execCommand('unlink');\n        afterCommand();\n      }\n    };\n\n    /**\n     * create link (command)\n     *\n     * @param {Object} linkInfo\n     */\n    this.createLink = this.wrapCommand(function (linkInfo) {\n      var linkUrl = linkInfo.url;\n      var linkText = linkInfo.text;\n      var isNewWindow = linkInfo.isNewWindow;\n      var rng = linkInfo.range || this.createRange();\n      var isTextChanged = rng.toString() !== linkText;\n\n      // handle spaced urls from input\n      if (typeof linkUrl === 'string') {\n        linkUrl = linkUrl.trim();\n      }\n\n      if (options.onCreateLink) {\n        linkUrl = options.onCreateLink(linkUrl);\n      }\n\n      var anchors = [];\n      if (isTextChanged) {\n        rng = rng.deleteContents();\n        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n        anchors.push(anchor);\n      } else {\n        anchors = style.styleNodes(rng, {\n          nodeName: 'A',\n          expandClosestSibling: true,\n          onlyPartialContains: true\n        });\n      }\n\n      $.each(anchors, function (idx, anchor) {\n        // if url doesn't match an URL schema, set http:// as default\n        linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?/.test(linkUrl) ?\n          linkUrl : 'http://' + linkUrl;\n\n        $(anchor).attr('href', linkUrl);\n        if (isNewWindow) {\n          $(anchor).attr('target', '_blank');\n        } else {\n          $(anchor).removeAttr('target');\n        }\n      });\n\n      var startRange = range.createFromNodeBefore(list.head(anchors));\n      var startPoint = startRange.getStartPoint();\n      var endRange = range.createFromNodeAfter(list.last(anchors));\n      var endPoint = endRange.getEndPoint();\n\n      range.create(\n        startPoint.node,\n        startPoint.offset,\n        endPoint.node,\n        endPoint.offset\n      ).select();\n    });\n\n    /**\n     * returns link info\n     *\n     * @return {Object}\n     * @return {WrappedRange} return.range\n     * @return {String} return.text\n     * @return {Boolean} [return.isNewWindow=true]\n     * @return {String} [return.url=\"\"]\n     */\n    this.getLinkInfo = function () {\n      var rng = this.createRange().expand(dom.isAnchor);\n\n      // Get the first anchor on range(for edit).\n      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n\n      return {\n        range: rng,\n        text: rng.toString(),\n        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,\n        url: $anchor.length ? $anchor.attr('href') : ''\n      };\n    };\n\n    /**\n     * setting color\n     *\n     * @param {Object} sObjColor  color code\n     * @param {String} sObjColor.foreColor foreground color\n     * @param {String} sObjColor.backColor background color\n     */\n    this.color = this.wrapCommand(function (colorInfo) {\n      var foreColor = colorInfo.foreColor;\n      var backColor = colorInfo.backColor;\n\n      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n      if (backColor) { document.execCommand('backColor', false, backColor); }\n    });\n\n    /**\n     * insert Table\n     *\n     * @param {String} dimension of table (ex : \"5x5\")\n     */\n    this.insertTable = this.wrapCommand(function (dim) {\n      var dimension = dim.split('x');\n\n      var rng = this.createRange().deleteContents();\n      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n    });\n\n    /**\n     * float me\n     *\n     * @param {String} value\n     */\n    this.floatMe = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css('float', value);\n    });\n\n    /**\n     * resize overlay element\n     * @param {String} value\n     */\n    this.resize = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css({\n        width: value * 100 + '%',\n        height: ''\n      });\n    });\n\n    /**\n     * @param {Position} pos\n     * @param {jQuery} $target - target element\n     * @param {Boolean} [bKeepRatio] - keep ratio\n     */\n    this.resizeTo = function (pos, $target, bKeepRatio) {\n      var imageSize;\n      if (bKeepRatio) {\n        var newRatio = pos.y / pos.x;\n        var ratio = $target.data('ratio');\n        imageSize = {\n          width: ratio > newRatio ? pos.x : pos.y / ratio,\n          height: ratio > newRatio ? pos.x * ratio : pos.y\n        };\n      } else {\n        imageSize = {\n          width: pos.x,\n          height: pos.y\n        };\n      }\n\n      $target.css(imageSize);\n    };\n\n    /**\n     * remove media object\n     */\n    this.removeMedia = this.wrapCommand(function () {\n      var $target = $(this.restoreTarget()).detach();\n      context.triggerEvent('media.delete', $target, $editable);\n    });\n\n    /**\n     * returns whether editable area has focus or not.\n     */\n    this.hasFocus = function () {\n      return $editable.is(':focus');\n    };\n\n    /**\n     * set focus\n     */\n    this.focus = function () {\n      // [workaround] Screen will move when page is scolled in IE.\n      //  - do focus when not focused\n      if (!this.hasFocus()) {\n        $editable.focus();\n      }\n    };\n\n    /**\n     * returns whether contents is empty or not.\n     * @return {Boolean}\n     */\n    this.isEmpty = function () {\n      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n    };\n\n    /**\n     * Removes all contents and restores the editable instance to an _emptyPara_.\n     */\n    this.empty = function () {\n      context.invoke('code', dom.emptyPara);\n    };\n  };\n\n  var Clipboard = function (context) {\n    var self = this;\n\n    var $editable = context.layoutInfo.editable;\n\n    this.events = {\n      'summernote.keydown': function (we, e) {\n        if (self.needKeydownHook()) {\n          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n            context.invoke('editor.saveRange');\n            self.$paste.focus();\n\n            setTimeout(function () {\n              self.pasteByHook();\n            }, 0);\n          }\n        }\n      }\n    };\n\n    this.needKeydownHook = function () {\n      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n    };\n\n    this.initialize = function () {\n      // [workaround] getting image from clipboard\n      //  - IE11 and Firefox: CTRL+v hook\n      //  - Webkit: event.clipboardData\n      if (this.needKeydownHook()) {\n        this.$paste = $('<div tabindex=\"-1\" />').attr('contenteditable', true).css({\n          position: 'absolute',\n          left: -100000,\n          opacity: 0\n        });\n        $editable.before(this.$paste);\n\n        this.$paste.on('paste', function (event) {\n          context.triggerEvent('paste', event);\n        });\n      } else {\n        $editable.on('paste', this.pasteByEvent);\n      }\n    };\n\n    this.destroy = function () {\n      if (this.needKeydownHook()) {\n        this.$paste.remove();\n        this.$paste = null;\n      }\n    };\n\n    this.pasteByHook = function () {\n      var node = this.$paste[0].firstChild;\n\n      if (dom.isImg(node)) {\n        var dataURI = node.src;\n        var decodedData = atob(dataURI.split(',')[1]);\n        var array = new Uint8Array(decodedData.length);\n        for (var i = 0; i < decodedData.length; i++) {\n          array[i] = decodedData.charCodeAt(i);\n        }\n\n        var blob = new Blob([array], { type: 'image/png' });\n        blob.name = 'clipboard.png';\n\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n        context.invoke('editor.insertImagesOrCallback', [blob]);\n      } else {\n        var pasteContent = $('<div />').html(this.$paste.html()).html();\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n\n        if (pasteContent) {\n          context.invoke('editor.pasteHTML', pasteContent);\n        }\n      }\n\n      this.$paste.empty();\n    };\n\n    /**\n     * paste by clipboard event\n     *\n     * @param {Event} event\n     */\n    this.pasteByEvent = function (event) {\n      var clipboardData = event.originalEvent.clipboardData;\n      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n        var item = list.head(clipboardData.items);\n        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n        }\n        context.invoke('editor.afterCommand');\n      }\n    };\n  };\n\n  var Dropzone = function (context) {\n    var $document = $(document);\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n    var documentEventHandlers = {};\n\n    var $dropzone = $([\n      '<div class=\"note-dropzone\">',\n      '  <div class=\"note-dropzone-message\"/>',\n      '</div>'\n    ].join('')).prependTo($editor);\n\n    var detachDocumentEvent = function () {\n      Object.keys(documentEventHandlers).forEach(function (key) {\n        $document.off(key.substr(2).toLowerCase(), documentEventHandlers[key]);\n      });\n      documentEventHandlers = {};\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.initialize = function () {\n      if (options.disableDragAndDrop) {\n        // prevent default drop event\n        documentEventHandlers.onDrop = function (e) {\n          e.preventDefault();\n        };\n        $document.on('drop', documentEventHandlers.onDrop);\n      } else {\n        this.attachDragAndDropEvent();\n      }\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.attachDragAndDropEvent = function () {\n      var collection = $(),\n          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\n      documentEventHandlers.onDragenter = function (e) {\n        var isCodeview = context.invoke('codeview.isActivated');\n        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n        if (!isCodeview && !collection.length && hasEditorSize) {\n          $editor.addClass('dragover');\n          $dropzone.width($editor.width());\n          $dropzone.height($editor.height());\n          $dropzoneMessage.text(lang.image.dragImageHere);\n        }\n        collection = collection.add(e.target);\n      };\n\n      documentEventHandlers.onDragleave = function (e) {\n        collection = collection.not(e.target);\n        if (!collection.length) {\n          $editor.removeClass('dragover');\n        }\n      };\n\n      documentEventHandlers.onDrop = function () {\n        collection = $();\n        $editor.removeClass('dragover');\n      };\n\n      // show dropzone on dragenter when dragging a object to document\n      // -but only if the editor is visible, i.e. has a positive width and height\n      $document.on('dragenter', documentEventHandlers.onDragenter)\n        .on('dragleave', documentEventHandlers.onDragleave)\n        .on('drop', documentEventHandlers.onDrop);\n\n      // change dropzone's message on hover.\n      $dropzone.on('dragenter', function () {\n        $dropzone.addClass('hover');\n        $dropzoneMessage.text(lang.image.dropImage);\n      }).on('dragleave', function () {\n        $dropzone.removeClass('hover');\n        $dropzoneMessage.text(lang.image.dragImageHere);\n      });\n\n      // attach dropImage\n      $dropzone.on('drop', function (event) {\n        var dataTransfer = event.originalEvent.dataTransfer;\n\n        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n          event.preventDefault();\n          $editable.focus();\n          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n        } else {\n          $.each(dataTransfer.types, function (idx, type) {\n            var content = dataTransfer.getData(type);\n\n            if (type.toLowerCase().indexOf('text') > -1) {\n              context.invoke('editor.pasteHTML', content);\n            } else {\n              $(content).each(function () {\n                context.invoke('editor.insertNode', this);\n              });\n            }\n          });\n        }\n      }).on('dragover', false); // prevent default dragover event\n    };\n\n    this.destroy = function () {\n      detachDocumentEvent();\n    };\n  };\n\n\n  var CodeMirror;\n  if (agent.hasCodeMirror) {\n    if (agent.isSupportAmd) {\n      require(['codemirror'], function (cm) {\n        CodeMirror = cm;\n      });\n    } else {\n      CodeMirror = window.CodeMirror;\n    }\n  }\n\n  /**\n   * @class Codeview\n   */\n  var Codeview = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n    var options = context.options;\n\n    this.sync = function () {\n      var isCodeview = this.isActivated();\n      if (isCodeview && agent.hasCodeMirror) {\n        $codable.data('cmEditor').save();\n      }\n    };\n\n    /**\n     * @return {Boolean}\n     */\n    this.isActivated = function () {\n      return $editor.hasClass('codeview');\n    };\n\n    /**\n     * toggle codeview\n     */\n    this.toggle = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n      context.triggerEvent('codeview.toggled');\n    };\n\n    /**\n     * activate code view\n     */\n    this.activate = function () {\n      $codable.val(dom.html($editable, options.prettifyHtml));\n      $codable.height($editable.height());\n\n      context.invoke('toolbar.updateCodeview', true);\n      $editor.addClass('codeview');\n      $codable.focus();\n\n      // activate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\n        // CodeMirror TernServer\n        if (options.codemirror.tern) {\n          var server = new CodeMirror.TernServer(options.codemirror.tern);\n          cmEditor.ternServer = server;\n          cmEditor.on('cursorActivity', function (cm) {\n            server.updateArgHints(cm);\n          });\n        }\n\n        // CodeMirror hasn't Padding.\n        cmEditor.setSize(null, $editable.outerHeight());\n        $codable.data('cmEditor', cmEditor);\n      }\n    };\n\n    /**\n     * deactivate code view\n     */\n    this.deactivate = function () {\n      // deactivate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = $codable.data('cmEditor');\n        $codable.val(cmEditor.getValue());\n        cmEditor.toTextArea();\n      }\n\n      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n      var isChange = $editable.html() !== value;\n\n      $editable.html(value);\n      $editable.height(options.height ? $codable.height() : 'auto');\n      $editor.removeClass('codeview');\n\n      if (isChange) {\n        context.triggerEvent('change', $editable.html(), $editable);\n      }\n\n      $editable.focus();\n\n      context.invoke('toolbar.updateCodeview', false);\n    };\n\n    this.destroy = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      }\n    };\n  };\n\n  var EDITABLE_PADDING = 24;\n\n  var Statusbar = function (context) {\n    var $document = $(document);\n    var $statusbar = context.layoutInfo.statusbar;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n\n    this.initialize = function () {\n      if (options.airMode || options.disableResizeEditor) {\n        return;\n      }\n\n      $statusbar.on('mousedown', function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        var editableTop = $editable.offset().top - $document.scrollTop();\n\n        $document.on('mousemove', function (event) {\n          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\n          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\n          $editable.height(height);\n        }).one('mouseup', function () {\n          $document.off('mousemove');\n        });\n      });\n    };\n\n    this.destroy = function () {\n      $statusbar.off();\n      $statusbar.remove();\n    };\n  };\n\n  var Fullscreen = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n\n    var $window = $(window);\n    var $scrollbar = $('html, body');\n\n    /**\n     * toggle fullscreen\n     */\n    this.toggle = function () {\n      var resize = function (size) {\n        $editable.css('height', size.h);\n        $codable.css('height', size.h);\n        if ($codable.data('cmeditor')) {\n          $codable.data('cmeditor').setsize(null, size.h);\n        }\n      };\n\n      $editor.toggleClass('fullscreen');\n      if (this.isFullscreen()) {\n        $editable.data('orgHeight', $editable.css('height'));\n\n        $window.on('resize', function () {\n          resize({\n            h: $window.height() - $toolbar.outerHeight()\n          });\n        }).trigger('resize');\n\n        $scrollbar.css('overflow', 'hidden');\n      } else {\n        $window.off('resize');\n        resize({\n          h: $editable.data('orgHeight')\n        });\n        $scrollbar.css('overflow', 'visible');\n      }\n\n      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n    };\n\n    this.isFullscreen = function () {\n      return $editor.hasClass('fullscreen');\n    };\n  };\n\n  var Handle = function (context) {\n    var self = this;\n\n    var $document = $(document);\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        if (self.update(e.target)) {\n          e.preventDefault();\n        }\n      },\n      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n        self.update();\n      }\n    };\n\n    this.initialize = function () {\n      this.$handle = $([\n        '<div class=\"note-handle\">',\n        '<div class=\"note-control-selection\">',\n        '<div class=\"note-control-selection-bg\"></div>',\n        '<div class=\"note-control-holder note-control-nw\"></div>',\n        '<div class=\"note-control-holder note-control-ne\"></div>',\n        '<div class=\"note-control-holder note-control-sw\"></div>',\n        '<div class=\"',\n        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n        ' note-control-se\"></div>',\n        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n        '</div>',\n        '</div>'\n      ].join('')).prependTo($editingArea);\n\n      this.$handle.on('mousedown', function (event) {\n        if (dom.isControlSizing(event.target)) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          var $target = self.$handle.find('.note-control-selection').data('target'),\n              posStart = $target.offset(),\n              scrollTop = $document.scrollTop();\n\n          $document.on('mousemove', function (event) {\n            context.invoke('editor.resizeTo', {\n              x: event.clientX - posStart.left,\n              y: event.clientY - (posStart.top - scrollTop)\n            }, $target, !event.shiftKey);\n\n            self.update($target[0]);\n          }).one('mouseup', function (e) {\n            e.preventDefault();\n            $document.off('mousemove');\n            context.invoke('editor.afterCommand');\n          });\n\n          if (!$target.data('ratio')) { // original ratio.\n            $target.data('ratio', $target.height() / $target.width());\n          }\n        }\n      });\n    };\n\n    this.destroy = function () {\n      this.$handle.remove();\n    };\n\n    this.update = function (target) {\n      var isImage = dom.isImg(target);\n      var $selection = this.$handle.find('.note-control-selection');\n\n      context.invoke('imagePopover.update', target);\n\n      if (isImage) {\n        var $image = $(target);\n        var pos = $image.position();\n\n        // include margin\n        var imageSize = {\n          w: $image.outerWidth(true),\n          h: $image.outerHeight(true)\n        };\n\n        $selection.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top,\n          width: imageSize.w,\n          height: imageSize.h\n        }).data('target', $image); // save current image element.\n\n        var sizingText = imageSize.w + 'x' + imageSize.h;\n        $selection.find('.note-control-selection-info').text(sizingText);\n        context.invoke('editor.saveTarget', target);\n      } else {\n        this.hide();\n      }\n\n      return isImage;\n    };\n\n    /**\n     * hide\n     *\n     * @param {jQuery} $handle\n     */\n    this.hide = function () {\n      context.invoke('editor.clearTarget');\n      this.$handle.children().hide();\n    };\n  };\n\n  var AutoLink = function (context) {\n    var self = this;\n    var defaultScheme = 'http://';\n    var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      }\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n    };\n\n    this.destroy = function () {\n      this.lastWordRange = null;\n    };\n\n    this.replace = function () {\n      if (!this.lastWordRange) {\n        return;\n      }\n\n      var keyword = this.lastWordRange.toString();\n      var match = keyword.match(linkPattern);\n\n      if (match && (match[1] || match[2])) {\n        var link = match[1] ? keyword : defaultScheme + keyword;\n        var node = $('<a />').html(keyword).attr('href', link)[0];\n\n        this.lastWordRange.insertNode(node);\n        this.lastWordRange = null;\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.handleKeydown = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        this.lastWordRange = wordRange;\n      }\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        this.replace();\n      }\n    };\n  };\n\n  /**\n   * textarea auto sync.\n   */\n  var AutoSync = function (context) {\n    var $note = context.layoutInfo.note;\n\n    this.events = {\n      'summernote.change': function () {\n        $note.val(context.invoke('code'));\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return dom.isTextarea($note[0]);\n    };\n  };\n\n  var Placeholder = function (context) {\n    var self = this;\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.init summernote.change': function () {\n        self.update();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !!options.placeholder;\n    };\n\n    this.initialize = function () {\n      this.$placeholder = $('<div class=\"note-placeholder\">');\n      this.$placeholder.on('click', function () {\n        context.invoke('focus');\n      }).text(options.placeholder).prependTo($editingArea);\n    };\n\n    this.destroy = function () {\n      this.$placeholder.remove();\n    };\n\n    this.update = function () {\n      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n      this.$placeholder.toggle(isShow);\n    };\n  };\n\n  var Buttons = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\n    var representShortcut = this.representShortcut = function (editorMethod) {\n      var shortcut = invertedKeyMap[editorMethod];\n      if (!options.shortcuts || !shortcut) {\n        return '';\n      }\n      \n      if (agent.isMac) {\n        shortcut = shortcut.replace('CMD', '⌘').replace('SHIFT', '⇧');\n      }\n\n      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n                         .replace('SLASH', '/')\n                         .replace('LEFTBRACKET', '[')\n                         .replace('RIGHTBRACKET', ']');\n\n      return ' (' + shortcut + ')';\n    };\n\n    this.initialize = function () {\n      this.addToolbarButtons();\n      this.addImagePopoverButtons();\n      this.addLinkPopoverButtons();\n      this.fontInstalledMap = {};\n    };\n\n    this.destroy = function () {\n      delete this.fontInstalledMap;\n    };\n\n    this.isFontInstalled = function (name) {\n      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n          list.contains(options.fontNamesIgnoreCheck, name);\n      }\n\n      return self.fontInstalledMap[name];\n    };\n\n    this.addToolbarButtons = function () {\n      context.memo('button.style', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.style.style,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'dropdown-style',\n            items: context.options.styleTags,\n            template: function (item) {\n\n              if (typeof item === 'string') {\n                item = { tag: item, title: (lang.style.hasOwnProperty(item) ? lang.style[item] : item) };\n              }\n\n              var tag = item.tag;\n              var title = item.title;\n              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n              var className = item.className ? ' class=\"' + item.className + '\"' : '';\n\n              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n            },\n            click: context.createInvokeHandler('editor.formatBlock')\n          })\n        ]).render();\n      });\n\n      context.memo('button.bold', function () {\n        return ui.button({\n          className: 'note-btn-bold',\n          contents: ui.icon(options.icons.bold),\n          tooltip: lang.font.bold + representShortcut('bold'),\n          click: context.createInvokeHandler('editor.bold')\n        }).render();\n      });\n\n      context.memo('button.italic', function () {\n        return ui.button({\n          className: 'note-btn-italic',\n          contents: ui.icon(options.icons.italic),\n          tooltip: lang.font.italic + representShortcut('italic'),\n          click: context.createInvokeHandler('editor.italic')\n        }).render();\n      });\n\n      context.memo('button.underline', function () {\n        return ui.button({\n          className: 'note-btn-underline',\n          contents: ui.icon(options.icons.underline),\n          tooltip: lang.font.underline + representShortcut('underline'),\n          click: context.createInvokeHandler('editor.underline')\n        }).render();\n      });\n\n      context.memo('button.clear', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.eraser),\n          tooltip: lang.font.clear + representShortcut('removeFormat'),\n          click: context.createInvokeHandler('editor.removeFormat')\n        }).render();\n      });\n\n      context.memo('button.strikethrough', function () {\n        return ui.button({\n          className: 'note-btn-strikethrough',\n          contents: ui.icon(options.icons.strikethrough),\n          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n          click: context.createInvokeHandler('editor.strikethrough')\n        }).render();\n      });\n\n      context.memo('button.superscript', function () {\n        return ui.button({\n          className: 'note-btn-superscript',\n          contents: ui.icon(options.icons.superscript),\n          tooltip: lang.font.superscript,\n          click: context.createInvokeHandler('editor.superscript')\n        }).render();\n      });\n\n      context.memo('button.subscript', function () {\n        return ui.button({\n          className: 'note-btn-subscript',\n          contents: ui.icon(options.icons.subscript),\n          tooltip: lang.font.subscript,\n          click: context.createInvokeHandler('editor.subscript')\n        }).render();\n      });\n\n      context.memo('button.fontname', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontname\"/> ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.name,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontname',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontNames.filter(self.isFontInstalled),\n            template: function (item) {\n              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n            },\n            click: context.createInvokeHandler('editor.fontName')\n          })\n        ]).render();\n      });\n\n      context.memo('button.fontsize', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontsize\"/>' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.size,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontsize',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontSizes,\n            click: context.createInvokeHandler('editor.fontSize')\n          })\n        ]).render();\n      });\n\n      context.memo('button.color', function () {\n        return ui.buttonGroup({\n          className: 'note-color',\n          children: [\n            ui.button({\n              className: 'note-current-color-button',\n              contents: ui.icon(options.icons.font + ' note-recent-color'),\n              tooltip: lang.color.recent,\n              click: function (e) {\n                var $button = $(e.currentTarget);\n                context.invoke('editor.color', {\n                  backColor: $button.attr('data-backColor'),\n                  foreColor: $button.attr('data-foreColor')\n                });\n              },\n              callback: function ($button) {\n                var $recentColor = $button.find('.note-recent-color');\n                $recentColor.css('background-color', '#FFFF00');\n                $button.attr('data-backColor', '#FFFF00');\n              }\n            }),\n            ui.button({\n              className: 'dropdown-toggle',\n              contents: ui.icon(options.icons.caret, 'span'),\n              tooltip: lang.color.more,\n              data: {\n                toggle: 'dropdown'\n              }\n            }),\n            ui.dropdown({\n              items: [\n                '<li>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"backColor\" data-value=\"inherit\">',\n                lang.color.transparent,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n                '</div>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n                lang.color.resetToDefault,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n                '</div>',\n                '</li>'\n              ].join(''),\n              callback: function ($dropdown) {\n                $dropdown.find('.note-holder').each(function () {\n                  var $holder = $(this);\n                  $holder.append(ui.palette({\n                    colors: options.colors,\n                    eventName: $holder.data('event')\n                  }).render());\n                });\n              },\n              click: function (event) {\n                var $button = $(event.target);\n                var eventName = $button.data('event');\n                var value = $button.data('value');\n\n                if (eventName && value) {\n                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n                  var $color = $button.closest('.note-color').find('.note-recent-color');\n                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\n                  $color.css(key, value);\n                  $currentButton.attr('data-' + eventName, value);\n                  context.invoke('editor.' + eventName, value);\n                }\n              }\n            })\n          ]\n        }).render();\n      });\n\n      context.memo('button.ul',  function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unorderedlist),\n          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n          click: context.createInvokeHandler('editor.insertUnorderedList')\n        }).render();\n      });\n\n      context.memo('button.ol', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.orderedlist),\n          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n          click:  context.createInvokeHandler('editor.insertOrderedList')\n        }).render();\n      });\n\n      var justifyLeft = ui.button({\n        contents: ui.icon(options.icons.alignLeft),\n        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n        click: context.createInvokeHandler('editor.justifyLeft')\n      });\n\n      var justifyCenter = ui.button({\n        contents: ui.icon(options.icons.alignCenter),\n        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n        click: context.createInvokeHandler('editor.justifyCenter')\n      });\n\n      var justifyRight = ui.button({\n        contents: ui.icon(options.icons.alignRight),\n        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n        click: context.createInvokeHandler('editor.justifyRight')\n      });\n\n      var justifyFull = ui.button({\n        contents: ui.icon(options.icons.alignJustify),\n        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n        click: context.createInvokeHandler('editor.justifyFull')\n      });\n\n      var outdent = ui.button({\n        contents: ui.icon(options.icons.outdent),\n        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n        click: context.createInvokeHandler('editor.outdent')\n      });\n\n      var indent = ui.button({\n        contents: ui.icon(options.icons.indent),\n        tooltip: lang.paragraph.indent + representShortcut('indent'),\n        click: context.createInvokeHandler('editor.indent')\n      });\n\n      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n      context.memo('button.outdent', func.invoke(outdent, 'render'));\n      context.memo('button.indent', func.invoke(indent, 'render'));\n\n      context.memo('button.paragraph', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.paragraph.paragraph,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown([\n            ui.buttonGroup({\n              className: 'note-align',\n              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n            }),\n            ui.buttonGroup({\n              className: 'note-list',\n              children: [outdent, indent]\n            })\n          ])\n        ]).render();\n      });\n\n      context.memo('button.height', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.height,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            items: options.lineHeights,\n            checkClassName: options.icons.menuCheck,\n            className: 'dropdown-line-height',\n            click: context.createInvokeHandler('editor.lineHeight')\n          })\n        ]).render();\n      });\n\n      context.memo('button.table', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.table.table,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'note-table',\n            items: [\n              '<div class=\"note-dimension-picker\">',\n              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n              '  <div class=\"note-dimension-picker-highlighted\"/>',\n              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n              '</div>',\n              '<div class=\"note-dimension-display\">1 x 1</div>'\n            ].join('')\n          })\n        ], {\n          callback: function ($node) {\n            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n            $catcher.css({\n              width: options.insertTableMaxSize.col + 'em',\n              height: options.insertTableMaxSize.row + 'em'\n            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n              .on('mousemove', self.tableMoveHandler);\n          }\n        }).render();\n      });\n\n      context.memo('button.link', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.link + representShortcut('linkDialog.show'),\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.picture', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.picture),\n          tooltip: lang.image.image,\n          click: context.createInvokeHandler('imageDialog.show')\n        }).render();\n      });\n\n      context.memo('button.video', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.video),\n          tooltip: lang.video.video,\n          click: context.createInvokeHandler('videoDialog.show')\n        }).render();\n      });\n\n      context.memo('button.hr', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.minus),\n          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n          click: context.createInvokeHandler('editor.insertHorizontalRule')\n        }).render();\n      });\n\n      context.memo('button.fullscreen', function () {\n        return ui.button({\n          className: 'btn-fullscreen',\n          contents: ui.icon(options.icons.arrowsAlt),\n          tooltip: lang.options.fullscreen,\n          click: context.createInvokeHandler('fullscreen.toggle')\n        }).render();\n      });\n\n      context.memo('button.codeview', function () {\n        return ui.button({\n          className: 'btn-codeview',\n          contents: ui.icon(options.icons.code),\n          tooltip: lang.options.codeview,\n          click: context.createInvokeHandler('codeview.toggle')\n        }).render();\n      });\n\n      context.memo('button.redo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.redo),\n          tooltip: lang.history.redo + representShortcut('redo'),\n          click: context.createInvokeHandler('editor.redo')\n        }).render();\n      });\n\n      context.memo('button.undo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.undo),\n          tooltip: lang.history.undo + representShortcut('undo'),\n          click: context.createInvokeHandler('editor.undo')\n        }).render();\n      });\n\n      context.memo('button.help', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.question),\n          tooltip: lang.options.help,\n          click: context.createInvokeHandler('helpDialog.show')\n        }).render();\n      });\n    };\n\n    /**\n     * image : [\n     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n     *   ['remove', ['removeMedia']]\n     * ],\n     */\n    this.addImagePopoverButtons = function () {\n      // Image Size Buttons\n      context.memo('button.imageSize100', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">100%</span>',\n          tooltip: lang.image.resizeFull,\n          click: context.createInvokeHandler('editor.resize', '1')\n        }).render();\n      });\n      context.memo('button.imageSize50', function () {\n        return  ui.button({\n          contents: '<span class=\"note-fontsize-10\">50%</span>',\n          tooltip: lang.image.resizeHalf,\n          click: context.createInvokeHandler('editor.resize', '0.5')\n        }).render();\n      });\n      context.memo('button.imageSize25', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">25%</span>',\n          tooltip: lang.image.resizeQuarter,\n          click: context.createInvokeHandler('editor.resize', '0.25')\n        }).render();\n      });\n\n      // Float Buttons\n      context.memo('button.floatLeft', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignLeft),\n          tooltip: lang.image.floatLeft,\n          click: context.createInvokeHandler('editor.floatMe', 'left')\n        }).render();\n      });\n\n      context.memo('button.floatRight', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignRight),\n          tooltip: lang.image.floatRight,\n          click: context.createInvokeHandler('editor.floatMe', 'right')\n        }).render();\n      });\n\n      context.memo('button.floatNone', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignJustify),\n          tooltip: lang.image.floatNone,\n          click: context.createInvokeHandler('editor.floatMe', 'none')\n        }).render();\n      });\n\n      // Remove Buttons\n      context.memo('button.removeMedia', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.image.remove,\n          click: context.createInvokeHandler('editor.removeMedia')\n        }).render();\n      });\n    };\n\n    this.addLinkPopoverButtons = function () {\n      context.memo('button.linkDialogShow', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.edit,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.unlink', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unlink),\n          tooltip: lang.link.unlink,\n          click: context.createInvokeHandler('editor.unlink')\n        }).render();\n      });\n    };\n\n    this.build = function ($container, groups) {\n      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n        var group = groups[groupIdx];\n        var groupName = group[0];\n        var buttons = group[1];\n\n        var $group = ui.buttonGroup({\n          className: 'note-' + groupName\n        }).render();\n\n        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n          var button = context.memo('button.' + buttons[idx]);\n          if (button) {\n            $group.append(typeof button === 'function' ? button(context) : button);\n          }\n        }\n        $group.appendTo($container);\n      }\n    };\n\n    this.updateCurrentStyle = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      this.updateBtnStates({\n        '.note-btn-bold': function () {\n          return styleInfo['font-bold'] === 'bold';\n        },\n        '.note-btn-italic': function () {\n          return styleInfo['font-italic'] === 'italic';\n        },\n        '.note-btn-underline': function () {\n          return styleInfo['font-underline'] === 'underline';\n        },\n        '.note-btn-subscript': function () {\n          return styleInfo['font-subscript'] === 'subscript';\n        },\n        '.note-btn-superscript': function () {\n          return styleInfo['font-superscript'] === 'superscript';\n        },\n        '.note-btn-strikethrough': function () {\n          return styleInfo['font-strikethrough'] === 'strikethrough';\n        }\n      });\n\n      if (styleInfo['font-family']) {\n        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n          return name.replace(/[\\'\\\"]/g, '')\n            .replace(/\\s+$/, '')\n            .replace(/^\\s+/, '');\n        });\n        var fontName = list.find(fontNames, self.isFontInstalled);\n\n        $toolbar.find('.dropdown-fontname li a').each(function () {\n          // always compare string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontName + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontname').text(fontName);\n      }\n\n      if (styleInfo['font-size']) {\n        var fontSize = styleInfo['font-size'];\n        $toolbar.find('.dropdown-fontsize li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontSize + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontsize').text(fontSize);\n      }\n\n      if (styleInfo['line-height']) {\n        var lineHeight = styleInfo['line-height'];\n        $toolbar.find('.dropdown-line-height li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n      }\n    };\n\n    this.updateBtnStates = function (infos) {\n      $.each(infos, function (selector, pred) {\n        ui.toggleBtnActive($toolbar.find(selector), pred());\n      });\n    };\n\n    this.tableMoveHandler = function (event) {\n      var PX_PER_EM = 18;\n      var $picker = $(event.target.parentNode); // target is mousecatcher\n      var $dimensionDisplay = $picker.next();\n      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\n      var posOffset;\n      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n      if (event.offsetX === undefined) {\n        var posCatcher = $(event.target).offset();\n        posOffset = {\n          x: event.pageX - posCatcher.left,\n          y: event.pageY - posCatcher.top\n        };\n      } else {\n        posOffset = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      }\n\n      var dim = {\n        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n      };\n\n      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n      $catcher.data('value', dim.c + 'x' + dim.r);\n\n      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n      }\n\n      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n      }\n\n      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n    };\n  };\n\n  var Toolbar = function (context) {\n    var ui = $.summernote.ui;\n\n    var $note = context.layoutInfo.note;\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !options.airMode;\n    };\n\n    this.initialize = function () {\n      options.toolbar = options.toolbar || [];\n\n      if (!options.toolbar.length) {\n        $toolbar.hide();\n      } else {\n        context.invoke('buttons.build', $toolbar, options.toolbar);\n      }\n\n      if (options.toolbarContainer) {\n        $toolbar.appendTo(options.toolbarContainer);\n      }\n\n      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n        context.invoke('buttons.updateCurrentStyle');\n      });\n\n      context.invoke('buttons.updateCurrentStyle');\n    };\n\n    this.destroy = function () {\n      $toolbar.children().remove();\n    };\n\n    this.updateFullscreen = function (isFullscreen) {\n      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n    };\n\n    this.updateCodeview = function (isCodeview) {\n      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n      if (isCodeview) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    };\n\n    this.activate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, true);\n    };\n\n    this.deactivate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, false);\n    };\n  };\n\n  var LinkDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group\">' +\n                   '<label>' + lang.link.textToDisplay + '</label>' +\n                   '<input class=\"note-link-text form-control\" type=\"text\" />' +\n                 '</div>' +\n                 '<div class=\"form-group\">' +\n                   '<label>' + lang.link.url + '</label>' +\n                   '<input class=\"note-link-url form-control\" type=\"text\" value=\"http://\" />' +\n                 '</div>' +\n                 (!options.disableLinkTarget ?\n                   '<div class=\"checkbox\">' +\n                     '<label>' + '<input type=\"checkbox\" checked> ' + lang.link.openInNewWindow + '</label>' +\n                   '</div>' : ''\n                 );\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        className: 'link-dialog',\n        title: lang.link.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    /**\n     * toggle update button\n     */\n    this.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {\n      ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n    };\n\n    /**\n     * Show link dialog and set event handlers on dialog controls.\n     *\n     * @param {Object} linkInfo\n     * @return {Promise}\n     */\n    this.showLinkDialog = function (linkInfo) {\n      return $.Deferred(function (deferred) {\n        var $linkText = self.$dialog.find('.note-link-text'),\n        $linkUrl = self.$dialog.find('.note-link-url'),\n        $linkBtn = self.$dialog.find('.note-link-btn'),\n        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // if no url was given, copy text to url\n          if (!linkInfo.url) {\n            linkInfo.url = linkInfo.text;\n          }\n\n          $linkText.val(linkInfo.text);\n\n          var handleLinkTextUpdate = function () {\n            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n            // if linktext was modified by keyup,\n            // stop cloning text from linkUrl\n            linkInfo.text = $linkText.val();\n          };\n\n          $linkText.on('input', handleLinkTextUpdate).on('paste', function () {\n            setTimeout(handleLinkTextUpdate, 0);\n          });\n\n          var handleLinkUrlUpdate = function () {\n            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n            // display same link on `Text to display` input\n            // when create a new link\n            if (!linkInfo.text) {\n              $linkText.val($linkUrl.val());\n            }\n          };\n\n          $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {\n            setTimeout(handleLinkUrlUpdate, 0);\n          }).val(linkInfo.url).trigger('focus');\n\n          self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n          self.bindEnterKey($linkUrl, $linkBtn);\n          self.bindEnterKey($linkText, $linkBtn);\n\n          $openInNewWindow.prop('checked', linkInfo.isNewWindow);\n\n          $linkBtn.one('click', function (event) {\n            event.preventDefault();\n\n            deferred.resolve({\n              range: linkInfo.range,\n              url: $linkUrl.val(),\n              text: $linkText.val(),\n              isNewWindow: $openInNewWindow.is(':checked')\n            });\n            self.$dialog.modal('hide');\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          // detach events\n          $linkText.off('input paste keypress');\n          $linkUrl.off('input paste keypress');\n          $linkBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function () {\n      var linkInfo = context.invoke('editor.getLinkInfo');\n\n      context.invoke('editor.saveRange');\n      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.createLink', linkInfo);\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n  };\n\n  var LinkPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.link);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-link-popover',\n        callback: function ($node) {\n          var $content = $node.find('.popover-content');\n          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n        }\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.link);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      // Prevent focusing on editable when invoke('code') is executed\n      if (!context.invoke('editor.hasFocus')) {\n        this.hide();\n        return;\n      }\n\n      var rng = context.invoke('editor.createRange');\n      if (rng.isCollapsed() && rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        var href = $(anchor).attr('href');\n        this.$popover.find('a').attr('href', href).html(href);\n\n        var pos = dom.posFromPlaceholder(anchor);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var ImageDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var imageLimitation = '';\n      if (options.maximumImageFileSize) {\n        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n                           ' ' + ' KMGTP'[unit] + 'B';\n        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n      }\n\n      var body = '<div class=\"form-group note-group-select-from-files\">' +\n                   '<label>' + lang.image.selectFromFiles + '</label>' +\n                   '<input class=\"note-image-input form-control\" type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n                   imageLimitation +\n                 '</div>' +\n                 '<div class=\"form-group note-group-image-url\" style=\"overflow:auto;\">' +\n                   '<label>' + lang.image.url + '</label>' +\n                   '<input class=\"note-image-url form-control col-md-12\" type=\"text\" />' +\n                 '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.image.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showImageDialog().then(function (data) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        if (typeof data === 'string') { // image url\n          context.invoke('editor.insertImage', data);\n        } else { // array of files\n          context.invoke('editor.insertImagesOrCallback', data);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showImageDialog = function () {\n      return $.Deferred(function (deferred) {\n        var $imageInput = self.$dialog.find('.note-image-input'),\n            $imageUrl = self.$dialog.find('.note-image-url'),\n            $imageBtn = self.$dialog.find('.note-image-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // Cloning imageInput to clear element.\n          $imageInput.replaceWith($imageInput.clone()\n            .on('change', function () {\n              deferred.resolve(this.files || this.value);\n            })\n            .val('')\n          );\n\n          $imageBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($imageUrl.val());\n          });\n\n          $imageUrl.on('keyup paste', function () {\n            var url = $imageUrl.val();\n            ui.toggleBtn($imageBtn, url);\n          }).val('').trigger('focus');\n          self.bindEnterKey($imageUrl, $imageBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $imageInput.off('change');\n          $imageUrl.off('keyup paste keypress');\n          $imageBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var ImagePopover = function (context) {\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.image);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-image-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.image);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (dom.isImg(target)) {\n        var pos = dom.posFromPlaceholder(target);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var VideoDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group row-fluid\">' +\n          '<label>' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n          '<input class=\"note-video-url form-control span12\" type=\"text\" />' +\n          '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.video.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.createVideoNode = function (url) {\n      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n      var ytMatch = url.match(ytRegExp);\n\n      var igRegExp = /(?:www\\.|\\/\\/)instagram\\.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n      var igMatch = url.match(igRegExp);\n\n      var vRegExp = /\\/\\/vine\\.co\\/v\\/([a-zA-Z0-9]+)/;\n      var vMatch = url.match(vRegExp);\n\n      var vimRegExp = /\\/\\/(player\\.)?vimeo\\.com\\/([a-z]*\\/)*([0-9]{6,11})[?]?.*/;\n      var vimMatch = url.match(vimRegExp);\n\n      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n      var dmMatch = url.match(dmRegExp);\n\n      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n      var youkuMatch = url.match(youkuRegExp);\n\n      var mp4RegExp = /^.+.(mp4|m4v)$/;\n      var mp4Match = url.match(mp4RegExp);\n\n      var oggRegExp = /^.+.(ogg|ogv)$/;\n      var oggMatch = url.match(oggRegExp);\n\n      var webmRegExp = /^.+.(webm)$/;\n      var webmMatch = url.match(webmRegExp);\n\n      var $video;\n      if (ytMatch && ytMatch[1].length === 11) {\n        var youtubeId = ytMatch[1];\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n            .attr('width', '640').attr('height', '360');\n      } else if (igMatch && igMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/')\n            .attr('width', '612').attr('height', '710')\n            .attr('scrolling', 'no')\n            .attr('allowtransparency', 'true');\n      } else if (vMatch && vMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', vMatch[0] + '/embed/simple')\n            .attr('width', '600').attr('height', '600')\n            .attr('class', 'vine-embed');\n      } else if (vimMatch && vimMatch[3].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n            .attr('width', '640').attr('height', '360');\n      } else if (dmMatch && dmMatch[2].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n            .attr('width', '640').attr('height', '360');\n      } else if (youkuMatch && youkuMatch[1].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '498')\n            .attr('width', '510')\n            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n      } else if (mp4Match || oggMatch || webmMatch) {\n        $video = $('<video controls>')\n            .attr('src', url)\n            .attr('width', '640').attr('height', '360');\n      } else {\n        // this is not a known video link. Now what, Cat? Now what?\n        return false;\n      }\n\n      $video.addClass('note-video-clip');\n\n      return $video[0];\n    };\n\n    this.show = function () {\n      var text = context.invoke('editor.getSelectedText');\n      context.invoke('editor.saveRange');\n      this.showVideoDialog(text).then(function (url) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        // build node\n        var $node = self.createVideoNode(url);\n\n        if ($node) {\n          // insert video node\n          context.invoke('editor.insertNode', $node);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showVideoDialog = function (text) {\n      return $.Deferred(function (deferred) {\n        var $videoUrl = self.$dialog.find('.note-video-url'),\n            $videoBtn = self.$dialog.find('.note-video-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $videoUrl.val(text).on('input', function () {\n            ui.toggleBtn($videoBtn, $videoUrl.val());\n          }).trigger('focus');\n\n          $videoBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($videoUrl.val());\n          });\n\n          self.bindEnterKey($videoUrl, $videoBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $videoUrl.off('input');\n          $videoBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var HelpDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.createShortCutList = function () {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      return Object.keys(keyMap).map(function (key) {\n        var command = keyMap[key];\n        var $row = $('<div><div class=\"help-list-item\"/></div>');\n        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n          'width': 180,\n          'margin-right': 10\n        })).append($('<span/>').html(context.memo('help.' + command) || command));\n        return $row.html();\n      }).join('');\n    };\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = [\n        '<p class=\"text-center\">',\n        '<a href=\"http://summernote.org/\" target=\"_blank\">Summernote 0.8.2</a> · ',\n        '<a href=\"https://github.com/summernote/summernote\" target=\"_blank\">Project</a> · ',\n        '<a href=\"https://github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n        '</p>'\n      ].join('');\n\n      this.$dialog = ui.dialog({\n        title: lang.options.help,\n        fade: options.dialogsFade,\n        body: this.createShortCutList(),\n        footer: body,\n        callback: function ($node) {\n          $node.find('.modal-body').css({\n            'max-height': 300,\n            'overflow': 'scroll'\n          });\n        }\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    /**\n     * show help dialog\n     *\n     * @return {Promise}\n     */\n    this.showHelpDialog = function () {\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n          deferred.resolve();\n        });\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showHelpDialog().then(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n  };\n\n  var AirPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.change summernote.dialog.shown': function () {\n        self.hide();\n      },\n      'summernote.focusout': function (we, e) {\n        // [workaround] Firefox doesn't support relatedTarget on focusout\n        //  - Ignore hide action on focus out in FF.\n        if (agent.isFF) {\n          return;\n        }\n\n        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n          self.hide();\n        }\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return options.airMode && !list.isEmpty(options.popover.air);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-air-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.air);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n        var rect = list.last(styleInfo.range.getClientRects());\n        if (rect) {\n          var bnd = func.rect2bnd(rect);\n          this.$popover.css({\n            display: 'block',\n            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n            top: bnd.top + bnd.height\n          });\n        }\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var HintPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var POPOVER_DIST = 5;\n    var hint = context.options.hint || [];\n    var direction = context.options.hintDirection || 'bottom';\n    var hints = $.isArray(hint) ? hint : [hint];\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return hints.length > 0;\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n      this.$popover = ui.popover({\n        className: 'note-hint-popover',\n        hideArrow: true,\n        direction: ''\n      }).render().appendTo('body');\n\n      this.$popover.hide();\n\n      this.$content = this.$popover.find('.popover-content');\n\n      this.$content.on('click', '.note-hint-item', function () {\n        self.$content.find('.active').removeClass('active');\n        $(this).addClass('active');\n        self.replace();\n      });\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.selectItem = function ($item) {\n      this.$content.find('.active').removeClass('active');\n      $item.addClass('active');\n\n      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n    };\n\n    this.moveDown = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $next = $current.next();\n\n      if ($next.length) {\n        this.selectItem($next);\n      } else {\n        var $nextGroup = $current.parent().next();\n\n        if (!$nextGroup.length) {\n          $nextGroup = this.$content.find('.note-hint-group').first();\n        }\n\n        this.selectItem($nextGroup.find('.note-hint-item').first());\n      }\n    };\n\n    this.moveUp = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $prev = $current.prev();\n\n      if ($prev.length) {\n        this.selectItem($prev);\n      } else {\n        var $prevGroup = $current.parent().prev();\n\n        if (!$prevGroup.length) {\n          $prevGroup = this.$content.find('.note-hint-group').last();\n        }\n\n        this.selectItem($prevGroup.find('.note-hint-item').last());\n      }\n    };\n\n    this.replace = function () {\n      var $item = this.$content.find('.note-hint-item.active');\n\n      if ($item.length) {\n        var node = this.nodeFromItem($item);\n        this.lastWordRange.insertNode(node);\n        range.createFromNode(node).collapse().select();\n\n        this.lastWordRange = null;\n        this.hide();\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.nodeFromItem = function ($item) {\n      var hint = hints[$item.data('index')];\n      var item = $item.data('item');\n      var node = hint.content ? hint.content(item) : item;\n      if (typeof node === 'string') {\n        node = dom.createText(node);\n      }\n      return node;\n    };\n\n    this.createItemTemplates = function (hintIdx, items) {\n      var hint = hints[hintIdx];\n      return items.map(function (item, idx) {\n        var $item = $('<div class=\"note-hint-item\"/>');\n        $item.append(hint.template ? hint.template(item) : item + '');\n        $item.data({\n          'index': hintIdx,\n          'item': item\n        });\n\n        if (hintIdx === 0 && idx === 0) {\n          $item.addClass('active');\n        }\n        return $item;\n      });\n    };\n\n    this.handleKeydown = function (e) {\n      if (!this.$popover.is(':visible')) {\n        return;\n      }\n\n      if (e.keyCode === key.code.ENTER) {\n        e.preventDefault();\n        this.replace();\n      } else if (e.keyCode === key.code.UP) {\n        e.preventDefault();\n        this.moveUp();\n      } else if (e.keyCode === key.code.DOWN) {\n        e.preventDefault();\n        this.moveDown();\n      }\n    };\n\n    this.searchKeyword = function (index, keyword, callback) {\n      var hint = hints[index];\n      if (hint && hint.match.test(keyword) && hint.search) {\n        var matches = hint.match.exec(keyword);\n        hint.search(matches[1], callback);\n      } else {\n        callback();\n      }\n    };\n\n    this.createGroup = function (idx, keyword) {\n      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n      this.searchKeyword(idx, keyword, function (items) {\n        items = items || [];\n        if (items.length) {\n          $group.html(self.createItemTemplates(idx, items));\n          self.show();\n        }\n      });\n\n      return $group;\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n        if (e.keyCode === key.code.ENTER) {\n          if (this.$popover.is(':visible')) {\n            return;\n          }\n        }\n      } else {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        var keyword = wordRange.toString();\n        if (hints.length && keyword) {\n          this.$content.empty();\n\n          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n          if (bnd) {\n\n            this.$popover.hide();\n\n            this.lastWordRange = wordRange;\n\n            hints.forEach(function (hint, idx) {\n              if (hint.match.test(keyword)) {\n                self.createGroup(idx, keyword).appendTo(self.$content);\n              }\n            });\n\n            // set position for popover after group is created\n            if (direction === 'top') {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n              });\n            } else {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top + bnd.height + POPOVER_DIST\n              });\n            }\n\n          }\n        } else {\n          this.hide();\n        }\n      }\n    };\n\n    this.show = function () {\n      this.$popover.show();\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n\n  $.summernote = $.extend($.summernote, {\n    version: '0.8.2',\n    ui: ui,\n    dom: dom,\n\n    plugins: {},\n\n    options: {\n      modules: {\n        'editor': Editor,\n        'clipboard': Clipboard,\n        'dropzone': Dropzone,\n        'codeview': Codeview,\n        'statusbar': Statusbar,\n        'fullscreen': Fullscreen,\n        'handle': Handle,\n        // FIXME: HintPopover must be front of autolink\n        //  - Script error about range when Enter key is pressed on hint popover\n        'hintPopover': HintPopover,\n        'autoLink': AutoLink,\n        'autoSync': AutoSync,\n        'placeholder': Placeholder,\n        'buttons': Buttons,\n        'toolbar': Toolbar,\n        'linkDialog': LinkDialog,\n        'linkPopover': LinkPopover,\n        'imageDialog': ImageDialog,\n        'imagePopover': ImagePopover,\n        'videoDialog': VideoDialog,\n        'helpDialog': HelpDialog,\n        'airPopover': AirPopover\n      },\n\n      buttons: {},\n      \n      lang: 'en-US',\n\n      // toolbar\n      toolbar: [\n        ['style', ['style']],\n        ['font', ['bold', 'underline', 'clear']],\n        ['fontname', ['fontname']],\n        ['color', ['color']],\n        ['para', ['ul', 'ol', 'paragraph']],\n        ['table', ['table']],\n        ['insert', ['link', 'picture', 'video']],\n        ['view', ['fullscreen', 'codeview', 'help']]\n      ],\n\n      // popover\n      popover: {\n        image: [\n          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n          ['remove', ['removeMedia']]\n        ],\n        link: [\n          ['link', ['linkDialogShow', 'unlink']]\n        ],\n        air: [\n          ['color', ['color']],\n          ['font', ['bold', 'underline', 'clear']],\n          ['para', ['ul', 'paragraph']],\n          ['table', ['table']],\n          ['insert', ['link', 'picture']]\n        ]\n      },\n\n      // air mode: inline editor\n      airMode: false,\n\n      width: null,\n      height: null,\n\n      focus: false,\n      tabSize: 4,\n      styleWithSpan: true,\n      shortcuts: true,\n      textareaAutoSync: true,\n      direction: null,\n\n      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n      fontNames: [\n        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n        'Tahoma', 'Times New Roman', 'Verdana'\n      ],\n\n      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\n      // pallete colors(n x n)\n      colors: [\n        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n      ],\n\n      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\n      tableClassName: 'table table-bordered',\n\n      insertTableMaxSize: {\n        col: 10,\n        row: 10\n      },\n\n      dialogsInBody: false,\n      dialogsFade: false,\n\n      maximumImageFileSize: null,\n\n      callbacks: {\n        onInit: null,\n        onFocus: null,\n        onBlur: null,\n        onEnter: null,\n        onKeyup: null,\n        onKeydown: null,\n        onImageUpload: null,\n        onImageUploadError: null\n      },\n\n      codemirror: {\n        mode: 'text/html',\n        htmlMode: true,\n        lineNumbers: true\n      },\n\n      keyMap: {\n        pc: {\n          'ENTER': 'insertParagraph',\n          'CTRL+Z': 'undo',\n          'CTRL+Y': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CTRL+B': 'bold',\n          'CTRL+I': 'italic',\n          'CTRL+U': 'underline',\n          'CTRL+SHIFT+S': 'strikethrough',\n          'CTRL+BACKSLASH': 'removeFormat',\n          'CTRL+SHIFT+L': 'justifyLeft',\n          'CTRL+SHIFT+E': 'justifyCenter',\n          'CTRL+SHIFT+R': 'justifyRight',\n          'CTRL+SHIFT+J': 'justifyFull',\n          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n          'CTRL+LEFTBRACKET': 'outdent',\n          'CTRL+RIGHTBRACKET': 'indent',\n          'CTRL+NUM0': 'formatPara',\n          'CTRL+NUM1': 'formatH1',\n          'CTRL+NUM2': 'formatH2',\n          'CTRL+NUM3': 'formatH3',\n          'CTRL+NUM4': 'formatH4',\n          'CTRL+NUM5': 'formatH5',\n          'CTRL+NUM6': 'formatH6',\n          'CTRL+ENTER': 'insertHorizontalRule',\n          'CTRL+K': 'linkDialog.show'\n        },\n\n        mac: {\n          'ENTER': 'insertParagraph',\n          'CMD+Z': 'undo',\n          'CMD+SHIFT+Z': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CMD+B': 'bold',\n          'CMD+I': 'italic',\n          'CMD+U': 'underline',\n          'CMD+SHIFT+S': 'strikethrough',\n          'CMD+BACKSLASH': 'removeFormat',\n          'CMD+SHIFT+L': 'justifyLeft',\n          'CMD+SHIFT+E': 'justifyCenter',\n          'CMD+SHIFT+R': 'justifyRight',\n          'CMD+SHIFT+J': 'justifyFull',\n          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n          'CMD+SHIFT+NUM8': 'insertOrderedList',\n          'CMD+LEFTBRACKET': 'outdent',\n          'CMD+RIGHTBRACKET': 'indent',\n          'CMD+NUM0': 'formatPara',\n          'CMD+NUM1': 'formatH1',\n          'CMD+NUM2': 'formatH2',\n          'CMD+NUM3': 'formatH3',\n          'CMD+NUM4': 'formatH4',\n          'CMD+NUM5': 'formatH5',\n          'CMD+NUM6': 'formatH6',\n          'CMD+ENTER': 'insertHorizontalRule',\n          'CMD+K': 'linkDialog.show'\n        }\n      },\n      icons: {\n        'align': 'note-icon-align',\n        'alignCenter': 'note-icon-align-center',\n        'alignJustify': 'note-icon-align-justify',\n        'alignLeft': 'note-icon-align-left',\n        'alignRight': 'note-icon-align-right',\n        'indent': 'note-icon-align-indent',\n        'outdent': 'note-icon-align-outdent',\n        'arrowsAlt': 'note-icon-arrows-alt',\n        'bold': 'note-icon-bold',\n        'caret': 'note-icon-caret',\n        'circle': 'note-icon-circle',\n        'close': 'note-icon-close',\n        'code': 'note-icon-code',\n        'eraser': 'note-icon-eraser',\n        'font': 'note-icon-font',\n        'frame': 'note-icon-frame',\n        'italic': 'note-icon-italic',\n        'link': 'note-icon-link',\n        'unlink': 'note-icon-chain-broken',\n        'magic': 'note-icon-magic',\n        'menuCheck': 'note-icon-check',\n        'minus': 'note-icon-minus',\n        'orderedlist': 'note-icon-orderedlist',\n        'pencil': 'note-icon-pencil',\n        'picture': 'note-icon-picture',\n        'question': 'note-icon-question',\n        'redo': 'note-icon-redo',\n        'square': 'note-icon-square',\n        'strikethrough': 'note-icon-strikethrough',\n        'subscript': 'note-icon-subscript',\n        'superscript': 'note-icon-superscript',\n        'table': 'note-icon-table',\n        'textHeight': 'note-icon-text-height',\n        'trash': 'note-icon-trash',\n        'underline': 'note-icon-underline',\n        'undo': 'note-icon-undo',\n        'unorderedlist': 'note-icon-unorderedlist',\n        'video': 'note-icon-video'\n      }\n    }\n  });\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /projects/rede_gsti/resources/~/summernote/dist/summernote.js\n ** module id = 78\n ** module chunks = 2\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 79\n ** module chunks = 2\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    module.exports = mod();\n  else if (typeof define == \"function\" && define.amd) // AMD\n    return define([], mod);\n  else // Plain browser env\n    (this || window).CodeMirror = mod();\n})(function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n  var webkit = /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) presto_version = Number(presto_version[1]);\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // EDITOR CONSTRUCTOR\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    if (options.autofocus && !mobile) display.input.focus();\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    var cm = this;\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || cm.hasFocus())\n      setTimeout(bind(onFocus, this), 20);\n    else\n      onBlur(this);\n\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n      optionHandlers[opt](this, options[opt], Init);\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) options.finishInit(this);\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      display.lineDiv.style.textRendering = \"auto\";\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\n    if (place) {\n      if (place.appendChild) place.appendChild(d.wrapper);\n      else place(d.wrapper);\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    input.init(d);\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line)) return 0;\n\n      var widgetsHeight = 0;\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n      }\n\n      if (wrapping)\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return widgetsHeight + th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find(0, true);\n      len -= cur.text.length - found.from.ch;\n      cur = found.to.line;\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    };\n  }\n\n  function NativeScrollbars(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function() {\n      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n    });\n    on(horiz, \"scroll\", function() {\n      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n  }\n\n  NativeScrollbars.prototype = copyObj({\n    update: function(measure) {\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n      var sWidth = measure.nativeBarWidth;\n\n      if (needsV) {\n        this.vert.style.display = \"block\";\n        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n        // A bug in IE8 can cause this value to be negative, so guard it.\n        this.vert.firstChild.style.height =\n          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n      } else {\n        this.vert.style.display = \"\";\n        this.vert.firstChild.style.height = \"0\";\n      }\n\n      if (needsH) {\n        this.horiz.style.display = \"block\";\n        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n        this.horiz.style.left = measure.barLeft + \"px\";\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n        this.horiz.firstChild.style.width =\n          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n      } else {\n        this.horiz.style.display = \"\";\n        this.horiz.firstChild.style.width = \"0\";\n      }\n\n      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n        if (sWidth == 0) this.zeroWidthHack();\n        this.checkedZeroWidth = true;\n      }\n\n      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n    },\n    setScrollLeft: function(pos) {\n      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n    },\n    setScrollTop: function(pos) {\n      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n    },\n    zeroWidthHack: function() {\n      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n      this.horiz.style.height = this.vert.style.width = w;\n      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n      this.disableHoriz = new Delayed;\n      this.disableVert = new Delayed;\n    },\n    enableZeroWidthBar: function(bar, delay) {\n      bar.style.pointerEvents = \"auto\";\n      function maybeDisable() {\n        // To find out whether the scrollbar is still visible, we\n        // check whether the element under the pixel in the bottom\n        // left corner of the scrollbar box is the scrollbar box\n        // itself (when the bar is still visible) or its filler child\n        // (when the bar is hidden). If it is still visible, we keep\n        // it enabled, if it's hidden, we disable pointer events.\n        var box = bar.getBoundingClientRect();\n        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n        if (elt != bar) bar.style.pointerEvents = \"none\";\n        else delay.set(1000, maybeDisable);\n      }\n      delay.set(1000, maybeDisable);\n    },\n    clear: function() {\n      var parent = this.horiz.parentNode;\n      parent.removeChild(this.horiz);\n      parent.removeChild(this.vert);\n    }\n  }, NativeScrollbars.prototype);\n\n  function NullScrollbars() {}\n\n  NullScrollbars.prototype = copyObj({\n    update: function() { return {bottom: 0, right: 0}; },\n    setScrollLeft: function() {},\n    setScrollTop: function() {},\n    clear: function() {}\n  }, NullScrollbars.prototype);\n\n  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n    }\n\n    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function() {\n        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function(pos, axis) {\n      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n      else setScrollTop(cm, pos);\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n  }\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) measure = measureForScrollbars(cm);\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        updateHeightsInViewport(cm);\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\"\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)};\n  }\n\n  // LINE NUMBERS\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n      if (cm.options.fixedGutter && view[i].gutter)\n        view[i].gutter.style.left = left;\n      var align = view[i].alignable;\n      if (align) for (var j = 0; j < align.length; j++)\n        align[j].style.left = left;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  }\n\n  // DISPLAY DRAWING\n\n  function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  }\n\n  DisplayUpdate.prototype.signal = function(emitter, type) {\n    if (hasHandler(emitter, type))\n      this.events.push(arguments);\n  };\n  DisplayUpdate.prototype.finish = function() {\n    for (var i = 0; i < this.events.length; i++)\n      signal.apply(null, this.events[i]);\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      return false;\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      return false;\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var focused = activeElt();\n    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          break;\n      }\n      if (!updateDisplayIfNeeded(cm, update)) break;\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], height;\n      if (cur.hidden) continue;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n      }\n      var diff = cur.line.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n          updateWidgetHeight(cur.rest[j]);\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        node.style.display = \"none\";\n      else\n        node.parentNode.removeChild(node);\n      return next;\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) {\n      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) cur = rm(cur);\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) cur = rm(cur);\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") updateLineText(cm, lineView);\n      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n      else if (type == \"class\") updateLineClasses(lineView);\n      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n    }\n    return lineView.node;\n  }\n\n  function updateLineBackground(lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) cls += \" CodeMirror-linebackground\";\n    if (lineView.background) {\n      if (cls) lineView.background.className = cls;\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n    return buildLineContent(cm, lineView);\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) lineView.node = built.pre;\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(lineView) {\n    updateLineBackground(lineView);\n    if (lineView.line.wrapClass)\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    else if (lineView.node != lineView.text)\n      lineView.node.className = \"\";\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + cm.display.lineNumInnerWidth + \"px\"));\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n      }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) lineView.alignable = null;\n    for (var node = lineView.node.firstChild, next; node; node = next) {\n      var next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        lineView.node.removeChild(node);\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) lineView.bgClass = built.bgClass;\n    if (built.textClass) lineView.textClass = built.textClass;\n\n    updateLineClasses(lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node;\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) return;\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // POSITION OBJECT\n\n  // A Pos instance represents a position within the text.\n  var Pos = CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\n  function copyPos(x) {return Pos(x.line, x.ch);}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\n  // INPUT HANDLING\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) sel = doc.sel;\n\n    var paste = cm.state.pasteIncoming || origin == \"paste\";\n    var textLines = doc.splitLines(inserted), multiPaste = null\n    // When pasing N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            multiPaste.push(doc.splitLines(lastCopied.text[i]));\n        }\n      } else if (textLines.length == sel.ranges.length) {\n        multiPaste = map(textLines, function(l) { return [l]; });\n      }\n    }\n\n    // Normal behavior is to insert the new text into every selection\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          from = Pos(from.line, from.ch - deleted);\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n          from = to = Pos(from.line, 0)\n      }\n      var updateInput = cm.curOp.updateInput;\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      triggerElectric(cm, inserted);\n\n    ensureCursorVisible(cm);\n    cm.curOp.updateInput = updateInput;\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"text/plain\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n      return true;\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break;\n          }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          indented = indentLine(cm, range.head.line, \"smart\");\n      }\n      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges};\n  }\n\n  function disableBrowserMagic(field) {\n    field.setAttribute(\"autocorrect\", \"off\");\n    field.setAttribute(\"autocapitalize\", \"off\");\n    field.setAttribute(\"spellcheck\", \"false\");\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  function TextareaInput(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Tracks when input.reset has punted to just putting a short\n    // string into the textarea instead of the full selection.\n    this.inaccurateSelection = false;\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) te.style.width = \"1000px\";\n    else te.setAttribute(\"wrap\", \"off\");\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) te.style.border = \"1px solid black\";\n    disableBrowserMagic(te);\n    return div;\n  }\n\n  TextareaInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = this.cm;\n\n      // Wraps and hides input textarea\n      var div = this.wrapper = hiddenTextarea();\n      // The semihidden textarea that is focused when the editor is\n      // focused, and receives input.\n      var te = this.textarea = div.firstChild;\n      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n      if (ios) te.style.width = \"0px\";\n\n      on(te, \"input\", function() {\n        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n        input.poll();\n      });\n\n      on(te, \"paste\", function(e) {\n        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n\n        cm.state.pasteIncoming = true;\n        input.fastPoll();\n      });\n\n      function prepareCopyCut(e) {\n        if (signalDOMEvent(cm, e)) return\n        if (cm.somethingSelected()) {\n          lastCopied = {lineWise: false, text: cm.getSelections()};\n          if (input.inaccurateSelection) {\n            input.prevInput = \"\";\n            input.inaccurateSelection = false;\n            te.value = lastCopied.text.join(\"\\n\");\n            selectInput(te);\n          }\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = {lineWise: true, text: ranges.text};\n          if (e.type == \"cut\") {\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n          } else {\n            input.prevInput = \"\";\n            te.value = ranges.text.join(\"\\n\");\n            selectInput(te);\n          }\n        }\n        if (e.type == \"cut\") cm.state.cutIncoming = true;\n      }\n      on(te, \"cut\", prepareCopyCut);\n      on(te, \"copy\", prepareCopyCut);\n\n      on(display.scroller, \"paste\", function(e) {\n        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;\n        cm.state.pasteIncoming = true;\n        input.focus();\n      });\n\n      // Prevent normal selection in the editor (we handle our own)\n      on(display.lineSpace, \"selectstart\", function(e) {\n        if (!eventInWidget(display, e)) e_preventDefault(e);\n      });\n\n      on(te, \"compositionstart\", function() {\n        var start = cm.getCursor(\"from\");\n        if (input.composing) input.composing.range.clear()\n        input.composing = {\n          start: start,\n          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n        };\n      });\n      on(te, \"compositionend\", function() {\n        if (input.composing) {\n          input.poll();\n          input.composing.range.clear();\n          input.composing = null;\n        }\n      });\n    },\n\n    prepareSelection: function() {\n      // Redraw the selection and/or cursor\n      var cm = this.cm, display = cm.display, doc = cm.doc;\n      var result = prepareSelection(cm);\n\n      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n      if (cm.options.moveInputWithCursor) {\n        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                            headPos.top + lineOff.top - wrapOff.top));\n        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                             headPos.left + lineOff.left - wrapOff.left));\n      }\n\n      return result;\n    },\n\n    showSelection: function(drawn) {\n      var cm = this.cm, display = cm.display;\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n      if (drawn.teTop != null) {\n        this.wrapper.style.top = drawn.teTop + \"px\";\n        this.wrapper.style.left = drawn.teLeft + \"px\";\n      }\n    },\n\n    // Reset the input to correspond to the selection (or to be empty,\n    // when not typing and nothing is selected)\n    reset: function(typing) {\n      if (this.contextMenuPending) return;\n      var minimal, selected, cm = this.cm, doc = cm.doc;\n      if (cm.somethingSelected()) {\n        this.prevInput = \"\";\n        var range = doc.sel.primary();\n        minimal = hasCopyEvent &&\n          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n        var content = minimal ? \"-\" : selected || cm.getSelection();\n        this.textarea.value = content;\n        if (cm.state.focused) selectInput(this.textarea);\n        if (ie && ie_version >= 9) this.hasSelection = content;\n      } else if (!typing) {\n        this.prevInput = this.textarea.value = \"\";\n        if (ie && ie_version >= 9) this.hasSelection = null;\n      }\n      this.inaccurateSelection = minimal;\n    },\n\n    getField: function() { return this.textarea; },\n\n    supportsTouch: function() { return false; },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n        try { this.textarea.focus(); }\n        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n      }\n    },\n\n    blur: function() { this.textarea.blur(); },\n\n    resetPosition: function() {\n      this.wrapper.style.top = this.wrapper.style.left = 0;\n    },\n\n    receivedFocus: function() { this.slowPoll(); },\n\n    // Poll for input changes, using the normal rate of polling. This\n    // runs as long as the editor is focused.\n    slowPoll: function() {\n      var input = this;\n      if (input.pollingFast) return;\n      input.polling.set(this.cm.options.pollInterval, function() {\n        input.poll();\n        if (input.cm.state.focused) input.slowPoll();\n      });\n    },\n\n    // When an event has just come in that is likely to add or change\n    // something in the input textarea, we poll faster, to ensure that\n    // the change appears on the screen quickly.\n    fastPoll: function() {\n      var missed = false, input = this;\n      input.pollingFast = true;\n      function p() {\n        var changed = input.poll();\n        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n        else {input.pollingFast = false; input.slowPoll();}\n      }\n      input.polling.set(20, p);\n    },\n\n    // Read input from the textarea, and update the document to match.\n    // When something is selected, it is present in the textarea, and\n    // selected (unless it is huge, in which case a placeholder is\n    // used). When nothing is selected, the cursor sits after previously\n    // seen text (can be empty), which is stored in prevInput (we must\n    // not reset the textarea when typing, because that breaks IME).\n    poll: function() {\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n      // Since this is called a *lot*, try to bail out as cheaply as\n      // possible when it is clear that nothing happened. hasSelection\n      // will be the case when there is a lot of text in the textarea,\n      // in which case reading its value would be expensive.\n      if (this.contextMenuPending || !cm.state.focused ||\n          (hasSelection(input) && !prevInput && !this.composing) ||\n          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n        return false;\n\n      var text = input.value;\n      // If nothing changed, bail.\n      if (text == prevInput && !cm.somethingSelected()) return false;\n      // Work around nonsensical selection resetting in IE9/10, and\n      // inexplicable appearance of private area unicode characters on\n      // some key combos in Mac (#2689).\n      if (ie && ie_version >= 9 && this.hasSelection === text ||\n          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n        cm.display.input.reset();\n        return false;\n      }\n\n      if (cm.doc.sel == cm.display.selForContextMenu) {\n        var first = text.charCodeAt(0);\n        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n      }\n      // Find the part of the input that is actually new\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\n      var self = this;\n      runInOp(cm, function() {\n        applyTextInput(cm, text.slice(same), prevInput.length - same,\n                       null, self.composing ? \"*compose\" : null);\n\n        // Don't leave long text in the textarea, since it makes further polling slow\n        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n        else self.prevInput = text;\n\n        if (self.composing) {\n          self.composing.range.clear();\n          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n                                             {className: \"CodeMirror-composing\"});\n        }\n      });\n      return true;\n    },\n\n    ensurePolled: function() {\n      if (this.pollingFast && this.poll()) this.pollingFast = false;\n    },\n\n    onKeyPress: function() {\n      if (ie && ie_version >= 9) this.hasSelection = null;\n      this.fastPoll();\n    },\n\n    onContextMenu: function(e) {\n      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n      if (!pos || presto) return; // Opera is difficult.\n\n      // Reset the current text selection only if the click is done outside of the selection\n      // and 'resetSelectionOnContextMenu' option is true.\n      var reset = cm.options.resetSelectionOnContextMenu;\n      if (reset && cm.doc.sel.contains(pos) == -1)\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\n      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n      input.wrapper.style.cssText = \"position: absolute\"\n      var wrapperBox = input.wrapper.getBoundingClientRect()\n      te.style.cssText = \"position: absolute; width: 30px; height: 30px; top: \" + (e.clientY - wrapperBox.top - 5) +\n        \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px; z-index: 1000; background: \" +\n        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n      display.input.focus();\n      if (webkit) window.scrollTo(null, oldScrollY);\n      display.input.reset();\n      // Adds \"Select all\" to context menu in FF\n      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n      input.contextMenuPending = true;\n      display.selForContextMenu = cm.doc.sel;\n      clearTimeout(display.detectingSelectAll);\n\n      // Select-all will be greyed out if there's nothing to select, so\n      // this adds a zero-width space so that we can later check whether\n      // it got selected.\n      function prepareSelectAllHack() {\n        if (te.selectionStart != null) {\n          var selected = cm.somethingSelected();\n          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n          te.value = \"\\u21da\"; // Used to catch context-menu undo\n          te.value = extval;\n          input.prevInput = selected ? \"\" : \"\\u200b\";\n          te.selectionStart = 1; te.selectionEnd = extval.length;\n          // Re-set this, in case some other handler touched the\n          // selection in the meantime.\n          display.selForContextMenu = cm.doc.sel;\n        }\n      }\n      function rehide() {\n        input.contextMenuPending = false;\n        input.wrapper.style.cssText = oldWrapperCSS\n        te.style.cssText = oldCSS;\n        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\n        // Try to detect the user choosing select-all\n        if (te.selectionStart != null) {\n          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n          var i = 0, poll = function() {\n            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n              operation(cm, commands.selectAll)(cm);\n            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n            else display.input.reset();\n          };\n          display.detectingSelectAll = setTimeout(poll, 200);\n        }\n      }\n\n      if (ie && ie_version >= 9) prepareSelectAllHack();\n      if (captureRightClick) {\n        e_stop(e);\n        var mouseup = function() {\n          off(window, \"mouseup\", mouseup);\n          setTimeout(rehide, 20);\n        };\n        on(window, \"mouseup\", mouseup);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    },\n\n    readOnlyChanged: function(val) {\n      if (!val) this.reset();\n    },\n\n    setUneditable: nothing,\n\n    needsContentAttribute: false\n  }, TextareaInput.prototype);\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  function ContentEditableInput(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.gracePeriod = false;\n  }\n\n  ContentEditableInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = input.cm;\n      var div = input.div = display.lineDiv;\n      disableBrowserMagic(div);\n\n      on(div, \"paste\", function(e) {\n        if (!signalDOMEvent(cm, e)) handlePaste(e, cm);\n      })\n\n      on(div, \"compositionstart\", function(e) {\n        var data = e.data;\n        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n        if (!data) return;\n        var prim = cm.doc.sel.primary();\n        var line = cm.getLine(prim.head.line);\n        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n        if (found > -1 && found <= prim.head.ch)\n          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n                                                Pos(prim.head.line, found + data.length));\n      });\n      on(div, \"compositionupdate\", function(e) {\n        input.composing.data = e.data;\n      });\n      on(div, \"compositionend\", function(e) {\n        var ours = input.composing;\n        if (!ours) return;\n        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n          ours.data = e.data;\n        // Need a small delay to prevent other code (input event,\n        // selection polling) from doing damage when fired right after\n        // compositionend.\n        setTimeout(function() {\n          if (!ours.handled)\n            input.applyComposition(ours);\n          if (input.composing == ours)\n            input.composing = null;\n        }, 50);\n      });\n\n      on(div, \"touchstart\", function() {\n        input.forceCompositionEnd();\n      });\n\n      on(div, \"input\", function() {\n        if (input.composing) return;\n        if (cm.isReadOnly() || !input.pollContent())\n          runInOp(input.cm, function() {regChange(cm);});\n      });\n\n      function onCopyCut(e) {\n        if (signalDOMEvent(cm, e)) return\n        if (cm.somethingSelected()) {\n          lastCopied = {lineWise: false, text: cm.getSelections()};\n          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = {lineWise: true, text: ranges.text};\n          if (e.type == \"cut\") {\n            cm.operation(function() {\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n              cm.replaceSelection(\"\", null, \"cut\");\n            });\n          }\n        }\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        if (e.clipboardData && !ios) {\n          e.preventDefault();\n          e.clipboardData.clearData();\n          e.clipboardData.setData(\"text/plain\", lastCopied.text.join(\"\\n\"));\n        } else {\n          // Old-fashioned briefly-focus-a-textarea hack\n          var kludge = hiddenTextarea(), te = kludge.firstChild;\n          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n          te.value = lastCopied.text.join(\"\\n\");\n          var hadFocus = document.activeElement;\n          selectInput(te);\n          setTimeout(function() {\n            cm.display.lineSpace.removeChild(kludge);\n            hadFocus.focus();\n          }, 50);\n        }\n      }\n      on(div, \"copy\", onCopyCut);\n      on(div, \"cut\", onCopyCut);\n    },\n\n    prepareSelection: function() {\n      var result = prepareSelection(this.cm, false);\n      result.focus = this.cm.state.focused;\n      return result;\n    },\n\n    showSelection: function(info, takeFocus) {\n      if (!info || !this.cm.display.view.length) return;\n      if (info.focus || takeFocus) this.showPrimarySelection();\n      this.showMultipleSelections(info);\n    },\n\n    showPrimarySelection: function() {\n      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n        return;\n\n      var start = posToDOM(this.cm, prim.from());\n      var end = posToDOM(this.cm, prim.to());\n      if (!start && !end) return;\n\n      var view = this.cm.display.view;\n      var old = sel.rangeCount && sel.getRangeAt(0);\n      if (!start) {\n        start = {node: view[0].measure.map[2], offset: 0};\n      } else if (!end) { // FIXME dangerously hacky\n        var measure = view[view.length - 1].measure;\n        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n      }\n\n      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n      if (rng) {\n        if (!gecko && this.cm.state.focused) {\n          sel.collapse(start.node, start.offset);\n          if (!rng.collapsed) sel.addRange(rng);\n        } else {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n        if (old && sel.anchorNode == null) sel.addRange(old);\n        else if (gecko) this.startGracePeriod();\n      }\n      this.rememberSelection();\n    },\n\n    startGracePeriod: function() {\n      var input = this;\n      clearTimeout(this.gracePeriod);\n      this.gracePeriod = setTimeout(function() {\n        input.gracePeriod = false;\n        if (input.selectionChanged())\n          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n      }, 20);\n    },\n\n    showMultipleSelections: function(info) {\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n    },\n\n    rememberSelection: function() {\n      var sel = window.getSelection();\n      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n    },\n\n    selectionInEditor: function() {\n      var sel = window.getSelection();\n      if (!sel.rangeCount) return false;\n      var node = sel.getRangeAt(0).commonAncestorContainer;\n      return contains(this.div, node);\n    },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n    },\n    blur: function() { this.div.blur(); },\n    getField: function() { return this.div; },\n\n    supportsTouch: function() { return true; },\n\n    receivedFocus: function() {\n      var input = this;\n      if (this.selectionInEditor())\n        this.pollSelection();\n      else\n        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\n      function poll() {\n        if (input.cm.state.focused) {\n          input.pollSelection();\n          input.polling.set(input.cm.options.pollInterval, poll);\n        }\n      }\n      this.polling.set(this.cm.options.pollInterval, poll);\n    },\n\n    selectionChanged: function() {\n      var sel = window.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n    },\n\n    pollSelection: function() {\n      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n        var sel = window.getSelection(), cm = this.cm;\n        this.rememberSelection();\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n        if (anchor && head) runInOp(cm, function() {\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n        });\n      }\n    },\n\n    pollContent: function() {\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n      var from = sel.from(), to = sel.to();\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\n      var fromIndex;\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n        var fromLine = lineNo(display.view[0].line);\n        var fromNode = display.view[0].node;\n      } else {\n        var fromLine = lineNo(display.view[fromIndex].line);\n        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n      }\n      var toIndex = findViewIndex(cm, to.line);\n      if (toIndex == display.view.length - 1) {\n        var toLine = display.viewTo - 1;\n        var toNode = display.lineDiv.lastChild;\n      } else {\n        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n        var toNode = display.view[toIndex + 1].node.previousSibling;\n      }\n\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n      while (newText.length > 1 && oldText.length > 1) {\n        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n        else break;\n      }\n\n      var cutFront = 0, cutEnd = 0;\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n        ++cutFront;\n      var newBot = lst(newText), oldBot = lst(oldText);\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n      while (cutEnd < maxCutEnd &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n        ++cutEnd;\n\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n      newText[0] = newText[0].slice(cutFront);\n\n      var chFrom = Pos(fromLine, cutFront);\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n        return true;\n      }\n    },\n\n    ensurePolled: function() {\n      this.forceCompositionEnd();\n    },\n    reset: function() {\n      this.forceCompositionEnd();\n    },\n    forceCompositionEnd: function() {\n      if (!this.composing || this.composing.handled) return;\n      this.applyComposition(this.composing);\n      this.composing.handled = true;\n      this.div.blur();\n      this.div.focus();\n    },\n    applyComposition: function(composing) {\n      if (this.cm.isReadOnly())\n        operation(this.cm, regChange)(this.cm)\n      else if (composing.data && composing.data != composing.startData)\n        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n    },\n\n    setUneditable: function(node) {\n      node.contentEditable = \"false\"\n    },\n\n    onKeyPress: function(e) {\n      e.preventDefault();\n      if (!this.cm.isReadOnly())\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n    },\n\n    readOnlyChanged: function(val) {\n      this.div.contentEditable = String(val != \"nocursor\")\n    },\n\n    onContextMenu: nothing,\n    resetPosition: nothing,\n\n    needsContentAttribute: true\n  }, ContentEditableInput.prototype);\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) return null;\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result;\n  }\n\n  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        return locateNodeInLineView(lineView, node, offset);\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad);\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) offset = textNode.nodeValue.length;\n    }\n    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n            return Pos(line, ch);\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) return badPos(found, bad);\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        return badPos(Pos(found.line, found.ch - dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        return badPos(Pos(found.line, found.ch + dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n  }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText != null) {\n          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n          text += cmText;\n          return;\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find()))\n            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n          return;\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n        for (var i = 0; i < node.childNodes.length; i++)\n          walk(node.childNodes[i]);\n        if (/^(pre|div|p)$/i.test(node.nodeName))\n          closing = true;\n      } else if (node.nodeType == 3) {\n        var val = node.nodeValue;\n        if (!val) return;\n        if (closing) {\n          text += lineSep;\n          closing = false;\n        }\n        text += val;\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) break;\n      from = from.nextSibling;\n    }\n    return text;\n  }\n\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // SELECTION / CURSOR\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  }\n\n  Selection.prototype = {\n    primary: function() { return this.ranges[this.primIndex]; },\n    equals: function(other) {\n      if (other == this) return true;\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var here = this.ranges[i], there = other.ranges[i];\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n      }\n      return true;\n    },\n    deepCopy: function() {\n      for (var out = [], i = 0; i < this.ranges.length; i++)\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n      return new Selection(out, this.primIndex);\n    },\n    somethingSelected: function() {\n      for (var i = 0; i < this.ranges.length; i++)\n        if (!this.ranges[i].empty()) return true;\n      return false;\n    },\n    contains: function(pos, end) {\n      if (!end) end = pos;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var range = this.ranges[i];\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n          return i;\n      }\n      return -1;\n    }\n  };\n\n  function Range(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  }\n\n  Range.prototype = {\n    from: function() { return minPos(this.anchor, this.head); },\n    to: function() { return maxPos(this.anchor, this.head); },\n    empty: function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    }\n  };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(ranges, primIndex) {\n    var prim = ranges[primIndex];\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      if (cmp(prev.to(), cur.from()) >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) --primIndex;\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n  function clipPosArray(doc, array) {\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n    return out;\n  }\n\n  // SELECTION UPDATES\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(doc, range, head, other) {\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options) {\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head));\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n    else return sel;\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      sel = filterSelectionChange(doc, sel, options);\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      ensureCursorVisible(doc.cm);\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) return;\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) out = sel.ranges.slice(0, i);\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) break;\n            else {--i; continue;}\n          }\n        }\n        if (!m.atomic) continue;\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff;\n          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            return skipAtomicInner(doc, near, pos, dir, mayClear);\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n          far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n      }\n    }\n    return pos;\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0);\n    }\n    return found;\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));\n      else return null;\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);\n      else return null;\n    } else {\n      return new Pos(pos.line, pos.ch + dir);\n    }\n  }\n\n  // SELECTION DRAWING\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (primary === false && i == doc.sel.primIndex) continue;\n      var range = doc.sel.ranges[i];\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        drawSelectionCursor(cm, range.head, curFragment);\n      if (!collapsed)\n        drawSelectionRange(cm, range, selFragment);\n    }\n    return result;\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = leftSide;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = leftSide;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = rightSide;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < leftSide + 1) left = leftSide;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    else if (cm.options.cursorBlinkRate < 0)\n      display.cursorDiv.style.visibility = \"hidden\";\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.viewTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changedLines = [];\n\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) line.styleClasses = newCls;\n        else if (oldCls) line.styleClasses = null;\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) changedLines.push(doc.frontier);\n        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changedLines.length) runInOp(cm, function() {\n      for (var i = 0; i < changedLines.length; i++)\n        regLineChange(cm, changedLines[i], \"text\");\n    });\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingH(display) {\n    if (display.cachedPaddingH) return display.cachedPaddingH;\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n    return data;\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineView.rest[i] == line)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineNo(lineView.rest[i]) > lineN)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      return cm.display.view[findViewIndex(cm, lineN)];\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      return ext;\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      view = updateExternalMeasurement(cm, line);\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    };\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) ch = -1;\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) prepared.cache[key] = found;\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom};\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      var mStart = map[i], mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) collapse = \"right\";\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          collapse = bias;\n        if (bias == \"left\" && start == 0)\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        if (bias == \"right\" && start == mEnd - mStart)\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        break;\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect\n    if (bias == \"left\") for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) break\n    } else for (var i = rects.length - 1; i >= 0; i--) {\n      if ((rect = rects[i]).left != rect.right) break\n    }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          rect = node.parentNode.getBoundingClientRect();\n        else\n          rect = getUsefulRect(range(node, start, end).getClientRects(), bias)\n        if (rect.left || rect.right || start == 0) break;\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) collapse = bias = \"right\";\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      else\n        rect = node.getBoundingClientRect();\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n      else\n        rect = nullRect;\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    for (var i = 0; i < heights.length - 1; i++)\n      if (mid < heights[i]) break;\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) result.bogus = true;\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result;\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      return rect;\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n        lineView.measure.caches[i] = {};\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0, pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find(0, true);\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineN = lineNo(lineObj = mergedPos.to.line);\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var outside = ch == from ? fromOutside : toOutside\n        var xDiff = x - (ch == from ? fromX : toX);\n        // This is a kludge to handle the case where the coordinates\n        // are after a line-wrapped line. We should replace it with a\n        // more general handling of cursor positions around line\n        // breaks. (Issue #4078)\n        if (toOutside && !bidi && !/\\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&\n            ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {\n          var charSize = measureCharPrepared(cm, preparedMeasure, ch, \"right\");\n          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {\n            outside = false\n            ch++\n            xDiff = x - charSize.right\n          }\n        }\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var operationGroup = null;\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: null,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    if (operationGroup) {\n      operationGroup.ops.push(cm.curOp);\n    } else {\n      cm.curOp.ownsGroup = operationGroup = {\n        ops: [cm.curOp],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        callbacks[i].call(null);\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n      }\n    } while (i < callbacks.length);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp, group = op.ownsGroup;\n    if (!group) return;\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      for (var i = 0; i < group.ops.length; i++)\n        group.ops[i].cm.curOp = null;\n      endOperations(group);\n    }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_finish(ops[i]);\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) findMaxLine(cm);\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      op.preparedSelection = display.input.prepareSelection(op.focus);\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())\n    if (op.preparedSelection)\n      cm.display.input.showSelection(op.preparedSelection, takeFocus);\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      updateScrollbars(cm, op.barMeasure);\n    if (op.updatedDisplay)\n      setDocumentHeight(cm, op.barMeasure);\n\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      cm.display.input.reset(op.typing);\n    if (takeFocus) ensureFocus(op.cm);\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      display.wheelStartX = display.wheelStartY = null;\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n      display.scrollbars.setScrollTop(doc.scrollTop);\n      display.scroller.scrollTop = doc.scrollTop;\n    }\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));\n      display.scrollbars.setScrollLeft(doc.scrollLeft);\n      display.scroller.scrollLeft = doc.scrollLeft;\n      alignHorizontally(cm);\n    }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    if (display.wrapper.offsetHeight)\n      doc.scrollTop = cm.display.scroller.scrollTop;\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      signal(cm, \"changes\", cm, op.changeObjs);\n    if (op.update)\n      op.update.finish();\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) return f();\n    startOperation(cm);\n    try { return f(); }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) return f.apply(cm, arguments);\n      startOperation(cm);\n      try { return f.apply(cm, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) return f.apply(this, arguments);\n      startOperation(this);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(this); }\n    };\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) return f.apply(this, arguments);\n      startOperation(cm);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n\n  // VIEW TRACKING\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array;\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    if (!lendiff) lendiff = 0;\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      display.updateLineNumbers = from;\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        resetView(cm);\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut = viewCuttingPoint(cm, from, from, -1);\n      if (cut) {\n        display.view = display.view.slice(0, cut.index);\n        display.viewTo = cut.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        ext.lineN += lendiff;\n      else if (from < ext.lineN + ext.size)\n        display.externalMeasured = null;\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      display.externalMeasured = null;\n\n    if (line < display.viewFrom || line >= display.viewTo) return;\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) return;\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) arr.push(type);\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) return null;\n    n -= cm.display.viewFrom;\n    if (n < 0) return null;\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) return i;\n    }\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      return {index: index, lineN: newN};\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n      n += view[i].size;\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) return null;\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN};\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      else if (display.viewFrom < from)\n        display.view = display.view.slice(findViewIndex(cm, from));\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      else if (display.viewTo > to)\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n    }\n    return dirty;\n  }\n\n  // EVENT HANDLERS\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    else\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    };\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) return false;\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\n    }\n    function farAway(touch, other) {\n      if (other.left == null) return true;\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20;\n    }\n    on(d.scroller, \"touchstart\", function(e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function() {\n      if (d.activeTouch) d.activeTouch.moved = true;\n    });\n    on(d.scroller, \"touchend\", function(e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          range = new Range(pos, pos);\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          range = cm.findWordAt(pos);\n        else // Triple tap\n          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function(e){onDragStart(cm, e);},\n      drop: operation(cm, onDrop),\n      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", bind(onFocus, cm));\n    on(inp, \"blur\", bind(onBlur, cm));\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != CodeMirror.Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n      return;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  // MOUSE EVENTS\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        return true;\n    }\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null; }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords;\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n    window.focus();\n\n    switch (e_button(e)) {\n    case 1:\n      // #3261: make sure, that we're not starting a second selection\n      if (cm.state.selectingText)\n        cm.state.selectingText(e);\n      else if (start)\n        leftButtonDown(cm, e, start);\n      else if (e_target(e) == display.scroller)\n        e_preventDefault(e);\n      break;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(function() {display.input.focus();}, 20);\n      e_preventDefault(e);\n      break;\n    case 3:\n      if (captureRightClick) onContextMenu(cm, e);\n      else delayBlurEvent(cm);\n      break;\n    }\n  }\n\n  var lastClick, lastDoubleClick;\n  function leftButtonDown(cm, e, start) {\n    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n    else cm.curOp.focus = activeElt();\n\n    var now = +new Date, type;\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n      type = \"triple\";\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n    } else {\n      type = \"single\";\n      lastClick = {time: now, pos: start};\n    }\n\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n      leftButtonStartDrag(cm, e, start, modifier);\n    else\n      leftButtonSelect(cm, e, start, type, modifier);\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, e, start, modifier) {\n    var display = cm.display, startTime = +new Date;\n    var dragEnd = operation(cm, function(e2) {\n      if (webkit) display.scroller.draggable = false;\n      cm.state.draggingText = false;\n      off(document, \"mouseup\", dragEnd);\n      off(display.scroller, \"drop\", dragEnd);\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n        e_preventDefault(e2);\n        if (!modifier && +new Date - 200 < startTime)\n          extendSelection(cm.doc, start);\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n        else\n          display.input.focus();\n      }\n    });\n    // Let the drag handler handle this.\n    if (webkit) display.scroller.draggable = true;\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = mac ? e.altKey : e.ctrlKey\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\n    on(document, \"mouseup\", dragEnd);\n    on(display.scroller, \"drop\", dragEnd);\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, e, start, type, addNew) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(e);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (addNew && !e.shiftKey) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        ourRange = ranges[ourIndex];\n      else\n        ourRange = new Range(start, start);\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\n      type = \"rect\";\n      if (!addNew) ourRange = new Range(start, start);\n      start = posFromMouse(cm, e, true, true);\n      ourIndex = -1;\n    } else if (type == \"double\") {\n      var word = cm.findWordAt(start);\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n      else\n        ourRange = word;\n    } else if (type == \"triple\") {\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n      else\n        ourRange = line;\n    } else {\n      ourRange = extendRange(doc, ourRange, start);\n    }\n\n    if (!addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) return;\n      lastPos = pos;\n\n      if (type == \"rect\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          else if (text.length > leftPos)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n        }\n        if (!ranges.length) ranges.push(new Range(start, start));\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var anchor = oldRange.anchor, head = pos;\n        if (type != \"single\") {\n          if (type == \"double\")\n            var range = cm.findWordAt(pos);\n          else\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n          if (cmp(range.anchor, anchor) > 0) {\n            head = range.head;\n            anchor = minPos(oldRange.from(), range.anchor);\n          } else {\n            head = range.anchor;\n            anchor = maxPos(oldRange.to(), range.head);\n          }\n        }\n        var ranges = startSel.ranges.slice(0);\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, type == \"rect\");\n      if (!cur) return;\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      e_preventDefault(e);\n      display.input.focus();\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function(e) {\n      if (!e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signal(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) return;\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          return;\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function() {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function() {cm.display.input.focus();}, 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            var selected = cm.listSelections();\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) for (var i = 0; i < selected.length; ++i)\n            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n          cm.replaceSelection(text, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\"\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) img.parentNode.removeChild(img);\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) return;\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // SCROLL EVENTS\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplaySimple(cm, {top: val});\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (gecko) updateDisplaySimple(cm);\n    startWorker(cm, 100);\n  }\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  var wheelEventDelta = function(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n    return {x: dx, y: dy};\n  };\n  CodeMirror.wheelEventPixels = function(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta;\n  };\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // KEY EVENTS\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) cm.state.suppressEdits = true;\n      if (dropShift) cm.display.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) return result;\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm);\n  }\n\n  var stopSeq = new Delayed;\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) return \"handled\";\n      stopSeq.set(50, function() {\n        if (cm.state.keySeq == seq) {\n          cm.state.keySeq = null;\n          cm.display.input.reset();\n        }\n      });\n      name = seq + \" \" + name;\n    }\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      cm.state.keySeq = name;\n    if (result == \"handled\")\n      signalLater(cm, \"keyHandled\", cm, name, e);\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    if (seq && !result && /\\'$/.test(name)) {\n      e_preventDefault(e);\n      return true;\n    }\n    return !!result;\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) return false;\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n          || dispatchKey(cm, name, e, function(b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 return doHandleBinding(cm, b);\n             });\n    } else {\n      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n                       function(b) { return doHandleBinding(cm, b, true); });\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) return;\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\", null, \"cut\");\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      showCrossHair(cm);\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) this.doc.sel.shift = false;\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    cm.display.input.onKeyPress(e);\n  }\n\n  // FOCUS/BLUR EVENTS\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function() {\n      if (cm.state.delayingBlurEvent) {\n        cm.state.delayingBlurEvent = false;\n        onBlur(cm);\n      }\n    }, 100);\n  }\n\n  function onFocus(cm) {\n    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.delayingBlurEvent) return;\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n    cm.display.input.onContextMenu(e);\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n  }\n\n  // UPDATING\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) return pos;\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    else\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex);\n  }\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) return;\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    for (var i = 0; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        break;\n    }\n    if (i == source.length) return;\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return;\n        }\n        selAfter = event;\n      }\n      else break;\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return;\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) return;\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n                       Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        regLineChange(doc.cm, l, \"gutter\");\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n    else updateDoc(doc, change, spans);\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      signalCursorActivity(cm);\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      regChange(cm);\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      regLineChange(cm, from.line, \"text\");\n    else\n      regChange(cm, from.line, to.line + 1, lendiff);\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = doc.splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, coords) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n                           coords.left + \"px; width: 2px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) break;\n    }\n    return coords;\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (y2 - y1 > screen) y2 = y1 + screen;\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = x2 - x1 > screenw;\n    if (tooWide) x2 = x1 + screenw;\n    if (x1 < 10)\n      result.scrollLeft = 0;\n    else if (x1 < screenleft)\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n    else if (x2 > screenw + screenleft - 3)\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n    return result;\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollPos(cm, left, top) {\n    if (left != null || top != null) resolveScrollToPos(cm);\n    if (left != null)\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n    if (top != null)\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor(), from = cur, to = cur;\n    if (!cm.options.lineWrapping) {\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n      to = Pos(cur.line, cur.ch + 1);\n    }\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n                                    Math.min(from.top, to.top) - range.margin,\n                                    Math.max(from.right, to.right),\n                                    Math.max(from.bottom, to.bottom) + range.margin);\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n    }\n  }\n\n  // API UTILITIES\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) how = \"add\";\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) how = \"prev\";\n      else state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) line.stateAfter = null;\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true;\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\n        var range = doc.sel.ranges[i];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i, new Range(pos, pos));\n          break;\n        }\n      }\n    }\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n    return line;\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function() {\n      for (var i = kill.length - 1; i >= 0; i--)\n        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      ensureCursorVisible(cm);\n    });\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return false\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return false\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") {\n      moveOnce()\n    } else if (unit == \"column\") {\n      moveOnce(true)\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) type = \"s\";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);\n    if (!cmp(pos, result)) result.hitSide = true;\n    return result;\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  // EDITOR METHODS\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || maps[i].name == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: methodOp(function(how) {\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (!range.empty()) {\n          var from = range.from(), to = range.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            indentLine(this, j, how);\n          var newRanges = this.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n        } else if (range.head.line > end) {\n          indentLine(this, range.head.line, how, true);\n          end = range.head.line;\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise);\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true);\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) type = styles[2];\n      else for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else { type = styles[mid * 2 + 2]; break; }\n      }\n      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return found;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range = this.doc.sel.primary();\n      if (start == null) pos = range.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? range.from() : range.to();\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) line = this.doc.first;\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: methodOp(function(line, gutterID, value) {\n      return changeLine(this.doc, line, \"gutter\", function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: methodOp(function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regLineChange(cm, i, \"gutter\");\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd].call(null, this);\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var cm = this;\n      cm.extendSelectionsBy(function(range) {\n        if (cm.display.shift || cm.doc.extend || range.empty())\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n        else\n          return dir < 0 ? range.from() : range.to();\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        doc.replaceSelection(\"\", null, \"+delete\");\n      else\n        deleteNearSelection(this, function(range) {\n          var other = findPosH(doc, range.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n        });\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var cm = this, doc = this.doc, goals = [];\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function(range) {\n        if (collapse)\n          return dir < 0 ? range.from() : range.to();\n        var headPos = cursorCoords(cm, range.head, \"div\");\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\n        goals.push(headPos.left);\n        var pos = findPosV(cm, headPos, dir, unit);\n        if (unit == \"page\" && range == doc.sel.primary())\n          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n        return pos;\n      }, sel_move);\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n        doc.sel.ranges[i].goalColumn = goals[i];\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function(ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n        while (start > 0 && check(line.charAt(start - 1))) --start;\n        while (end < line.length && check(line.charAt(end))) ++end;\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n      else\n        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },\n\n    scrollTo: methodOp(function(x, y) {\n      if (x != null || y != null) resolveScrollToPos(this);\n      if (x != null) this.curOp.scrollLeft = x;\n      if (y != null) this.curOp.scrollTop = y;\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n    },\n\n    scrollIntoView: methodOp(function(range, margin) {\n      if (range == null) {\n        range = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) margin = this.options.cursorScrollMargin;\n      } else if (typeof range == \"number\") {\n        range = {from: Pos(range, 0), to: null};\n      } else if (range.from == null) {\n        range = {from: range, to: null};\n      }\n      if (!range.to) range.to = range.from;\n      range.margin = margin || 0;\n\n      if (range.from.line != null) {\n        resolveScrollToPos(this);\n        this.curOp.scrollToPos = range;\n      } else {\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n                                      Math.min(range.from.top, range.to.top) - range.margin,\n                                      Math.max(range.from.right, range.to.right),\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var cm = this;\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n      var lineNo = cm.display.viewFrom;\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n        ++lineNo;\n      });\n      cm.curOp.forceUpdate = true;\n      signal(cm, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        estimateLineHeights(this);\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input.getField();},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n  // Functions to run when options are changed.\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  // Passed to option handlers when there is no old value.\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function(cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) return;\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function(line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) break;\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != CodeMirror.Init) cm.refresh();\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n  }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function(cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != CodeMirror.Init && getKeyMap(old);\n    if (prev && prev.detach) prev.detach(cm, next);\n    if (next.attach) next.attach(cm, prev || null);\n  });\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n  option(\"scrollbarStyle\", \"native\", function(cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n    }\n    cm.display.input.readOnlyChanged(val)\n  });\n  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function(cm, val) {\n    if (!val) cm.display.input.resetPosition();\n  });\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.getField().tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2)\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") found = {name: found};\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    }\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because nested\n  // modes need to do this for their inner modes.\n\n  var copyState = CodeMirror.copyState = function(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  };\n\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  };\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n    singleSelection: function(cm) {\n      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n          if (range.head.ch == len && range.head.line < cm.lastLine())\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n          else\n            return {from: range.head, to: Pos(range.head.line, len)};\n        } else {\n          return {from: range.from(), to: range.to()};\n        }\n      });\n    },\n    deleteLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0),\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n      });\n    },\n    delLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0), to: range.from()};\n      });\n    },\n    delWrappedLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n        return {from: leftPos, to: range.from()};\n      });\n    },\n    delWrappedLineRight: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n        return {from: range.from(), to: rightPos };\n      });\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    undoSelection: function(cm) {cm.undoSelection();},\n    redoSelection: function(cm) {cm.redoSelection();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n                            {origin: \"+move\", bias: 1});\n    },\n    goLineStartSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        return lineStartSmart(cm, range.head);\n      }, {origin: \"+move\", bias: 1});\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n                            {origin: \"+move\", bias: -1});\n    },\n    goLineRight: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: 0, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n    insertSoftTab: function(cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.execCommand(\"insertTab\");\n    },\n    transposeChars: function(cm) {\n      runInOp(cm, function() {\n        var ranges = cm.listSelections(), newSel = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n          if (line) {\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n              if (prev)\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                                prev.charAt(prev.length - 1),\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n            }\n          }\n          newSel.push(new Range(cur, cur));\n        }\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function(cm) {\n      runInOp(cm, function() {\n        var len = cm.listSelections().length;\n        for (var i = 0; i < len; i++) {\n          var range = cm.listSelections()[i];\n          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n          cm.indentLine(range.from().line + 1, null, true);\n        }\n        ensureCursorVisible(cm);\n      });\n    },\n    openLine: function(cm) {cm.replaceSelection(\"\\n\", \"start\")},\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    fallthrough: \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n      else if (/^a(lt)?$/i.test(mod)) alt = true;\n      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n      else if (/^s(hift)$/i.test(mod)) shift = true;\n      else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) name = \"Alt-\" + name;\n    if (ctrl) name = \"Ctrl-\" + name;\n    if (cmd) name = \"Cmd-\" + name;\n    if (shift) name = \"Shift-\" + name;\n    return name;\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  CodeMirror.normalizeKeyMap = function(keymap) {\n    var copy = {};\n    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n      if (value == \"...\") { delete keymap[keyname]; continue; }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val, name;\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) copy[name] = val;\n        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n      }\n      delete keymap[keyname];\n    }\n    for (var prop in copy) keymap[prop] = copy[prop];\n    return keymap;\n  };\n\n  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        return lookupKey(key, map.fallthrough, handle, context);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) return result;\n      }\n    }\n  };\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  };\n\n  // Look up the name of a key as indicated by an event object.\n  var keyName = CodeMirror.keyName = function(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n    var base = keyNames[event.keyCode], name = base;\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n    return name;\n  };\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val;\n  }\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      options.tabindex = textarea.tabIndex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function(cm) {\n      cm.save = save;\n      cm.getTextArea = function() { return textarea; };\n      cm.toTextArea = function() {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (typeof textarea.form.submit == \"function\")\n            textarea.form.submit = realSubmit;\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  var nextMarkerId = 0;\n\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n  eventMixin(TextMarker);\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) signalLater(this, \"clear\", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n      else if (cm) {\n        if (span.to != null) max = lineNo(line);\n        if (span.from != null) min = lineNo(line);\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm.doc);\n    }\n    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n    if (withOp) endOperation(cm);\n    if (this.parent) this.parent.clear();\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function(side, lineObj) {\n    if (side == null && this.type == \"bookmark\") side = 1;\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) return from;\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) return to;\n      }\n    }\n    return from && {from: from, to: to};\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) return;\n    runInOp(cm, function() {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          updateLineHeight(line, line.height + dHeight);\n      }\n    });\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) copyObj(options, marker, false);\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        updateMaxLine = true;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n      if (marker.atomic) reCheckSelection(cm.doc);\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      markers[i].parent = this;\n  };\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function(side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.widgetNode = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n                         function(m) { return m.parent; });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], linked = [marker.primary.doc];;\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    }\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    }\n    return nw;\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    }\n    return nw;\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) return null;\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          newParts.push({from: p.from, to: m.from});\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        return true;\n    }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = merged.find(-1, true).line;\n    return line;\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n    return lines;\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) return lineN;\n    return lineNo(vis);\n  }\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) return lineN;\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) return lineN;\n    while (merged = collapsedSpanAtEnd(line))\n      line = merged.find(1, true).line;\n    return lineNo(line) + 1;\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.widgetNode) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  // LINE WIDGETS\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.doc = doc;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      addToScrollPos(cm, null, diff);\n  }\n\n  LineWidget.prototype.clear = function() {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) line.widgets = null;\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) runInOp(cm, function() {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n  };\n  LineWidget.prototype.changed = function() {\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(line, line.height + diff);\n    if (cm) runInOp(cm, function() {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n    });\n  };\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    var cm = widget.doc.cm;\n    if (!cm) return 0;\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n      if (widget.noHScroll)\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight;\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(doc, handle, \"widget\", function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n        cm.curOp.forceUpdate = true;\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        output[prop] = lineClass[2];\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        output[prop] += \" \" + lineClass[2];\n    }\n    return type;\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) return mode.blankLine(state);\n    if (!mode.innerMode) return;\n    var inner = CodeMirror.innerMode(mode, state);\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) return style;\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    function getObj(copy) {\n      return {start: stream.start, end: stream.pos,\n              string: stream.current(),\n              type: style || null,\n              state: copy ? copyState(doc.mode, state) : state};\n    }\n\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n    if (asArray) tokens = [];\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, state);\n      if (asArray) tokens.push(getObj(true));\n    }\n    return asArray ? tokens : getObj();\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 50000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, lineClasses, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"cm-overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n          }\n        }\n      }, lineClasses);\n    }\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var state = getStateBefore(cm, lineNo(line));\n      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n      line.stateAfter = state;\n      line.styles = result.styles;\n      if (result.classes) line.styleClasses = result.classes;\n      else if (line.styleClasses) line.styleClasses = null;\n      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n    }\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") callBlankLine(mode, state);\n    while (!stream.eol()) {\n      readToken(mode, stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) return null;\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        if (line.styleClasses.textClass)\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        builder.content.className = \"cm-tab-wrap-hack\";\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token;\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n    if (!text) return;\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) mustWrap = true;\n      builder.pos += text.length;\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt.setAttribute(\"role\", \"presentation\");\n          txt.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (title) token.title = title;\n      return builder.content.appendChild(token);\n    }\n    builder.content.appendChild(content);\n  }\n\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) return text\n    var spaceBefore = trailingBefore, result = \"\"\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i)\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        ch = \"\\u00a0\"\n      result += ch\n      spaceBefore = ch == \" \"\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function(builder, text, style, startStyle, endStyle, title, css) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        for (var i = 0; i < order.length; i++) {\n          var part = order[i];\n          if (part.to > start && part.from <= start) break;\n        }\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        widget = builder.content.appendChild(document.createElement(\"span\"));\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\n          if (endStyles[j + 1] == nextChange) spanEndStyle += \" \" + endStyles[j]\n\n        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return;\n          if (collapsed.to == pos) collapsed = false;\n        }\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      for (var i = start, result = []; i < end; ++i)\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\n      return result;\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added = linesFor(1, text.length - 1);\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added = linesFor(1, text.length - 1);\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, height = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.extend = false;\n\n    if (typeof text == \"string\") text = this.splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      setSelection(this, simpleSelection(top));\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") line = getLine(this, line);\n      return visualLine(line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") pos = range.head;\n      else if (start == \"anchor\") pos = range.anchor;\n      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n      else pos = range.from();\n      return pos;\n    },\n    listSelections: function() { return this.sel.ranges; },\n    somethingSelected: function() {return this.sel.somethingSelected();},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) return;\n      for (var i = 0, out = []; i < ranges.length; i++)\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head));\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      setSelection(this, normalizeSelection(out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) return lines;\n      else return lines.join(lineSep || this.lineSeparator());\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n        parts[i] = sel;\n      }\n      return parts;\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        dup[i] = code;\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i = changes.length - 1; i >= 0; i--)\n        makeChange(this, changes[i]);\n      if (newSel) setSelectionReplaceHistory(this, newSel);\n      else if (this.cm) ensureCursorVisible(this.cm);\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend;},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n      return {undo: done, redo: undone};\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (classTest(cls).test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function(line) {\n        var spans = line.markedSpans;\n        if (spans) for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n                span.from == null && lineNo != from.line ||\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            found.push(span.marker.parent || span.marker);\n        }\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function(line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + sepSize;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;},\n\n    splitLines: function(str) {\n      if (this.lineSep) return str.split(this.lineSep);\n      return splitLinesAuto(str);\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) findMaxLine(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    for (var chunk = doc; !chunk.lines;) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0; i < chunk.children.length; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) array.pop();\n      else break;\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, ore are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        pushSelectionToHistory(doc.sel, hist.done);\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) hist.done.shift();\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) signal(doc, \"historyAdded\");\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      hist.done[hist.done.length - 1] = sel;\n    else\n      pushSelectionToHistory(sel, hist.done);\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      clearSelectionEvents(hist.undone);\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      dest.push(sel);\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue;\n      }\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT UTILITIES\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  };\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  };\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var on = CodeMirror.on = function(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  };\n\n  var noHandlers = []\n  function getHandlers(emitter, type, copy) {\n    var arr = emitter._handlers && emitter._handlers[type]\n    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n    else return arr || noHandlers\n  }\n\n  var off = CodeMirror.off = function(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var handlers = getHandlers(emitter, type, false)\n      for (var i = 0; i < handlers.length; ++i)\n        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n    }\n  };\n\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type, true)\n    if (!handlers.length) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n  };\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type, false)\n    if (!arr.length) return;\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      list.push(bnd(arr[i]));\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) return;\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n      set.push(arr[i]);\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype.set = function(ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        return n + (end - i);\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  };\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) nextTab = string.length;\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        return pos + Math.min(skipped, goal - col);\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) return pos;\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n  else if (ie) // Suppress mysterious IE10 errors\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      if (array[i] == elt) return i;\n    return -1;\n  }\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n    return out;\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) copyObj(props, inst);\n    return inst;\n  };\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) target = {};\n    for (var prop in obj)\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        target[prop] = obj[prop];\n    return target;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  };\n  function isWordChar(ch, helper) {\n    if (!helper) return isWordCharBasic(ch);\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  var range;\n  if (document.createRange) range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r;\n  };\n  else range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r; }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r;\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  var contains = CodeMirror.contains = function(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      child = child.parentNode;\n    if (parent.contains)\n      return parent.contains(child);\n    do {\n      if (child.nodeType == 11) child = child.host;\n      if (child == parent) return true;\n    } while (child = child.parentNode);\n  };\n\n  function activeElt() {\n    var activeElement = document.activeElement;\n    while (activeElement && activeElement.root && activeElement.root.activeElement)\n      activeElement = activeElement.root.activeElement;\n    return activeElement;\n  }\n  // Older versions of IE throws unspecified error when touching\n  // document.activeElement in some cases (during loading, in iframe)\n  if (ie && ie_version < 11) activeElt = function() {\n    try { return document.activeElement; }\n    catch(e) { return document.body; }\n  };\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n  var rmClass = CodeMirror.rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n  var addClass = CodeMirror.addClass = function(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n  };\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n    return b;\n  }\n\n  // WINDOW-WIDE EVENTS\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.body.getElementsByClassName) return;\n    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) f(cm);\n    }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) return;\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100);\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function() {\n      forEachCodeMirror(onBlur);\n    });\n  }\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node;\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) return badBidiRects;\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3);\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) return badZoomedRects;\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  }\n\n  // KEY NAMES\n\n  var keyNames = CodeMirror.keyNames = {\n    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, \"ltr\");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line = getLine(cm.doc, lineN);\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      lineN = null;\n    }\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS);\n    }\n    return start;\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is needed in order to move 'visually' through bi-directional\n  // text -- i.e., pressing left should make the cursor go left, even\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\n  // LTR text touch each other. This often requires the cursor offset\n  // to move more than one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n    function charType(code) {\n      if (code <= 0xf7) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n      else if (code == 0x200c) return \"b\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push(new BidiSpan(0, start, i));\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n      if (order[0].level == 2)\n        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n      if (order[0].level != lst(order).level)\n        order.push(new BidiSpan(order[0].level, len, len));\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"5.17.0\";\n\n  return CodeMirror;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /projects/rede_gsti/resources/~/codemirror/lib/codemirror.js\n ** module id = 80\n ** module chunks = 2\n **/","(function ($) {\n  $.extend($.summernote.lang, {\n    'pt-BR': {\n      font: {\n        bold: 'Negrito',\n        italic: 'Itálico',\n        underline: 'Sublinhado',\n        clear: 'Remover estilo da fonte',\n        height: 'Altura da linha',\n        name: 'Fonte',\n        strikethrough: 'Riscado',\n        size: 'Tamanho da fonte'\n      },\n      image: {\n        image: 'Imagem',\n        insert: 'Inserir imagem',\n        resizeFull: 'Redimensionar Completamente',\n        resizeHalf: 'Redimensionar pela Metade',\n        resizeQuarter: 'Redimensionar um Quarto',\n        floatLeft: 'Flutuar para Esquerda',\n        floatRight: 'Flutuar para Direira',\n        floatNone: 'Não Flutuar',\n        dragImageHere: 'Arraste uma imagem para cá',\n        selectFromFiles: 'Selecione a partir dos arquivos',\n        url: 'URL da imagem'\n      },\n      video: {\n        video: 'Vídeo',\n        videoLink: 'Link para vídeo',\n        insert: 'Inserir vídeo',\n        url: 'URL do vídeo?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion ou Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Inserir link',\n        unlink: 'Remover link',\n        edit: 'Editar',\n        textToDisplay: 'Texto para exibir',\n        url: 'Para qual URL esse link leva?',\n        openInNewWindow: 'Abrir em uma nova janela'\n      },\n      table: {\n        table: 'Tabela'\n      },\n      hr: {\n        insert: 'Inserir linha horizontal'\n      },\n      style: {\n        style: 'Estilo',\n        normal: 'Normal',\n        blockquote: 'Citação',\n        pre: 'Código',\n        h1: 'Título 1',\n        h2: 'Título 2',\n        h3: 'Título 3',\n        h4: 'Título 4',\n        h5: 'Título 5',\n        h6: 'Título 6'\n      },\n      lists: {\n        unordered: 'Lista com marcadores',\n        ordered: 'Lista numerada'\n      },\n      options: {\n        help: 'Ajuda',\n        fullscreen: 'Tela cheia',\n        codeview: 'Ver código-fonte'\n      },\n      paragraph: {\n        paragraph: 'Parágrafo',\n        outdent: 'Menor tabulação',\n        indent: 'Maior tabulação',\n        left: 'Alinhar à esquerda',\n        center: 'Alinhar ao centro',\n        right: 'Alinha à direita',\n        justify: 'Justificado'\n      },\n      color: {\n        recent: 'Cor recente',\n        more: 'Mais cores',\n        background: 'Fundo',\n        foreground: 'Fonte',\n        transparent: 'Transparente',\n        setTransparent: 'Fundo transparente',\n        reset: 'Restaurar',\n        resetToDefault: 'Restaurar padrão'\n      },\n      shortcut: {\n        shortcuts: 'Atalhos do teclado',\n        close: 'Fechar',\n        textFormatting: 'Formatação de texto',\n        action: 'Ação',\n        paragraphFormatting: 'Formatação de parágrafo',\n        documentStyle: 'Estilo de documento'\n      },\n      history: {\n        undo: 'Desfazer',\n        redo: 'Refazer'\n      },\n      help: {\n        'insertParagraph': 'Inserir Parágrafo',\n        'undo': 'Desfazer o último comando',\n        'redo': 'Refazer o último comando',\n        'tab': 'Tab',\n        'untab': 'Desfazer tab',\n        'bold': 'Colocar em negrito',\n        'italic': 'Colocar em itálico',\n        'underline': 'Sublinhado',\n        'strikethrough': 'Tachado',\n        'removeFormat': 'Remover estilo',\n        'justifyLeft': 'Alinhar à esquerda',\n        'justifyCenter': 'Centralizar',\n        'justifyRight': 'Alinhar à esquerda',\n        'justifyFull': 'Justificar',\n        'insertUnorderedList': 'Lista não ordenada',\n        'insertOrderedList': 'Lista ordenada',\n        'outdent': 'Recuar parágrafo atual',\n        'indent': 'Avançar parágrafo atual',\n        'formatPara': 'Alterar formato do bloco para parágrafo(tag P)',\n        'formatH1': 'Alterar formato do bloco para H1',\n        'formatH2': 'Alterar formato do bloco para H2',\n        'formatH3': 'Alterar formato do bloco para H3',\n        'formatH4': 'Alterar formato do bloco para H4',\n        'formatH5': 'Alterar formato do bloco para H5',\n        'formatH6': 'Alterar formato do bloco para H6',\n        'insertHorizontalRule': 'Inserir régua horizontal',\n        'linkDialog.show': 'Inserir um Hiperlink'\n      }\n    }\n  });\n})(jQuery);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /projects/rede_gsti/resources/~/summernote/lang/summernote-pt-BR.js\n ** module id = 81\n ** module chunks = 2\n **/","(function(factory) {\n    /* global define */\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['jquery'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n}(function($) {\n  var embedToSummernote = function (context) {\n    var self = this;\n\n    var options = context.options;\n    var inToolbar = false;\n\n    for (var idx in options.toolbar) {\n      // toolbar => [groupName, [list of button]]\n      var buttons = options.toolbar[idx][1];\n      if ($.inArray('oembed', buttons) > -1) {\n        inToolbar = true;\n        break;\n      }\n    }\n\n    if (!inToolbar) {\n      return;\n    }\n\n    var ui = $.summernote.ui;\n    var $editor = context.layoutInfo.editor;\n    var lang = options.langInfo;\n\n    var oEmbedOptions = {\n      service: 'https://noembed.com/'\n    };\n\n    options.oEmbed = $.extend(oEmbedOptions, options.oEmbed);\n\n    context.memo('button.oembed', function () {\n      var button = ui.button({\n        contents: '<i class=\"note-icon-frame\">',\n        tooltip: lang.oEmbedButton.tooltip,\n        click: function (event) {\n          self.show();\n        }\n      });\n\n      return button.render();\n    });\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n\n      self.showEmbedDialog()\n        .then(function showEmbedDialogCb (data) {\n          context.invoke('editor.restoreRange');\n          self.insertEmbedToEditor(data.uri);\n          ui.hideDialog(self.$dialog);\n        }).fail(function () {\n          context.invoke('editor.restoreRange');\n        });\n    };\n\n    this.showEmbedDialog = function () {\n      self.disableAddButton();\n      self.$embedInput.value = '';\n\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function dialogShownCb () {\n          context.triggerEvent('dialog.shown');\n          self.$embedInput.focus();\n\n          self.$addBtn.on('click', function addEmbedCb (event) {\n            event.preventDefault();\n            deferred.resolve({\n              uri: self.$embedInput.value\n            });\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function dialogHiddenCb () {\n          self.$addBtn.off('click');\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n\n    this.createDialog = function ($container) {\n      var dialogOption = {\n        title: lang.oEmbedDialog.title,\n        body: '<div class=\"form-group\">' +\n        '<label>' + lang.oEmbedDialog.label + '</label>' +\n        '<input id=\"input-autocomplete\" class=\"form-control\" type=\"text\" placeholder=\"' + lang.oEmbedDialog.placeholder + '\" />' +\n        '</div>' +\n        '<div id=\"embed-in-dialog\"></div>',\n        footer: '<button href=\"#\" id=\"btn-add\" class=\"btn btn-primary\">' + lang.oEmbedDialog.button + '</button>',\n        closeOnEscape: true\n      };\n\n      self.$dialog = ui.dialog(dialogOption).render().appendTo($container);\n      self.$addBtn = self.$dialog.find('#btn-add');\n      self.$embedInput = self.$dialog.find('#input-autocomplete')[0];\n      self.$embedContainer = self.$dialog.find('#embed-in-dialog')[0];\n    };\n\n    this.enableAddButton = function() {\n      if (self.$embedInput.value && self.$embedInput.value.length > 0) {\n        self.$addBtn.attr(\"disabled\", false);\n      }\n    };\n\n    this.disableAddButton = function() {\n      self.$addBtn.attr(\"disabled\", true);\n    };\n\n    this.insertEmbedToEditor = function (iframe) {\n      var $div = $('<div>');\n\n\n      $.getJSON(options.oEmbed.service+'?url='+iframe)\n        .done(function (data) {\n          $div.html(self.normalizeEmbed(data.html));\n\n          context.invoke('editor.insertNode', $div[0]);\n          self.$embedContainer.innerHTML = '';\n        });\n    };\n\n    this.normalizeEmbed = function(data){\n\n    if(data){\n      var $div = $('<div>');\n    var $iframe = $(data).find(\"iframe\");\n\n    $div.css({\n      'position': 'relative',\n      'padding-top': '25px',\n      'padding-bottom': '56.25%',\n      'height': '0'\n    });\n    $iframe.css({\n      'position': 'absolute',\n      'top': '0',\n      'left': '0',\n      'width': '100%',\n      'height': '100%'\n    });\n    $iframe.removeAttr(\"width\");\n    $iframe.removeAttr(\"height\");\n\n    $div.html($iframe);\n\n    return $div;\n\n    }  else{\n      console.log(lang);\n      throw new Error(lang.errorMessage.invalid_provider);\n    }\n\n    };\n\n    this.initOembed = function () {\n\n      self.$embedInput.addEventListener('input', function (event) {\n\n        var url = this.value;\n\n        setTimeout(function () {\n          if(options.oEmbed.spinner){\n            self.$embedContainer.innerHTML = options.oEmbed.spinner;\n          }\n\n          $.getJSON(options.oEmbed.service+'?url='+url)\n          .done(function (data) {\n\n              var content;\n              try{\n                content = self.normalizeEmbed(data.html);\n\n              }catch(e){\n\n                content = e.message;\n              }\n\n              $(self.$embedContainer).html(content);\n\n\n            self.enableAddButton();\n          });\n        }, 1000);\n      });\n    };\n\n    this.initialize = function() {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n      self.createDialog($container);\n    };\n\n    this.destroy = function() {\n      ui.hideDialog(self.$dialog);\n      self.$dialog.remove();\n    };\n\n    this.events = {\n      // This will be called after modules are initialized.\n      'summernote.init': function(we, e) {\n        self.initOembed();\n      }\n    };\n\n  };\n\n  $.extend(true, $.summernote, {\n    lang: {\n      'en-US': {\n        oEmbedButton: {\n          tooltip: \"Embed\"\n        },\n        oEmbedDialog: {\n          title: \"Insert Embed\",\n          label: \"Place your embed url link\",\n          placeholder: \"E.g. https://www.youtube.com/watch?v=sJ9HR-kcZHg\",\n          button: \"Insert\"\n        },\n        errorMessage: {\n          invalid_provider: 'Invalid Provider!'\n        }\n      },\n      'pt-BR': {\n        oEmbedButton: {\n          tooltip: \"Adicionar Embed\"\n        },\n        oEmbedDialog: {\n          title: \"Inserir Embed\",\n          label: \"Coloque a url do seu embed\",\n          placeholder: \"Ex.: https://www.youtube.com/watch?v=sJ9HR-kcZHg\",\n          button: \"Inserir\"\n        },\n        errorMessage: {\n          invalid_provider: 'Provedor inválido'\n        }\n      }\n    },\n    plugins: {\n      'oembed': embedToSummernote\n    }\n  });\n}));\n\n\n\n/** WEBPACK FOOTER **\n ** ./vendor/summernote/plugins/summernote-oembed-plugin.js\n **/","(function(factory) {\n    /* global define */\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['jquery'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n}(function($) {\n  'use strict';\n\n  var summernotePrettyprint = function (context) {\n    var self = this;\n    var options = context.options;\n    var inToolbar = false;\n\n    for (var idx in options.toolbar) {\n      var buttons = options.toolbar[idx][1];\n      if ($.inArray('prettyprint', buttons) > -1) {\n        inToolbar = true;\n        break;\n      }\n    }\n\n    if (!inToolbar) { return; }\n\n    var ui = $.summernote.ui;\n    var $editor = context.layoutInfo.editor;\n    var lang = options.langInfo;\n\n    var prettyprintOpitions = {\n\n    };\n\n    options.prettyprint = $.extend(prettyprintOpitions, options.prettyprint);\n\n    context.memo('button.prettyprint', function () {\n      var button = ui.button({\n        contents: '{}',\n        tooltip: lang.button.tooltip,\n        click: function (event) {\n          self.show();\n        }\n      });\n\n      return button.render();\n    });\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n\n      self.showDialog()\n        .then(function showDialogCb (data) {\n          context.invoke('editor.restoreRange');\n          // Insert code prettyprinted into editor\n          // [function here]\n          self.insertToEditor(data);\n          ui.hideDialog(self.$dialog);\n        }).fail(function () {\n          context.invoke('editor.restoreRange');\n        });\n    };\n\n    this.showDialog = function () {\n      self.disableAddButton();\n      self.$code.value = '';\n\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function dialogShownCb () {\n          context.triggerEvent('dialog.shown');\n          self.$codeLanguage.focus();\n\n          self.$addBtn.on('click', function addEmbedCb (event) {\n            event.preventDefault();\n            deferred.resolve({\n              language: self.$codeLanguage.value,\n              code: self.$code.value\n            });\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function dialogHiddenCb () {\n          self.$addBtn.off('click');\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n\n    this.createDialog = function ($container) {\n\n      var languages = [\n          'bsh', 'c', 'cc', 'cpp', 'cs', 'csh', 'cyc', 'cv', 'htm', 'html',\n          'java', 'js', 'm', 'mxml', 'perl', 'pl', 'pm', 'py', 'php', 'rb',\n          'sh', 'xhtml', 'xml', 'xsl'\n      ];\n\n      var select = '<select class=\"form-control\" id=\"code-language\"><option>' + languages.join('</option><option>') + '</option></select>';\n\n      var dialogOption = {\n        title: lang.dialogPrettyfi.title,\n        body: '<div class=\"form-group\">' +\n        '<label>' + lang.dialogPrettyfi.selectLabel + '</label>' +\n        select +\n        '</div>' +\n        '<div class=\"form-group\">' +\n        '<label>' + lang.dialogPrettyfi.codeLabel + '</label>' +\n        '<textarea class=\"form-control\" id=\"code\" rows=\"7\"></textarea>' +\n        '</div>',\n        footer: '<button href=\"#\" id=\"btn-add\" class=\"btn btn-primary\">' + lang.dialogPrettyfi.button + '</button>',\n        closeOnEscape: true\n      };\n\n      self.$dialog = ui.dialog(dialogOption).render().appendTo($container);\n      self.$addBtn = self.$dialog.find('#btn-add');\n      self.$codeLanguage = self.$dialog.find('#code-language')[0];\n      self.$code = self.$dialog.find('#code')[0];\n    };\n\n    this.insertToEditor = function (options) {\n      var innerOptions = {\n        code: '',\n        language: ''\n      };\n\n      var _options = $.extend(innerOptions, options);\n\n      var $node = $('<pre>', {\n        class: 'prettyprint linenums'\n      });\n      var $code = $('<code>');\n      $code.html(_options.code.replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\"));\n      $code.addClass('language-' + _options.language);\n\n      $node.html($code)\n\n      context.invoke('editor.insertNode', $node[0]);\n      self.$code.innerHTML = '';\n    };\n\n    this.enableAddButton = function() {\n      if (!!self.$codeLanguage.value && self.$code.value.length > 0) {\n        self.$addBtn.attr(\"disabled\", false);\n      }\n    };\n\n    this.disableAddButton = function() {\n      self.$addBtn.attr(\"disabled\", true);\n    };\n\n    this.init = function () {\n        self.$code.addEventListener('input', function (event) {\n          self.enableAddButton();\n        }, false);\n        self.$codeLanguage.addEventListener('change', function (event) {\n          self.enableAddButton();\n        }, false);\n    };\n\n    this.initialize = function() {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n      self.createDialog($container);\n    };\n\n    this.destroy = function() {\n      ui.hideDialog(self.$dialog);\n      self.$dialog.remove();\n    };\n\n    this.events = {\n      'summernote.init': function(we, e) {\n        self.init();\n      },\n      'summernote.change': function (we, contents) {\n        if (window.PR) {\n          PR.prettyPrint(contents);\n        } else {\n          prettyPrint(contents);\n        }\n      }\n    };\n  };\n\n  $.extend(true, $.summernote, {\n    lang: {\n      'en-US': {\n        dialogPrettyfi: {\n          title: 'Insert fragment code into editor',\n          selectLabel: 'Choose your language',\n          codeLabel: 'Type your code',\n          button: 'Insert code'\n        },\n        button: {\n          tooltip: 'Insert code'\n        }\n      },\n      'pt-BR': {\n        dialogPrettyfi: {\n          title: 'Adicionar fragmento de código ao editor',\n          selectLabel: 'Escolha a linguagem',\n          codeLabel: 'Digite o seu código aqui',\n          button: 'Inserir código'\n        },\n        button: {\n          tooltip: 'Adicionar código'\n        }\n      }\n    },\n    plugins: {\n      'prettyprint': summernotePrettyprint\n    }\n  });\n}));\n\n\n\n/** WEBPACK FOOTER **\n ** ./vendor/summernote/plugins/summernote-prettyprint-plugin.js\n **/"],"sourceRoot":""}