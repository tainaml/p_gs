{"version":3,"sources":["webpack:///vendor.js","webpack:///./vendor.js","webpack:///./vendor/code-prettify/prettify.js","webpack:////home/anniel/Workspace/rede_gsti/resources/~/summernote/dist/summernote.js","webpack:///(webpack)/buildin/amd-options.js","webpack:////home/anniel/Workspace/rede_gsti/resources/~/codemirror/lib/codemirror.js","webpack:////home/anniel/Workspace/rede_gsti/resources/~/summernote/lang/summernote-pt-BR.js","webpack:///./vendor/summernote/plugins/summernote-oembed-plugin.js","webpack:///./vendor/summernote/plugins/summernote-prettyprint-plugin.js"],"names":["webpackJsonp","0","module","exports","__webpack_require__","78","$","PR","prettyPrint","refreshEditors","call","79","IN_GLOBAL_SCOPE","window","prettyPrintOne","combinePrefixPatterns","regexs","decodeEscape","charsetPart","cc0","charCodeAt","c1","charAt","escapeCharToCodeUnit","parseInt","substring","encodeEscape","charCode","toString","ch","String","fromCharCode","caseFoldCharset","charSet","charsetParts","length","match","RegExp","ranges","inverse","out","push","i","n","p","test","end","start","Math","max","min","sort","a","b","consolidatedRanges","lastRange","range","join","allowAnywhereFoldCaseAndRenumberGroups","regex","parts","source","capturedGroups","groupIndex","decimalValue","capturedGroupIndex","ignoreCase","needToFoldCase","ch0","replace","cc","t","v","f","r","rewritten","global","multiline","Error","extractSourceSpans","node","isPreformatted","walk","type","nodeType","nocode","className","child","firstChild","nextSibling","nodeName","toLowerCase","chunks","k","spans","text","nodeValue","sourceCode","appendDecorations","sourceNode","basePos","langHandler","job","pre","langExtension","numberLines","decorations","apply","childContentWrapper","element","wrapper","undefined","c","notWs","createSimpleLexer","shortcutStylePatterns","fallthroughStylePatterns","tokenizer","shortcuts","allPatterns","concat","allRegexs","regexKeys","patternParts","shortcutChars","hasOwnProperty","nPatterns","decorate","PR_PLAIN","pos","tokens","styleCache","ti","nTokens","isEmbedded","token","style","PR_SOURCE","tokenStart","embeddedSource","embeddedSourceStart","indexOf","embeddedSourceEnd","lang","langHandlerForExtension","sourceDecorator","options","PR_STRING","hc","PR_COMMENT","regexLiterals","regexExcls","regexAny","REGEX_LITERAL","REGEXP_PRECEDER_PATTERN","types","PR_TYPE","keywords","PR_KEYWORD","punctuation","PR_LITERAL","PR_PUNCTUATION","startLineNum","lineBreak","firstLine","index","tail","parent","parentNode","insertBefore","document","createTextNode","breakAfter","removeChild","lineEndNode","breakLeftOf","limit","copy","rightSide","cloneNode","parentClone","next","appendChild","sibling","copiedListItem","listItems","ownerDocument","li","createElement","setAttribute","ol","offset","recombineTagsAndDecorations","isIE8OrEarlier","exec","navigator","userAgent","newlineRe","sourceLength","sourceIndex","nSpans","spanIndex","nDecorations","decorationIndex","decPos","startPos","startDec","oldDisplay","display","styledText","spanEnd","decEnd","textNode","span","replaceChild","registerLangHandler","handler","fileExtensions","ext","langHandlerRegistry","win","console","extension","applyDecorator","opt_langExtension","sourceAndSpans","e","$prettyPrintOne","sourceCodeHtml","opt_numberLines","nl","container","innerHTML","$prettyPrint","opt_whenDone","opt_root","byTagName","tn","root","getElementsByTagName","doWork","endTime","clock","Infinity","elements","cs","attrs","EMPTY","preceder","previousSibling","nt","value","_","name","prettyPrintRe","prettyPrintedRe","nested","tagName","preCodeXmpRe","langExtensionRe","codeRe","preformatted","preformattedTagNameRe","currentStyle","defaultView","doc","whitespace","getComputedStyle","getPropertyValue","lineNums","prettyPrintingJob","setTimeout","body","codeSegments","j","Date","now","FLOW_CONTROL_KEYWORDS","C_KEYWORDS","COMMON_KEYWORDS","CPP_KEYWORDS","JAVA_KEYWORDS","CSHARP_KEYWORDS","COFFEE_KEYWORDS","JSCRIPT_KEYWORDS","PERL_KEYWORDS","PYTHON_KEYWORDS","RUBY_KEYWORDS","SH_KEYWORDS","ALL_KEYWORDS","C_TYPES","PR_TAG","PR_DECLARATION","PR_ATTRIB_NAME","PR_ATTRIB_VALUE","PR_NOCODE","decorateSource","hashComments","cStyleComments","multiLineStrings","verbatimStrings","tripleQuotedStrings","multilineStrings","define","80","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","factory","func","eq","itemA","itemB","eq2","peq2","propName","ok","fail","not","arguments","and","fA","fB","item","self","invoke","obj","method","idCounter","uniqueId","prefix","id","rect2bnd","rect","$document","top","scrollTop","left","scrollLeft","width","right","height","bottom","invertObject","inverted","key","namespaceToCamel","namespace","split","map","toUpperCase","debounce","wait","immediate","timeout","context","this","args","later","callNow","clearTimeout","list","head","array","last","initial","slice","find","pred","idx","len","all","inArray","contains","sum","fn","reduce","memo","from","collection","result","isEmpty","clusterBy","aTail","aLast","compact","aResult","unique","results","prev","isSupportAmd","isFontInstalled","fontName","testFontName","$tester","css","position","fontSize","appendTo","originalWidth","remove","isMSIE","browserVersion","matches","parseFloat","isEdge","hasCodeMirror","CodeMirror","agent","isMac","appVersion","isFF","isPhantom","isWebkit","isChrome","isSafari","jqueryVersion","jquery","isW3CRangeSupport","createRange","NBSP_CHAR","ZERO_WIDTH_NBSP_CHAR","dom","isEditable","hasClass","isControlSizing","makePredByNodeName","isText","isElement","isVoid","isPara","isHeading","isPre","isLi","isPurePara","isTable","isData","isInline","isBodyContainer","isList","isHr","isBlockquote","isCell","isAnchor","isParaInline","ancestor","isBodyInline","isBody","isClosestSibling","nodeA","nodeB","withClosestSiblings","siblings","blankHTML","nodeLength","childNodes","paddingBlankHTML","singleChildAncestor","listAncestor","ancestors","el","lastAncestor","filter","commonAncestor","listPrev","nodes","listNext","listDescendant","descendants","fnWalk","current","wrap","wrapperName","insertAfter","preceding","appendChildNodes","aChild","each","isLeftEdgePoint","point","isRightEdgePoint","isEdgePoint","isLeftEdgeOf","isRightEdgeOf","isLeftEdgePointOf","isRightEdgePointOf","hasChildren","prevPoint","isSkipInnerOffset","nextPoint","isSamePoint","pointA","pointB","isVisiblePoint","leftNode","rightNode","prevPointUntil","nextPointUntil","isCharPoint","walkPoint","startPoint","endPoint","isSkipOffset","makeOffsetPath","reverse","fromOffsetPath","offsets","splitNode","isSkipPaddingBlankHTML","isNotSplitEdgePoint","splitText","childNode","clone","splitTree","splitPoint","splitRoot","topAncestor","pivot","create","createText","isRemoveChild","removeNode","removeWhile","newNode","cssText","isTextarea","$node","stripLinebreaks","val","html","isNewlineOnBlock","markup","regexTag","endSlash","isEndOfInlineContainer","isBlockNode","trim","posFromPlaceholder","placeholder","$placeholder","outerHeight","attachEvents","events","Object","keys","forEach","on","detachEvents","off","blank","emptyPara","isBlock","isDiv","isBR","isSpan","isB","isU","isS","isI","isImg","isEmptyAnchor","Context","$note","ui","summernote","memos","modules","layoutInfo","initialize","createLayout","_initialize","hide","destroy","_destroy","removeData","removeLayout","reset","disabled","isDisabled","code","disable","buttons","extend","plugins","initializeModule","removeModule","removeMemo","isActivated","codable","editable","triggerEvent","attr","enable","callback","callbacks","trigger","shouldInitialize","ModuleClass","withoutIntialize","createInvokeHandler","event","preventDefault","target","closest","data","splits","hasSeparator","moduleName","methodName","isExternalAPICalled","hasInitOptions","langInfo","icons","note","first","focus","Renderer","children","render","$parent","contents","addClass","click","$container","append","renderer","isArray","editor","toolbar","editingArea","statusbar","airEditor","airEditable","buttonGroup","button","tooltip","title","placement","dropdown","items","content","template","dropdownCheck","icon","checkClassName","palette","row","rowSize","colors","eventName","col","colSize","color","dialog","fade","footer","popover","direction","hideArrow","iconClassName","toggleBtn","$btn","isEnable","toggleClass","toggleBtnActive","isActive","onDialogShown","$dialog","one","onDialogHidden","showDialog","modal","hideDialog","$editor","airMode","show","en-US","font","bold","italic","underline","clear","strikethrough","subscript","superscript","size","image","insert","resizeFull","resizeHalf","resizeQuarter","floatLeft","floatRight","floatNone","shapeRounded","shapeCircle","shapeThumbnail","shapeNone","dragImageHere","dropImage","selectFromFiles","maximumFileSize","maximumFileSizeError","url","video","videoLink","providers","link","unlink","edit","textToDisplay","openInNewWindow","table","hr","normal","blockquote","h1","h2","h3","h4","h5","h6","lists","unordered","ordered","help","fullscreen","codeview","paragraph","outdent","indent","center","justify","recent","more","background","foreground","transparent","setTransparent","resetToDefault","shortcut","close","textFormatting","action","paragraphFormatting","documentStyle","extraKeys","insertParagraph","undo","redo","tab","untab","removeFormat","justifyLeft","justifyCenter","justifyRight","justifyFull","insertUnorderedList","insertOrderedList","formatPara","formatH1","formatH2","formatH3","formatH4","formatH5","formatH6","insertHorizontalRule","linkDialog.show","history","specialChar","select","keyMap","BACKSPACE","TAB","ENTER","SPACE","LEFT","UP","RIGHT","DOWN","NUM0","NUM1","NUM2","NUM3","NUM4","NUM5","NUM6","NUM7","NUM8","B","E","I","J","K","L","R","S","U","V","Y","Z","SLASH","LEFTBRACKET","BACKSLASH","RIGHTBRACKET","isEdit","keyCode","isMove","nameFromCode","textRangeToPoint","textRange","isStart","prevContainer","parentElement","tester","createTextRange","moveToElementText","compareEndPoints","textRangeStart","curTextNode","collapse","pointTester","duplicate","setEndPoint","textCount","cont","pointToTextRange","textRangeInfo","isCollapseToStart","prevTextNodes","collapseToStart","info","moveStart","WrappedRange","sc","so","ec","eo","nativeRange","w3cRange","setStart","setEnd","getPoints","getStartPoint","getEndPoint","nativeRng","selection","getSelection","rangeCount","removeAllRanges","addRange","scrollIntoView","offsetTop","abs","normalize","getVisiblePoint","isLeftToRight","block","isCollapsed","includeAncestor","fullyContains","leftEdgeNodes","expand","startAncestor","endAncestor","boundaryPoints","isSameContainer","deleteContents","rng","emptyParents","makeIsOn","isOnEditable","isOnList","isOnAnchor","isOnCell","isOnData","wrapBodyInlineWithPara","inlineSiblings","para","insertNode","pasteHTML","contentsContainer","getWordRange","findAfter","bookmark","s","path","paraBookmark","paras","getClientRects","wrappedRange","createFromSelection","createFromNode","anchorNode","getRangeAt","startContainer","startOffset","endContainer","endOffset","textRangeEnd","isTextNode","createFromNodeBefore","createFromNodeAfter","createFromBookmark","createFromParaBookmark","async","readFileAsDataURL","file","Deferred","deferred","FileReader","onload","dataURL","resolve","onerror","reject","readAsDataURL","promise","createImage","$img","detach","History","$editable","stack","stackOffset","makeSnapshot","emptyBookmark","applySnapshot","snapshot","rewind","recordUndo","Style","jQueryCSS","$obj","propertyNames","propertyName","fromNode","properties","styleInfo","stylePara","styleNodes","expandClosestSibling","onlyPartialContains","nodesInRange","tails","elem","$cont","font-bold","queryCommandState","font-italic","font-underline","font-subscript","font-superscript","font-strikethrough","orderedTypes","isUnordered","lineHeight","toFixed","anchor","Bullet","toggleList","clustereds","wrapList","releaseList","listName","wrappedParas","diffLists","listNode","prevList","nextList","isEscapseToBody","releasedParas","headList","lastList","middleList","rootLists","rootList","listNodes","Typing","bullet","insertTab","tabsize","Array","nextPara","emptyAnchors","Table","isShift","cell","cells","nextCell","createTable","colCount","rowCount","tdHTML","tds","idxCol","trHTML","trs","idxRow","$table","tableClassName","KEY_BOGUS","Editor","typing","isDefaultPrevented","handleKeyMap","preventDefaultEditableShortCuts","changeEventName","outerWidth","maxHeight","minHeight","metaKey","ctrlKey","altKey","shiftKey","keyName","afterCommand","saveRange","thenCollapse","restoreRange","saveTarget","clearTarget","restoreTarget","styleFromNode","beforeCommand","isPreventTrigger","commands","sCmd","execCommand","tabSize","wrapCommand","insertImage","src","param","then","$image","insertImages","files","filename","maximumImageFileSize","insertImagesOrCallback","onImageUpload","insertText","getSelectedText","formatBlock","firstSpan","font-size","hrNode","removeBogus","bogusNode","bogusCharIdx","deleteData","createLink","linkInfo","linkUrl","linkText","isNewWindow","isTextChanged","onCreateLink","anchors","removeAttr","startRange","endRange","getLinkInfo","$anchor","colorInfo","foreColor","backColor","insertTable","dim","dimension","floatMe","$target","resize","resizeTo","bKeepRatio","imageSize","newRatio","y","x","ratio","removeMedia","hasFocus","is","empty","Clipboard","summernote.keydown","we","needKeydownHook","$paste","pasteByHook","opacity","before","pasteByEvent","dataURI","decodedData","atob","Uint8Array","blob","Blob","pasteContent","clipboardData","originalEvent","kind","getAsFile","Dropzone","documentEventHandlers","$dropzone","prependTo","detachDocumentEvent","substr","disableDragAndDrop","onDrop","attachDragAndDropEvent","$dropzoneMessage","onDragenter","isCodeview","hasEditorSize","add","onDragleave","removeClass","dataTransfer","getData","__WEBPACK_AMD_REQUIRE_ARRAY__","cm","Codeview","$codable","sync","save","toggle","deactivate","activate","prettifyHtml","cmEditor","fromTextArea","codemirror","tern","server","TernServer","ternServer","updateArgHints","setSize","getValue","toTextArea","isChange","EDITABLE_PADDING","Statusbar","$statusbar","disableResizeEditor","stopPropagation","editableTop","clientY","minheight","Fullscreen","$toolbar","$window","$scrollbar","h","setsize","isFullscreen","Handle","$editingArea","summernote.mousedown","update","summernote.keyup summernote.scroll summernote.change summernote.dialog.shown","$handle","disableResizeImage","posStart","clientX","isImage","$selection","w","sizingText","AutoLink","defaultScheme","linkPattern","summernote.keyup","handleKeyup","handleKeydown","lastWordRange","keyword","wordRange","AutoSync","summernote.change","Placeholder","summernote.init summernote.change","summernote.codeview.toggled","isShow","Buttons","invertedKeyMap","representShortcut","editorMethod","addToolbarButtons","addImagePopoverButtons","addLinkPopoverButtons","fontInstalledMap","fontNamesIgnoreCheck","magic","caret","styleTags","tag","eraser","menuCheck","fontNames","fontSizes","$button","currentTarget","$recentColor","$dropdown","$holder","$color","$currentButton","unorderedlist","orderedlist","alignLeft","alignCenter","alignRight","alignJustify","textHeight","lineHeights","$catcher","insertTableMaxSize","mousedown","tableMoveHandler","picture","minus","arrowsAlt","question","trash","build","groups","groupIdx","groupLen","group","groupName","$group","updateCurrentStyle","updateBtnStates",".note-btn-bold",".note-btn-italic",".note-btn-underline",".note-btn-subscript",".note-btn-superscript",".note-btn-strikethrough","isChecked","infos","selector","posOffset","PX_PER_EM","$picker","$dimensionDisplay","$highlighted","$unhighlighted","offsetX","posCatcher","pageX","pageY","offsetY","ceil","Toolbar","toolbarContainer","updateFullscreen","updateCodeview","isIncludeCodeview","LinkDialog","dialogsInBody","disableLinkTarget","dialogsFade","bindEnterKey","$input","toggleLinkBtn","$linkBtn","$linkText","$linkUrl","showLinkDialog","$openInNewWindow","handleLinkTextUpdate","handleLinkUrlUpdate","prop","state","LinkPopover","summernote.keyup summernote.mouseup summernote.change summernote.scroll","summernote.dialog.shown","$popover","$content","prepend","href","ImageDialog","imageLimitation","unit","floor","log","readableSize","pow","showImageDialog","$imageInput","$imageUrl","$imageBtn","replaceWith","ImagePopover","VideoDialog","createVideoNode","$video","ytRegExp","ytMatch","igRegExp","igMatch","vRegExp","vMatch","vimRegExp","vimMatch","dmRegExp","dmMatch","youkuRegExp","youkuMatch","mp4RegExp","mp4Match","oggRegExp","oggMatch","webmRegExp","webmMatch","youtubeId","showVideoDialog","$videoUrl","$videoBtn","HelpDialog","createShortCutList","command","$row","margin-right","max-height","overflow","showHelpDialog","AirPopover","AIR_MODE_POPOVER_X_OFFSET","summernote.keyup summernote.mouseup summernote.scroll","summernote.change summernote.dialog.shown","summernote.focusout","relatedTarget","air","bnd","HintPopover","POPOVER_DIST","hint","hintDirection","hints","selectItem","$item","innerHeight","moveDown","$current","$next","$nextGroup","moveUp","$prev","$prevGroup","nodeFromItem","createItemTemplates","hintIdx","searchKeyword","search","createGroup","version","clipboard","dropzone","handle","hintPopover","autoLink","autoSync","linkDialog","linkPopover","imageDialog","imagePopover","videoDialog","helpDialog","airPopover","styleWithSpan","textareaAutoSync","onInit","onFocus","onBlur","onEnter","onKeyup","onKeydown","onImageUploadError","mode","htmlMode","lineNumbers","pc","CTRL+Z","CTRL+Y","SHIFT+TAB","CTRL+B","CTRL+I","CTRL+U","CTRL+SHIFT+S","CTRL+BACKSLASH","CTRL+SHIFT+L","CTRL+SHIFT+E","CTRL+SHIFT+R","CTRL+SHIFT+J","CTRL+SHIFT+NUM7","CTRL+SHIFT+NUM8","CTRL+LEFTBRACKET","CTRL+RIGHTBRACKET","CTRL+NUM0","CTRL+NUM1","CTRL+NUM2","CTRL+NUM3","CTRL+NUM4","CTRL+NUM5","CTRL+NUM6","CTRL+ENTER","CTRL+K","mac","CMD+Z","CMD+SHIFT+Z","CMD+B","CMD+I","CMD+U","CMD+SHIFT+S","CMD+BACKSLASH","CMD+SHIFT+L","CMD+SHIFT+E","CMD+SHIFT+R","CMD+SHIFT+J","CMD+SHIFT+NUM7","CMD+SHIFT+NUM8","CMD+LEFTBRACKET","CMD+RIGHTBRACKET","CMD+NUM0","CMD+NUM1","CMD+NUM2","CMD+NUM3","CMD+NUM4","CMD+NUM5","CMD+NUM6","CMD+ENTER","CMD+K","align","circle","frame","pencil","square","81","__webpack_amd_options__","82","mod","place","copyObj","defaults","setGuttersForLineNumbers","Doc","lineSeparator","input","inputStyles","inputStyle","Display","updateGutters","themeChanged","lineWrapping","autofocus","mobile","initScrollbars","keyMaps","overlays","modeGen","overwrite","delayingBlurEvent","focused","suppressEdits","pasteIncoming","cutIncoming","selectingText","draggingText","highlight","Delayed","keySeq","specialChars","ie","ie_version","registerEventHandlers","ensureGlobalHandlers","startOperation","curOp","forceUpdate","attachDoc","bind","opt","optionHandlers","Init","maybeUpdateLineNumberWidth","finishInit","initHooks","endOperation","webkit","lineDiv","textRendering","d","scrollbarFiller","elt","gutterFiller","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","mover","sizer","sizerWidth","heightForcer","scrollerGap","gutters","lineGutter","scroller","zIndex","paddingRight","gecko","draggable","viewFrom","viewTo","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","activeTouch","init","loadMode","getMode","modeOption","resetModeState","iter","line","stateAfter","styles","frontier","startWorker","regChange","wrappingChanged","minWidth","rmClass","findMaxLine","estimateLineHeights","clearCaches","updateScrollbars","estimateHeight","th","wrapping","perLine","clientWidth","charWidth","lineIsHidden","widgetsHeight","widgets","est","estHeight","updateLineHeight","theme","guttersChanged","alignHorizontally","specs","removeChildren","gutterClass","gElt","updateGutterSpace","offsetWidth","marginLeft","lineLength","merged","cur","collapsedSpanAtStart","found","to","collapsedSpanAtEnd","getLine","splice","measureForScrollbars","gutterW","docH","round","paddingVert","clientHeight","viewHeight","scrollWidth","viewWidth","barLeft","fixedGutter","docHeight","scrollHeight","scrollGap","gutterWidth","NativeScrollbars","scroll","vert","horiz","checkedZeroWidth","NullScrollbars","scrollbars","scrollbarModel","scrollbarStyle","axis","setScrollLeft","setScrollTop","startWidth","startHeight","updateScrollbarsInner","updateHeightsInViewport","sizes","paddingBottom","borderBottom","coverGutterNextToScrollbar","visibleLines","viewport","paddingTop","lineAtHeight","ensure","ensureFrom","ensureTo","heightAtLine","lastLine","comp","compensateForHScroll","hidden","gutter","gutterBackground","alignable","lineNumberFor","innerW","padding","lineNumberFormatter","firstLineNumber","getBoundingClientRect","DisplayUpdate","force","visible","editorIsHidden","wrapperHeight","wrapperWidth","oldDisplayWidth","displayWidth","dims","getDimensions","maybeClipScrollbars","marginBottom","borderRightWidth","updateDisplayIfNeeded","resetView","countDirtyView","viewportMargin","sawCollapsedSpans","visualLineNo","visualLineEndNo","different","adjustView","toUpdate","activeElt","patchDisplay","offsetHeight","postUpdateDisplay","displayHeight","barMeasure","updateSelection","setDocumentHeight","signal","updateDisplaySimple","finish","prevBottom","bot","box","diff","updateWidgetHeight","rest","gutterLeft","clientLeft","offsetLeft","fixedPos","gutterTotalWidth","updateNumbersFrom","rm","currentWheelTarget","lineN","lineView","updateNumber","lineNumber","changes","updateLineForChanges","buildLineElement","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","updateLineBackground","cls","bgClass","getLineContent","built","buildLineContent","textClass","wrapClass","markers","gutterMarkers","gutterWrap","setUneditable","insertLineWidgets","insertLineWidgetsFor","allowAbove","ws","widget","handleMouseEvents","positionLineWidget","above","signalLater","noHScroll","coverGutter","paddingLeft","copyPos","Pos","maxPos","cmp","minPos","ensureFocus","applyTextInput","inserted","deleted","sel","origin","paste","textLines","splitLines","multiPaste","lastCopied","l","lst","lineWise","updateInput","changeEvent","makeChange","triggerElectric","ensureCursorVisible","handlePaste","pasted","isReadOnly","disableInput","runInOp","electricChars","smartIndent","getModeAt","indented","indentLine","electricInput","copyableRanges","lineRange","getRange","disableBrowserMagic","field","spellcheck","TextareaInput","prevInput","pollingFast","polling","inaccurateSelection","hasSelection","composing","hiddenTextarea","te","div","ios","border","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","gracePeriod","posToDOM","findViewForLine","mapFromLineView","order","getOrder","side","partPos","getBidiPartAt","nodeAndOffsetInLineMap","badPos","bad","domToPos","lineNode","clipPos","locateNodeInLineView","topNode","maps","curNode","lineNo","after","dist","textContent","domTextBetween","fromLine","toLine","recognizeMarker","marker","cmText","getAttribute","markerID","findMarks","getBetween","lineSep","closing","Selection","primIndex","Range","normalizeSelection","prim","inv","simpleSelection","clipLine","clipToLen","linelen","isLine","clipPosArray","extendRange","other","posBefore","extendSelection","setSelection","primary","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","filterSelectionChange","setSelectionReplaceHistory","done","setSelectionNoUndo","addSelectionToHistory","NaN","hasHandler","bias","setSelectionInner","skipAtomicInSelection","equals","selectionChanged","signalCursorActivity","reCheckSelection","sel_dontScroll","mayClear","old","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","dir","markedSpans","sp","m","inclusiveLeft","inclusiveRight","explicitlyCleared","atomic","near","movePos","far","cantEdit","showSelection","prepareSelection","curFragment","cursors","createDocumentFragment","selFragment","collapsed","showCursorWhenSelecting","drawSelectionCursor","drawSelectionRange","output","cursorCoords","singleCursorHeightPerLine","cursor","cursorHeight","otherCursor","fragment","drawForLine","fromArg","toArg","coords","charCoords","lineObj","lineLen","iterateBidiSections","rightPos","leftPos","tmp","leftSide","paddingH","sFrom","sTo","singleVLine","visualLine","leftEnd","rightStart","restartBlink","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","time","startState","set","highlightWorker","workTime","copyState","getStateBefore","changedLines","oldStyles","tooLong","maxHighlightLength","highlighted","highlightLine","oldCls","styleClasses","newCls","classes","ischange","processLine","workDelay","regLineChange","findStartLine","precise","minindent","minline","lim","innerMode","countColumn","removeChildrenAndAdd","isNaN","ensureLineHeights","curWidth","heights","rects","cache","caches","updateExternalMeasurement","LineView","measureChar","measureCharPrepared","prepareMeasureForLine","findViewIndex","hasHeights","prepared","varHeight","measureCharInner","bogus","rtop","rbottom","mStart","mEnd","insertLeft","coverStart","coverEnd","getUsefulRect","nullRect","isExtendingChar","maybeUpdateRectForZooming","rSpan","rbot","mid","screen","logicalXDPI","deviceXDPI","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","pageScrollX","pageXOffset","documentElement","pageScrollY","pageYOffset","intoCoordSystem","widgetHeight","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","preparedMeasure","get","getBidi","part","level","bidiLeft","bidiRight","bidiOther","estimateCoords","PosWithInfo","outside","xRel","coordsChar","coordsCharInner","mergedPos","getX","wrongLine","innerOff","adjust","bidi","lineLeft","lineRight","fromX","fromOutside","toX","toOutside","moveVisually","xDiff","charSize","step","middle","middleX","measureText","viewChanged","changeObjs","cursorActivityHandlers","cursorActivityCalled","updateMaxLine","scrollToPos","nextOpId","operationGroup","ops","ownsGroup","delayedCallbacks","fireCallbacksForOps","op","endOperations","endOperation_R1","endOperation_W1","endOperation_R2","endOperation_W2","endOperation_finish","mustUpdate","updatedDisplay","adjustWidthTo","maxScrollLeft","preparedSelection","takeFocus","forceScroll","scrollPosIntoView","margin","isCursor","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","lines","operation","methodOp","docMethodOp","visualLineContinued","buildViewArray","nextPos","lendiff","cut","viewCuttingPoint","cutTop","cutBot","arr","oldN","newN","dirty","finishTouch","touchFinished","prevTouch","isMouseLikeTouchEvent","touches","touch","radiusX","radiusY","farAway","dx","dy","onMouseDown","signalDOMEvent","posFromMouse","clickInGutter","eventInWidget","e_preventDefault","word","findWordAt","captureRightClick","onContextMenu","moved","onScrollWheel","dragFunctions","enter","e_stop","over","onDragOver","onDragStart","drop","leave","clearDragCursor","inp","getField","onKeyUp","onKeyDown","onKeyPress","dragDropChanged","wasOn","funcs","onResize","e_target","liberal","forRect","space","colDiff","supportsTouch","e_button","leftButtonDown","lastMiddleDown","delayBlurEvent","lastDoubleClick","lastClick","contained","modifier","dragDrop","dragAndDrop","leftButtonStartDrag","leftButtonSelect","startTime","dragEnd","e2","addNew","extendTo","lastPos","startCol","posCol","findColumn","startSel","ourIndex","oldRange","ourRange","sel_mouse","curCount","counter","editorSize","move","up","lastSelOrigin","chromeOS","gutterEvent","prevent","mX","mY","lineBox","e_defaultPrevented","g","lastDrop","File","read","loadFile","allowDropFileTypes","reader","change","changeEnd","readAsText","selected","listSelections","replaceRange","replaceSelection","setData","effectAllowed","setDragImage","safari","img","presto","_top","frag","dragCursor","isScroller","delta","wheelEventDelta","canScrollX","canScrollY","outer","wheelPixelsPerUnit","pixels","wheelSamples","movedX","movedY","sample","doHandleBinding","bound","dropShift","ensurePolled","prevShift","Pass","lookupKeyForEditor","lookupKey","dispatchKey","seq","isModifierKey","stopSeq","handleKeyBinding","motion","handleCharBinding","returnValue","handled","lastStoppedKey","hasCopyEvent","showCrossHair","which","readOnly","receivedFocus","contextMenuInGutter","adjustForChange","computeSelAfterChange","offsetPos","nw","computeReplacedSel","oldPrev","newPrev","filterChange","canceled","cancel","ignoreReadOnly","sawReadOnlySpans","removeReadOnlyRanges","makeChangeInner","selAfter","addChangeToHistory","makeChangeSingleDoc","stretchSpansOverChange","rebased","linkedDocs","sharedHist","rebaseHist","makeChangeFromHistory","allowSelectionOnly","hist","undone","dest","lastOrigin","pop","pushSelectionToHistory","clearRedo","antiChanges","generation","maxGeneration","historyChangeFromChange","mergeOldSpans","shiftDoc","distance","removed","makeChangeSingleDocInEditor","updateDoc","recomputeMaxLength","checkWidthStart","full","isWholeLineUpdate","changesHandler","changeHandler","doScroll","phantom","scrollNode","changed","endCoords","scrollPos","calculateScrollPos","startTop","startLeft","x1","y1","x2","y2","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollPos","resolveScrollToPos","getCursor","cursorScrollMargin","sPos","scrollTo","how","aggressive","curSpace","indentation","curSpaceString","indentUnit","indentString","indentWithTabs","spaceStr","changeLine","changeType","no","deleteNearSelection","compute","kill","toKill","replaced","findPosH","visually","findNextLine","moveOnce","boundToLine","moveLogically","origDir","sawType","helper","getHelper","isWordChar","hitSide","findPosV","pageSize","moveAmount","option","deflt","notOnInit","normalizeKeyName","alt","ctrl","cmd","getKeyMap","markText","shared","markTextShared","TextMarker","clearWhenEmpty","replacedWith","widgetNode","conflictingCollapsedRange","addToHistory","curLine","addMarkedSpan","MarkedSpan","clearOnEnter","clearHistory","nextMarkerId","startStyle","endStyle","linked","isParent","SharedTextMarker","findSharedMarkers","copySharedMarkers","mFrom","mTo","subMark","detachSharedMarkers","subMarker","getMarkedSpanFor","removeMarkedSpan","attachLine","markedSpansBefore","startCh","isInsert","startsBefore","endsAfter","markedSpansAfter","endCh","oldFirst","oldLast","sameLine","clearEmptySpans","newMarkers","gapMarkers","gap","getOldSpans","stretched","oldCur","stretchCur","mark","mk","newParts","dfrom","dto","detachMarkedSpans","detachLine","attachMarkedSpans","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","vis","lineIsHiddenInner","adjustScrollWhenAboveVisible","parentStyle","addLineWidget","LineWidget","insertAt","aboveVisible","updateLine","cleanUpLine","extractLineClasses","lineClass","callBlankLine","blankLine","inner","readToken","stream","takeToken","asArray","getObj","string","StringStream","eol","runMode","lineClasses","forceToEnd","flattenSpans","curStart","curStyle","addModeClass","mName","st","o","overlay","at","i_end","opaque","getLineStyles","updateFrontier","startAt","interpretTokenStyle","styleToClassCacheWithMode","styleToClassCache","builder","trailingSpace","splitSpaces","getOption","addToken","buildToken","hasBadBidiRects","buildTokenBadBidi","allowFrontierUpdate","insertLineContent","joinClasses","zeroWidthElement","lastChild","querySelector","defaultSpecialCharPlaceholder","displayText","special","mustWrap","lastIndex","skipped","txt","tabWidth","specialCharPlaceholder","fullStyle","trailingBefore","spaceBefore","buildCollapsedSpan","ignoreWidget","needsContentAttribute","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","endStyles","foundBookmarks","upto","tokenText","wholeLineUpdateBefore","spansFor","linesFor","Line","lastText","lastSpans","nlines","added","LeafChunk","BranchChunk","chunkSize","sharedHistOnly","propagate","skip","rel","chunk","sz","getLines","lh","bidiOrdering","startGen","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","histChange","attachLocalSpans","clearSelectionEvents","lastChangeEvent","opId","historyEventDelay","selectionEventCanBeMerged","somethingSelected","existing","removeClearedSpans","copyHistoryArray","newGroup","instantiateSel","prototype","deepCopy","newChanges","Number","rebaseHistSelSingle","rebaseHistArray","sub","copied","defaultPrevented","srcElement","getHandlers","emitter","_handlers","noHandlers","orphanDelayedCallbacks","fireOrphanDelayed","delayed","override","codemirrorIgnore","cursorActivity","eventMixin","ctor","spaceStrs","insertSorted","score","priority","nothing","createObj","base","props","inst","isWordCharBasic","extendingChars","count","activeElement","classTest","as","forEachCodeMirror","getElementsByClassName","byClass","globalsRegistered","registerGlobalHandlers","resizeTimer","zwspSupported","badBidiRects","r0","r1","badZoomedRects","fromRange","lineStart","visual","lineEnd","lineStartSmart","firstNonWS","inWS","compareBidiLevel","linedir","moveInLine","byUnit","platform","ie_upto10","ie_11up","documentMode","qtwebkit","chrome","vendor","mac_geMountainLion","windows","presto_version","flipCtrlCmd","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","pointerEvents","bar","delay","maybeDisable","elementFromPoint","native","null","cmpPos","prepareCopyCut","getSelections","selectInput","lineWiseCopyCut","setSelections","textarea","poll","fastPoll","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","minimal","blur","resetPosition","slowPoll","pollInterval","missed","same","prepareSelectAllHack","selectionStart","extval","selectionEnd","rehide","oldWrapperCSS","oldCSS","selectAll","detectingSelectAll","resetSelectionOnContextMenu","wrapperBox","oldScrollY","scrollY","mouseup","readOnlyChanged","onCopyCut","clearData","kludge","hadFocus","showPrimarySelection","pollContent","startData","ours","applyComposition","forceCompositionEnd","showMultipleSelections","curAnchor","anchorOffset","curFocus","focusNode","focusOffset","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","pollSelection","fromIndex","toIndex","toNode","newText","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","contenteditable","here","there","wheelDeltaX","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","constructor","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","spec","modeSpec","removeOverlay","indentSelection","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","helpers","helperType","_global","getStateAfter","defaultTextHeight","defaultCharWidth","setGutterMarker","gutterID","clearGutter","lineInfo","getViewport","addWidget","vspace","hspace","triggerOnKeyDown","triggerOnKeyPress","triggerOnKeyUp","amount","moveH","extendSelectionsBy","rtlMoveVisually","sel_move","deleteH","goalColumn","moveV","goals","startChar","check","toggleOverwrite","getScrollInfo","interpret","refresh","oldHeight","swapDoc","getInputField","getWrapperElement","getScrollerElement","getGutterElement","setValue","newBreaks","attach","integer","tabIndex","modes","mimeModes","defineMode","dependencies","defineMIME","mime","resolveMode","mfactory","modeObj","modeExtensions","exts","modeProps","skipToEnd","extendMode","defineExtension","defineDocExtension","defineOption","defineInitHook","registerHelper","registerGlobalHelper","predicate","nstate","a1","a2","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","delWrappedLineRight","undoSelection","redoSelection","goDocStart","goDocEnd","goLineStart","goLineStartSmart","goLineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","goLineDown","goPageUp","goPageDown","goCharLeft","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentMore","indentLess","insertSoftTab","spaces","replaceSelections","defaultTab","transposeChars","newlineAndIndent","openLine","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","fallthrough","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","normalizeKeyMap","keymap","keyname","keyNames","noShift","altGraphKey","tabindex","form","leaveSubmitMethodAlone","realSubmit","submit","wrappedSubmit","getTextArea","lastColumnPos","lastColumnValue","sol","peek","eat","eatWhile","eatSpace","skipTo","backUp","column","pattern","consume","caseInsensitive","cased","str","hideFirstChars","withOp","dHeight","oldH","removeInner","insertInner","iterN","remaining","leaf","maybeSpill","me","spilled","myIndex","used","nextDocId","cleanGeneration","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","setCursor","addSelection","dup","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","addLineClass","where","removeLineClass","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","unlinkDoc","splitIds","iterLinkedDocs","getEditor","splitLinesAuto","eachLine","dontDelegate","e_stopPropagation","cancelBubble","addEventListener","attachEvent","removeEventListener","detachEvent","handlers","ms","startIndex","startValue","nextTab","goal","_e","nonASCIISingleCaseWordChar","endNode","moveEnd","host","rt","oncopy","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","127","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","charType","lowTypes","arabicTypes","BidiSpan","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","outerType","nstart","unshift","83","jQuery","pt-BR","84","embedToSummernote","inToolbar","oEmbedOptions","service","oEmbed","oEmbedButton","showEmbedDialog","insertEmbedToEditor","uri","disableAddButton","$embedInput","$addBtn","createDialog","dialogOption","oEmbedDialog","label","closeOnEscape","$embedContainer","enableAddButton","iframe","$div","getJSON","normalizeEmbed","$iframe","padding-top","padding-bottom","errorMessage","invalid_provider","initOembed","spinner","message","summernote.init","oembed","85","summernotePrettyprint","prettyprintOpitions","languages","prettyprint","insertToEditor","$code","$codeLanguage","language","dialogPrettyfi","selectLabel","codeLabel","innerOptions","_options","class"],"mappings":"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","file":"vendor.js","sourcesContent":["webpackJsonp([2],{\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(78);\n\n\n/***/ },\n\n/***/ 78:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function($) {'use strict';\n\t\n\t__webpack_require__(79);\n\t__webpack_require__(80);\n\t__webpack_require__(83);\n\t__webpack_require__(84);\n\t__webpack_require__(85);\n\t__webpack_require__(47);\n\t\n\tPR.prettyPrint();\n\t$('[data-target=\"container-editor\"]').refreshEditors();\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n\n/***/ 79:\n/***/ function(module, exports) {\n\n\t/**\n\t * @license\n\t * Copyright (C) 2006 Google Inc.\n\t *\n\t * Licensed under the Apache License, Version 2.0 (the \"License\");\n\t * you may not use this file except in compliance with the License.\n\t * You may obtain a copy of the License at\n\t *\n\t *      http://www.apache.org/licenses/LICENSE-2.0\n\t *\n\t * Unless required by applicable law or agreed to in writing, software\n\t * distributed under the License is distributed on an \"AS IS\" BASIS,\n\t * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\t * See the License for the specific language governing permissions and\n\t * limitations under the License.\n\t */\n\t\n\t/**\n\t * @fileoverview\n\t * some functions for browser-side pretty printing of code contained in html.\n\t *\n\t * <p>\n\t * For a fairly comprehensive set of languages see the\n\t * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n\t * file that came with this source.  At a minimum, the lexer should work on a\n\t * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n\t * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n\t * and a subset of Perl, but, because of commenting conventions, doesn't work on\n\t * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n\t * <p>\n\t * Usage: <ol>\n\t * <li> include this source file in an html page via\n\t *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n\t * <li> define style rules.  See the example page for examples.\n\t * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n\t *    {@code class=prettyprint.}\n\t *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n\t *    printer needs to do more substantial DOM manipulations to support that, so\n\t *    some css styles may not be preserved.\n\t * </ol>\n\t * That's it.  I wanted to keep the API as simple as possible, so there's no\n\t * need to specify which language the code is in, but if you wish, you can add\n\t * another class to the {@code <pre>} or {@code <code>} element to specify the\n\t * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n\t * starts with \"lang-\" followed by a file extension, specifies the file type.\n\t * See the \"lang-*.js\" files in this directory for code that implements\n\t * per-language file handlers.\n\t * <p>\n\t * Change log:<br>\n\t * cbeust, 2006/08/22\n\t * <blockquote>\n\t *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n\t * </blockquote>\n\t * @requires console\n\t */\n\t\n\t// JSLint declarations\n\t/*global console, document, navigator, setTimeout, window, define */\n\t\n\t/**\n\t * {@type !{\n\t *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n\t *   'registerLangHandler': function (function (JobT), Array.<string>),\n\t *   'PR_ATTRIB_NAME': string,\n\t *   'PR_ATTRIB_NAME': string,\n\t *   'PR_ATTRIB_VALUE': string,\n\t *   'PR_COMMENT': string,\n\t *   'PR_DECLARATION': string,\n\t *   'PR_KEYWORD': string,\n\t *   'PR_LITERAL': string,\n\t *   'PR_NOCODE': string,\n\t *   'PR_PLAIN': string,\n\t *   'PR_PUNCTUATION': string,\n\t *   'PR_SOURCE': string,\n\t *   'PR_STRING': string,\n\t *   'PR_TAG': string,\n\t *   'PR_TYPE': string,\n\t *   'prettyPrintOne': function (string, string, number|boolean),\n\t *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n\t * }}\n\t * @const\n\t */\n\t/**\n\t* @typedef {!Array.<number|string>}\n\t* Alternating indices and the decorations that should be inserted there.\n\t* The indices are monotonically increasing.\n\t*/\n\t\"use strict\";\n\t\n\tvar DecorationsT;\n\t\n\t/**\n\t* @typedef {!{\n\t*   sourceNode: !Element,\n\t*   pre: !(number|boolean),\n\t*   langExtension: ?string,\n\t*   numberLines: ?(number|boolean),\n\t*   sourceCode: ?string,\n\t*   spans: ?(Array.<number|Node>),\n\t*   basePos: ?number,\n\t*   decorations: ?DecorationsT\n\t* }}\n\t* <dl>\n\t*  <dt>sourceNode<dd>the element containing the source\n\t*  <dt>sourceCode<dd>source as plain text\n\t*  <dt>pre<dd>truthy if white-space in text nodes\n\t*     should be considered significant.\n\t*  <dt>spans<dd> alternating span start indices into source\n\t*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n\t*     span.\n\t*  <dt>decorations<dd>an array of style classes preceded\n\t*     by the position at which they start in job.sourceCode in order\n\t*  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n\t*     source.\n\t* </dl>\n\t*/\n\tvar JobT;\n\t\n\t/**\n\t* @typedef {!{\n\t*   sourceCode: string,\n\t*   spans: !(Array.<number|Node>)\n\t* }}\n\t* <dl>\n\t*  <dt>sourceCode<dd>source as plain text\n\t*  <dt>spans<dd> alternating span start indices into source\n\t*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n\t*     span.\n\t* </dl>\n\t*/\n\tvar SourceSpansT;\n\t\n\t/** @define {boolean} */\n\tvar IN_GLOBAL_SCOPE = false;\n\t\n\tvar PR;\n\t\n\t/**\n\t * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n\t * UI events.\n\t * If set to {@code false}, {@code prettyPrint()} is synchronous.\n\t */\n\twindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\t\n\t/**\n\t * Pretty print a chunk of code.\n\t * @param {string} sourceCodeHtml The HTML to pretty print.\n\t * @param {string} opt_langExtension The language name to use.\n\t *     Typically, a filename extension like 'cpp' or 'java'.\n\t * @param {number|boolean} opt_numberLines True to number lines,\n\t *     or the 1-indexed number of the first line in sourceCodeHtml.\n\t * @return {string} code as html, but prettier\n\t */\n\tvar prettyPrintOne;\n\t/**\n\t * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n\t * {@code class=prettyprint} and prettify them.\n\t *\n\t * @param {Function} opt_whenDone called when prettifying is done.\n\t * @param {HTMLElement|HTMLDocument} opt_root an element or document\n\t *   containing all the elements to pretty print.\n\t *   Defaults to {@code document.body}.\n\t */\n\tvar prettyPrint;\n\t\n\t(function () {\n\t  var win = window;\n\t  // Keyword lists for various languages.\n\t  // We use things that coerce to strings to make them compact when minified\n\t  // and to defeat aggressive optimizers that fold large string constants.\n\t  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n\t  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"auto,case,char,const,default,\" + \"double,enum,extern,float,goto,inline,int,long,register,short,signed,\" + \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n\t  var COMMON_KEYWORDS = [C_KEYWORDS, \"catch,class,delete,false,import,\" + \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n\t  var CPP_KEYWORDS = [COMMON_KEYWORDS, \"alignof,align_union,asm,axiom,bool,\" + \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" + \"dynamic_cast,explicit,export,friend,generic,late_check,\" + \"mutable,namespace,nullptr,property,reinterpret_cast,static_assert,\" + \"static_cast,template,typeid,typename,using,virtual,where\"];\n\t  var JAVA_KEYWORDS = [COMMON_KEYWORDS, \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" + \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" + \"throws,transient\"];\n\t  var CSHARP_KEYWORDS = [COMMON_KEYWORDS, \"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,\" + \"dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,\" + \"internal,into,is,let,lock,null,object,out,override,orderby,params,\" + \"partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,\" + \"unchecked,unsafe,ushort,var,virtual,where\"];\n\t  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" + \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" + \"throw,true,try,unless,until,when,while,yes\";\n\t  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS, \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" + \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" + \"yield,Infinity,NaN\"];\n\t  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" + \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" + \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n\t  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" + \"elif,except,exec,finally,from,global,import,in,is,lambda,\" + \"nonlocal,not,or,pass,print,raise,try,with,yield,\" + \"False,True,None\"];\n\t  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" + \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" + \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" + \"BEGIN,END\"];\n\t  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" + \"function,in,local,set,then,until\"];\n\t  var ALL_KEYWORDS = [CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS, PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n\t  var C_TYPES = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\t\n\t  // token style names.  correspond to css classes\n\t  /**\n\t   * token style for a string literal\n\t   * @const\n\t   */\n\t  var PR_STRING = 'str';\n\t  /**\n\t   * token style for a keyword\n\t   * @const\n\t   */\n\t  var PR_KEYWORD = 'kwd';\n\t  /**\n\t   * token style for a comment\n\t   * @const\n\t   */\n\t  var PR_COMMENT = 'com';\n\t  /**\n\t   * token style for a type\n\t   * @const\n\t   */\n\t  var PR_TYPE = 'typ';\n\t  /**\n\t   * token style for a literal value.  e.g. 1, null, true.\n\t   * @const\n\t   */\n\t  var PR_LITERAL = 'lit';\n\t  /**\n\t   * token style for a punctuation string.\n\t   * @const\n\t   */\n\t  var PR_PUNCTUATION = 'pun';\n\t  /**\n\t   * token style for plain text.\n\t   * @const\n\t   */\n\t  var PR_PLAIN = 'pln';\n\t\n\t  /**\n\t   * token style for an sgml tag.\n\t   * @const\n\t   */\n\t  var PR_TAG = 'tag';\n\t  /**\n\t   * token style for a markup declaration such as a DOCTYPE.\n\t   * @const\n\t   */\n\t  var PR_DECLARATION = 'dec';\n\t  /**\n\t   * token style for embedded source.\n\t   * @const\n\t   */\n\t  var PR_SOURCE = 'src';\n\t  /**\n\t   * token style for an sgml attribute name.\n\t   * @const\n\t   */\n\t  var PR_ATTRIB_NAME = 'atn';\n\t  /**\n\t   * token style for an sgml attribute value.\n\t   * @const\n\t   */\n\t  var PR_ATTRIB_VALUE = 'atv';\n\t\n\t  /**\n\t   * A class that indicates a section of markup that is not code, e.g. to allow\n\t   * embedding of line numbers within code listings.\n\t   * @const\n\t   */\n\t  var PR_NOCODE = 'nocode';\n\t\n\t  /**\n\t   * A set of tokens that can precede a regular expression literal in\n\t   * javascript\n\t   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n\t   * has the full list, but I've removed ones that might be problematic when\n\t   * seen in languages that don't support regular expression literals.\n\t   *\n\t   * <p>Specifically, I've removed any keywords that can't precede a regexp\n\t   * literal in a syntactically legal javascript program, and I've removed the\n\t   * \"in\" keyword since it's not a keyword in many languages, and might be used\n\t   * as a count of inches.\n\t   *\n\t   * <p>The link above does not accurately describe EcmaScript rules since\n\t   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n\t   * very well in practice.\n\t   *\n\t   * @private\n\t   * @const\n\t   */\n\t  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n\t\n\t  // CAVEAT: this does not properly handle the case where a regular\n\t  // expression immediately follows another since a regular expression may\n\t  // have flags for case-sensitivity and the like.  Having regexp tokens\n\t  // adjacent is not valid in any language I'm aware of, so I'm punting.\n\t  // TODO: maybe style special characters inside a regexp as punctuation.\n\t\n\t  /**\n\t   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n\t   * matches the union of the sets of strings matched by the input RegExp.\n\t   * Since it matches globally, if the input strings have a start-of-input\n\t   * anchor (/^.../), it is ignored for the purposes of unioning.\n\t   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n\t   * @return {RegExp} a global regex.\n\t   */\n\t  function combinePrefixPatterns(regexs) {\n\t    var capturedGroupIndex = 0;\n\t\n\t    var needToFoldCase = false;\n\t    var ignoreCase = false;\n\t    for (var i = 0, n = regexs.length; i < n; ++i) {\n\t      var regex = regexs[i];\n\t      if (regex.ignoreCase) {\n\t        ignoreCase = true;\n\t      } else if (/[a-z]/i.test(regex.source.replace(/\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n\t        needToFoldCase = true;\n\t        ignoreCase = false;\n\t        break;\n\t      }\n\t    }\n\t\n\t    var escapeCharToCodeUnit = {\n\t      'b': 8,\n\t      't': 9,\n\t      'n': 0xa,\n\t      'v': 0xb,\n\t      'f': 0xc,\n\t      'r': 0xd\n\t    };\n\t\n\t    function decodeEscape(charsetPart) {\n\t      var cc0 = charsetPart.charCodeAt(0);\n\t      if (cc0 !== 92 /* \\\\ */) {\n\t          return cc0;\n\t        }\n\t      var c1 = charsetPart.charAt(1);\n\t      cc0 = escapeCharToCodeUnit[c1];\n\t      if (cc0) {\n\t        return cc0;\n\t      } else if ('0' <= c1 && c1 <= '7') {\n\t        return parseInt(charsetPart.substring(1), 8);\n\t      } else if (c1 === 'u' || c1 === 'x') {\n\t        return parseInt(charsetPart.substring(2), 16);\n\t      } else {\n\t        return charsetPart.charCodeAt(1);\n\t      }\n\t    }\n\t\n\t    function encodeEscape(charCode) {\n\t      if (charCode < 0x20) {\n\t        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n\t      }\n\t      var ch = String.fromCharCode(charCode);\n\t      return ch === '\\\\' || ch === '-' || ch === ']' || ch === '^' ? \"\\\\\" + ch : ch;\n\t    }\n\t\n\t    function caseFoldCharset(charSet) {\n\t      var charsetParts = charSet.substring(1, charSet.length - 1).match(new RegExp(\"\\\\\\\\u[0-9A-Fa-f]{4}\" + '|\\\\\\\\x[0-9A-Fa-f]{2}' + '|\\\\\\\\[0-3][0-7]{0,2}' + '|\\\\\\\\[0-7]{1,2}' + '|\\\\\\\\[\\\\s\\\\S]' + '|-' + '|[^-\\\\\\\\]', 'g'));\n\t      var ranges = [];\n\t      var inverse = charsetParts[0] === '^';\n\t\n\t      var out = ['['];\n\t      if (inverse) {\n\t        out.push('^');\n\t      }\n\t\n\t      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n\t        var p = charsetParts[i];\n\t        if (/\\\\[bdsw]/i.test(p)) {\n\t          // Don't muck with named groups.\n\t          out.push(p);\n\t        } else {\n\t          var start = decodeEscape(p);\n\t          var end;\n\t          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n\t            end = decodeEscape(charsetParts[i + 2]);\n\t            i += 2;\n\t          } else {\n\t            end = start;\n\t          }\n\t          ranges.push([start, end]);\n\t          // If the range might intersect letters, then expand it.\n\t          // This case handling is too simplistic.\n\t          // It does not deal with non-latin case folding.\n\t          // It works for latin source code identifiers though.\n\t          if (!(end < 65 || start > 122)) {\n\t            if (!(end < 65 || start > 90)) {\n\t              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n\t            }\n\t            if (!(end < 97 || start > 122)) {\n\t              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n\t      // -> [[1, 12], [14, 14], [16, 17]]\n\t      ranges.sort(function (a, b) {\n\t        return a[0] - b[0] || b[1] - a[1];\n\t      });\n\t      var consolidatedRanges = [];\n\t      var lastRange = [];\n\t      for (var i = 0; i < ranges.length; ++i) {\n\t        var range = ranges[i];\n\t        if (range[0] <= lastRange[1] + 1) {\n\t          lastRange[1] = Math.max(lastRange[1], range[1]);\n\t        } else {\n\t          consolidatedRanges.push(lastRange = range);\n\t        }\n\t      }\n\t\n\t      for (var i = 0; i < consolidatedRanges.length; ++i) {\n\t        var range = consolidatedRanges[i];\n\t        out.push(encodeEscape(range[0]));\n\t        if (range[1] > range[0]) {\n\t          if (range[1] + 1 > range[0]) {\n\t            out.push('-');\n\t          }\n\t          out.push(encodeEscape(range[1]));\n\t        }\n\t      }\n\t      out.push(']');\n\t      return out.join('');\n\t    }\n\t\n\t    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n\t      // Split into character sets, escape sequences, punctuation strings\n\t      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n\t      // include any of the above.\n\t      var parts = regex.source.match(new RegExp('(?:' + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]' // a character set\n\t       + \"|\\\\\\\\u[A-Fa-f0-9]{4}\" // a unicode escape\n\t       + '|\\\\\\\\x[A-Fa-f0-9]{2}' // a hex escape\n\t       + '|\\\\\\\\[0-9]+' // a back-reference or octal escape\n\t       + '|\\\\\\\\[^ux0-9]' // other escape sequence\n\t       + '|\\\\(\\\\?[:!=]' // start of a non-capturing group\n\t       + '|[\\\\(\\\\)\\\\^]' // start/end of a group, or line start\n\t       + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+' // run of other characters\n\t       + ')', 'g'));\n\t      var n = parts.length;\n\t\n\t      // Maps captured group numbers to the number they will occupy in\n\t      // the output or to -1 if that has not been determined, or to\n\t      // undefined if they need not be capturing in the output.\n\t      var capturedGroups = [];\n\t\n\t      // Walk over and identify back references to build the capturedGroups\n\t      // mapping.\n\t      for (var i = 0, groupIndex = 0; i < n; ++i) {\n\t        var p = parts[i];\n\t        if (p === '(') {\n\t          // groups are 1-indexed, so max group index is count of '('\n\t          ++groupIndex;\n\t        } else if ('\\\\' === p.charAt(0)) {\n\t          var decimalValue = +p.substring(1);\n\t          if (decimalValue) {\n\t            if (decimalValue <= groupIndex) {\n\t              capturedGroups[decimalValue] = -1;\n\t            } else {\n\t              // Replace with an unambiguous escape sequence so that\n\t              // an octal escape sequence does not turn into a backreference\n\t              // to a capturing group from an earlier regex.\n\t              parts[i] = encodeEscape(decimalValue);\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      // Renumber groups and reduce capturing groups to non-capturing groups\n\t      // where possible.\n\t      for (var i = 1; i < capturedGroups.length; ++i) {\n\t        if (-1 === capturedGroups[i]) {\n\t          capturedGroups[i] = ++capturedGroupIndex;\n\t        }\n\t      }\n\t      for (var i = 0, groupIndex = 0; i < n; ++i) {\n\t        var p = parts[i];\n\t        if (p === '(') {\n\t          ++groupIndex;\n\t          if (!capturedGroups[groupIndex]) {\n\t            parts[i] = '(?:';\n\t          }\n\t        } else if ('\\\\' === p.charAt(0)) {\n\t          var decimalValue = +p.substring(1);\n\t          if (decimalValue && decimalValue <= groupIndex) {\n\t            parts[i] = '\\\\' + capturedGroups[decimalValue];\n\t          }\n\t        }\n\t      }\n\t\n\t      // Remove any prefix anchors so that the output will match anywhere.\n\t      // ^^ really does mean an anchored match though.\n\t      for (var i = 0; i < n; ++i) {\n\t        if ('^' === parts[i] && '^' !== parts[i + 1]) {\n\t          parts[i] = '';\n\t        }\n\t      }\n\t\n\t      // Expand letters to groups to handle mixing of case-sensitive and\n\t      // case-insensitive patterns if necessary.\n\t      if (regex.ignoreCase && needToFoldCase) {\n\t        for (var i = 0; i < n; ++i) {\n\t          var p = parts[i];\n\t          var ch0 = p.charAt(0);\n\t          if (p.length >= 2 && ch0 === '[') {\n\t            parts[i] = caseFoldCharset(p);\n\t          } else if (ch0 !== '\\\\') {\n\t            // TODO: handle letters in numeric escapes.\n\t            parts[i] = p.replace(/[a-zA-Z]/g, function (ch) {\n\t              var cc = ch.charCodeAt(0);\n\t              return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n\t            });\n\t          }\n\t        }\n\t      }\n\t\n\t      return parts.join('');\n\t    }\n\t\n\t    var rewritten = [];\n\t    for (var i = 0, n = regexs.length; i < n; ++i) {\n\t      var regex = regexs[i];\n\t      if (regex.global || regex.multiline) {\n\t        throw new Error('' + regex);\n\t      }\n\t      rewritten.push('(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n\t    }\n\t\n\t    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n\t  }\n\t\n\t  /**\n\t   * Split markup into a string of source code and an array mapping ranges in\n\t   * that string to the text nodes in which they appear.\n\t   *\n\t   * <p>\n\t   * The HTML DOM structure:</p>\n\t   * <pre>\n\t   * (Element   \"p\"\n\t   *   (Element \"b\"\n\t   *     (Text  \"print \"))       ; #1\n\t   *   (Text    \"'Hello '\")      ; #2\n\t   *   (Element \"br\")            ; #3\n\t   *   (Text    \"  + 'World';\")) ; #4\n\t   * </pre>\n\t   * <p>\n\t   * corresponds to the HTML\n\t   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n\t   *\n\t   * <p>\n\t   * It will produce the output:</p>\n\t   * <pre>\n\t   * {\n\t   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n\t   *   //                     1          2\n\t   *   //           012345678901234 5678901234567\n\t   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n\t   * }\n\t   * </pre>\n\t   * <p>\n\t   * where #1 is a reference to the {@code \"print \"} text node above, and so\n\t   * on for the other text nodes.\n\t   * </p>\n\t   *\n\t   * <p>\n\t   * The {@code} spans array is an array of pairs.  Even elements are the start\n\t   * indices of substrings, and odd elements are the text nodes (or BR elements)\n\t   * that contain the text for those substrings.\n\t   * Substrings continue until the next index or the end of the source.\n\t   * </p>\n\t   *\n\t   * @param {Node} node an HTML DOM subtree containing source-code.\n\t   * @param {boolean|number} isPreformatted truthy if white-space in\n\t   *    text nodes should be considered significant.\n\t   * @return {SourceSpansT} source code and the nodes in which they occur.\n\t   */\n\t  function extractSourceSpans(node, isPreformatted) {\n\t    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\t\n\t    var chunks = [];\n\t    var length = 0;\n\t    var spans = [];\n\t    var k = 0;\n\t\n\t    function walk(node) {\n\t      var type = node.nodeType;\n\t      if (type == 1) {\n\t        // Element\n\t        if (nocode.test(node.className)) {\n\t          return;\n\t        }\n\t        for (var child = node.firstChild; child; child = child.nextSibling) {\n\t          walk(child);\n\t        }\n\t        var nodeName = node.nodeName.toLowerCase();\n\t        if ('br' === nodeName || 'li' === nodeName) {\n\t          chunks[k] = '\\n';\n\t          spans[k << 1] = length++;\n\t          spans[k++ << 1 | 1] = node;\n\t        }\n\t      } else if (type == 3 || type == 4) {\n\t        // Text\n\t        var text = node.nodeValue;\n\t        if (text.length) {\n\t          if (!isPreformatted) {\n\t            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n\t          } else {\n\t            text = text.replace(/\\r\\n?/g, '\\n'); // Normalize newlines.\n\t          }\n\t          // TODO: handle tabs here?\n\t          chunks[k] = text;\n\t          spans[k << 1] = length;\n\t          length += text.length;\n\t          spans[k++ << 1 | 1] = node;\n\t        }\n\t      }\n\t    }\n\t\n\t    walk(node);\n\t\n\t    return {\n\t      sourceCode: chunks.join('').replace(/\\n$/, ''),\n\t      spans: spans\n\t    };\n\t  }\n\t\n\t  /**\n\t   * Apply the given language handler to sourceCode and add the resulting\n\t   * decorations to out.\n\t   * @param {!Element} sourceNode\n\t   * @param {number} basePos the index of sourceCode within the chunk of source\n\t   *    whose decorations are already present on out.\n\t   * @param {string} sourceCode\n\t   * @param {function(JobT)} langHandler\n\t   * @param {DecorationsT} out\n\t   */\n\t  function appendDecorations(sourceNode, basePos, sourceCode, langHandler, out) {\n\t    if (!sourceCode) {\n\t      return;\n\t    }\n\t    /** @type {JobT} */\n\t    var job = {\n\t      sourceNode: sourceNode,\n\t      pre: 1,\n\t      langExtension: null,\n\t      numberLines: null,\n\t      sourceCode: sourceCode,\n\t      spans: null,\n\t      basePos: basePos,\n\t      decorations: null\n\t    };\n\t    langHandler(job);\n\t    out.push.apply(out, job.decorations);\n\t  }\n\t\n\t  var notWs = /\\S/;\n\t\n\t  /**\n\t   * Given an element, if it contains only one child element and any text nodes\n\t   * it contains contain only space characters, return the sole child element.\n\t   * Otherwise returns undefined.\n\t   * <p>\n\t   * This is meant to return the CODE element in {@code <pre><code ...>} when\n\t   * there is a single child element that contains all the non-space textual\n\t   * content, but not to return anything where there are multiple child elements\n\t   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n\t   * is textual content.\n\t   */\n\t  function childContentWrapper(element) {\n\t    var wrapper = undefined;\n\t    for (var c = element.firstChild; c; c = c.nextSibling) {\n\t      var type = c.nodeType;\n\t      wrapper = type === 1 ? // Element Node\n\t      wrapper ? element : c : type === 3 ? // Text Node\n\t      notWs.test(c.nodeValue) ? element : wrapper : wrapper;\n\t    }\n\t    return wrapper === element ? undefined : wrapper;\n\t  }\n\t\n\t  /** Given triples of [style, pattern, context] returns a lexing function,\n\t    * The lexing function interprets the patterns to find token boundaries and\n\t    * returns a decoration list of the form\n\t    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n\t    * where index_n is an index into the sourceCode, and style_n is a style\n\t    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n\t    * all characters in sourceCode[index_n-1:index_n].\n\t    *\n\t    * The stylePatterns is a list whose elements have the form\n\t    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n\t    *\n\t    * Style is a style constant like PR_PLAIN, or can be a string of the\n\t    * form 'lang-FOO', where FOO is a language extension describing the\n\t    * language of the portion of the token in $1 after pattern executes.\n\t    * E.g., if style is 'lang-lisp', and group 1 contains the text\n\t    * '(hello (world))', then that portion of the token will be passed to the\n\t    * registered lisp handler for formatting.\n\t    * The text before and after group 1 will be restyled using this decorator\n\t    * so decorators should take care that this doesn't result in infinite\n\t    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n\t    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n\t    * '<script>foo()<\\/script>', which would cause the current decorator to\n\t    * be called with '<script>' which would not match the same rule since\n\t    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n\t    * the generic tag rule.  The handler registered for the 'js' extension would\n\t    * then be called with 'foo()', and finally, the current decorator would\n\t    * be called with '<\\/script>' which would not match the original rule and\n\t    * so the generic tag rule would identify it as a tag.\n\t    *\n\t    * Pattern must only match prefixes, and if it matches a prefix, then that\n\t    * match is considered a token with the same style.\n\t    *\n\t    * Context is applied to the last non-whitespace, non-comment token\n\t    * recognized.\n\t    *\n\t    * Shortcut is an optional string of characters, any of which, if the first\n\t    * character, gurantee that this pattern and only this pattern matches.\n\t    *\n\t    * @param {Array} shortcutStylePatterns patterns that always start with\n\t    *   a known character.  Must have a shortcut string.\n\t    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n\t    *   order if the shortcut ones fail.  May have shortcuts.\n\t    *\n\t    * @return {function (JobT)} a function that takes an undecorated job and\n\t    *   attaches a list of decorations.\n\t    */\n\t  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n\t    var shortcuts = {};\n\t    var tokenizer;\n\t    (function () {\n\t      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n\t      var allRegexs = [];\n\t      var regexKeys = {};\n\t      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n\t        var patternParts = allPatterns[i];\n\t        var shortcutChars = patternParts[3];\n\t        if (shortcutChars) {\n\t          for (var c = shortcutChars.length; --c >= 0;) {\n\t            shortcuts[shortcutChars.charAt(c)] = patternParts;\n\t          }\n\t        }\n\t        var regex = patternParts[1];\n\t        var k = '' + regex;\n\t        if (!regexKeys.hasOwnProperty(k)) {\n\t          allRegexs.push(regex);\n\t          regexKeys[k] = null;\n\t        }\n\t      }\n\t      allRegexs.push(/[\\0-\\uffff]/);\n\t      tokenizer = combinePrefixPatterns(allRegexs);\n\t    })();\n\t\n\t    var nPatterns = fallthroughStylePatterns.length;\n\t\n\t    /**\n\t     * Lexes job.sourceCode and attaches an output array job.decorations of\n\t     * style classes preceded by the position at which they start in\n\t     * job.sourceCode in order.\n\t     *\n\t     * @type{function (JobT)}\n\t     */\n\t    var decorate = function decorate(job) {\n\t      var sourceCode = job.sourceCode,\n\t          basePos = job.basePos;\n\t      var sourceNode = job.sourceNode;\n\t      /** Even entries are positions in source in ascending order.  Odd enties\n\t        * are style markers (e.g., PR_COMMENT) that run from that position until\n\t        * the end.\n\t        * @type {DecorationsT}\n\t        */\n\t      var decorations = [basePos, PR_PLAIN];\n\t      var pos = 0; // index into sourceCode\n\t      var tokens = sourceCode.match(tokenizer) || [];\n\t      var styleCache = {};\n\t\n\t      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n\t        var token = tokens[ti];\n\t        var style = styleCache[token];\n\t        var match = void 0;\n\t\n\t        var isEmbedded;\n\t        if (typeof style === 'string') {\n\t          isEmbedded = false;\n\t        } else {\n\t          var patternParts = shortcuts[token.charAt(0)];\n\t          if (patternParts) {\n\t            match = token.match(patternParts[1]);\n\t            style = patternParts[0];\n\t          } else {\n\t            for (var i = 0; i < nPatterns; ++i) {\n\t              patternParts = fallthroughStylePatterns[i];\n\t              match = token.match(patternParts[1]);\n\t              if (match) {\n\t                style = patternParts[0];\n\t                break;\n\t              }\n\t            }\n\t\n\t            if (!match) {\n\t              // make sure that we make progress\n\t              style = PR_PLAIN;\n\t            }\n\t          }\n\t\n\t          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n\t          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n\t            isEmbedded = false;\n\t            style = PR_SOURCE;\n\t          }\n\t\n\t          if (!isEmbedded) {\n\t            styleCache[token] = style;\n\t          }\n\t        }\n\t\n\t        var tokenStart = pos;\n\t        pos += token.length;\n\t\n\t        if (!isEmbedded) {\n\t          decorations.push(basePos + tokenStart, style);\n\t        } else {\n\t          // Treat group 1 as an embedded block of source code.\n\t          var embeddedSource = match[1];\n\t          var embeddedSourceStart = token.indexOf(embeddedSource);\n\t          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n\t          if (match[2]) {\n\t            // If embeddedSource can be blank, then it would match at the\n\t            // beginning which would cause us to infinitely recurse on the\n\t            // entire token, so we catch the right context in match[2].\n\t            embeddedSourceEnd = token.length - match[2].length;\n\t            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n\t          }\n\t          var lang = style.substring(5);\n\t          // Decorate the left of the embedded source\n\t          appendDecorations(sourceNode, basePos + tokenStart, token.substring(0, embeddedSourceStart), decorate, decorations);\n\t          // Decorate the embedded source\n\t          appendDecorations(sourceNode, basePos + tokenStart + embeddedSourceStart, embeddedSource, langHandlerForExtension(lang, embeddedSource), decorations);\n\t          // Decorate the right of the embedded section\n\t          appendDecorations(sourceNode, basePos + tokenStart + embeddedSourceEnd, token.substring(embeddedSourceEnd), decorate, decorations);\n\t        }\n\t      }\n\t      job.decorations = decorations;\n\t    };\n\t    return decorate;\n\t  }\n\t\n\t  /** returns a function that produces a list of decorations from source text.\n\t    *\n\t    * This code treats \", ', and ` as string delimiters, and \\ as a string\n\t    * escape.  It does not recognize perl's qq() style strings.\n\t    * It has no special handling for double delimiter escapes as in basic, or\n\t    * the tripled delimiters used in python, but should work on those regardless\n\t    * although in those cases a single string literal may be broken up into\n\t    * multiple adjacent string literals.\n\t    *\n\t    * It recognizes C, C++, and shell style comments.\n\t    *\n\t    * @param {Object} options a set of optional parameters.\n\t    * @return {function (JobT)} a function that examines the source code\n\t    *     in the input job and builds a decoration list which it attaches to\n\t    *     the job.\n\t    */\n\t  function sourceDecorator(options) {\n\t    var shortcutStylePatterns = [],\n\t        fallthroughStylePatterns = [];\n\t    if (options['tripleQuotedStrings']) {\n\t      // '''multi-line-string''', 'single-line-string', and double-quoted\n\t      shortcutStylePatterns.push([PR_STRING, /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/, null, '\\'\"']);\n\t    } else if (options['multiLineStrings']) {\n\t      // 'multi-line-string', \"multi-line-string\"\n\t      shortcutStylePatterns.push([PR_STRING, /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/, null, '\\'\"`']);\n\t    } else {\n\t      // 'single-line-string', \"single-line-string\"\n\t      shortcutStylePatterns.push([PR_STRING, /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/, null, '\"\\'']);\n\t    }\n\t    if (options['verbatimStrings']) {\n\t      // verbatim-string-literal production from the C# grammar.  See issue 93.\n\t      fallthroughStylePatterns.push([PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n\t    }\n\t    var hc = options['hashComments'];\n\t    if (hc) {\n\t      if (options['cStyleComments']) {\n\t        if (hc > 1) {\n\t          // multiline hash comments\n\t          shortcutStylePatterns.push([PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n\t        } else {\n\t          // Stop C preprocessor declarations at an unclosed open comment\n\t          shortcutStylePatterns.push([PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/, null, '#']);\n\t        }\n\t        // #include <stdio.h>\n\t        fallthroughStylePatterns.push([PR_STRING, /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/, null]);\n\t      } else {\n\t        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n\t      }\n\t    }\n\t    if (options['cStyleComments']) {\n\t      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n\t      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n\t    }\n\t    var regexLiterals = options['regexLiterals'];\n\t    if (regexLiterals) {\n\t      /**\n\t       * @const\n\t       */\n\t      var regexExcls = regexLiterals > 1 ? '' // Multiline regex literals\n\t      : '\\n\\r';\n\t      /**\n\t       * @const\n\t       */\n\t      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n\t      /**\n\t       * @const\n\t       */\n\t      var REGEX_LITERAL =\n\t      // A regular expression literal starts with a slash that is\n\t      // not followed by * or / so that it is not confused with\n\t      // comments.\n\t      '/(?=[^/*' + regexExcls + '])'\n\t      // and then contains any number of raw characters,\n\t       + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n\t      // escape sequences (\\x5C),\n\t       + '|\\\\x5C' + regexAny\n\t      // or non-nesting character sets (\\x5B\\x5D);\n\t       + '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']' + '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n\t      // finally closed by a /.\n\t       + '/';\n\t      fallthroughStylePatterns.push(['lang-regex', RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')]);\n\t    }\n\t\n\t    var types = options['types'];\n\t    if (types) {\n\t      fallthroughStylePatterns.push([PR_TYPE, types]);\n\t    }\n\t\n\t    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n\t    if (keywords.length) {\n\t      fallthroughStylePatterns.push([PR_KEYWORD, new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'), null]);\n\t    }\n\t\n\t    shortcutStylePatterns.push([PR_PLAIN, /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\t\n\t    var punctuation =\n\t    // The Bash man page says\n\t\n\t    // A word is a sequence of characters considered as a single\n\t    // unit by GRUB. Words are separated by metacharacters,\n\t    // which are the following plus space, tab, and newline: { }\n\t    // | & $ ; < >\n\t    // ...\n\t\n\t    // A word beginning with # causes that word and all remaining\n\t    // characters on that line to be ignored.\n\t\n\t    // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n\t    // comment but empirically\n\t    // $ echo {#}\n\t    // {#}\n\t    // $ echo \\$#\n\t    // $#\n\t    // $ echo }#\n\t    // }#\n\t\n\t    // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\t\n\t    // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n\t    // suggests that this definition is compatible with a\n\t    // default mode that tries to use a single token definition\n\t    // to recognize both bash/python style comments and C\n\t    // preprocessor directives.\n\t\n\t    // This definition of punctuation does not include # in the list of\n\t    // follow-on exclusions, so # will not be broken before if preceeded\n\t    // by a punctuation character.  We could try to exclude # after\n\t    // [|&;<>] but that doesn't seem to cause many major problems.\n\t    // If that does turn out to be a problem, we should change the below\n\t    // when hc is truthy to include # in the run of punctuation characters\n\t    // only when not followint [|&;<>].\n\t    '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n\t    if (options['regexLiterals']) {\n\t      punctuation += '(?!\\s*\\/)';\n\t    }\n\t\n\t    fallthroughStylePatterns.push(\n\t    // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n\t    [PR_LITERAL, /^@[a-z_$][a-z_$@0-9]*/i, null], [PR_TYPE, /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null], [PR_PLAIN, /^[a-z_$][a-z_$@0-9]*/i, null], [PR_LITERAL, new RegExp('^(?:'\n\t    // A hex number\n\t     + '0x[a-f0-9]+'\n\t    // or an octal or decimal number,\n\t     + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n\t    // possibly in scientific notation\n\t     + '(?:e[+\\\\-]?\\\\d+)?' + ')'\n\t    // with an optional modifier like UL for unsigned long\n\t     + '[a-z]*', 'i'), null, '0123456789'],\n\t    // Don't treat escaped quotes in bash as starting strings.\n\t    // See issue 144.\n\t    [PR_PLAIN, /^\\\\[\\s\\S]?/, null], [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\t\n\t    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n\t  }\n\t\n\t  var decorateSource = sourceDecorator({\n\t    'keywords': ALL_KEYWORDS,\n\t    'hashComments': true,\n\t    'cStyleComments': true,\n\t    'multiLineStrings': true,\n\t    'regexLiterals': true\n\t  });\n\t\n\t  /**\n\t   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n\t   * list item.\n\t   *\n\t   * @param {Node} node modified in place.  Its content is pulled into an\n\t   *     HTMLOListElement, and each line is moved into a separate list item.\n\t   *     This requires cloning elements, so the input might not have unique\n\t   *     IDs after numbering.\n\t   * @param {number|null|boolean} startLineNum\n\t   *     If truthy, coerced to an integer which is the 1-indexed line number\n\t   *     of the first line of code.  The number of the first line will be\n\t   *     attached to the list.\n\t   * @param {boolean} isPreformatted true iff white-space in text nodes should\n\t   *     be treated as significant.\n\t   */\n\t  function numberLines(node, startLineNum, isPreformatted) {\n\t    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\t    var lineBreak = /\\r\\n?|\\n/;\n\t\n\t    var document = node.ownerDocument;\n\t\n\t    var li = document.createElement('li');\n\t    while (node.firstChild) {\n\t      li.appendChild(node.firstChild);\n\t    }\n\t    // An array of lines.  We split below, so this is initialized to one\n\t    // un-split line.\n\t    var listItems = [li];\n\t\n\t    function walk(node) {\n\t      var type = node.nodeType;\n\t      if (type == 1 && !nocode.test(node.className)) {\n\t        // Element\n\t        if ('br' === node.nodeName) {\n\t          breakAfter(node);\n\t          // Discard the <BR> since it is now flush against a </LI>.\n\t          if (node.parentNode) {\n\t            node.parentNode.removeChild(node);\n\t          }\n\t        } else {\n\t          for (var child = node.firstChild; child; child = child.nextSibling) {\n\t            walk(child);\n\t          }\n\t        }\n\t      } else if ((type == 3 || type == 4) && isPreformatted) {\n\t        // Text\n\t        var text = node.nodeValue;\n\t        var match = text.match(lineBreak);\n\t        if (match) {\n\t          var firstLine = text.substring(0, match.index);\n\t          node.nodeValue = firstLine;\n\t          var tail = text.substring(match.index + match[0].length);\n\t          if (tail) {\n\t            var parent = node.parentNode;\n\t            parent.insertBefore(document.createTextNode(tail), node.nextSibling);\n\t          }\n\t          breakAfter(node);\n\t          if (!firstLine) {\n\t            // Don't leave blank text nodes in the DOM.\n\t            node.parentNode.removeChild(node);\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // Split a line after the given node.\n\t    function breakAfter(lineEndNode) {\n\t      // If there's nothing to the right, then we can skip ending the line\n\t      // here, and move root-wards since splitting just before an end-tag\n\t      // would require us to create a bunch of empty copies.\n\t      while (!lineEndNode.nextSibling) {\n\t        lineEndNode = lineEndNode.parentNode;\n\t        if (!lineEndNode) {\n\t          return;\n\t        }\n\t      }\n\t\n\t      function breakLeftOf(limit, copy) {\n\t        // Clone shallowly if this node needs to be on both sides of the break.\n\t        var rightSide = copy ? limit.cloneNode(false) : limit;\n\t        var parent = limit.parentNode;\n\t        if (parent) {\n\t          // We clone the parent chain.\n\t          // This helps us resurrect important styling elements that cross lines.\n\t          // E.g. in <i>Foo<br>Bar</i>\n\t          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n\t          var parentClone = breakLeftOf(parent, 1);\n\t          // Move the clone and everything to the right of the original\n\t          // onto the cloned parent.\n\t          var next = limit.nextSibling;\n\t          parentClone.appendChild(rightSide);\n\t          for (var sibling = next; sibling; sibling = next) {\n\t            next = sibling.nextSibling;\n\t            parentClone.appendChild(sibling);\n\t          }\n\t        }\n\t        return rightSide;\n\t      }\n\t\n\t      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n\t\n\t      // Walk the parent chain until we reach an unattached LI.\n\t      for (var parent;\n\t      // Check nodeType since IE invents document fragments.\n\t      (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n\t        copiedListItem = parent;\n\t      }\n\t      // Put it on the list of lines for later processing.\n\t      listItems.push(copiedListItem);\n\t    }\n\t\n\t    // Split lines while there are lines left to split.\n\t    for (var i = 0; // Number of lines that have been split so far.\n\t    i < listItems.length; // length updated by breakAfter calls.\n\t    ++i) {\n\t      walk(listItems[i]);\n\t    }\n\t\n\t    // Make sure numeric indices show correctly.\n\t    if (startLineNum === (startLineNum | 0)) {\n\t      listItems[0].setAttribute('value', startLineNum);\n\t    }\n\t\n\t    var ol = document.createElement('ol');\n\t    ol.className = 'linenums';\n\t    var offset = Math.max(0, startLineNum - 1 /* zero index */ | 0) || 0;\n\t    for (var i = 0, n = listItems.length; i < n; ++i) {\n\t      li = listItems[i];\n\t      // Stick a class on the LIs so that stylesheets can\n\t      // color odd/even rows, or any other row pattern that\n\t      // is co-prime with 10.\n\t      li.className = 'L' + (i + offset) % 10;\n\t      if (!li.firstChild) {\n\t        li.appendChild(document.createTextNode('\\xA0'));\n\t      }\n\t      ol.appendChild(li);\n\t    }\n\t\n\t    node.appendChild(ol);\n\t  }\n\t\n\t  /**\n\t   * Breaks {@code job.sourceCode} around style boundaries in\n\t   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n\t   * @param {JobT} job\n\t   * @private\n\t   */\n\t  function recombineTagsAndDecorations(job) {\n\t    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n\t    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n\t    var newlineRe = /\\n/g;\n\t\n\t    var source = job.sourceCode;\n\t    var sourceLength = source.length;\n\t    // Index into source after the last code-unit recombined.\n\t    var sourceIndex = 0;\n\t\n\t    var spans = job.spans;\n\t    var nSpans = spans.length;\n\t    // Index into spans after the last span which ends at or before sourceIndex.\n\t    var spanIndex = 0;\n\t\n\t    var decorations = job.decorations;\n\t    var nDecorations = decorations.length;\n\t    // Index into decorations after the last decoration which ends at or before\n\t    // sourceIndex.\n\t    var decorationIndex = 0;\n\t\n\t    // Remove all zero-length decorations.\n\t    decorations[nDecorations] = sourceLength;\n\t    var decPos, i;\n\t    for (i = decPos = 0; i < nDecorations;) {\n\t      if (decorations[i] !== decorations[i + 2]) {\n\t        decorations[decPos++] = decorations[i++];\n\t        decorations[decPos++] = decorations[i++];\n\t      } else {\n\t        i += 2;\n\t      }\n\t    }\n\t    nDecorations = decPos;\n\t\n\t    // Simplify decorations.\n\t    for (i = decPos = 0; i < nDecorations;) {\n\t      var startPos = decorations[i];\n\t      // Conflate all adjacent decorations that use the same style.\n\t      var startDec = decorations[i + 1];\n\t      var end = i + 2;\n\t      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n\t        end += 2;\n\t      }\n\t      decorations[decPos++] = startPos;\n\t      decorations[decPos++] = startDec;\n\t      i = end;\n\t    }\n\t\n\t    nDecorations = decorations.length = decPos;\n\t\n\t    var sourceNode = job.sourceNode;\n\t    var oldDisplay = \"\";\n\t    if (sourceNode) {\n\t      oldDisplay = sourceNode.style.display;\n\t      sourceNode.style.display = 'none';\n\t    }\n\t    try {\n\t      var decoration = null;\n\t      while (spanIndex < nSpans) {\n\t        var spanStart = spans[spanIndex];\n\t        var spanEnd = /** @type{number} */spans[spanIndex + 2] || sourceLength;\n\t\n\t        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n\t\n\t        var end = Math.min(spanEnd, decEnd);\n\t\n\t        var textNode = /** @type{Node} */spans[spanIndex + 1];\n\t        var styledText;\n\t        if (textNode.nodeType !== 1 // Don't muck with <BR>s or <LI>s\n\t        // Don't introduce spans around empty text nodes.\n\t         && (styledText = source.substring(sourceIndex, end))) {\n\t          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n\t          // code to display with spaces instead of line breaks.\n\t          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n\t          // space to appear at the beginning of every line but the first.\n\t          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n\t          if (isIE8OrEarlier) {\n\t            styledText = styledText.replace(newlineRe, '\\r');\n\t          }\n\t          textNode.nodeValue = styledText;\n\t          var document = textNode.ownerDocument;\n\t          var span = document.createElement('span');\n\t          span.className = decorations[decorationIndex + 1];\n\t          var parentNode = textNode.parentNode;\n\t          parentNode.replaceChild(span, textNode);\n\t          span.appendChild(textNode);\n\t          if (sourceIndex < spanEnd) {\n\t            // Split off a text node.\n\t            spans[spanIndex + 1] = textNode\n\t            // TODO: Possibly optimize by using '' if there's no flicker.\n\t             = document.createTextNode(source.substring(end, spanEnd));\n\t            parentNode.insertBefore(textNode, span.nextSibling);\n\t          }\n\t        }\n\t\n\t        sourceIndex = end;\n\t\n\t        if (sourceIndex >= spanEnd) {\n\t          spanIndex += 2;\n\t        }\n\t        if (sourceIndex >= decEnd) {\n\t          decorationIndex += 2;\n\t        }\n\t      }\n\t    } finally {\n\t      if (sourceNode) {\n\t        sourceNode.style.display = oldDisplay;\n\t      }\n\t    }\n\t  }\n\t\n\t  /** Maps language-specific file extensions to handlers. */\n\t  var langHandlerRegistry = {};\n\t  /** Register a language handler for the given file extensions.\n\t    * @param {function (JobT)} handler a function from source code to a list\n\t    *      of decorations.  Takes a single argument job which describes the\n\t    *      state of the computation and attaches the decorations to it.\n\t    * @param {Array.<string>} fileExtensions\n\t    */\n\t  function registerLangHandler(handler, fileExtensions) {\n\t    for (var i = fileExtensions.length; --i >= 0;) {\n\t      var ext = fileExtensions[i];\n\t      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n\t        langHandlerRegistry[ext] = handler;\n\t      } else if (win['console']) {\n\t        console['warn']('cannot override language handler %s', ext);\n\t      }\n\t    }\n\t  }\n\t  function langHandlerForExtension(extension, source) {\n\t    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n\t      // Treat it as markup if the first non whitespace character is a < and\n\t      // the last non-whitespace character is a >.\n\t      extension = /^\\s*</.test(source) ? 'default-markup' : 'default-code';\n\t    }\n\t    return langHandlerRegistry[extension];\n\t  }\n\t  registerLangHandler(decorateSource, ['default-code']);\n\t  registerLangHandler(createSimpleLexer([], [[PR_PLAIN, /^[^<?]+/], [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/], [PR_COMMENT, /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n\t  // Unescaped content in an unknown language\n\t  ['lang-', /^<\\?([\\s\\S]+?)(?:\\?>|$)/], ['lang-', /^<%([\\s\\S]+?)(?:%>|$)/], [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/], ['lang-', /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n\t  // Unescaped content in javascript.  (Or possibly vbscript).\n\t  ['lang-js', /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n\t  // Contains unescaped stylesheet content\n\t  ['lang-css', /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i], ['lang-in.tag', /^(<\\/?[a-z][^<>]*>)/i]]), ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n\t  registerLangHandler(createSimpleLexer([[PR_PLAIN, /^[\\s]+/, null, ' \\t\\r\\n'], [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']], [[PR_TAG, /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i], [PR_ATTRIB_NAME, /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i], ['lang-uq.val', /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/], [PR_PUNCTUATION, /^[=<>\\/]+/], ['lang-js', /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i], ['lang-js', /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i], ['lang-js', /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i], ['lang-css', /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i], ['lang-css', /^style\\s*=\\s*\\'([^\\']+)\\'/i], ['lang-css', /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]]), ['in.tag']);\n\t  registerLangHandler(createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': CPP_KEYWORDS,\n\t    'hashComments': true,\n\t    'cStyleComments': true,\n\t    'types': C_TYPES\n\t  }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': 'null,true,false'\n\t  }), ['json']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': CSHARP_KEYWORDS,\n\t    'hashComments': true,\n\t    'cStyleComments': true,\n\t    'verbatimStrings': true,\n\t    'types': C_TYPES\n\t  }), ['cs']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': JAVA_KEYWORDS,\n\t    'cStyleComments': true\n\t  }), ['java']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': SH_KEYWORDS,\n\t    'hashComments': true,\n\t    'multiLineStrings': true\n\t  }), ['bash', 'bsh', 'csh', 'sh']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': PYTHON_KEYWORDS,\n\t    'hashComments': true,\n\t    'multiLineStrings': true,\n\t    'tripleQuotedStrings': true\n\t  }), ['cv', 'py', 'python']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': PERL_KEYWORDS,\n\t    'hashComments': true,\n\t    'multiLineStrings': true,\n\t    'regexLiterals': 2 // multiline regex literals\n\t  }), ['perl', 'pl', 'pm']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': RUBY_KEYWORDS,\n\t    'hashComments': true,\n\t    'multiLineStrings': true,\n\t    'regexLiterals': true\n\t  }), ['rb', 'ruby']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': JSCRIPT_KEYWORDS,\n\t    'cStyleComments': true,\n\t    'regexLiterals': true\n\t  }), ['javascript', 'js', 'ts', 'typescript']);\n\t  registerLangHandler(sourceDecorator({\n\t    'keywords': COFFEE_KEYWORDS,\n\t    'hashComments': 3, // ### style block comments\n\t    'cStyleComments': true,\n\t    'multilineStrings': true,\n\t    'tripleQuotedStrings': true,\n\t    'regexLiterals': true\n\t  }), ['coffee']);\n\t  registerLangHandler(createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\t\n\t  /** @param {JobT} job */\n\t  function applyDecorator(job) {\n\t    var opt_langExtension = job.langExtension;\n\t\n\t    try {\n\t      // Extract tags, and convert the source code to plain text.\n\t      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n\t      /** Plain text. @type {string} */\n\t      var source = sourceAndSpans.sourceCode;\n\t      job.sourceCode = source;\n\t      job.spans = sourceAndSpans.spans;\n\t      job.basePos = 0;\n\t\n\t      // Apply the appropriate language handler\n\t      langHandlerForExtension(opt_langExtension, source)(job);\n\t\n\t      // Integrate the decorations and tags back into the source code,\n\t      // modifying the sourceNode in place.\n\t      recombineTagsAndDecorations(job);\n\t    } catch (e) {\n\t      if (win['console']) {\n\t        console['log'](e && e['stack'] || e);\n\t      }\n\t    }\n\t  }\n\t\n\t  /**\n\t   * Pretty print a chunk of code.\n\t   * @param sourceCodeHtml {string} The HTML to pretty print.\n\t   * @param opt_langExtension {string} The language name to use.\n\t   *     Typically, a filename extension like 'cpp' or 'java'.\n\t   * @param opt_numberLines {number|boolean} True to number lines,\n\t   *     or the 1-indexed number of the first line in sourceCodeHtml.\n\t   */\n\t  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n\t    /** @type{number|boolean} */\n\t    var nl = opt_numberLines || false;\n\t    /** @type{string|null} */\n\t    var langExtension = opt_langExtension || null;\n\t    /** @type{!Element} */\n\t    var container = document.createElement('div');\n\t    // This could cause images to load and onload listeners to fire.\n\t    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n\t    // We assume that the inner HTML is from a trusted source.\n\t    // The pre-tag is required for IE8 which strips newlines from innerHTML\n\t    // when it is injected into a <pre> tag.\n\t    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n\t    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n\t    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n\t    container = /** @type{!Element} */container.firstChild;\n\t    if (nl) {\n\t      numberLines(container, nl, true);\n\t    }\n\t\n\t    /** @type{JobT} */\n\t    var job = {\n\t      langExtension: langExtension,\n\t      numberLines: nl,\n\t      sourceNode: container,\n\t      pre: 1,\n\t      sourceCode: null,\n\t      basePos: null,\n\t      spans: null,\n\t      decorations: null\n\t    };\n\t    applyDecorator(job);\n\t    return container.innerHTML;\n\t  }\n\t\n\t  /**\n\t   * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n\t   * {@code class=prettyprint} and prettify them.\n\t   *\n\t   * @param {Function} opt_whenDone called when prettifying is done.\n\t   * @param {HTMLElement|HTMLDocument} opt_root an element or document\n\t   *   containing all the elements to pretty print.\n\t   *   Defaults to {@code document.body}.\n\t   */\n\t  function $prettyPrint(opt_whenDone, opt_root) {\n\t    var root = opt_root || document.body;\n\t    var doc = root.ownerDocument || document;\n\t    function byTagName(tn) {\n\t      return root.getElementsByTagName(tn);\n\t    }\n\t    // fetch a list of nodes to rewrite\n\t    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n\t    var elements = [];\n\t    for (var i = 0; i < codeSegments.length; ++i) {\n\t      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n\t        elements.push(codeSegments[i][j]);\n\t      }\n\t    }\n\t    codeSegments = null;\n\t\n\t    var clock = Date;\n\t    if (!clock['now']) {\n\t      clock = { 'now': function now() {\n\t          return +new Date();\n\t        } };\n\t    }\n\t\n\t    // The loop is broken into a series of continuations to make sure that we\n\t    // don't make the browser unresponsive when rewriting a large page.\n\t    var k = 0;\n\t\n\t    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n\t    var prettyPrintRe = /\\bprettyprint\\b/;\n\t    var prettyPrintedRe = /\\bprettyprinted\\b/;\n\t    var preformattedTagNameRe = /pre|xmp/i;\n\t    var codeRe = /^code$/i;\n\t    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n\t    var EMPTY = {};\n\t\n\t    function doWork() {\n\t      var endTime = win['PR_SHOULD_USE_CONTINUATION'] ? clock['now']() + 250 /* ms */ : Infinity;\n\t      for (; k < elements.length && clock['now']() < endTime; k++) {\n\t        var cs = elements[k];\n\t\n\t        // Look for a preceding comment like\n\t        // <?prettify lang=\"...\" linenums=\"...\"?>\n\t        var attrs = EMPTY;\n\t        {\n\t          for (var preceder = cs; preceder = preceder.previousSibling;) {\n\t            var nt = preceder.nodeType;\n\t            // <?foo?> is parsed by HTML 5 to a comment node (8)\n\t            // like <!--?foo?-->, but in XML is a processing instruction\n\t            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n\t            if (value ? !/^\\??prettify\\b/.test(value) : nt !== 3 || /\\S/.test(preceder.nodeValue)) {\n\t              // Skip over white-space text nodes but not others.\n\t              break;\n\t            }\n\t            if (value) {\n\t              attrs = {};\n\t              value.replace(/\\b(\\w+)=([\\w:.%+-]+)/g, function (_, name, value) {\n\t                attrs[name] = value;\n\t              });\n\t              break;\n\t            }\n\t          }\n\t        }\n\t\n\t        var className = cs.className;\n\t        if ((attrs !== EMPTY || prettyPrintRe.test(className)) &&\n\t        // Don't redo this if we've already done it.\n\t        // This allows recalling pretty print to just prettyprint elements\n\t        // that have been added to the page since last call.\n\t        !prettyPrintedRe.test(className)) {\n\t\n\t          // make sure this is not nested in an already prettified element\n\t          var nested = false;\n\t          for (var p = cs.parentNode; p; p = p.parentNode) {\n\t            var tn = p.tagName;\n\t            if (preCodeXmpRe.test(tn) && p.className && prettyPrintRe.test(p.className)) {\n\t              nested = true;\n\t              break;\n\t            }\n\t          }\n\t          if (!nested) {\n\t            // Mark done.  If we fail to prettyprint for whatever reason,\n\t            // we shouldn't try again.\n\t            cs.className += ' prettyprinted';\n\t\n\t            // If the classes includes a language extensions, use it.\n\t            // Language extensions can be specified like\n\t            //     <pre class=\"prettyprint lang-cpp\">\n\t            // the language extension \"cpp\" is used to find a language handler\n\t            // as passed to PR.registerLangHandler.\n\t            // HTML5 recommends that a language be specified using \"language-\"\n\t            // as the prefix instead.  Google Code Prettify supports both.\n\t            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n\t            var langExtension = attrs['lang'];\n\t            if (!langExtension) {\n\t              langExtension = className.match(langExtensionRe);\n\t              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n\t              var wrapper;\n\t              if (!langExtension && (wrapper = childContentWrapper(cs)) && codeRe.test(wrapper.tagName)) {\n\t                langExtension = wrapper.className.match(langExtensionRe);\n\t              }\n\t\n\t              if (langExtension) {\n\t                langExtension = langExtension[1];\n\t              }\n\t            }\n\t\n\t            var preformatted;\n\t            if (preformattedTagNameRe.test(cs.tagName)) {\n\t              preformatted = 1;\n\t            } else {\n\t              var currentStyle = cs['currentStyle'];\n\t              var defaultView = doc.defaultView;\n\t              var whitespace = currentStyle ? currentStyle['whiteSpace'] : defaultView && defaultView.getComputedStyle ? defaultView.getComputedStyle(cs, null).getPropertyValue('white-space') : 0;\n\t              preformatted = whitespace && 'pre' === whitespace.substring(0, 3);\n\t            }\n\t\n\t            // Look for a class like linenums or linenums:<n> where <n> is the\n\t            // 1-indexed number of the first line.\n\t            var lineNums = attrs['linenums'];\n\t            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n\t              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n\t              lineNums = lineNums ? lineNums[1] && lineNums[1].length ? +lineNums[1] : true : false;\n\t            }\n\t            if (lineNums) {\n\t              numberLines(cs, lineNums, preformatted);\n\t            }\n\t\n\t            // do the pretty printing\n\t            var prettyPrintingJob = {\n\t              langExtension: langExtension,\n\t              sourceNode: cs,\n\t              numberLines: lineNums,\n\t              pre: preformatted,\n\t              sourceCode: null,\n\t              basePos: null,\n\t              spans: null,\n\t              decorations: null\n\t            };\n\t            applyDecorator(prettyPrintingJob);\n\t          }\n\t        }\n\t      }\n\t      if (k < elements.length) {\n\t        // finish up in a continuation\n\t        win.setTimeout(doWork, 250);\n\t      } else if ('function' === typeof opt_whenDone) {\n\t        opt_whenDone();\n\t      }\n\t    }\n\t\n\t    doWork();\n\t  }\n\t\n\t  /**\n\t   * Contains functions for creating and registering new language handlers.\n\t   * @type {Object}\n\t   */\n\t  var PR = win['PR'] = {\n\t    'createSimpleLexer': createSimpleLexer,\n\t    'registerLangHandler': registerLangHandler,\n\t    'sourceDecorator': sourceDecorator,\n\t    'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n\t    'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n\t    'PR_COMMENT': PR_COMMENT,\n\t    'PR_DECLARATION': PR_DECLARATION,\n\t    'PR_KEYWORD': PR_KEYWORD,\n\t    'PR_LITERAL': PR_LITERAL,\n\t    'PR_NOCODE': PR_NOCODE,\n\t    'PR_PLAIN': PR_PLAIN,\n\t    'PR_PUNCTUATION': PR_PUNCTUATION,\n\t    'PR_SOURCE': PR_SOURCE,\n\t    'PR_STRING': PR_STRING,\n\t    'PR_TAG': PR_TAG,\n\t    'PR_TYPE': PR_TYPE,\n\t    'prettyPrintOne': IN_GLOBAL_SCOPE ? win['prettyPrintOne'] = $prettyPrintOne : prettyPrintOne = $prettyPrintOne,\n\t    'prettyPrint': prettyPrint = IN_GLOBAL_SCOPE ? win['prettyPrint'] = $prettyPrint : prettyPrint = $prettyPrint\n\t  };\n\t\n\t  // Make PR available via the Asynchronous Module Definition (AMD) API.\n\t  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n\t  // The Asynchronous Module Definition (AMD) API specifies a\n\t  // mechanism for defining modules such that the module and its\n\t  // dependencies can be asynchronously loaded.\n\t  // ...\n\t  // To allow a clear indicator that a global define function (as\n\t  // needed for script src browser loading) conforms to the AMD API,\n\t  // any global define function SHOULD have a property called \"amd\"\n\t  // whose value is an object. This helps avoid conflict with any\n\t  // other existing JavaScript code that could have defined a define()\n\t  // function that does not conform to the AMD API.\n\t  var define = win['define'];\n\t  if (typeof define === \"function\" && define['amd']) {\n\t    define(\"google-code-prettify\", [], function () {\n\t      return PR;\n\t    });\n\t  }\n\t})();\n\n/***/ },\n\n/***/ 80:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n\t * Super simple wysiwyg editor v0.8.2\n\t * http://summernote.org/\n\t *\n\t * summernote.js\n\t * Copyright 2013-2016 Alan Hong. and other contributors\n\t * summernote may be freely distributed under the MIT license./\n\t *\n\t * Date: 2016-08-07T05:11Z\n\t */\n\t(function (factory) {\n\t  /* global define */\n\t  if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof module === 'object' && module.exports) {\n\t    // Node/CommonJS\n\t    module.exports = factory(require('jquery'));\n\t  } else {\n\t    // Browser globals\n\t    factory(window.jQuery);\n\t  }\n\t}(function ($) {\n\t  'use strict';\n\t\n\t  /**\n\t   * @class core.func\n\t   *\n\t   * func utils (for high-order func's arg)\n\t   *\n\t   * @singleton\n\t   * @alternateClassName func\n\t   */\n\t  var func = (function () {\n\t    var eq = function (itemA) {\n\t      return function (itemB) {\n\t        return itemA === itemB;\n\t      };\n\t    };\n\t\n\t    var eq2 = function (itemA, itemB) {\n\t      return itemA === itemB;\n\t    };\n\t\n\t    var peq2 = function (propName) {\n\t      return function (itemA, itemB) {\n\t        return itemA[propName] === itemB[propName];\n\t      };\n\t    };\n\t\n\t    var ok = function () {\n\t      return true;\n\t    };\n\t\n\t    var fail = function () {\n\t      return false;\n\t    };\n\t\n\t    var not = function (f) {\n\t      return function () {\n\t        return !f.apply(f, arguments);\n\t      };\n\t    };\n\t\n\t    var and = function (fA, fB) {\n\t      return function (item) {\n\t        return fA(item) && fB(item);\n\t      };\n\t    };\n\t\n\t    var self = function (a) {\n\t      return a;\n\t    };\n\t\n\t    var invoke = function (obj, method) {\n\t      return function () {\n\t        return obj[method].apply(obj, arguments);\n\t      };\n\t    };\n\t\n\t    var idCounter = 0;\n\t\n\t    /**\n\t     * generate a globally-unique id\n\t     *\n\t     * @param {String} [prefix]\n\t     */\n\t    var uniqueId = function (prefix) {\n\t      var id = ++idCounter + '';\n\t      return prefix ? prefix + id : id;\n\t    };\n\t\n\t    /**\n\t     * returns bnd (bounds) from rect\n\t     *\n\t     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n\t     * - Scroll Issue: http://goo.gl/sNjUc\n\t     *\n\t     * @param {Rect} rect\n\t     * @return {Object} bounds\n\t     * @return {Number} bounds.top\n\t     * @return {Number} bounds.left\n\t     * @return {Number} bounds.width\n\t     * @return {Number} bounds.height\n\t     */\n\t    var rect2bnd = function (rect) {\n\t      var $document = $(document);\n\t      return {\n\t        top: rect.top + $document.scrollTop(),\n\t        left: rect.left + $document.scrollLeft(),\n\t        width: rect.right - rect.left,\n\t        height: rect.bottom - rect.top\n\t      };\n\t    };\n\t\n\t    /**\n\t     * returns a copy of the object where the keys have become the values and the values the keys.\n\t     * @param {Object} obj\n\t     * @return {Object}\n\t     */\n\t    var invertObject = function (obj) {\n\t      var inverted = {};\n\t      for (var key in obj) {\n\t        if (obj.hasOwnProperty(key)) {\n\t          inverted[obj[key]] = key;\n\t        }\n\t      }\n\t      return inverted;\n\t    };\n\t\n\t    /**\n\t     * @param {String} namespace\n\t     * @param {String} [prefix]\n\t     * @return {String}\n\t     */\n\t    var namespaceToCamel = function (namespace, prefix) {\n\t      prefix = prefix || '';\n\t      return prefix + namespace.split('.').map(function (name) {\n\t        return name.substring(0, 1).toUpperCase() + name.substring(1);\n\t      }).join('');\n\t    };\n\t\n\t    /**\n\t     * Returns a function, that, as long as it continues to be invoked, will not\n\t     * be triggered. The function will be called after it stops being called for\n\t     * N milliseconds. If `immediate` is passed, trigger the function on the\n\t     * leading edge, instead of the trailing.\n\t     * @param {Function} func\n\t     * @param {Number} wait\n\t     * @param {Boolean} immediate\n\t     * @return {Function}\n\t     */\n\t    var debounce = function (func, wait, immediate) {\n\t      var timeout;\n\t      return function () {\n\t        var context = this, args = arguments;\n\t        var later = function () {\n\t          timeout = null;\n\t          if (!immediate) {\n\t            func.apply(context, args);\n\t          }\n\t        };\n\t        var callNow = immediate && !timeout;\n\t        clearTimeout(timeout);\n\t        timeout = setTimeout(later, wait);\n\t        if (callNow) {\n\t          func.apply(context, args);\n\t        }\n\t      };\n\t    };\n\t\n\t    return {\n\t      eq: eq,\n\t      eq2: eq2,\n\t      peq2: peq2,\n\t      ok: ok,\n\t      fail: fail,\n\t      self: self,\n\t      not: not,\n\t      and: and,\n\t      invoke: invoke,\n\t      uniqueId: uniqueId,\n\t      rect2bnd: rect2bnd,\n\t      invertObject: invertObject,\n\t      namespaceToCamel: namespaceToCamel,\n\t      debounce: debounce\n\t    };\n\t  })();\n\t\n\t  /**\n\t   * @class core.list\n\t   *\n\t   * list utils\n\t   *\n\t   * @singleton\n\t   * @alternateClassName list\n\t   */\n\t  var list = (function () {\n\t    /**\n\t     * returns the first item of an array.\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var head = function (array) {\n\t      return array[0];\n\t    };\n\t\n\t    /**\n\t     * returns the last item of an array.\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var last = function (array) {\n\t      return array[array.length - 1];\n\t    };\n\t\n\t    /**\n\t     * returns everything but the last entry of the array.\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var initial = function (array) {\n\t      return array.slice(0, array.length - 1);\n\t    };\n\t\n\t    /**\n\t     * returns the rest of the items in an array.\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var tail = function (array) {\n\t      return array.slice(1);\n\t    };\n\t\n\t    /**\n\t     * returns item of array\n\t     */\n\t    var find = function (array, pred) {\n\t      for (var idx = 0, len = array.length; idx < len; idx ++) {\n\t        var item = array[idx];\n\t        if (pred(item)) {\n\t          return item;\n\t        }\n\t      }\n\t    };\n\t\n\t    /**\n\t     * returns true if all of the values in the array pass the predicate truth test.\n\t     */\n\t    var all = function (array, pred) {\n\t      for (var idx = 0, len = array.length; idx < len; idx ++) {\n\t        if (!pred(array[idx])) {\n\t          return false;\n\t        }\n\t      }\n\t      return true;\n\t    };\n\t\n\t    /**\n\t     * returns index of item\n\t     */\n\t    var indexOf = function (array, item) {\n\t      return $.inArray(item, array);\n\t    };\n\t\n\t    /**\n\t     * returns true if the value is present in the list.\n\t     */\n\t    var contains = function (array, item) {\n\t      return indexOf(array, item) !== -1;\n\t    };\n\t\n\t    /**\n\t     * get sum from a list\n\t     *\n\t     * @param {Array} array - array\n\t     * @param {Function} fn - iterator\n\t     */\n\t    var sum = function (array, fn) {\n\t      fn = fn || func.self;\n\t      return array.reduce(function (memo, v) {\n\t        return memo + fn(v);\n\t      }, 0);\n\t    };\n\t  \n\t    /**\n\t     * returns a copy of the collection with array type.\n\t     * @param {Collection} collection - collection eg) node.childNodes, ...\n\t     */\n\t    var from = function (collection) {\n\t      var result = [], idx = -1, length = collection.length;\n\t      while (++idx < length) {\n\t        result[idx] = collection[idx];\n\t      }\n\t      return result;\n\t    };\n\t\n\t    /**\n\t     * returns whether list is empty or not\n\t     */\n\t    var isEmpty = function (array) {\n\t      return !array || !array.length;\n\t    };\n\t  \n\t    /**\n\t     * cluster elements by predicate function.\n\t     *\n\t     * @param {Array} array - array\n\t     * @param {Function} fn - predicate function for cluster rule\n\t     * @param {Array[]}\n\t     */\n\t    var clusterBy = function (array, fn) {\n\t      if (!array.length) { return []; }\n\t      var aTail = tail(array);\n\t      return aTail.reduce(function (memo, v) {\n\t        var aLast = last(memo);\n\t        if (fn(last(aLast), v)) {\n\t          aLast[aLast.length] = v;\n\t        } else {\n\t          memo[memo.length] = [v];\n\t        }\n\t        return memo;\n\t      }, [[head(array)]]);\n\t    };\n\t  \n\t    /**\n\t     * returns a copy of the array with all false values removed\n\t     *\n\t     * @param {Array} array - array\n\t     * @param {Function} fn - predicate function for cluster rule\n\t     */\n\t    var compact = function (array) {\n\t      var aResult = [];\n\t      for (var idx = 0, len = array.length; idx < len; idx ++) {\n\t        if (array[idx]) { aResult.push(array[idx]); }\n\t      }\n\t      return aResult;\n\t    };\n\t\n\t    /**\n\t     * produces a duplicate-free version of the array\n\t     *\n\t     * @param {Array} array\n\t     */\n\t    var unique = function (array) {\n\t      var results = [];\n\t\n\t      for (var idx = 0, len = array.length; idx < len; idx ++) {\n\t        if (!contains(results, array[idx])) {\n\t          results.push(array[idx]);\n\t        }\n\t      }\n\t\n\t      return results;\n\t    };\n\t\n\t    /**\n\t     * returns next item.\n\t     * @param {Array} array\n\t     */\n\t    var next = function (array, item) {\n\t      var idx = indexOf(array, item);\n\t      if (idx === -1) { return null; }\n\t\n\t      return array[idx + 1];\n\t    };\n\t\n\t    /**\n\t     * returns prev item.\n\t     * @param {Array} array\n\t     */\n\t    var prev = function (array, item) {\n\t      var idx = indexOf(array, item);\n\t      if (idx === -1) { return null; }\n\t\n\t      return array[idx - 1];\n\t    };\n\t\n\t    return { head: head, last: last, initial: initial, tail: tail,\n\t             prev: prev, next: next, find: find, contains: contains,\n\t             all: all, sum: sum, from: from, isEmpty: isEmpty,\n\t             clusterBy: clusterBy, compact: compact, unique: unique };\n\t  })();\n\t\n\t  var isSupportAmd = \"function\" === 'function' && __webpack_require__(81);\n\t\n\t  /**\n\t   * returns whether font is installed or not.\n\t   *\n\t   * @param {String} fontName\n\t   * @return {Boolean}\n\t   */\n\t  var isFontInstalled = function (fontName) {\n\t    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n\t    var $tester = $('<div>').css({\n\t      position: 'absolute',\n\t      left: '-9999px',\n\t      top: '-9999px',\n\t      fontSize: '200px'\n\t    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\t\n\t    var originalWidth = $tester.css('fontFamily', testFontName).width();\n\t    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\t\n\t    $tester.remove();\n\t\n\t    return originalWidth !== width;\n\t  };\n\t\n\t  var userAgent = navigator.userAgent;\n\t  var isMSIE = /MSIE|Trident/i.test(userAgent);\n\t  var browserVersion;\n\t  if (isMSIE) {\n\t    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n\t    if (matches) {\n\t      browserVersion = parseFloat(matches[1]);\n\t    }\n\t    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n\t    if (matches) {\n\t      browserVersion = parseFloat(matches[1]);\n\t    }\n\t  }\n\t\n\t  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\t\n\t  var hasCodeMirror = !!window.CodeMirror;\n\t  if (!hasCodeMirror && isSupportAmd && \"function\" !== 'undefined') {\n\t    if (true) {\n\t      try {\n\t        // If CodeMirror can't be resolved, `require.resolve` will throw an\n\t        // exception and `hasCodeMirror` won't be set to `true`.\n\t        /*require.resolve*/(82);\n\t        hasCodeMirror = true;\n\t      } catch (e) {\n\t        // Do nothing.\n\t      }\n\t    } else if (typeof eval('require').specified !== 'undefined') {\n\t      hasCodeMirror = eval('require').specified('codemirror');\n\t    }\n\t  }\n\t\n\t  /**\n\t   * @class core.agent\n\t   *\n\t   * Object which check platform and agent\n\t   *\n\t   * @singleton\n\t   * @alternateClassName agent\n\t   */\n\t  var agent = {\n\t    isMac: navigator.appVersion.indexOf('Mac') > -1,\n\t    isMSIE: isMSIE,\n\t    isEdge: isEdge,\n\t    isFF: !isEdge && /firefox/i.test(userAgent),\n\t    isPhantom: /PhantomJS/i.test(userAgent),\n\t    isWebkit: !isEdge && /webkit/i.test(userAgent),\n\t    isChrome: !isEdge && /chrome/i.test(userAgent),\n\t    isSafari: !isEdge && /safari/i.test(userAgent),\n\t    browserVersion: browserVersion,\n\t    jqueryVersion: parseFloat($.fn.jquery),\n\t    isSupportAmd: isSupportAmd,\n\t    hasCodeMirror: hasCodeMirror,\n\t    isFontInstalled: isFontInstalled,\n\t    isW3CRangeSupport: !!document.createRange\n\t  };\n\t\n\t\n\t  var NBSP_CHAR = String.fromCharCode(160);\n\t  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\t\n\t  /**\n\t   * @class core.dom\n\t   *\n\t   * Dom functions\n\t   *\n\t   * @singleton\n\t   * @alternateClassName dom\n\t   */\n\t  var dom = (function () {\n\t    /**\n\t     * @method isEditable\n\t     *\n\t     * returns whether node is `note-editable` or not.\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean}\n\t     */\n\t    var isEditable = function (node) {\n\t      return node && $(node).hasClass('note-editable');\n\t    };\n\t\n\t    /**\n\t     * @method isControlSizing\n\t     *\n\t     * returns whether node is `note-control-sizing` or not.\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean}\n\t     */\n\t    var isControlSizing = function (node) {\n\t      return node && $(node).hasClass('note-control-sizing');\n\t    };\n\t\n\t    /**\n\t     * @method makePredByNodeName\n\t     *\n\t     * returns predicate which judge whether nodeName is same\n\t     *\n\t     * @param {String} nodeName\n\t     * @return {Function}\n\t     */\n\t    var makePredByNodeName = function (nodeName) {\n\t      nodeName = nodeName.toUpperCase();\n\t      return function (node) {\n\t        return node && node.nodeName.toUpperCase() === nodeName;\n\t      };\n\t    };\n\t\n\t    /**\n\t     * @method isText\n\t     *\n\t     *\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean} true if node's type is text(3)\n\t     */\n\t    var isText = function (node) {\n\t      return node && node.nodeType === 3;\n\t    };\n\t\n\t    /**\n\t     * @method isElement\n\t     *\n\t     *\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean} true if node's type is element(1)\n\t     */\n\t    var isElement = function (node) {\n\t      return node && node.nodeType === 1;\n\t    };\n\t\n\t    /**\n\t     * ex) br, col, embed, hr, img, input, ...\n\t     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n\t     */\n\t    var isVoid = function (node) {\n\t      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isPara = function (node) {\n\t      if (isEditable(node)) {\n\t        return false;\n\t      }\n\t\n\t      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n\t      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isHeading = function (node) {\n\t      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isPre = makePredByNodeName('PRE');\n\t\n\t    var isLi = makePredByNodeName('LI');\n\t\n\t    var isPurePara = function (node) {\n\t      return isPara(node) && !isLi(node);\n\t    };\n\t\n\t    var isTable = makePredByNodeName('TABLE');\n\t\n\t    var isData = makePredByNodeName('DATA');\n\t\n\t    var isInline = function (node) {\n\t      return !isBodyContainer(node) &&\n\t             !isList(node) &&\n\t             !isHr(node) &&\n\t             !isPara(node) &&\n\t             !isTable(node) &&\n\t             !isBlockquote(node) &&\n\t             !isData(node);\n\t    };\n\t\n\t    var isList = function (node) {\n\t      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isHr = makePredByNodeName('HR');\n\t\n\t    var isCell = function (node) {\n\t      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n\t    };\n\t\n\t    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\t\n\t    var isBodyContainer = function (node) {\n\t      return isCell(node) || isBlockquote(node) || isEditable(node);\n\t    };\n\t\n\t    var isAnchor = makePredByNodeName('A');\n\t\n\t    var isParaInline = function (node) {\n\t      return isInline(node) && !!ancestor(node, isPara);\n\t    };\n\t\n\t    var isBodyInline = function (node) {\n\t      return isInline(node) && !ancestor(node, isPara);\n\t    };\n\t\n\t    var isBody = makePredByNodeName('BODY');\n\t\n\t    /**\n\t     * returns whether nodeB is closest sibling of nodeA\n\t     *\n\t     * @param {Node} nodeA\n\t     * @param {Node} nodeB\n\t     * @return {Boolean}\n\t     */\n\t    var isClosestSibling = function (nodeA, nodeB) {\n\t      return nodeA.nextSibling === nodeB ||\n\t             nodeA.previousSibling === nodeB;\n\t    };\n\t\n\t    /**\n\t     * returns array of closest siblings with node\n\t     *\n\t     * @param {Node} node\n\t     * @param {function} [pred] - predicate function\n\t     * @return {Node[]}\n\t     */\n\t    var withClosestSiblings = function (node, pred) {\n\t      pred = pred || func.ok;\n\t\n\t      var siblings = [];\n\t      if (node.previousSibling && pred(node.previousSibling)) {\n\t        siblings.push(node.previousSibling);\n\t      }\n\t      siblings.push(node);\n\t      if (node.nextSibling && pred(node.nextSibling)) {\n\t        siblings.push(node.nextSibling);\n\t      }\n\t      return siblings;\n\t    };\n\t\n\t    /**\n\t     * blank HTML for cursor position\n\t     * - [workaround] old IE only works with &nbsp;\n\t     * - [workaround] IE11 and other browser works with bogus br\n\t     */\n\t    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\t\n\t    /**\n\t     * @method nodeLength\n\t     *\n\t     * returns #text's text size or element's childNodes size\n\t     *\n\t     * @param {Node} node\n\t     */\n\t    var nodeLength = function (node) {\n\t      if (isText(node)) {\n\t        return node.nodeValue.length;\n\t      }\n\t      \n\t      if (node) {\n\t        return node.childNodes.length;\n\t      }\n\t      \n\t      return 0;\n\t      \n\t    };\n\t\n\t    /**\n\t     * returns whether node is empty or not.\n\t     *\n\t     * @param {Node} node\n\t     * @return {Boolean}\n\t     */\n\t    var isEmpty = function (node) {\n\t      var len = nodeLength(node);\n\t\n\t      if (len === 0) {\n\t        return true;\n\t      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n\t        // ex) <p><br></p>, <span><br></span>\n\t        return true;\n\t      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n\t        // ex) <p></p>, <span></span>\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    /**\n\t     * padding blankHTML if node is empty (for cursor position)\n\t     */\n\t    var paddingBlankHTML = function (node) {\n\t      if (!isVoid(node) && !nodeLength(node)) {\n\t        node.innerHTML = blankHTML;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * find nearest ancestor predicate hit\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} pred - predicate function\n\t     */\n\t    var ancestor = function (node, pred) {\n\t      while (node) {\n\t        if (pred(node)) { return node; }\n\t        if (isEditable(node)) { break; }\n\t\n\t        node = node.parentNode;\n\t      }\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * find nearest ancestor only single child blood line and predicate hit\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} pred - predicate function\n\t     */\n\t    var singleChildAncestor = function (node, pred) {\n\t      node = node.parentNode;\n\t\n\t      while (node) {\n\t        if (nodeLength(node) !== 1) { break; }\n\t        if (pred(node)) { return node; }\n\t        if (isEditable(node)) { break; }\n\t\n\t        node = node.parentNode;\n\t      }\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * returns new array of ancestor nodes (until predicate hit).\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} [optional] pred - predicate function\n\t     */\n\t    var listAncestor = function (node, pred) {\n\t      pred = pred || func.fail;\n\t\n\t      var ancestors = [];\n\t      ancestor(node, function (el) {\n\t        if (!isEditable(el)) {\n\t          ancestors.push(el);\n\t        }\n\t\n\t        return pred(el);\n\t      });\n\t      return ancestors;\n\t    };\n\t\n\t    /**\n\t     * find farthest ancestor predicate hit\n\t     */\n\t    var lastAncestor = function (node, pred) {\n\t      var ancestors = listAncestor(node);\n\t      return list.last(ancestors.filter(pred));\n\t    };\n\t\n\t    /**\n\t     * returns common ancestor node between two nodes.\n\t     *\n\t     * @param {Node} nodeA\n\t     * @param {Node} nodeB\n\t     */\n\t    var commonAncestor = function (nodeA, nodeB) {\n\t      var ancestors = listAncestor(nodeA);\n\t      for (var n = nodeB; n; n = n.parentNode) {\n\t        if ($.inArray(n, ancestors) > -1) { return n; }\n\t      }\n\t      return null; // difference document area\n\t    };\n\t\n\t    /**\n\t     * listing all previous siblings (until predicate hit).\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} [optional] pred - predicate function\n\t     */\n\t    var listPrev = function (node, pred) {\n\t      pred = pred || func.fail;\n\t\n\t      var nodes = [];\n\t      while (node) {\n\t        if (pred(node)) { break; }\n\t        nodes.push(node);\n\t        node = node.previousSibling;\n\t      }\n\t      return nodes;\n\t    };\n\t\n\t    /**\n\t     * listing next siblings (until predicate hit).\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} [pred] - predicate function\n\t     */\n\t    var listNext = function (node, pred) {\n\t      pred = pred || func.fail;\n\t\n\t      var nodes = [];\n\t      while (node) {\n\t        if (pred(node)) { break; }\n\t        nodes.push(node);\n\t        node = node.nextSibling;\n\t      }\n\t      return nodes;\n\t    };\n\t\n\t    /**\n\t     * listing descendant nodes\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} [pred] - predicate function\n\t     */\n\t    var listDescendant = function (node, pred) {\n\t      var descendants = [];\n\t      pred = pred || func.ok;\n\t\n\t      // start DFS(depth first search) with node\n\t      (function fnWalk(current) {\n\t        if (node !== current && pred(current)) {\n\t          descendants.push(current);\n\t        }\n\t        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n\t          fnWalk(current.childNodes[idx]);\n\t        }\n\t      })(node);\n\t\n\t      return descendants;\n\t    };\n\t\n\t    /**\n\t     * wrap node with new tag.\n\t     *\n\t     * @param {Node} node\n\t     * @param {Node} tagName of wrapper\n\t     * @return {Node} - wrapper\n\t     */\n\t    var wrap = function (node, wrapperName) {\n\t      var parent = node.parentNode;\n\t      var wrapper = $('<' + wrapperName + '>')[0];\n\t\n\t      parent.insertBefore(wrapper, node);\n\t      wrapper.appendChild(node);\n\t\n\t      return wrapper;\n\t    };\n\t\n\t    /**\n\t     * insert node after preceding\n\t     *\n\t     * @param {Node} node\n\t     * @param {Node} preceding - predicate function\n\t     */\n\t    var insertAfter = function (node, preceding) {\n\t      var next = preceding.nextSibling, parent = preceding.parentNode;\n\t      if (next) {\n\t        parent.insertBefore(node, next);\n\t      } else {\n\t        parent.appendChild(node);\n\t      }\n\t      return node;\n\t    };\n\t\n\t    /**\n\t     * append elements.\n\t     *\n\t     * @param {Node} node\n\t     * @param {Collection} aChild\n\t     */\n\t    var appendChildNodes = function (node, aChild) {\n\t      $.each(aChild, function (idx, child) {\n\t        node.appendChild(child);\n\t      });\n\t      return node;\n\t    };\n\t\n\t    /**\n\t     * returns whether boundaryPoint is left edge or not.\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @return {Boolean}\n\t     */\n\t    var isLeftEdgePoint = function (point) {\n\t      return point.offset === 0;\n\t    };\n\t\n\t    /**\n\t     * returns whether boundaryPoint is right edge or not.\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @return {Boolean}\n\t     */\n\t    var isRightEdgePoint = function (point) {\n\t      return point.offset === nodeLength(point.node);\n\t    };\n\t\n\t    /**\n\t     * returns whether boundaryPoint is edge or not.\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @return {Boolean}\n\t     */\n\t    var isEdgePoint = function (point) {\n\t      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n\t    };\n\t\n\t    /**\n\t     * returns whether node is left edge of ancestor or not.\n\t     *\n\t     * @param {Node} node\n\t     * @param {Node} ancestor\n\t     * @return {Boolean}\n\t     */\n\t    var isLeftEdgeOf = function (node, ancestor) {\n\t      while (node && node !== ancestor) {\n\t        if (position(node) !== 0) {\n\t          return false;\n\t        }\n\t        node = node.parentNode;\n\t      }\n\t\n\t      return true;\n\t    };\n\t\n\t    /**\n\t     * returns whether node is right edge of ancestor or not.\n\t     *\n\t     * @param {Node} node\n\t     * @param {Node} ancestor\n\t     * @return {Boolean}\n\t     */\n\t    var isRightEdgeOf = function (node, ancestor) {\n\t      if (!ancestor) {\n\t        return false;\n\t      }\n\t      while (node && node !== ancestor) {\n\t        if (position(node) !== nodeLength(node.parentNode) - 1) {\n\t          return false;\n\t        }\n\t        node = node.parentNode;\n\t      }\n\t\n\t      return true;\n\t    };\n\t\n\t    /**\n\t     * returns whether point is left edge of ancestor or not.\n\t     * @param {BoundaryPoint} point\n\t     * @param {Node} ancestor\n\t     * @return {Boolean}\n\t     */\n\t    var isLeftEdgePointOf = function (point, ancestor) {\n\t      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n\t    };\n\t\n\t    /**\n\t     * returns whether point is right edge of ancestor or not.\n\t     * @param {BoundaryPoint} point\n\t     * @param {Node} ancestor\n\t     * @return {Boolean}\n\t     */\n\t    var isRightEdgePointOf = function (point, ancestor) {\n\t      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n\t    };\n\t\n\t    /**\n\t     * returns offset from parent.\n\t     *\n\t     * @param {Node} node\n\t     */\n\t    var position = function (node) {\n\t      var offset = 0;\n\t      while ((node = node.previousSibling)) {\n\t        offset += 1;\n\t      }\n\t      return offset;\n\t    };\n\t\n\t    var hasChildren = function (node) {\n\t      return !!(node && node.childNodes && node.childNodes.length);\n\t    };\n\t\n\t    /**\n\t     * returns previous boundaryPoint\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Boolean} isSkipInnerOffset\n\t     * @return {BoundaryPoint}\n\t     */\n\t    var prevPoint = function (point, isSkipInnerOffset) {\n\t      var node, offset;\n\t\n\t      if (point.offset === 0) {\n\t        if (isEditable(point.node)) {\n\t          return null;\n\t        }\n\t\n\t        node = point.node.parentNode;\n\t        offset = position(point.node);\n\t      } else if (hasChildren(point.node)) {\n\t        node = point.node.childNodes[point.offset - 1];\n\t        offset = nodeLength(node);\n\t      } else {\n\t        node = point.node;\n\t        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n\t      }\n\t\n\t      return {\n\t        node: node,\n\t        offset: offset\n\t      };\n\t    };\n\t\n\t    /**\n\t     * returns next boundaryPoint\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Boolean} isSkipInnerOffset\n\t     * @return {BoundaryPoint}\n\t     */\n\t    var nextPoint = function (point, isSkipInnerOffset) {\n\t      var node, offset;\n\t\n\t      if (nodeLength(point.node) === point.offset) {\n\t        if (isEditable(point.node)) {\n\t          return null;\n\t        }\n\t\n\t        node = point.node.parentNode;\n\t        offset = position(point.node) + 1;\n\t      } else if (hasChildren(point.node)) {\n\t        node = point.node.childNodes[point.offset];\n\t        offset = 0;\n\t      } else {\n\t        node = point.node;\n\t        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n\t      }\n\t\n\t      return {\n\t        node: node,\n\t        offset: offset\n\t      };\n\t    };\n\t\n\t    /**\n\t     * returns whether pointA and pointB is same or not.\n\t     *\n\t     * @param {BoundaryPoint} pointA\n\t     * @param {BoundaryPoint} pointB\n\t     * @return {Boolean}\n\t     */\n\t    var isSamePoint = function (pointA, pointB) {\n\t      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n\t    };\n\t\n\t    /**\n\t     * returns whether point is visible (can set cursor) or not.\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @return {Boolean}\n\t     */\n\t    var isVisiblePoint = function (point) {\n\t      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n\t        return true;\n\t      }\n\t\n\t      var leftNode = point.node.childNodes[point.offset - 1];\n\t      var rightNode = point.node.childNodes[point.offset];\n\t      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    };\n\t\n\t    /**\n\t     * @method prevPointUtil\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Function} pred\n\t     * @return {BoundaryPoint}\n\t     */\n\t    var prevPointUntil = function (point, pred) {\n\t      while (point) {\n\t        if (pred(point)) {\n\t          return point;\n\t        }\n\t\n\t        point = prevPoint(point);\n\t      }\n\t\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * @method nextPointUntil\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Function} pred\n\t     * @return {BoundaryPoint}\n\t     */\n\t    var nextPointUntil = function (point, pred) {\n\t      while (point) {\n\t        if (pred(point)) {\n\t          return point;\n\t        }\n\t\n\t        point = nextPoint(point);\n\t      }\n\t\n\t      return null;\n\t    };\n\t\n\t    /**\n\t     * returns whether point has character or not.\n\t     *\n\t     * @param {Point} point\n\t     * @return {Boolean}\n\t     */\n\t    var isCharPoint = function (point) {\n\t      if (!isText(point.node)) {\n\t        return false;\n\t      }\n\t\n\t      var ch = point.node.nodeValue.charAt(point.offset - 1);\n\t      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n\t    };\n\t\n\t    /**\n\t     * @method walkPoint\n\t     *\n\t     * @param {BoundaryPoint} startPoint\n\t     * @param {BoundaryPoint} endPoint\n\t     * @param {Function} handler\n\t     * @param {Boolean} isSkipInnerOffset\n\t     */\n\t    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n\t      var point = startPoint;\n\t\n\t      while (point) {\n\t        handler(point);\n\t\n\t        if (isSamePoint(point, endPoint)) {\n\t          break;\n\t        }\n\t\n\t        var isSkipOffset = isSkipInnerOffset &&\n\t                           startPoint.node !== point.node &&\n\t                           endPoint.node !== point.node;\n\t        point = nextPoint(point, isSkipOffset);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @method makeOffsetPath\n\t     *\n\t     * return offsetPath(array of offset) from ancestor\n\t     *\n\t     * @param {Node} ancestor - ancestor node\n\t     * @param {Node} node\n\t     */\n\t    var makeOffsetPath = function (ancestor, node) {\n\t      var ancestors = listAncestor(node, func.eq(ancestor));\n\t      return ancestors.map(position).reverse();\n\t    };\n\t\n\t    /**\n\t     * @method fromOffsetPath\n\t     *\n\t     * return element from offsetPath(array of offset)\n\t     *\n\t     * @param {Node} ancestor - ancestor node\n\t     * @param {array} offsets - offsetPath\n\t     */\n\t    var fromOffsetPath = function (ancestor, offsets) {\n\t      var current = ancestor;\n\t      for (var i = 0, len = offsets.length; i < len; i++) {\n\t        if (current.childNodes.length <= offsets[i]) {\n\t          current = current.childNodes[current.childNodes.length - 1];\n\t        } else {\n\t          current = current.childNodes[offsets[i]];\n\t        }\n\t      }\n\t      return current;\n\t    };\n\t\n\t    /**\n\t     * @method splitNode\n\t     *\n\t     * split element or #text\n\t     *\n\t     * @param {BoundaryPoint} point\n\t     * @param {Object} [options]\n\t     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n\t     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n\t     * @return {Node} right node of boundaryPoint\n\t     */\n\t    var splitNode = function (point, options) {\n\t      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n\t      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\t\n\t      // edge case\n\t      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n\t        if (isLeftEdgePoint(point)) {\n\t          return point.node;\n\t        } else if (isRightEdgePoint(point)) {\n\t          return point.node.nextSibling;\n\t        }\n\t      }\n\t\n\t      // split #text\n\t      if (isText(point.node)) {\n\t        return point.node.splitText(point.offset);\n\t      } else {\n\t        var childNode = point.node.childNodes[point.offset];\n\t        var clone = insertAfter(point.node.cloneNode(false), point.node);\n\t        appendChildNodes(clone, listNext(childNode));\n\t\n\t        if (!isSkipPaddingBlankHTML) {\n\t          paddingBlankHTML(point.node);\n\t          paddingBlankHTML(clone);\n\t        }\n\t\n\t        return clone;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @method splitTree\n\t     *\n\t     * split tree by point\n\t     *\n\t     * @param {Node} root - split root\n\t     * @param {BoundaryPoint} point\n\t     * @param {Object} [options]\n\t     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n\t     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n\t     * @return {Node} right node of boundaryPoint\n\t     */\n\t    var splitTree = function (root, point, options) {\n\t      // ex) [#text, <span>, <p>]\n\t      var ancestors = listAncestor(point.node, func.eq(root));\n\t\n\t      if (!ancestors.length) {\n\t        return null;\n\t      } else if (ancestors.length === 1) {\n\t        return splitNode(point, options);\n\t      }\n\t\n\t      return ancestors.reduce(function (node, parent) {\n\t        if (node === point.node) {\n\t          node = splitNode(point, options);\n\t        }\n\t\n\t        return splitNode({\n\t          node: parent,\n\t          offset: node ? dom.position(node) : nodeLength(parent)\n\t        }, options);\n\t      });\n\t    };\n\t\n\t    /**\n\t     * split point\n\t     *\n\t     * @param {Point} point\n\t     * @param {Boolean} isInline\n\t     * @return {Object}\n\t     */\n\t    var splitPoint = function (point, isInline) {\n\t      // find splitRoot, container\n\t      //  - inline: splitRoot is a child of paragraph\n\t      //  - block: splitRoot is a child of bodyContainer\n\t      var pred = isInline ? isPara : isBodyContainer;\n\t      var ancestors = listAncestor(point.node, pred);\n\t      var topAncestor = list.last(ancestors) || point.node;\n\t\n\t      var splitRoot, container;\n\t      if (pred(topAncestor)) {\n\t        splitRoot = ancestors[ancestors.length - 2];\n\t        container = topAncestor;\n\t      } else {\n\t        splitRoot = topAncestor;\n\t        container = splitRoot.parentNode;\n\t      }\n\t\n\t      // if splitRoot is exists, split with splitTree\n\t      var pivot = splitRoot && splitTree(splitRoot, point, {\n\t        isSkipPaddingBlankHTML: isInline,\n\t        isNotSplitEdgePoint: isInline\n\t      });\n\t\n\t      // if container is point.node, find pivot with point.offset\n\t      if (!pivot && container === point.node) {\n\t        pivot = point.node.childNodes[point.offset];\n\t      }\n\t\n\t      return {\n\t        rightNode: pivot,\n\t        container: container\n\t      };\n\t    };\n\t\n\t    var create = function (nodeName) {\n\t      return document.createElement(nodeName);\n\t    };\n\t\n\t    var createText = function (text) {\n\t      return document.createTextNode(text);\n\t    };\n\t\n\t    /**\n\t     * @method remove\n\t     *\n\t     * remove node, (isRemoveChild: remove child or not)\n\t     *\n\t     * @param {Node} node\n\t     * @param {Boolean} isRemoveChild\n\t     */\n\t    var remove = function (node, isRemoveChild) {\n\t      if (!node || !node.parentNode) { return; }\n\t      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\t\n\t      var parent = node.parentNode;\n\t      if (!isRemoveChild) {\n\t        var nodes = [];\n\t        var i, len;\n\t        for (i = 0, len = node.childNodes.length; i < len; i++) {\n\t          nodes.push(node.childNodes[i]);\n\t        }\n\t\n\t        for (i = 0, len = nodes.length; i < len; i++) {\n\t          parent.insertBefore(nodes[i], node);\n\t        }\n\t      }\n\t\n\t      parent.removeChild(node);\n\t    };\n\t\n\t    /**\n\t     * @method removeWhile\n\t     *\n\t     * @param {Node} node\n\t     * @param {Function} pred\n\t     */\n\t    var removeWhile = function (node, pred) {\n\t      while (node) {\n\t        if (isEditable(node) || !pred(node)) {\n\t          break;\n\t        }\n\t\n\t        var parent = node.parentNode;\n\t        remove(node);\n\t        node = parent;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @method replace\n\t     *\n\t     * replace node with provided nodeName\n\t     *\n\t     * @param {Node} node\n\t     * @param {String} nodeName\n\t     * @return {Node} - new node\n\t     */\n\t    var replace = function (node, nodeName) {\n\t      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n\t        return node;\n\t      }\n\t\n\t      var newNode = create(nodeName);\n\t\n\t      if (node.style.cssText) {\n\t        newNode.style.cssText = node.style.cssText;\n\t      }\n\t\n\t      appendChildNodes(newNode, list.from(node.childNodes));\n\t      insertAfter(newNode, node);\n\t      remove(node);\n\t\n\t      return newNode;\n\t    };\n\t\n\t    var isTextarea = makePredByNodeName('TEXTAREA');\n\t\n\t    /**\n\t     * @param {jQuery} $node\n\t     * @param {Boolean} [stripLinebreaks] - default: false\n\t     */\n\t    var value = function ($node, stripLinebreaks) {\n\t      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n\t      if (stripLinebreaks) {\n\t        return val.replace(/[\\n\\r]/g, '');\n\t      }\n\t      return val;\n\t    };\n\t\n\t    /**\n\t     * @method html\n\t     *\n\t     * get the HTML contents of node\n\t     *\n\t     * @param {jQuery} $node\n\t     * @param {Boolean} [isNewlineOnBlock]\n\t     */\n\t    var html = function ($node, isNewlineOnBlock) {\n\t      var markup = value($node);\n\t\n\t      if (isNewlineOnBlock) {\n\t        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n\t        markup = markup.replace(regexTag, function (match, endSlash, name) {\n\t          name = name.toUpperCase();\n\t          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n\t                                       !!endSlash;\n\t          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\t\n\t          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n\t        });\n\t        markup = $.trim(markup);\n\t      }\n\t\n\t      return markup;\n\t    };\n\t\n\t    var posFromPlaceholder = function (placeholder) {\n\t      var $placeholder = $(placeholder);\n\t      var pos = $placeholder.offset();\n\t      var height = $placeholder.outerHeight(true); // include margin\n\t\n\t      return {\n\t        left: pos.left,\n\t        top: pos.top + height\n\t      };\n\t    };\n\t\n\t    var attachEvents = function ($node, events) {\n\t      Object.keys(events).forEach(function (key) {\n\t        $node.on(key, events[key]);\n\t      });\n\t    };\n\t\n\t    var detachEvents = function ($node, events) {\n\t      Object.keys(events).forEach(function (key) {\n\t        $node.off(key, events[key]);\n\t      });\n\t    };\n\t\n\t    return {\n\t      /** @property {String} NBSP_CHAR */\n\t      NBSP_CHAR: NBSP_CHAR,\n\t      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n\t      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n\t      /** @property {String} blank */\n\t      blank: blankHTML,\n\t      /** @property {String} emptyPara */\n\t      emptyPara: '<p>' + blankHTML + '</p>',\n\t      makePredByNodeName: makePredByNodeName,\n\t      isEditable: isEditable,\n\t      isControlSizing: isControlSizing,\n\t      isText: isText,\n\t      isElement: isElement,\n\t      isVoid: isVoid,\n\t      isPara: isPara,\n\t      isPurePara: isPurePara,\n\t      isHeading: isHeading,\n\t      isInline: isInline,\n\t      isBlock: func.not(isInline),\n\t      isBodyInline: isBodyInline,\n\t      isBody: isBody,\n\t      isParaInline: isParaInline,\n\t      isPre: isPre,\n\t      isList: isList,\n\t      isTable: isTable,\n\t      isData: isData,\n\t      isCell: isCell,\n\t      isBlockquote: isBlockquote,\n\t      isBodyContainer: isBodyContainer,\n\t      isAnchor: isAnchor,\n\t      isDiv: makePredByNodeName('DIV'),\n\t      isLi: isLi,\n\t      isBR: makePredByNodeName('BR'),\n\t      isSpan: makePredByNodeName('SPAN'),\n\t      isB: makePredByNodeName('B'),\n\t      isU: makePredByNodeName('U'),\n\t      isS: makePredByNodeName('S'),\n\t      isI: makePredByNodeName('I'),\n\t      isImg: makePredByNodeName('IMG'),\n\t      isTextarea: isTextarea,\n\t      isEmpty: isEmpty,\n\t      isEmptyAnchor: func.and(isAnchor, isEmpty),\n\t      isClosestSibling: isClosestSibling,\n\t      withClosestSiblings: withClosestSiblings,\n\t      nodeLength: nodeLength,\n\t      isLeftEdgePoint: isLeftEdgePoint,\n\t      isRightEdgePoint: isRightEdgePoint,\n\t      isEdgePoint: isEdgePoint,\n\t      isLeftEdgeOf: isLeftEdgeOf,\n\t      isRightEdgeOf: isRightEdgeOf,\n\t      isLeftEdgePointOf: isLeftEdgePointOf,\n\t      isRightEdgePointOf: isRightEdgePointOf,\n\t      prevPoint: prevPoint,\n\t      nextPoint: nextPoint,\n\t      isSamePoint: isSamePoint,\n\t      isVisiblePoint: isVisiblePoint,\n\t      prevPointUntil: prevPointUntil,\n\t      nextPointUntil: nextPointUntil,\n\t      isCharPoint: isCharPoint,\n\t      walkPoint: walkPoint,\n\t      ancestor: ancestor,\n\t      singleChildAncestor: singleChildAncestor,\n\t      listAncestor: listAncestor,\n\t      lastAncestor: lastAncestor,\n\t      listNext: listNext,\n\t      listPrev: listPrev,\n\t      listDescendant: listDescendant,\n\t      commonAncestor: commonAncestor,\n\t      wrap: wrap,\n\t      insertAfter: insertAfter,\n\t      appendChildNodes: appendChildNodes,\n\t      position: position,\n\t      hasChildren: hasChildren,\n\t      makeOffsetPath: makeOffsetPath,\n\t      fromOffsetPath: fromOffsetPath,\n\t      splitTree: splitTree,\n\t      splitPoint: splitPoint,\n\t      create: create,\n\t      createText: createText,\n\t      remove: remove,\n\t      removeWhile: removeWhile,\n\t      replace: replace,\n\t      html: html,\n\t      value: value,\n\t      posFromPlaceholder: posFromPlaceholder,\n\t      attachEvents: attachEvents,\n\t      detachEvents: detachEvents\n\t    };\n\t  })();\n\t\n\t  /**\n\t   * @param {jQuery} $note\n\t   * @param {Object} options\n\t   * @return {Context}\n\t   */\n\t  var Context = function ($note, options) {\n\t    var self = this;\n\t\n\t    var ui = $.summernote.ui;\n\t    this.memos = {};\n\t    this.modules = {};\n\t    this.layoutInfo = {};\n\t    this.options = options;\n\t\n\t    /**\n\t     * create layout and initialize modules and other resources\n\t     */\n\t    this.initialize = function () {\n\t      this.layoutInfo = ui.createLayout($note, options);\n\t      this._initialize();\n\t      $note.hide();\n\t      return this;\n\t    };\n\t\n\t    /**\n\t     * destroy modules and other resources and remove layout\n\t     */\n\t    this.destroy = function () {\n\t      this._destroy();\n\t      $note.removeData('summernote');\n\t      ui.removeLayout($note, this.layoutInfo);\n\t    };\n\t\n\t    /**\n\t     * destory modules and other resources and initialize it again\n\t     */\n\t    this.reset = function () {\n\t      var disabled = self.isDisabled();\n\t      this.code(dom.emptyPara);\n\t      this._destroy();\n\t      this._initialize();\n\t\n\t      if (disabled) {\n\t        self.disable();\n\t      }\n\t    };\n\t\n\t    this._initialize = function () {\n\t      // add optional buttons\n\t      var buttons = $.extend({}, this.options.buttons);\n\t      Object.keys(buttons).forEach(function (key) {\n\t        self.memo('button.' + key, buttons[key]);\n\t      });\n\t\n\t      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\t\n\t      // add and initialize modules\n\t      Object.keys(modules).forEach(function (key) {\n\t        self.module(key, modules[key], true);\n\t      });\n\t\n\t      Object.keys(this.modules).forEach(function (key) {\n\t        self.initializeModule(key);\n\t      });\n\t    };\n\t\n\t    this._destroy = function () {\n\t      // destroy modules with reversed order\n\t      Object.keys(this.modules).reverse().forEach(function (key) {\n\t        self.removeModule(key);\n\t      });\n\t\n\t      Object.keys(this.memos).forEach(function (key) {\n\t        self.removeMemo(key);\n\t      });\n\t    };\n\t\n\t    this.code = function (html) {\n\t      var isActivated = this.invoke('codeview.isActivated');\n\t\n\t      if (html === undefined) {\n\t        this.invoke('codeview.sync');\n\t        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n\t      } else {\n\t        if (isActivated) {\n\t          this.layoutInfo.codable.val(html);\n\t        } else {\n\t          this.layoutInfo.editable.html(html);\n\t        }\n\t        $note.val(html);\n\t        this.triggerEvent('change', html);\n\t      }\n\t    };\n\t\n\t    this.isDisabled = function () {\n\t      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n\t    };\n\t\n\t    this.enable = function () {\n\t      this.layoutInfo.editable.attr('contenteditable', true);\n\t      this.invoke('toolbar.activate', true);\n\t    };\n\t\n\t    this.disable = function () {\n\t      // close codeview if codeview is opend\n\t      if (this.invoke('codeview.isActivated')) {\n\t        this.invoke('codeview.deactivate');\n\t      }\n\t      this.layoutInfo.editable.attr('contenteditable', false);\n\t      this.invoke('toolbar.deactivate', true);\n\t    };\n\t\n\t    this.triggerEvent = function () {\n\t      var namespace = list.head(arguments);\n\t      var args = list.tail(list.from(arguments));\n\t\n\t      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n\t      if (callback) {\n\t        callback.apply($note[0], args);\n\t      }\n\t      $note.trigger('summernote.' + namespace, args);\n\t    };\n\t\n\t    this.initializeModule = function (key) {\n\t      var module = this.modules[key];\n\t      module.shouldInitialize = module.shouldInitialize || func.ok;\n\t      if (!module.shouldInitialize()) {\n\t        return;\n\t      }\n\t\n\t      // initialize module\n\t      if (module.initialize) {\n\t        module.initialize();\n\t      }\n\t\n\t      // attach events\n\t      if (module.events) {\n\t        dom.attachEvents($note, module.events);\n\t      }\n\t    };\n\t\n\t    this.module = function (key, ModuleClass, withoutIntialize) {\n\t      if (arguments.length === 1) {\n\t        return this.modules[key];\n\t      }\n\t\n\t      this.modules[key] = new ModuleClass(this);\n\t\n\t      if (!withoutIntialize) {\n\t        this.initializeModule(key);\n\t      }\n\t    };\n\t\n\t    this.removeModule = function (key) {\n\t      var module = this.modules[key];\n\t      if (module.shouldInitialize()) {\n\t        if (module.events) {\n\t          dom.detachEvents($note, module.events);\n\t        }\n\t\n\t        if (module.destroy) {\n\t          module.destroy();\n\t        }\n\t      }\n\t\n\t      delete this.modules[key];\n\t    };\n\t\n\t    this.memo = function (key, obj) {\n\t      if (arguments.length === 1) {\n\t        return this.memos[key];\n\t      }\n\t      this.memos[key] = obj;\n\t    };\n\t\n\t    this.removeMemo = function (key) {\n\t      if (this.memos[key] && this.memos[key].destroy) {\n\t        this.memos[key].destroy();\n\t      }\n\t\n\t      delete this.memos[key];\n\t    };\n\t\n\t    this.createInvokeHandler = function (namespace, value) {\n\t      return function (event) {\n\t        event.preventDefault();\n\t        self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));\n\t      };\n\t    };\n\t\n\t    this.invoke = function () {\n\t      var namespace = list.head(arguments);\n\t      var args = list.tail(list.from(arguments));\n\t\n\t      var splits = namespace.split('.');\n\t      var hasSeparator = splits.length > 1;\n\t      var moduleName = hasSeparator && list.head(splits);\n\t      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\t\n\t      var module = this.modules[moduleName || 'editor'];\n\t      if (!moduleName && this[methodName]) {\n\t        return this[methodName].apply(this, args);\n\t      } else if (module && module[methodName] && module.shouldInitialize()) {\n\t        return module[methodName].apply(module, args);\n\t      }\n\t    };\n\t\n\t    return this.initialize();\n\t  };\n\t\n\t  $.fn.extend({\n\t    /**\n\t     * Summernote API\n\t     *\n\t     * @param {Object|String}\n\t     * @return {this}\n\t     */\n\t    summernote: function () {\n\t      var type = $.type(list.head(arguments));\n\t      var isExternalAPICalled = type === 'string';\n\t      var hasInitOptions = type === 'object';\n\t\n\t      var options = hasInitOptions ? list.head(arguments) : {};\n\t\n\t      options = $.extend({}, $.summernote.options, options);\n\t      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n\t      options.icons = $.extend(true, {}, $.summernote.options.icons, options.icons);\n\t\n\t      this.each(function (idx, note) {\n\t        var $note = $(note);\n\t        if (!$note.data('summernote')) {\n\t          var context = new Context($note, options);\n\t          $note.data('summernote', context);\n\t          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n\t        }\n\t      });\n\t\n\t      var $note = this.first();\n\t      if ($note.length) {\n\t        var context = $note.data('summernote');\n\t        if (isExternalAPICalled) {\n\t          return context.invoke.apply(context, list.from(arguments));\n\t        } else if (options.focus) {\n\t          context.invoke('editor.focus');\n\t        }\n\t      }\n\t\n\t      return this;\n\t    }\n\t  });\n\t\n\t\n\t  var Renderer = function (markup, children, options, callback) {\n\t    this.render = function ($parent) {\n\t      var $node = $(markup);\n\t\n\t      if (options && options.contents) {\n\t        $node.html(options.contents);\n\t      }\n\t\n\t      if (options && options.className) {\n\t        $node.addClass(options.className);\n\t      }\n\t\n\t      if (options && options.data) {\n\t        $.each(options.data, function (k, v) {\n\t          $node.attr('data-' + k, v);\n\t        });\n\t      }\n\t\n\t      if (options && options.click) {\n\t        $node.on('click', options.click);\n\t      }\n\t\n\t      if (children) {\n\t        var $container = $node.find('.note-children-container');\n\t        children.forEach(function (child) {\n\t          child.render($container.length ? $container : $node);\n\t        });\n\t      }\n\t\n\t      if (callback) {\n\t        callback($node, options);\n\t      }\n\t\n\t      if (options && options.callback) {\n\t        options.callback($node);\n\t      }\n\t\n\t      if ($parent) {\n\t        $parent.append($node);\n\t      }\n\t\n\t      return $node;\n\t    };\n\t  };\n\t\n\t  var renderer = {\n\t    create: function (markup, callback) {\n\t      return function () {\n\t        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n\t        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n\t        if (options && options.children) {\n\t          children = options.children;\n\t        }\n\t        return new Renderer(markup, children, options, callback);\n\t      };\n\t    }\n\t  };\n\t\n\t  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n\t  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n\t  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n\t  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n\t  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n\t  var statusbar = renderer.create([\n\t    '<div class=\"note-statusbar\">',\n\t    '  <div class=\"note-resizebar\">',\n\t    '    <div class=\"note-icon-bar\"/>',\n\t    '    <div class=\"note-icon-bar\"/>',\n\t    '    <div class=\"note-icon-bar\"/>',\n\t    '  </div>',\n\t    '</div>'\n\t  ].join(''));\n\t\n\t  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n\t  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\t\n\t  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n\t  var button = renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\" tabindex=\"-1\">', function ($node, options) {\n\t    if (options && options.tooltip) {\n\t      $node.attr({\n\t        title: options.tooltip\n\t      }).tooltip({\n\t        container: 'body',\n\t        trigger: 'hover',\n\t        placement: 'bottom'\n\t      });\n\t    }\n\t  });\n\t\n\t  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n\t    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n\t      var value = (typeof item === 'string') ? item : (item.value || '');\n\t      var content = options.template ? options.template(item) : item;\n\t      return '<li><a href=\"#\" data-value=\"' + value + '\">' + content + '</a></li>';\n\t    }).join('') : options.items;\n\t\n\t    $node.html(markup);\n\t  });\n\t\n\t  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n\t    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n\t      var value = (typeof item === 'string') ? item : (item.value || '');\n\t      var content = options.template ? options.template(item) : item;\n\t      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n\t    }).join('') : options.items;\n\t    $node.html(markup);\n\t  });\n\t\n\t  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n\t    var contents = [];\n\t    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n\t      var eventName = options.eventName;\n\t      var colors = options.colors[row];\n\t      var buttons = [];\n\t      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n\t        var color = colors[col];\n\t        buttons.push([\n\t          '<button type=\"button\" class=\"note-color-btn\"',\n\t          'style=\"background-color:', color, '\" ',\n\t          'data-event=\"', eventName, '\" ',\n\t          'data-value=\"', color, '\" ',\n\t          'title=\"', color, '\" ',\n\t          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n\t        ].join(''));\n\t      }\n\t      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n\t    }\n\t    $node.html(contents.join(''));\n\t\n\t    $node.find('.note-color-btn').tooltip({\n\t      container: 'body',\n\t      trigger: 'hover',\n\t      placement: 'bottom'\n\t    });\n\t  });\n\t\n\t  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n\t    if (options.fade) {\n\t      $node.addClass('fade');\n\t    }\n\t    $node.html([\n\t      '<div class=\"modal-dialog\">',\n\t      '  <div class=\"modal-content\">',\n\t      (options.title ?\n\t      '    <div class=\"modal-header\">' +\n\t      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n\t      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n\t      '    </div>' : ''\n\t      ),\n\t      '    <div class=\"modal-body\">' + options.body + '</div>',\n\t      (options.footer ?\n\t      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n\t      ),\n\t      '  </div>',\n\t      '</div>'\n\t    ].join(''));\n\t  });\n\t\n\t  var popover = renderer.create([\n\t    '<div class=\"note-popover popover in\">',\n\t    '  <div class=\"arrow\"/>',\n\t    '  <div class=\"popover-content note-children-container\"/>',\n\t    '</div>'\n\t  ].join(''), function ($node, options) {\n\t    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\t\n\t    $node.addClass(direction);\n\t\n\t    if (options.hideArrow) {\n\t      $node.find('.arrow').hide();\n\t    }\n\t  });\n\t\n\t  var icon = function (iconClassName, tagName) {\n\t    tagName = tagName || 'i';\n\t    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n\t  };\n\t\n\t  var ui = {\n\t    editor: editor,\n\t    toolbar: toolbar,\n\t    editingArea: editingArea,\n\t    codable: codable,\n\t    editable: editable,\n\t    statusbar: statusbar,\n\t    airEditor: airEditor,\n\t    airEditable: airEditable,\n\t    buttonGroup: buttonGroup,\n\t    button: button,\n\t    dropdown: dropdown,\n\t    dropdownCheck: dropdownCheck,\n\t    palette: palette,\n\t    dialog: dialog,\n\t    popover: popover,\n\t    icon: icon,\n\t\n\t    toggleBtn: function ($btn, isEnable) {\n\t      $btn.toggleClass('disabled', !isEnable);\n\t      $btn.attr('disabled', !isEnable);\n\t    },\n\t\n\t    toggleBtnActive: function ($btn, isActive) {\n\t      $btn.toggleClass('active', isActive);\n\t    },\n\t\n\t    onDialogShown: function ($dialog, handler) {\n\t      $dialog.one('shown.bs.modal', handler);\n\t    },\n\t\n\t    onDialogHidden: function ($dialog, handler) {\n\t      $dialog.one('hidden.bs.modal', handler);\n\t    },\n\t\n\t    showDialog: function ($dialog) {\n\t      $dialog.modal('show');\n\t    },\n\t\n\t    hideDialog: function ($dialog) {\n\t      $dialog.modal('hide');\n\t    },\n\t\n\t    createLayout: function ($note, options) {\n\t      var $editor = (options.airMode ? ui.airEditor([\n\t        ui.editingArea([\n\t          ui.airEditable()\n\t        ])\n\t      ]) : ui.editor([\n\t        ui.toolbar(),\n\t        ui.editingArea([\n\t          ui.codable(),\n\t          ui.editable()\n\t        ]),\n\t        ui.statusbar()\n\t      ])).render();\n\t\n\t      $editor.insertAfter($note);\n\t\n\t      return {\n\t        note: $note,\n\t        editor: $editor,\n\t        toolbar: $editor.find('.note-toolbar'),\n\t        editingArea: $editor.find('.note-editing-area'),\n\t        editable: $editor.find('.note-editable'),\n\t        codable: $editor.find('.note-codable'),\n\t        statusbar: $editor.find('.note-statusbar')\n\t      };\n\t    },\n\t\n\t    removeLayout: function ($note, layoutInfo) {\n\t      $note.html(layoutInfo.editable.html());\n\t      layoutInfo.editor.remove();\n\t      $note.show();\n\t    }\n\t  };\n\t\n\t  $.summernote = $.summernote || {\n\t    lang: {}\n\t  };\n\t\n\t  $.extend($.summernote.lang, {\n\t    'en-US': {\n\t      font: {\n\t        bold: 'Bold',\n\t        italic: 'Italic',\n\t        underline: 'Underline',\n\t        clear: 'Remove Font Style',\n\t        height: 'Line Height',\n\t        name: 'Font Family',\n\t        strikethrough: 'Strikethrough',\n\t        subscript: 'Subscript',\n\t        superscript: 'Superscript',\n\t        size: 'Font Size'\n\t      },\n\t      image: {\n\t        image: 'Picture',\n\t        insert: 'Insert Image',\n\t        resizeFull: 'Resize Full',\n\t        resizeHalf: 'Resize Half',\n\t        resizeQuarter: 'Resize Quarter',\n\t        floatLeft: 'Float Left',\n\t        floatRight: 'Float Right',\n\t        floatNone: 'Float None',\n\t        shapeRounded: 'Shape: Rounded',\n\t        shapeCircle: 'Shape: Circle',\n\t        shapeThumbnail: 'Shape: Thumbnail',\n\t        shapeNone: 'Shape: None',\n\t        dragImageHere: 'Drag image or text here',\n\t        dropImage: 'Drop image or Text',\n\t        selectFromFiles: 'Select from files',\n\t        maximumFileSize: 'Maximum file size',\n\t        maximumFileSizeError: 'Maximum file size exceeded.',\n\t        url: 'Image URL',\n\t        remove: 'Remove Image'\n\t      },\n\t      video: {\n\t        video: 'Video',\n\t        videoLink: 'Video Link',\n\t        insert: 'Insert Video',\n\t        url: 'Video URL?',\n\t        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n\t      },\n\t      link: {\n\t        link: 'Link',\n\t        insert: 'Insert Link',\n\t        unlink: 'Unlink',\n\t        edit: 'Edit',\n\t        textToDisplay: 'Text to display',\n\t        url: 'To what URL should this link go?',\n\t        openInNewWindow: 'Open in new window'\n\t      },\n\t      table: {\n\t        table: 'Table'\n\t      },\n\t      hr: {\n\t        insert: 'Insert Horizontal Rule'\n\t      },\n\t      style: {\n\t        style: 'Style',\n\t        normal: 'Normal',\n\t        blockquote: 'Quote',\n\t        pre: 'Code',\n\t        h1: 'Header 1',\n\t        h2: 'Header 2',\n\t        h3: 'Header 3',\n\t        h4: 'Header 4',\n\t        h5: 'Header 5',\n\t        h6: 'Header 6'\n\t      },\n\t      lists: {\n\t        unordered: 'Unordered list',\n\t        ordered: 'Ordered list'\n\t      },\n\t      options: {\n\t        help: 'Help',\n\t        fullscreen: 'Full Screen',\n\t        codeview: 'Code View'\n\t      },\n\t      paragraph: {\n\t        paragraph: 'Paragraph',\n\t        outdent: 'Outdent',\n\t        indent: 'Indent',\n\t        left: 'Align left',\n\t        center: 'Align center',\n\t        right: 'Align right',\n\t        justify: 'Justify full'\n\t      },\n\t      color: {\n\t        recent: 'Recent Color',\n\t        more: 'More Color',\n\t        background: 'Background Color',\n\t        foreground: 'Foreground Color',\n\t        transparent: 'Transparent',\n\t        setTransparent: 'Set transparent',\n\t        reset: 'Reset',\n\t        resetToDefault: 'Reset to default'\n\t      },\n\t      shortcut: {\n\t        shortcuts: 'Keyboard shortcuts',\n\t        close: 'Close',\n\t        textFormatting: 'Text formatting',\n\t        action: 'Action',\n\t        paragraphFormatting: 'Paragraph formatting',\n\t        documentStyle: 'Document Style',\n\t        extraKeys: 'Extra keys'\n\t      },\n\t      help: {\n\t        'insertParagraph': 'Insert Paragraph',\n\t        'undo': 'Undoes the last command',\n\t        'redo': 'Redoes the last command',\n\t        'tab': 'Tab',\n\t        'untab': 'Untab',\n\t        'bold': 'Set a bold style',\n\t        'italic': 'Set a italic style',\n\t        'underline': 'Set a underline style',\n\t        'strikethrough': 'Set a strikethrough style',\n\t        'removeFormat': 'Clean a style',\n\t        'justifyLeft': 'Set left align',\n\t        'justifyCenter': 'Set center align',\n\t        'justifyRight': 'Set right align',\n\t        'justifyFull': 'Set full align',\n\t        'insertUnorderedList': 'Toggle unordered list',\n\t        'insertOrderedList': 'Toggle ordered list',\n\t        'outdent': 'Outdent on current paragraph',\n\t        'indent': 'Indent on current paragraph',\n\t        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n\t        'formatH1': 'Change current block\\'s format as H1',\n\t        'formatH2': 'Change current block\\'s format as H2',\n\t        'formatH3': 'Change current block\\'s format as H3',\n\t        'formatH4': 'Change current block\\'s format as H4',\n\t        'formatH5': 'Change current block\\'s format as H5',\n\t        'formatH6': 'Change current block\\'s format as H6',\n\t        'insertHorizontalRule': 'Insert horizontal rule',\n\t        'linkDialog.show': 'Show Link Dialog'\n\t      },\n\t      history: {\n\t        undo: 'Undo',\n\t        redo: 'Redo'\n\t      },\n\t      specialChar: {\n\t        specialChar: 'SPECIAL CHARACTERS',\n\t        select: 'Select Special characters'\n\t      }\n\t    }\n\t  });\n\t\n\t\n\t  /**\n\t   * @class core.key\n\t   *\n\t   * Object for keycodes.\n\t   *\n\t   * @singleton\n\t   * @alternateClassName key\n\t   */\n\t  var key = (function () {\n\t    var keyMap = {\n\t      'BACKSPACE': 8,\n\t      'TAB': 9,\n\t      'ENTER': 13,\n\t      'SPACE': 32,\n\t\n\t      // Arrow\n\t      'LEFT': 37,\n\t      'UP': 38,\n\t      'RIGHT': 39,\n\t      'DOWN': 40,\n\t\n\t      // Number: 0-9\n\t      'NUM0': 48,\n\t      'NUM1': 49,\n\t      'NUM2': 50,\n\t      'NUM3': 51,\n\t      'NUM4': 52,\n\t      'NUM5': 53,\n\t      'NUM6': 54,\n\t      'NUM7': 55,\n\t      'NUM8': 56,\n\t\n\t      // Alphabet: a-z\n\t      'B': 66,\n\t      'E': 69,\n\t      'I': 73,\n\t      'J': 74,\n\t      'K': 75,\n\t      'L': 76,\n\t      'R': 82,\n\t      'S': 83,\n\t      'U': 85,\n\t      'V': 86,\n\t      'Y': 89,\n\t      'Z': 90,\n\t\n\t      'SLASH': 191,\n\t      'LEFTBRACKET': 219,\n\t      'BACKSLASH': 220,\n\t      'RIGHTBRACKET': 221\n\t    };\n\t\n\t    return {\n\t      /**\n\t       * @method isEdit\n\t       *\n\t       * @param {Number} keyCode\n\t       * @return {Boolean}\n\t       */\n\t      isEdit: function (keyCode) {\n\t        return list.contains([\n\t          keyMap.BACKSPACE,\n\t          keyMap.TAB,\n\t          keyMap.ENTER,\n\t          keyMap.SPACE\n\t        ], keyCode);\n\t      },\n\t      /**\n\t       * @method isMove\n\t       *\n\t       * @param {Number} keyCode\n\t       * @return {Boolean}\n\t       */\n\t      isMove: function (keyCode) {\n\t        return list.contains([\n\t          keyMap.LEFT,\n\t          keyMap.UP,\n\t          keyMap.RIGHT,\n\t          keyMap.DOWN\n\t        ], keyCode);\n\t      },\n\t      /**\n\t       * @property {Object} nameFromCode\n\t       * @property {String} nameFromCode.8 \"BACKSPACE\"\n\t       */\n\t      nameFromCode: func.invertObject(keyMap),\n\t      code: keyMap\n\t    };\n\t  })();\n\t\n\t  var range = (function () {\n\t\n\t    /**\n\t     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n\t     *\n\t     * @param {TextRange} textRange\n\t     * @param {Boolean} isStart\n\t     * @return {BoundaryPoint}\n\t     *\n\t     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n\t     */\n\t    var textRangeToPoint = function (textRange, isStart) {\n\t      var container = textRange.parentElement(), offset;\n\t  \n\t      var tester = document.body.createTextRange(), prevContainer;\n\t      var childNodes = list.from(container.childNodes);\n\t      for (offset = 0; offset < childNodes.length; offset++) {\n\t        if (dom.isText(childNodes[offset])) {\n\t          continue;\n\t        }\n\t        tester.moveToElementText(childNodes[offset]);\n\t        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n\t          break;\n\t        }\n\t        prevContainer = childNodes[offset];\n\t      }\n\t  \n\t      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n\t        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n\t        textRangeStart.moveToElementText(prevContainer || container);\n\t        textRangeStart.collapse(!prevContainer);\n\t        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n\t  \n\t        var pointTester = textRange.duplicate();\n\t        pointTester.setEndPoint('StartToStart', textRangeStart);\n\t        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n\t  \n\t        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n\t          textCount -= curTextNode.nodeValue.length;\n\t          curTextNode = curTextNode.nextSibling;\n\t        }\n\t  \n\t        /* jshint ignore:start */\n\t        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n\t        /* jshint ignore:end */\n\t  \n\t        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n\t            textCount === curTextNode.nodeValue.length) {\n\t          textCount -= curTextNode.nodeValue.length;\n\t          curTextNode = curTextNode.nextSibling;\n\t        }\n\t  \n\t        container = curTextNode;\n\t        offset = textCount;\n\t      }\n\t  \n\t      return {\n\t        cont: container,\n\t        offset: offset\n\t      };\n\t    };\n\t    \n\t    /**\n\t     * return TextRange from boundary point (inspired by google closure-library)\n\t     * @param {BoundaryPoint} point\n\t     * @return {TextRange}\n\t     */\n\t    var pointToTextRange = function (point) {\n\t      var textRangeInfo = function (container, offset) {\n\t        var node, isCollapseToStart;\n\t  \n\t        if (dom.isText(container)) {\n\t          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n\t          var prevContainer = list.last(prevTextNodes).previousSibling;\n\t          node =  prevContainer || container.parentNode;\n\t          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n\t          isCollapseToStart = !prevContainer;\n\t        } else {\n\t          node = container.childNodes[offset] || container;\n\t          if (dom.isText(node)) {\n\t            return textRangeInfo(node, 0);\n\t          }\n\t  \n\t          offset = 0;\n\t          isCollapseToStart = false;\n\t        }\n\t  \n\t        return {\n\t          node: node,\n\t          collapseToStart: isCollapseToStart,\n\t          offset: offset\n\t        };\n\t      };\n\t  \n\t      var textRange = document.body.createTextRange();\n\t      var info = textRangeInfo(point.node, point.offset);\n\t  \n\t      textRange.moveToElementText(info.node);\n\t      textRange.collapse(info.collapseToStart);\n\t      textRange.moveStart('character', info.offset);\n\t      return textRange;\n\t    };\n\t    \n\t    /**\n\t     * Wrapped Range\n\t     *\n\t     * @constructor\n\t     * @param {Node} sc - start container\n\t     * @param {Number} so - start offset\n\t     * @param {Node} ec - end container\n\t     * @param {Number} eo - end offset\n\t     */\n\t    var WrappedRange = function (sc, so, ec, eo) {\n\t      this.sc = sc;\n\t      this.so = so;\n\t      this.ec = ec;\n\t      this.eo = eo;\n\t  \n\t      // nativeRange: get nativeRange from sc, so, ec, eo\n\t      var nativeRange = function () {\n\t        if (agent.isW3CRangeSupport) {\n\t          var w3cRange = document.createRange();\n\t          w3cRange.setStart(sc, so);\n\t          w3cRange.setEnd(ec, eo);\n\t\n\t          return w3cRange;\n\t        } else {\n\t          var textRange = pointToTextRange({\n\t            node: sc,\n\t            offset: so\n\t          });\n\t\n\t          textRange.setEndPoint('EndToEnd', pointToTextRange({\n\t            node: ec,\n\t            offset: eo\n\t          }));\n\t\n\t          return textRange;\n\t        }\n\t      };\n\t\n\t      this.getPoints = function () {\n\t        return {\n\t          sc: sc,\n\t          so: so,\n\t          ec: ec,\n\t          eo: eo\n\t        };\n\t      };\n\t\n\t      this.getStartPoint = function () {\n\t        return {\n\t          node: sc,\n\t          offset: so\n\t        };\n\t      };\n\t\n\t      this.getEndPoint = function () {\n\t        return {\n\t          node: ec,\n\t          offset: eo\n\t        };\n\t      };\n\t\n\t      /**\n\t       * select update visible range\n\t       */\n\t      this.select = function () {\n\t        var nativeRng = nativeRange();\n\t        if (agent.isW3CRangeSupport) {\n\t          var selection = document.getSelection();\n\t          if (selection.rangeCount > 0) {\n\t            selection.removeAllRanges();\n\t          }\n\t          selection.addRange(nativeRng);\n\t        } else {\n\t          nativeRng.select();\n\t        }\n\t        \n\t        return this;\n\t      };\n\t\n\t      /**\n\t       * Moves the scrollbar to start container(sc) of current range\n\t       *\n\t       * @return {WrappedRange}\n\t       */\n\t      this.scrollIntoView = function (container) {\n\t        var height = $(container).height();\n\t        if (container.scrollTop + height < this.sc.offsetTop) {\n\t          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n\t        }\n\t\n\t        return this;\n\t      };\n\t\n\t      /**\n\t       * @return {WrappedRange}\n\t       */\n\t      this.normalize = function () {\n\t\n\t        /**\n\t         * @param {BoundaryPoint} point\n\t         * @param {Boolean} isLeftToRight\n\t         * @return {BoundaryPoint}\n\t         */\n\t        var getVisiblePoint = function (point, isLeftToRight) {\n\t          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n\t              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n\t              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n\t              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n\t            return point;\n\t          }\n\t\n\t          // point on block's edge\n\t          var block = dom.ancestor(point.node, dom.isBlock);\n\t          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n\t              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\t\n\t            // returns point already on visible point\n\t            if (dom.isVisiblePoint(point)) {\n\t              return point;\n\t            }\n\t            // reverse direction \n\t            isLeftToRight = !isLeftToRight;\n\t          }\n\t\n\t          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n\t                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n\t          return nextPoint || point;\n\t        };\n\t\n\t        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n\t        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\t\n\t        return new WrappedRange(\n\t          startPoint.node,\n\t          startPoint.offset,\n\t          endPoint.node,\n\t          endPoint.offset\n\t        );\n\t      };\n\t\n\t      /**\n\t       * returns matched nodes on range\n\t       *\n\t       * @param {Function} [pred] - predicate function\n\t       * @param {Object} [options]\n\t       * @param {Boolean} [options.includeAncestor]\n\t       * @param {Boolean} [options.fullyContains]\n\t       * @return {Node[]}\n\t       */\n\t      this.nodes = function (pred, options) {\n\t        pred = pred || func.ok;\n\t\n\t        var includeAncestor = options && options.includeAncestor;\n\t        var fullyContains = options && options.fullyContains;\n\t\n\t        // TODO compare points and sort\n\t        var startPoint = this.getStartPoint();\n\t        var endPoint = this.getEndPoint();\n\t\n\t        var nodes = [];\n\t        var leftEdgeNodes = [];\n\t\n\t        dom.walkPoint(startPoint, endPoint, function (point) {\n\t          if (dom.isEditable(point.node)) {\n\t            return;\n\t          }\n\t\n\t          var node;\n\t          if (fullyContains) {\n\t            if (dom.isLeftEdgePoint(point)) {\n\t              leftEdgeNodes.push(point.node);\n\t            }\n\t            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n\t              node = point.node;\n\t            }\n\t          } else if (includeAncestor) {\n\t            node = dom.ancestor(point.node, pred);\n\t          } else {\n\t            node = point.node;\n\t          }\n\t\n\t          if (node && pred(node)) {\n\t            nodes.push(node);\n\t          }\n\t        }, true);\n\t\n\t        return list.unique(nodes);\n\t      };\n\t\n\t      /**\n\t       * returns commonAncestor of range\n\t       * @return {Element} - commonAncestor\n\t       */\n\t      this.commonAncestor = function () {\n\t        return dom.commonAncestor(sc, ec);\n\t      };\n\t\n\t      /**\n\t       * returns expanded range by pred\n\t       *\n\t       * @param {Function} pred - predicate function\n\t       * @return {WrappedRange}\n\t       */\n\t      this.expand = function (pred) {\n\t        var startAncestor = dom.ancestor(sc, pred);\n\t        var endAncestor = dom.ancestor(ec, pred);\n\t\n\t        if (!startAncestor && !endAncestor) {\n\t          return new WrappedRange(sc, so, ec, eo);\n\t        }\n\t\n\t        var boundaryPoints = this.getPoints();\n\t\n\t        if (startAncestor) {\n\t          boundaryPoints.sc = startAncestor;\n\t          boundaryPoints.so = 0;\n\t        }\n\t\n\t        if (endAncestor) {\n\t          boundaryPoints.ec = endAncestor;\n\t          boundaryPoints.eo = dom.nodeLength(endAncestor);\n\t        }\n\t\n\t        return new WrappedRange(\n\t          boundaryPoints.sc,\n\t          boundaryPoints.so,\n\t          boundaryPoints.ec,\n\t          boundaryPoints.eo\n\t        );\n\t      };\n\t\n\t      /**\n\t       * @param {Boolean} isCollapseToStart\n\t       * @return {WrappedRange}\n\t       */\n\t      this.collapse = function (isCollapseToStart) {\n\t        if (isCollapseToStart) {\n\t          return new WrappedRange(sc, so, sc, so);\n\t        } else {\n\t          return new WrappedRange(ec, eo, ec, eo);\n\t        }\n\t      };\n\t\n\t      /**\n\t       * splitText on range\n\t       */\n\t      this.splitText = function () {\n\t        var isSameContainer = sc === ec;\n\t        var boundaryPoints = this.getPoints();\n\t\n\t        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n\t          ec.splitText(eo);\n\t        }\n\t\n\t        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n\t          boundaryPoints.sc = sc.splitText(so);\n\t          boundaryPoints.so = 0;\n\t\n\t          if (isSameContainer) {\n\t            boundaryPoints.ec = boundaryPoints.sc;\n\t            boundaryPoints.eo = eo - so;\n\t          }\n\t        }\n\t\n\t        return new WrappedRange(\n\t          boundaryPoints.sc,\n\t          boundaryPoints.so,\n\t          boundaryPoints.ec,\n\t          boundaryPoints.eo\n\t        );\n\t      };\n\t\n\t      /**\n\t       * delete contents on range\n\t       * @return {WrappedRange}\n\t       */\n\t      this.deleteContents = function () {\n\t        if (this.isCollapsed()) {\n\t          return this;\n\t        }\n\t\n\t        var rng = this.splitText();\n\t        var nodes = rng.nodes(null, {\n\t          fullyContains: true\n\t        });\n\t\n\t        // find new cursor point\n\t        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n\t          return !list.contains(nodes, point.node);\n\t        });\n\t\n\t        var emptyParents = [];\n\t        $.each(nodes, function (idx, node) {\n\t          // find empty parents\n\t          var parent = node.parentNode;\n\t          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n\t            emptyParents.push(parent);\n\t          }\n\t          dom.remove(node, false);\n\t        });\n\t\n\t        // remove empty parents\n\t        $.each(emptyParents, function (idx, node) {\n\t          dom.remove(node, false);\n\t        });\n\t\n\t        return new WrappedRange(\n\t          point.node,\n\t          point.offset,\n\t          point.node,\n\t          point.offset\n\t        ).normalize();\n\t      };\n\t      \n\t      /**\n\t       * makeIsOn: return isOn(pred) function\n\t       */\n\t      var makeIsOn = function (pred) {\n\t        return function () {\n\t          var ancestor = dom.ancestor(sc, pred);\n\t          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n\t        };\n\t      };\n\t  \n\t      // isOnEditable: judge whether range is on editable or not\n\t      this.isOnEditable = makeIsOn(dom.isEditable);\n\t      // isOnList: judge whether range is on list node or not\n\t      this.isOnList = makeIsOn(dom.isList);\n\t      // isOnAnchor: judge whether range is on anchor node or not\n\t      this.isOnAnchor = makeIsOn(dom.isAnchor);\n\t      // isOnCell: judge whether range is on cell node or not\n\t      this.isOnCell = makeIsOn(dom.isCell);\n\t      // isOnData: judge whether range is on data node or not\n\t      this.isOnData = makeIsOn(dom.isData);\n\t\n\t      /**\n\t       * @param {Function} pred\n\t       * @return {Boolean}\n\t       */\n\t      this.isLeftEdgeOf = function (pred) {\n\t        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n\t          return false;\n\t        }\n\t\n\t        var node = dom.ancestor(this.sc, pred);\n\t        return node && dom.isLeftEdgeOf(this.sc, node);\n\t      };\n\t\n\t      /**\n\t       * returns whether range was collapsed or not\n\t       */\n\t      this.isCollapsed = function () {\n\t        return sc === ec && so === eo;\n\t      };\n\t\n\t      /**\n\t       * wrap inline nodes which children of body with paragraph\n\t       *\n\t       * @return {WrappedRange}\n\t       */\n\t      this.wrapBodyInlineWithPara = function () {\n\t        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n\t          sc.innerHTML = dom.emptyPara;\n\t          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n\t        }\n\t\n\t        /**\n\t         * [workaround] firefox often create range on not visible point. so normalize here.\n\t         *  - firefox: |<p>text</p>|\n\t         *  - chrome: <p>|text|</p>\n\t         */\n\t        var rng = this.normalize();\n\t        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n\t          return rng;\n\t        }\n\t\n\t        // find inline top ancestor\n\t        var topAncestor;\n\t        if (dom.isInline(rng.sc)) {\n\t          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n\t          topAncestor = list.last(ancestors);\n\t          if (!dom.isInline(topAncestor)) {\n\t            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n\t          }\n\t        } else {\n\t          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n\t        }\n\t\n\t        // siblings not in paragraph\n\t        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n\t        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\t\n\t        // wrap with paragraph\n\t        if (inlineSiblings.length) {\n\t          var para = dom.wrap(list.head(inlineSiblings), 'p');\n\t          dom.appendChildNodes(para, list.tail(inlineSiblings));\n\t        }\n\t\n\t        return this.normalize();\n\t      };\n\t\n\t      /**\n\t       * insert node at current cursor\n\t       *\n\t       * @param {Node} node\n\t       * @return {Node}\n\t       */\n\t      this.insertNode = function (node) {\n\t        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\t        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\t\n\t        if (info.rightNode) {\n\t          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n\t        } else {\n\t          info.container.appendChild(node);\n\t        }\n\t\n\t        return node;\n\t      };\n\t\n\t      /**\n\t       * insert html at current cursor\n\t       */\n\t      this.pasteHTML = function (markup) {\n\t        var contentsContainer = $('<div></div>').html(markup)[0];\n\t        var childNodes = list.from(contentsContainer.childNodes);\n\t\n\t        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\t\n\t        return childNodes.reverse().map(function (childNode) {\n\t          return rng.insertNode(childNode);\n\t        }).reverse();\n\t      };\n\t  \n\t      /**\n\t       * returns text in range\n\t       *\n\t       * @return {String}\n\t       */\n\t      this.toString = function () {\n\t        var nativeRng = nativeRange();\n\t        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n\t      };\n\t\n\t      /**\n\t       * returns range for word before cursor\n\t       *\n\t       * @param {Boolean} [findAfter] - find after cursor, default: false\n\t       * @return {WrappedRange}\n\t       */\n\t      this.getWordRange = function (findAfter) {\n\t        var endPoint = this.getEndPoint();\n\t\n\t        if (!dom.isCharPoint(endPoint)) {\n\t          return this;\n\t        }\n\t\n\t        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n\t          return !dom.isCharPoint(point);\n\t        });\n\t\n\t        if (findAfter) {\n\t          endPoint = dom.nextPointUntil(endPoint, function (point) {\n\t            return !dom.isCharPoint(point);\n\t          });\n\t        }\n\t\n\t        return new WrappedRange(\n\t          startPoint.node,\n\t          startPoint.offset,\n\t          endPoint.node,\n\t          endPoint.offset\n\t        );\n\t      };\n\t  \n\t      /**\n\t       * create offsetPath bookmark\n\t       *\n\t       * @param {Node} editable\n\t       */\n\t      this.bookmark = function (editable) {\n\t        return {\n\t          s: {\n\t            path: dom.makeOffsetPath(editable, sc),\n\t            offset: so\n\t          },\n\t          e: {\n\t            path: dom.makeOffsetPath(editable, ec),\n\t            offset: eo\n\t          }\n\t        };\n\t      };\n\t\n\t      /**\n\t       * create offsetPath bookmark base on paragraph\n\t       *\n\t       * @param {Node[]} paras\n\t       */\n\t      this.paraBookmark = function (paras) {\n\t        return {\n\t          s: {\n\t            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n\t            offset: so\n\t          },\n\t          e: {\n\t            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n\t            offset: eo\n\t          }\n\t        };\n\t      };\n\t\n\t      /**\n\t       * getClientRects\n\t       * @return {Rect[]}\n\t       */\n\t      this.getClientRects = function () {\n\t        var nativeRng = nativeRange();\n\t        return nativeRng.getClientRects();\n\t      };\n\t    };\n\t\n\t  /**\n\t   * @class core.range\n\t   *\n\t   * Data structure\n\t   *  * BoundaryPoint: a point of dom tree\n\t   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n\t   *\n\t   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n\t   *\n\t   * @singleton\n\t   * @alternateClassName range\n\t   */\n\t    return {\n\t      /**\n\t       * create Range Object From arguments or Browser Selection\n\t       *\n\t       * @param {Node} sc - start container\n\t       * @param {Number} so - start offset\n\t       * @param {Node} ec - end container\n\t       * @param {Number} eo - end offset\n\t       * @return {WrappedRange}\n\t       */\n\t      create: function (sc, so, ec, eo) {\n\t        if (arguments.length === 4) {\n\t          return new WrappedRange(sc, so, ec, eo);\n\t        } else if (arguments.length === 2) { //collapsed\n\t          ec = sc;\n\t          eo = so;\n\t          return new WrappedRange(sc, so, ec, eo);\n\t        } else {\n\t          var wrappedRange = this.createFromSelection();\n\t          if (!wrappedRange && arguments.length === 1) {\n\t            wrappedRange = this.createFromNode(arguments[0]);\n\t            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n\t          }\n\t          return wrappedRange;\n\t        }\n\t      },\n\t\n\t      createFromSelection: function () {\n\t        var sc, so, ec, eo;\n\t        if (agent.isW3CRangeSupport) {\n\t          var selection = document.getSelection();\n\t          if (!selection || selection.rangeCount === 0) {\n\t            return null;\n\t          } else if (dom.isBody(selection.anchorNode)) {\n\t            // Firefox: returns entire body as range on initialization.\n\t            // We won't never need it.\n\t            return null;\n\t          }\n\t\n\t          var nativeRng = selection.getRangeAt(0);\n\t          sc = nativeRng.startContainer;\n\t          so = nativeRng.startOffset;\n\t          ec = nativeRng.endContainer;\n\t          eo = nativeRng.endOffset;\n\t        } else { // IE8: TextRange\n\t          var textRange = document.selection.createRange();\n\t          var textRangeEnd = textRange.duplicate();\n\t          textRangeEnd.collapse(false);\n\t          var textRangeStart = textRange;\n\t          textRangeStart.collapse(true);\n\t\n\t          var startPoint = textRangeToPoint(textRangeStart, true),\n\t          endPoint = textRangeToPoint(textRangeEnd, false);\n\t\n\t          // same visible point case: range was collapsed.\n\t          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n\t              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n\t              endPoint.node.nextSibling === startPoint.node) {\n\t            startPoint = endPoint;\n\t          }\n\t\n\t          sc = startPoint.cont;\n\t          so = startPoint.offset;\n\t          ec = endPoint.cont;\n\t          eo = endPoint.offset;\n\t        }\n\t\n\t        return new WrappedRange(sc, so, ec, eo);\n\t      },\n\t\n\t      /**\n\t       * @method \n\t       * \n\t       * create WrappedRange from node\n\t       *\n\t       * @param {Node} node\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromNode: function (node) {\n\t        var sc = node;\n\t        var so = 0;\n\t        var ec = node;\n\t        var eo = dom.nodeLength(ec);\n\t\n\t        // browsers can't target a picture or void node\n\t        if (dom.isVoid(sc)) {\n\t          so = dom.listPrev(sc).length - 1;\n\t          sc = sc.parentNode;\n\t        }\n\t        if (dom.isBR(ec)) {\n\t          eo = dom.listPrev(ec).length - 1;\n\t          ec = ec.parentNode;\n\t        } else if (dom.isVoid(ec)) {\n\t          eo = dom.listPrev(ec).length;\n\t          ec = ec.parentNode;\n\t        }\n\t\n\t        return this.create(sc, so, ec, eo);\n\t      },\n\t\n\t      /**\n\t       * create WrappedRange from node after position\n\t       *\n\t       * @param {Node} node\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromNodeBefore: function (node) {\n\t        return this.createFromNode(node).collapse(true);\n\t      },\n\t\n\t      /**\n\t       * create WrappedRange from node after position\n\t       *\n\t       * @param {Node} node\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromNodeAfter: function (node) {\n\t        return this.createFromNode(node).collapse();\n\t      },\n\t\n\t      /**\n\t       * @method \n\t       * \n\t       * create WrappedRange from bookmark\n\t       *\n\t       * @param {Node} editable\n\t       * @param {Object} bookmark\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromBookmark: function (editable, bookmark) {\n\t        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n\t        var so = bookmark.s.offset;\n\t        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n\t        var eo = bookmark.e.offset;\n\t        return new WrappedRange(sc, so, ec, eo);\n\t      },\n\t\n\t      /**\n\t       * @method \n\t       *\n\t       * create WrappedRange from paraBookmark\n\t       *\n\t       * @param {Object} bookmark\n\t       * @param {Node[]} paras\n\t       * @return {WrappedRange}\n\t       */\n\t      createFromParaBookmark: function (bookmark, paras) {\n\t        var so = bookmark.s.offset;\n\t        var eo = bookmark.e.offset;\n\t        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n\t        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\t\n\t        return new WrappedRange(sc, so, ec, eo);\n\t      }\n\t    };\n\t  })();\n\t\n\t  /**\n\t   * @class core.async\n\t   *\n\t   * Async functions which returns `Promise`\n\t   *\n\t   * @singleton\n\t   * @alternateClassName async\n\t   */\n\t  var async = (function () {\n\t    /**\n\t     * @method readFileAsDataURL\n\t     *\n\t     * read contents of file as representing URL\n\t     *\n\t     * @param {File} file\n\t     * @return {Promise} - then: dataUrl\n\t     */\n\t    var readFileAsDataURL = function (file) {\n\t      return $.Deferred(function (deferred) {\n\t        $.extend(new FileReader(), {\n\t          onload: function (e) {\n\t            var dataURL = e.target.result;\n\t            deferred.resolve(dataURL);\n\t          },\n\t          onerror: function () {\n\t            deferred.reject(this);\n\t          }\n\t        }).readAsDataURL(file);\n\t      }).promise();\n\t    };\n\t  \n\t    /**\n\t     * @method createImage\n\t     *\n\t     * create `<image>` from url string\n\t     *\n\t     * @param {String} url\n\t     * @return {Promise} - then: $image\n\t     */\n\t    var createImage = function (url) {\n\t      return $.Deferred(function (deferred) {\n\t        var $img = $('<img>');\n\t\n\t        $img.one('load', function () {\n\t          $img.off('error abort');\n\t          deferred.resolve($img);\n\t        }).one('error abort', function () {\n\t          $img.off('load').detach();\n\t          deferred.reject($img);\n\t        }).css({\n\t          display: 'none'\n\t        }).appendTo(document.body).attr('src', url);\n\t      }).promise();\n\t    };\n\t\n\t    return {\n\t      readFileAsDataURL: readFileAsDataURL,\n\t      createImage: createImage\n\t    };\n\t  })();\n\t\n\t  /**\n\t   * @class editing.History\n\t   *\n\t   * Editor History\n\t   *\n\t   */\n\t  var History = function ($editable) {\n\t    var stack = [], stackOffset = -1;\n\t    var editable = $editable[0];\n\t\n\t    var makeSnapshot = function () {\n\t      var rng = range.create(editable);\n\t      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\t\n\t      return {\n\t        contents: $editable.html(),\n\t        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n\t      };\n\t    };\n\t\n\t    var applySnapshot = function (snapshot) {\n\t      if (snapshot.contents !== null) {\n\t        $editable.html(snapshot.contents);\n\t      }\n\t      if (snapshot.bookmark !== null) {\n\t        range.createFromBookmark(editable, snapshot.bookmark).select();\n\t      }\n\t    };\n\t\n\t    /**\n\t    * @method rewind\n\t    * Rewinds the history stack back to the first snapshot taken.\n\t    * Leaves the stack intact, so that \"Redo\" can still be used.\n\t    */\n\t    this.rewind = function () {\n\t      // Create snap shot if not yet recorded\n\t      if ($editable.html() !== stack[stackOffset].contents) {\n\t        this.recordUndo();\n\t      }\n\t\n\t      // Return to the first available snapshot.\n\t      stackOffset = 0;\n\t\n\t      // Apply that snapshot.\n\t      applySnapshot(stack[stackOffset]);\n\t    };\n\t\n\t    /**\n\t    * @method reset\n\t    * Resets the history stack completely; reverting to an empty editor.\n\t    */\n\t    this.reset = function () {\n\t      // Clear the stack.\n\t      stack = [];\n\t\n\t      // Restore stackOffset to its original value.\n\t      stackOffset = -1;\n\t\n\t      // Clear the editable area.\n\t      $editable.html('');\n\t\n\t      // Record our first snapshot (of nothing).\n\t      this.recordUndo();\n\t    };\n\t\n\t    /**\n\t     * undo\n\t     */\n\t    this.undo = function () {\n\t      // Create snap shot if not yet recorded\n\t      if ($editable.html() !== stack[stackOffset].contents) {\n\t        this.recordUndo();\n\t      }\n\t\n\t      if (0 < stackOffset) {\n\t        stackOffset--;\n\t        applySnapshot(stack[stackOffset]);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * redo\n\t     */\n\t    this.redo = function () {\n\t      if (stack.length - 1 > stackOffset) {\n\t        stackOffset++;\n\t        applySnapshot(stack[stackOffset]);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * recorded undo\n\t     */\n\t    this.recordUndo = function () {\n\t      stackOffset++;\n\t\n\t      // Wash out stack after stackOffset\n\t      if (stack.length > stackOffset) {\n\t        stack = stack.slice(0, stackOffset);\n\t      }\n\t\n\t      // Create new snapshot and push it to the end\n\t      stack.push(makeSnapshot());\n\t    };\n\t  };\n\t\n\t  /**\n\t   * @class editing.Style\n\t   *\n\t   * Style\n\t   *\n\t   */\n\t  var Style = function () {\n\t    /**\n\t     * @method jQueryCSS\n\t     *\n\t     * [workaround] for old jQuery\n\t     * passing an array of style properties to .css()\n\t     * will result in an object of property-value pairs.\n\t     * (compability with version < 1.9)\n\t     *\n\t     * @private\n\t     * @param  {jQuery} $obj\n\t     * @param  {Array} propertyNames - An array of one or more CSS properties.\n\t     * @return {Object}\n\t     */\n\t    var jQueryCSS = function ($obj, propertyNames) {\n\t      if (agent.jqueryVersion < 1.9) {\n\t        var result = {};\n\t        $.each(propertyNames, function (idx, propertyName) {\n\t          result[propertyName] = $obj.css(propertyName);\n\t        });\n\t        return result;\n\t      }\n\t      return $obj.css.call($obj, propertyNames);\n\t    };\n\t\n\t    /**\n\t     * returns style object from node\n\t     *\n\t     * @param {jQuery} $node\n\t     * @return {Object}\n\t     */\n\t    this.fromNode = function ($node) {\n\t      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n\t      var styleInfo = jQueryCSS($node, properties) || {};\n\t      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n\t      return styleInfo;\n\t    };\n\t\n\t    /**\n\t     * paragraph level style\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @param {Object} styleInfo\n\t     */\n\t    this.stylePara = function (rng, styleInfo) {\n\t      $.each(rng.nodes(dom.isPara, {\n\t        includeAncestor: true\n\t      }), function (idx, para) {\n\t        $(para).css(styleInfo);\n\t      });\n\t    };\n\t\n\t    /**\n\t     * insert and returns styleNodes on range.\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @param {Object} [options] - options for styleNodes\n\t     * @param {String} [options.nodeName] - default: `SPAN`\n\t     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n\t     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n\t     * @return {Node[]}\n\t     */\n\t    this.styleNodes = function (rng, options) {\n\t      rng = rng.splitText();\n\t\n\t      var nodeName = options && options.nodeName || 'SPAN';\n\t      var expandClosestSibling = !!(options && options.expandClosestSibling);\n\t      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\t\n\t      if (rng.isCollapsed()) {\n\t        return [rng.insertNode(dom.create(nodeName))];\n\t      }\n\t\n\t      var pred = dom.makePredByNodeName(nodeName);\n\t      var nodes = rng.nodes(dom.isText, {\n\t        fullyContains: true\n\t      }).map(function (text) {\n\t        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n\t      });\n\t\n\t      if (expandClosestSibling) {\n\t        if (onlyPartialContains) {\n\t          var nodesInRange = rng.nodes();\n\t          // compose with partial contains predication\n\t          pred = func.and(pred, function (node) {\n\t            return list.contains(nodesInRange, node);\n\t          });\n\t        }\n\t\n\t        return nodes.map(function (node) {\n\t          var siblings = dom.withClosestSiblings(node, pred);\n\t          var head = list.head(siblings);\n\t          var tails = list.tail(siblings);\n\t          $.each(tails, function (idx, elem) {\n\t            dom.appendChildNodes(head, elem.childNodes);\n\t            dom.remove(elem);\n\t          });\n\t          return list.head(siblings);\n\t        });\n\t      } else {\n\t        return nodes;\n\t      }\n\t    };\n\t\n\t    /**\n\t     * get current style on cursor\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @return {Object} - object contains style properties.\n\t     */\n\t    this.current = function (rng) {\n\t      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n\t      var styleInfo = this.fromNode($cont);\n\t\n\t      // document.queryCommandState for toggle state\n\t      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n\t      try {\n\t        styleInfo = $.extend(styleInfo, {\n\t          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n\t          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n\t          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n\t          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n\t          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n\t          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'\n\t        });\n\t      } catch (e) {}\n\t\n\t      // list-style-type to list-style(unordered, ordered)\n\t      if (!rng.isOnList()) {\n\t        styleInfo['list-style'] = 'none';\n\t      } else {\n\t        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n\t        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n\t        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n\t      }\n\t\n\t      var para = dom.ancestor(rng.sc, dom.isPara);\n\t      if (para && para.style['line-height']) {\n\t        styleInfo['line-height'] = para.style.lineHeight;\n\t      } else {\n\t        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n\t        styleInfo['line-height'] = lineHeight.toFixed(1);\n\t      }\n\t\n\t      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n\t      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n\t      styleInfo.range = rng;\n\t\n\t      return styleInfo;\n\t    };\n\t  };\n\t\n\t\n\t  /**\n\t   * @class editing.Bullet\n\t   *\n\t   * @alternateClassName Bullet\n\t   */\n\t  var Bullet = function () {\n\t    var self = this;\n\t\n\t    /**\n\t     * toggle ordered list\n\t     */\n\t    this.insertOrderedList = function (editable) {\n\t      this.toggleList('OL', editable);\n\t    };\n\t\n\t    /**\n\t     * toggle unordered list\n\t     */\n\t    this.insertUnorderedList = function (editable) {\n\t      this.toggleList('UL', editable);\n\t    };\n\t\n\t    /**\n\t     * indent\n\t     */\n\t    this.indent = function (editable) {\n\t      var self = this;\n\t      var rng = range.create(editable).wrapBodyInlineWithPara();\n\t\n\t      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n\t      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\t\n\t      $.each(clustereds, function (idx, paras) {\n\t        var head = list.head(paras);\n\t        if (dom.isLi(head)) {\n\t          self.wrapList(paras, head.parentNode.nodeName);\n\t        } else {\n\t          $.each(paras, function (idx, para) {\n\t            $(para).css('marginLeft', function (idx, val) {\n\t              return (parseInt(val, 10) || 0) + 25;\n\t            });\n\t          });\n\t        }\n\t      });\n\t\n\t      rng.select();\n\t    };\n\t\n\t    /**\n\t     * outdent\n\t     */\n\t    this.outdent = function (editable) {\n\t      var self = this;\n\t      var rng = range.create(editable).wrapBodyInlineWithPara();\n\t\n\t      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n\t      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\t\n\t      $.each(clustereds, function (idx, paras) {\n\t        var head = list.head(paras);\n\t        if (dom.isLi(head)) {\n\t          self.releaseList([paras]);\n\t        } else {\n\t          $.each(paras, function (idx, para) {\n\t            $(para).css('marginLeft', function (idx, val) {\n\t              val = (parseInt(val, 10) || 0);\n\t              return val > 25 ? val - 25 : '';\n\t            });\n\t          });\n\t        }\n\t      });\n\t\n\t      rng.select();\n\t    };\n\t\n\t    /**\n\t     * toggle list\n\t     *\n\t     * @param {String} listName - OL or UL\n\t     */\n\t    this.toggleList = function (listName, editable) {\n\t      var rng = range.create(editable).wrapBodyInlineWithPara();\n\t\n\t      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n\t      var bookmark = rng.paraBookmark(paras);\n\t      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\t\n\t      // paragraph to list\n\t      if (list.find(paras, dom.isPurePara)) {\n\t        var wrappedParas = [];\n\t        $.each(clustereds, function (idx, paras) {\n\t          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n\t        });\n\t        paras = wrappedParas;\n\t      // list to paragraph or change list style\n\t      } else {\n\t        var diffLists = rng.nodes(dom.isList, {\n\t          includeAncestor: true\n\t        }).filter(function (listNode) {\n\t          return !$.nodeName(listNode, listName);\n\t        });\n\t\n\t        if (diffLists.length) {\n\t          $.each(diffLists, function (idx, listNode) {\n\t            dom.replace(listNode, listName);\n\t          });\n\t        } else {\n\t          paras = this.releaseList(clustereds, true);\n\t        }\n\t      }\n\t\n\t      range.createFromParaBookmark(bookmark, paras).select();\n\t    };\n\t\n\t    /**\n\t     * @param {Node[]} paras\n\t     * @param {String} listName\n\t     * @return {Node[]}\n\t     */\n\t    this.wrapList = function (paras, listName) {\n\t      var head = list.head(paras);\n\t      var last = list.last(paras);\n\t\n\t      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n\t      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\t\n\t      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\t\n\t      // P to LI\n\t      paras = paras.map(function (para) {\n\t        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n\t      });\n\t\n\t      // append to list(<ul>, <ol>)\n\t      dom.appendChildNodes(listNode, paras);\n\t\n\t      if (nextList) {\n\t        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n\t        dom.remove(nextList);\n\t      }\n\t\n\t      return paras;\n\t    };\n\t\n\t    /**\n\t     * @method releaseList\n\t     *\n\t     * @param {Array[]} clustereds\n\t     * @param {Boolean} isEscapseToBody\n\t     * @return {Node[]}\n\t     */\n\t    this.releaseList = function (clustereds, isEscapseToBody) {\n\t      var releasedParas = [];\n\t\n\t      $.each(clustereds, function (idx, paras) {\n\t        var head = list.head(paras);\n\t        var last = list.last(paras);\n\t\n\t        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n\t                                         head.parentNode;\n\t        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n\t          node: last.parentNode,\n\t          offset: dom.position(last) + 1\n\t        }, {\n\t          isSkipPaddingBlankHTML: true\n\t        }) : null;\n\t\n\t        var middleList = dom.splitTree(headList, {\n\t          node: head.parentNode,\n\t          offset: dom.position(head)\n\t        }, {\n\t          isSkipPaddingBlankHTML: true\n\t        });\n\t\n\t        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n\t                                  list.from(middleList.childNodes).filter(dom.isLi);\n\t\n\t        // LI to P\n\t        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n\t          paras = paras.map(function (para) {\n\t            return dom.replace(para, 'P');\n\t          });\n\t        }\n\t\n\t        $.each(list.from(paras).reverse(), function (idx, para) {\n\t          dom.insertAfter(para, headList);\n\t        });\n\t\n\t        // remove empty lists\n\t        var rootLists = list.compact([headList, middleList, lastList]);\n\t        $.each(rootLists, function (idx, rootList) {\n\t          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n\t          $.each(listNodes.reverse(), function (idx, listNode) {\n\t            if (!dom.nodeLength(listNode)) {\n\t              dom.remove(listNode, true);\n\t            }\n\t          });\n\t        });\n\t\n\t        releasedParas = releasedParas.concat(paras);\n\t      });\n\t\n\t      return releasedParas;\n\t    };\n\t  };\n\t\n\t\n\t  /**\n\t   * @class editing.Typing\n\t   *\n\t   * Typing\n\t   *\n\t   */\n\t  var Typing = function () {\n\t\n\t    // a Bullet instance to toggle lists off\n\t    var bullet = new Bullet();\n\t\n\t    /**\n\t     * insert tab\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @param {Number} tabsize\n\t     */\n\t    this.insertTab = function (rng, tabsize) {\n\t      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n\t      rng = rng.deleteContents();\n\t      rng.insertNode(tab, true);\n\t\n\t      rng = range.create(tab, tabsize);\n\t      rng.select();\n\t    };\n\t\n\t    /**\n\t     * insert paragraph\n\t     */\n\t    this.insertParagraph = function (editable) {\n\t      var rng = range.create(editable);\n\t\n\t      // deleteContents on range.\n\t      rng = rng.deleteContents();\n\t\n\t      // Wrap range if it needs to be wrapped by paragraph\n\t      rng = rng.wrapBodyInlineWithPara();\n\t\n\t      // finding paragraph\n\t      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\t\n\t      var nextPara;\n\t      // on paragraph: split paragraph\n\t      if (splitRoot) {\n\t        // if it is an empty line with li\n\t        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n\t          // toogle UL/OL and escape\n\t          bullet.toggleList(splitRoot.parentNode.nodeName);\n\t          return;\n\t        // if it is an empty line with para on blockquote\n\t        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n\t          // escape blockquote\n\t          dom.insertAfter(splitRoot, splitRoot.parentNode);\n\t          nextPara = splitRoot;\n\t        // if new line has content (not a line break)\n\t        } else {\n\t          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\t\n\t          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n\t          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\t\n\t          $.each(emptyAnchors, function (idx, anchor) {\n\t            dom.remove(anchor);\n\t          });\n\t\n\t          // replace empty heading or pre with P tag\n\t          if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {\n\t            nextPara = dom.replace(nextPara, 'p');\n\t          }\n\t        }\n\t      // no paragraph: insert empty paragraph\n\t      } else {\n\t        var next = rng.sc.childNodes[rng.so];\n\t        nextPara = $(dom.emptyPara)[0];\n\t        if (next) {\n\t          rng.sc.insertBefore(nextPara, next);\n\t        } else {\n\t          rng.sc.appendChild(nextPara);\n\t        }\n\t      }\n\t\n\t      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n\t    };\n\t  };\n\t\n\t  /**\n\t   * @class editing.Table\n\t   *\n\t   * Table\n\t   *\n\t   */\n\t  var Table = function () {\n\t    /**\n\t     * handle tab key\n\t     *\n\t     * @param {WrappedRange} rng\n\t     * @param {Boolean} isShift\n\t     */\n\t    this.tab = function (rng, isShift) {\n\t      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n\t      var table = dom.ancestor(cell, dom.isTable);\n\t      var cells = dom.listDescendant(table, dom.isCell);\n\t\n\t      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n\t      if (nextCell) {\n\t        range.create(nextCell, 0).select();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * create empty table element\n\t     *\n\t     * @param {Number} rowCount\n\t     * @param {Number} colCount\n\t     * @return {Node}\n\t     */\n\t    this.createTable = function (colCount, rowCount, options) {\n\t      var tds = [], tdHTML;\n\t      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n\t        tds.push('<td>' + dom.blank + '</td>');\n\t      }\n\t      tdHTML = tds.join('');\n\t\n\t      var trs = [], trHTML;\n\t      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n\t        trs.push('<tr>' + tdHTML + '</tr>');\n\t      }\n\t      trHTML = trs.join('');\n\t      var $table = $('<table>' + trHTML + '</table>');\n\t      if (options && options.tableClassName) {\n\t        $table.addClass(options.tableClassName);\n\t      }\n\t\n\t      return $table[0];\n\t    };\n\t  };\n\t\n\t\n\t  var KEY_BOGUS = 'bogus';\n\t\n\t  /**\n\t   * @class Editor\n\t   */\n\t  var Editor = function (context) {\n\t    var self = this;\n\t\n\t    var $note = context.layoutInfo.note;\n\t    var $editor = context.layoutInfo.editor;\n\t    var $editable = context.layoutInfo.editable;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    var editable = $editable[0];\n\t    var lastRange = null;\n\t\n\t    var style = new Style();\n\t    var table = new Table();\n\t    var typing = new Typing();\n\t    var bullet = new Bullet();\n\t    var history = new History($editable);\n\t\n\t    this.initialize = function () {\n\t      // bind custom events\n\t      $editable.on('keydown', function (event) {\n\t        if (event.keyCode === key.code.ENTER) {\n\t          context.triggerEvent('enter', event);\n\t        }\n\t        context.triggerEvent('keydown', event);\n\t\n\t        if (!event.isDefaultPrevented()) {\n\t          if (options.shortcuts) {\n\t            self.handleKeyMap(event);\n\t          } else {\n\t            self.preventDefaultEditableShortCuts(event);\n\t          }\n\t        }\n\t      }).on('keyup', function (event) {\n\t        context.triggerEvent('keyup', event);\n\t      }).on('focus', function (event) {\n\t        context.triggerEvent('focus', event);\n\t      }).on('blur', function (event) {\n\t        context.triggerEvent('blur', event);\n\t      }).on('mousedown', function (event) {\n\t        context.triggerEvent('mousedown', event);\n\t      }).on('mouseup', function (event) {\n\t        context.triggerEvent('mouseup', event);\n\t      }).on('scroll', function (event) {\n\t        context.triggerEvent('scroll', event);\n\t      }).on('paste', function (event) {\n\t        context.triggerEvent('paste', event);\n\t      });\n\t\n\t      // init content before set event\n\t      $editable.html(dom.html($note) || dom.emptyPara);\n\t\n\t      // [workaround] IE doesn't have input events for contentEditable\n\t      // - see: https://goo.gl/4bfIvA\n\t      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n\t      $editable.on(changeEventName, func.debounce(function () {\n\t        context.triggerEvent('change', $editable.html());\n\t      }, 250));\n\t\n\t      $editor.on('focusin', function (event) {\n\t        context.triggerEvent('focusin', event);\n\t      }).on('focusout', function (event) {\n\t        context.triggerEvent('focusout', event);\n\t      });\n\t\n\t      if (!options.airMode) {\n\t        if (options.width) {\n\t          $editor.outerWidth(options.width);\n\t        }\n\t        if (options.height) {\n\t          $editable.outerHeight(options.height);\n\t        }\n\t        if (options.maxHeight) {\n\t          $editable.css('max-height', options.maxHeight);\n\t        }\n\t        if (options.minHeight) {\n\t          $editable.css('min-height', options.minHeight);\n\t        }\n\t      }\n\t\n\t      history.recordUndo();\n\t    };\n\t\n\t    this.destroy = function () {\n\t      $editable.off();\n\t    };\n\t\n\t    this.handleKeyMap = function (event) {\n\t      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n\t      var keys = [];\n\t\n\t      if (event.metaKey) { keys.push('CMD'); }\n\t      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n\t      if (event.shiftKey) { keys.push('SHIFT'); }\n\t\n\t      var keyName = key.nameFromCode[event.keyCode];\n\t      if (keyName) {\n\t        keys.push(keyName);\n\t      }\n\t\n\t      var eventName = keyMap[keys.join('+')];\n\t      if (eventName) {\n\t        event.preventDefault();\n\t        context.invoke(eventName);\n\t      } else if (key.isEdit(event.keyCode)) {\n\t        this.afterCommand();\n\t      }\n\t    };\n\t\n\t    this.preventDefaultEditableShortCuts = function (event) {\n\t      // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)\n\t      if ((event.ctrlKey || event.metaKey) &&\n\t        list.contains([66, 73, 85], event.keyCode)) {\n\t        event.preventDefault();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * create range\n\t     * @return {WrappedRange}\n\t     */\n\t    this.createRange = function () {\n\t      this.focus();\n\t      return range.create(editable);\n\t    };\n\t\n\t    /**\n\t     * saveRange\n\t     *\n\t     * save current range\n\t     *\n\t     * @param {Boolean} [thenCollapse=false]\n\t     */\n\t    this.saveRange = function (thenCollapse) {\n\t      lastRange = this.createRange();\n\t      if (thenCollapse) {\n\t        lastRange.collapse().select();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * restoreRange\n\t     *\n\t     * restore lately range\n\t     */\n\t    this.restoreRange = function () {\n\t      if (lastRange) {\n\t        lastRange.select();\n\t        this.focus();\n\t      }\n\t    };\n\t\n\t    this.saveTarget = function (node) {\n\t      $editable.data('target', node);\n\t    };\n\t\n\t    this.clearTarget = function () {\n\t      $editable.removeData('target');\n\t    };\n\t\n\t    this.restoreTarget = function () {\n\t      return $editable.data('target');\n\t    };\n\t\n\t    /**\n\t     * currentStyle\n\t     *\n\t     * current style\n\t     * @return {Object|Boolean} unfocus\n\t     */\n\t    this.currentStyle = function () {\n\t      var rng = range.create();\n\t      if (rng) {\n\t        rng = rng.normalize();\n\t      }\n\t      return rng ? style.current(rng) : style.fromNode($editable);\n\t    };\n\t\n\t    /**\n\t     * style from node\n\t     *\n\t     * @param {jQuery} $node\n\t     * @return {Object}\n\t     */\n\t    this.styleFromNode = function ($node) {\n\t      return style.fromNode($node);\n\t    };\n\t\n\t    /**\n\t     * undo\n\t     */\n\t    this.undo = function () {\n\t      context.triggerEvent('before.command', $editable.html());\n\t      history.undo();\n\t      context.triggerEvent('change', $editable.html());\n\t    };\n\t    context.memo('help.undo', lang.help.undo);\n\t\n\t    /**\n\t     * redo\n\t     */\n\t    this.redo = function () {\n\t      context.triggerEvent('before.command', $editable.html());\n\t      history.redo();\n\t      context.triggerEvent('change', $editable.html());\n\t    };\n\t    context.memo('help.redo', lang.help.redo);\n\t\n\t    /**\n\t     * before command\n\t     */\n\t    var beforeCommand = this.beforeCommand = function () {\n\t      context.triggerEvent('before.command', $editable.html());\n\t      // keep focus on editable before command execution\n\t      self.focus();\n\t    };\n\t\n\t    /**\n\t     * after command\n\t     * @param {Boolean} isPreventTrigger\n\t     */\n\t    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n\t      history.recordUndo();\n\t      if (!isPreventTrigger) {\n\t        context.triggerEvent('change', $editable.html());\n\t      }\n\t    };\n\t\n\t    /* jshint ignore:start */\n\t    // native commands(with execCommand), generate function for execCommand\n\t    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n\t                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n\t                    'formatBlock', 'removeFormat',\n\t                    'backColor', 'foreColor', 'fontName'];\n\t\n\t    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n\t      this[commands[idx]] = (function (sCmd) {\n\t        return function (value) {\n\t          beforeCommand();\n\t          document.execCommand(sCmd, false, value);\n\t          afterCommand(true);\n\t        };\n\t      })(commands[idx]);\n\t      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n\t    }\n\t    /* jshint ignore:end */\n\t\n\t    /**\n\t     * handle tab key\n\t     */\n\t    this.tab = function () {\n\t      var rng = this.createRange();\n\t      if (rng.isCollapsed() && rng.isOnCell()) {\n\t        table.tab(rng);\n\t      } else {\n\t        beforeCommand();\n\t        typing.insertTab(rng, options.tabSize);\n\t        afterCommand();\n\t      }\n\t    };\n\t    context.memo('help.tab', lang.help.tab);\n\t\n\t    /**\n\t     * handle shift+tab key\n\t     */\n\t    this.untab = function () {\n\t      var rng = this.createRange();\n\t      if (rng.isCollapsed() && rng.isOnCell()) {\n\t        table.tab(rng, true);\n\t      }\n\t    };\n\t    context.memo('help.untab', lang.help.untab);\n\t\n\t    /**\n\t     * run given function between beforeCommand and afterCommand\n\t     */\n\t    this.wrapCommand = function (fn) {\n\t      return function () {\n\t        beforeCommand();\n\t        fn.apply(self, arguments);\n\t        afterCommand();\n\t      };\n\t    };\n\t\n\t    /**\n\t     * insert paragraph\n\t     */\n\t    this.insertParagraph = this.wrapCommand(function () {\n\t      typing.insertParagraph(editable);\n\t    });\n\t    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\t\n\t    this.insertOrderedList = this.wrapCommand(function () {\n\t      bullet.insertOrderedList(editable);\n\t    });\n\t    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\t\n\t    this.insertUnorderedList = this.wrapCommand(function () {\n\t      bullet.insertUnorderedList(editable);\n\t    });\n\t    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\t\n\t    this.indent = this.wrapCommand(function () {\n\t      bullet.indent(editable);\n\t    });\n\t    context.memo('help.indent', lang.help.indent);\n\t\n\t    this.outdent = this.wrapCommand(function () {\n\t      bullet.outdent(editable);\n\t    });\n\t    context.memo('help.outdent', lang.help.outdent);\n\t\n\t    /**\n\t     * insert image\n\t     *\n\t     * @param {String} src\n\t     * @param {String|Function} param\n\t     * @return {Promise}\n\t     */\n\t    this.insertImage = function (src, param) {\n\t      return async.createImage(src, param).then(function ($image) {\n\t        beforeCommand();\n\t\n\t        if (typeof param === 'function') {\n\t          param($image);\n\t        } else {\n\t          if (typeof param === 'string') {\n\t            $image.attr('data-filename', param);\n\t          }\n\t          $image.css('width', Math.min($editable.width(), $image.width()));\n\t        }\n\t\n\t        $image.show();\n\t        range.create(editable).insertNode($image[0]);\n\t        range.createFromNodeAfter($image[0]).select();\n\t        afterCommand();\n\t      }).fail(function (e) {\n\t        context.triggerEvent('image.upload.error', e);\n\t      });\n\t    };\n\t\n\t    /**\n\t     * insertImages\n\t     * @param {File[]} files\n\t     */\n\t    this.insertImages = function (files) {\n\t      $.each(files, function (idx, file) {\n\t        var filename = file.name;\n\t        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n\t          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n\t        } else {\n\t          async.readFileAsDataURL(file).then(function (dataURL) {\n\t            return self.insertImage(dataURL, filename);\n\t          }).fail(function () {\n\t            context.triggerEvent('image.upload.error');\n\t          });\n\t        }\n\t      });\n\t    };\n\t\n\t    /**\n\t     * insertImagesOrCallback\n\t     * @param {File[]} files\n\t     */\n\t    this.insertImagesOrCallback = function (files) {\n\t      var callbacks = options.callbacks;\n\t\n\t      // If onImageUpload options setted\n\t      if (callbacks.onImageUpload) {\n\t        context.triggerEvent('image.upload', files);\n\t      // else insert Image as dataURL\n\t      } else {\n\t        this.insertImages(files);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * insertNode\n\t     * insert node\n\t     * @param {Node} node\n\t     */\n\t    this.insertNode = this.wrapCommand(function (node) {\n\t      var rng = this.createRange();\n\t      rng.insertNode(node);\n\t      range.createFromNodeAfter(node).select();\n\t    });\n\t\n\t    /**\n\t     * insert text\n\t     * @param {String} text\n\t     */\n\t    this.insertText = this.wrapCommand(function (text) {\n\t      var rng = this.createRange();\n\t      var textNode = rng.insertNode(dom.createText(text));\n\t      range.create(textNode, dom.nodeLength(textNode)).select();\n\t    });\n\t\n\t    /**\n\t     * return selected plain text\n\t     * @return {String} text\n\t     */\n\t    this.getSelectedText = function () {\n\t      var rng = this.createRange();\n\t\n\t      // if range on anchor, expand range with anchor\n\t      if (rng.isOnAnchor()) {\n\t        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n\t      }\n\t\n\t      return rng.toString();\n\t    };\n\t\n\t    /**\n\t     * paste HTML\n\t     * @param {String} markup\n\t     */\n\t    this.pasteHTML = this.wrapCommand(function (markup) {\n\t      var contents = this.createRange().pasteHTML(markup);\n\t      range.createFromNodeAfter(list.last(contents)).select();\n\t    });\n\t\n\t    /**\n\t     * formatBlock\n\t     *\n\t     * @param {String} tagName\n\t     */\n\t    this.formatBlock = this.wrapCommand(function (tagName) {\n\t      // [workaround] for MSIE, IE need `<`\n\t      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n\t      document.execCommand('FormatBlock', false, tagName);\n\t    });\n\t\n\t    this.formatPara = function () {\n\t      this.formatBlock('P');\n\t    };\n\t    context.memo('help.formatPara', lang.help.formatPara);\n\t\n\t    /* jshint ignore:start */\n\t    for (var idx = 1; idx <= 6; idx ++) {\n\t      this['formatH' + idx] = function (idx) {\n\t        return function () {\n\t          this.formatBlock('H' + idx);\n\t        };\n\t      }(idx);\n\t      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n\t    };\n\t    /* jshint ignore:end */\n\t\n\t    /**\n\t     * fontSize\n\t     *\n\t     * @param {String} value - px\n\t     */\n\t    this.fontSize = function (value) {\n\t      var rng = this.createRange();\n\t\n\t      if (rng && rng.isCollapsed()) {\n\t        var spans = style.styleNodes(rng);\n\t        var firstSpan = list.head(spans);\n\t\n\t        $(spans).css({\n\t          'font-size': value + 'px'\n\t        });\n\t\n\t        // [workaround] added styled bogus span for style\n\t        //  - also bogus character needed for cursor position\n\t        if (firstSpan && !dom.nodeLength(firstSpan)) {\n\t          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n\t          range.createFromNodeAfter(firstSpan.firstChild).select();\n\t          $editable.data(KEY_BOGUS, firstSpan);\n\t        }\n\t      } else {\n\t        beforeCommand();\n\t        $(style.styleNodes(rng)).css({\n\t          'font-size': value + 'px'\n\t        });\n\t        afterCommand();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * insert horizontal rule\n\t     */\n\t    this.insertHorizontalRule = this.wrapCommand(function () {\n\t      var hrNode = this.createRange().insertNode(dom.create('HR'));\n\t      if (hrNode.nextSibling) {\n\t        range.create(hrNode.nextSibling, 0).normalize().select();\n\t      }\n\t    });\n\t    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\t\n\t    /**\n\t     * remove bogus node and character\n\t     */\n\t    this.removeBogus = function () {\n\t      var bogusNode = $editable.data(KEY_BOGUS);\n\t      if (!bogusNode) {\n\t        return;\n\t      }\n\t\n\t      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\t\n\t      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n\t      if (bogusCharIdx !== -1) {\n\t        textNode.deleteData(bogusCharIdx, 1);\n\t      }\n\t\n\t      if (dom.isEmpty(bogusNode)) {\n\t        dom.remove(bogusNode);\n\t      }\n\t\n\t      $editable.removeData(KEY_BOGUS);\n\t    };\n\t\n\t    /**\n\t     * lineHeight\n\t     * @param {String} value\n\t     */\n\t    this.lineHeight = this.wrapCommand(function (value) {\n\t      style.stylePara(this.createRange(), {\n\t        lineHeight: value\n\t      });\n\t    });\n\t\n\t    /**\n\t     * unlink\n\t     *\n\t     * @type command\n\t     */\n\t    this.unlink = function () {\n\t      var rng = this.createRange();\n\t      if (rng.isOnAnchor()) {\n\t        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n\t        rng = range.createFromNode(anchor);\n\t        rng.select();\n\t\n\t        beforeCommand();\n\t        document.execCommand('unlink');\n\t        afterCommand();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * create link (command)\n\t     *\n\t     * @param {Object} linkInfo\n\t     */\n\t    this.createLink = this.wrapCommand(function (linkInfo) {\n\t      var linkUrl = linkInfo.url;\n\t      var linkText = linkInfo.text;\n\t      var isNewWindow = linkInfo.isNewWindow;\n\t      var rng = linkInfo.range || this.createRange();\n\t      var isTextChanged = rng.toString() !== linkText;\n\t\n\t      // handle spaced urls from input\n\t      if (typeof linkUrl === 'string') {\n\t        linkUrl = linkUrl.trim();\n\t      }\n\t\n\t      if (options.onCreateLink) {\n\t        linkUrl = options.onCreateLink(linkUrl);\n\t      }\n\t\n\t      var anchors = [];\n\t      if (isTextChanged) {\n\t        rng = rng.deleteContents();\n\t        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n\t        anchors.push(anchor);\n\t      } else {\n\t        anchors = style.styleNodes(rng, {\n\t          nodeName: 'A',\n\t          expandClosestSibling: true,\n\t          onlyPartialContains: true\n\t        });\n\t      }\n\t\n\t      $.each(anchors, function (idx, anchor) {\n\t        // if url doesn't match an URL schema, set http:// as default\n\t        linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?/.test(linkUrl) ?\n\t          linkUrl : 'http://' + linkUrl;\n\t\n\t        $(anchor).attr('href', linkUrl);\n\t        if (isNewWindow) {\n\t          $(anchor).attr('target', '_blank');\n\t        } else {\n\t          $(anchor).removeAttr('target');\n\t        }\n\t      });\n\t\n\t      var startRange = range.createFromNodeBefore(list.head(anchors));\n\t      var startPoint = startRange.getStartPoint();\n\t      var endRange = range.createFromNodeAfter(list.last(anchors));\n\t      var endPoint = endRange.getEndPoint();\n\t\n\t      range.create(\n\t        startPoint.node,\n\t        startPoint.offset,\n\t        endPoint.node,\n\t        endPoint.offset\n\t      ).select();\n\t    });\n\t\n\t    /**\n\t     * returns link info\n\t     *\n\t     * @return {Object}\n\t     * @return {WrappedRange} return.range\n\t     * @return {String} return.text\n\t     * @return {Boolean} [return.isNewWindow=true]\n\t     * @return {String} [return.url=\"\"]\n\t     */\n\t    this.getLinkInfo = function () {\n\t      var rng = this.createRange().expand(dom.isAnchor);\n\t\n\t      // Get the first anchor on range(for edit).\n\t      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n\t\n\t      return {\n\t        range: rng,\n\t        text: rng.toString(),\n\t        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,\n\t        url: $anchor.length ? $anchor.attr('href') : ''\n\t      };\n\t    };\n\t\n\t    /**\n\t     * setting color\n\t     *\n\t     * @param {Object} sObjColor  color code\n\t     * @param {String} sObjColor.foreColor foreground color\n\t     * @param {String} sObjColor.backColor background color\n\t     */\n\t    this.color = this.wrapCommand(function (colorInfo) {\n\t      var foreColor = colorInfo.foreColor;\n\t      var backColor = colorInfo.backColor;\n\t\n\t      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n\t      if (backColor) { document.execCommand('backColor', false, backColor); }\n\t    });\n\t\n\t    /**\n\t     * insert Table\n\t     *\n\t     * @param {String} dimension of table (ex : \"5x5\")\n\t     */\n\t    this.insertTable = this.wrapCommand(function (dim) {\n\t      var dimension = dim.split('x');\n\t\n\t      var rng = this.createRange().deleteContents();\n\t      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n\t    });\n\t\n\t    /**\n\t     * float me\n\t     *\n\t     * @param {String} value\n\t     */\n\t    this.floatMe = this.wrapCommand(function (value) {\n\t      var $target = $(this.restoreTarget());\n\t      $target.css('float', value);\n\t    });\n\t\n\t    /**\n\t     * resize overlay element\n\t     * @param {String} value\n\t     */\n\t    this.resize = this.wrapCommand(function (value) {\n\t      var $target = $(this.restoreTarget());\n\t      $target.css({\n\t        width: value * 100 + '%',\n\t        height: ''\n\t      });\n\t    });\n\t\n\t    /**\n\t     * @param {Position} pos\n\t     * @param {jQuery} $target - target element\n\t     * @param {Boolean} [bKeepRatio] - keep ratio\n\t     */\n\t    this.resizeTo = function (pos, $target, bKeepRatio) {\n\t      var imageSize;\n\t      if (bKeepRatio) {\n\t        var newRatio = pos.y / pos.x;\n\t        var ratio = $target.data('ratio');\n\t        imageSize = {\n\t          width: ratio > newRatio ? pos.x : pos.y / ratio,\n\t          height: ratio > newRatio ? pos.x * ratio : pos.y\n\t        };\n\t      } else {\n\t        imageSize = {\n\t          width: pos.x,\n\t          height: pos.y\n\t        };\n\t      }\n\t\n\t      $target.css(imageSize);\n\t    };\n\t\n\t    /**\n\t     * remove media object\n\t     */\n\t    this.removeMedia = this.wrapCommand(function () {\n\t      var $target = $(this.restoreTarget()).detach();\n\t      context.triggerEvent('media.delete', $target, $editable);\n\t    });\n\t\n\t    /**\n\t     * returns whether editable area has focus or not.\n\t     */\n\t    this.hasFocus = function () {\n\t      return $editable.is(':focus');\n\t    };\n\t\n\t    /**\n\t     * set focus\n\t     */\n\t    this.focus = function () {\n\t      // [workaround] Screen will move when page is scolled in IE.\n\t      //  - do focus when not focused\n\t      if (!this.hasFocus()) {\n\t        $editable.focus();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * returns whether contents is empty or not.\n\t     * @return {Boolean}\n\t     */\n\t    this.isEmpty = function () {\n\t      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n\t    };\n\t\n\t    /**\n\t     * Removes all contents and restores the editable instance to an _emptyPara_.\n\t     */\n\t    this.empty = function () {\n\t      context.invoke('code', dom.emptyPara);\n\t    };\n\t  };\n\t\n\t  var Clipboard = function (context) {\n\t    var self = this;\n\t\n\t    var $editable = context.layoutInfo.editable;\n\t\n\t    this.events = {\n\t      'summernote.keydown': function (we, e) {\n\t        if (self.needKeydownHook()) {\n\t          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n\t            context.invoke('editor.saveRange');\n\t            self.$paste.focus();\n\t\n\t            setTimeout(function () {\n\t              self.pasteByHook();\n\t            }, 0);\n\t          }\n\t        }\n\t      }\n\t    };\n\t\n\t    this.needKeydownHook = function () {\n\t      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n\t    };\n\t\n\t    this.initialize = function () {\n\t      // [workaround] getting image from clipboard\n\t      //  - IE11 and Firefox: CTRL+v hook\n\t      //  - Webkit: event.clipboardData\n\t      if (this.needKeydownHook()) {\n\t        this.$paste = $('<div tabindex=\"-1\" />').attr('contenteditable', true).css({\n\t          position: 'absolute',\n\t          left: -100000,\n\t          opacity: 0\n\t        });\n\t        $editable.before(this.$paste);\n\t\n\t        this.$paste.on('paste', function (event) {\n\t          context.triggerEvent('paste', event);\n\t        });\n\t      } else {\n\t        $editable.on('paste', this.pasteByEvent);\n\t      }\n\t    };\n\t\n\t    this.destroy = function () {\n\t      if (this.needKeydownHook()) {\n\t        this.$paste.remove();\n\t        this.$paste = null;\n\t      }\n\t    };\n\t\n\t    this.pasteByHook = function () {\n\t      var node = this.$paste[0].firstChild;\n\t\n\t      if (dom.isImg(node)) {\n\t        var dataURI = node.src;\n\t        var decodedData = atob(dataURI.split(',')[1]);\n\t        var array = new Uint8Array(decodedData.length);\n\t        for (var i = 0; i < decodedData.length; i++) {\n\t          array[i] = decodedData.charCodeAt(i);\n\t        }\n\t\n\t        var blob = new Blob([array], { type: 'image/png' });\n\t        blob.name = 'clipboard.png';\n\t\n\t        context.invoke('editor.restoreRange');\n\t        context.invoke('editor.focus');\n\t        context.invoke('editor.insertImagesOrCallback', [blob]);\n\t      } else {\n\t        var pasteContent = $('<div />').html(this.$paste.html()).html();\n\t        context.invoke('editor.restoreRange');\n\t        context.invoke('editor.focus');\n\t\n\t        if (pasteContent) {\n\t          context.invoke('editor.pasteHTML', pasteContent);\n\t        }\n\t      }\n\t\n\t      this.$paste.empty();\n\t    };\n\t\n\t    /**\n\t     * paste by clipboard event\n\t     *\n\t     * @param {Event} event\n\t     */\n\t    this.pasteByEvent = function (event) {\n\t      var clipboardData = event.originalEvent.clipboardData;\n\t      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n\t        var item = list.head(clipboardData.items);\n\t        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n\t          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n\t        }\n\t        context.invoke('editor.afterCommand');\n\t      }\n\t    };\n\t  };\n\t\n\t  var Dropzone = function (context) {\n\t    var $document = $(document);\n\t    var $editor = context.layoutInfo.editor;\n\t    var $editable = context.layoutInfo.editable;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t    var documentEventHandlers = {};\n\t\n\t    var $dropzone = $([\n\t      '<div class=\"note-dropzone\">',\n\t      '  <div class=\"note-dropzone-message\"/>',\n\t      '</div>'\n\t    ].join('')).prependTo($editor);\n\t\n\t    var detachDocumentEvent = function () {\n\t      Object.keys(documentEventHandlers).forEach(function (key) {\n\t        $document.off(key.substr(2).toLowerCase(), documentEventHandlers[key]);\n\t      });\n\t      documentEventHandlers = {};\n\t    };\n\t\n\t    /**\n\t     * attach Drag and Drop Events\n\t     */\n\t    this.initialize = function () {\n\t      if (options.disableDragAndDrop) {\n\t        // prevent default drop event\n\t        documentEventHandlers.onDrop = function (e) {\n\t          e.preventDefault();\n\t        };\n\t        $document.on('drop', documentEventHandlers.onDrop);\n\t      } else {\n\t        this.attachDragAndDropEvent();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * attach Drag and Drop Events\n\t     */\n\t    this.attachDragAndDropEvent = function () {\n\t      var collection = $(),\n\t          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\t\n\t      documentEventHandlers.onDragenter = function (e) {\n\t        var isCodeview = context.invoke('codeview.isActivated');\n\t        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n\t        if (!isCodeview && !collection.length && hasEditorSize) {\n\t          $editor.addClass('dragover');\n\t          $dropzone.width($editor.width());\n\t          $dropzone.height($editor.height());\n\t          $dropzoneMessage.text(lang.image.dragImageHere);\n\t        }\n\t        collection = collection.add(e.target);\n\t      };\n\t\n\t      documentEventHandlers.onDragleave = function (e) {\n\t        collection = collection.not(e.target);\n\t        if (!collection.length) {\n\t          $editor.removeClass('dragover');\n\t        }\n\t      };\n\t\n\t      documentEventHandlers.onDrop = function () {\n\t        collection = $();\n\t        $editor.removeClass('dragover');\n\t      };\n\t\n\t      // show dropzone on dragenter when dragging a object to document\n\t      // -but only if the editor is visible, i.e. has a positive width and height\n\t      $document.on('dragenter', documentEventHandlers.onDragenter)\n\t        .on('dragleave', documentEventHandlers.onDragleave)\n\t        .on('drop', documentEventHandlers.onDrop);\n\t\n\t      // change dropzone's message on hover.\n\t      $dropzone.on('dragenter', function () {\n\t        $dropzone.addClass('hover');\n\t        $dropzoneMessage.text(lang.image.dropImage);\n\t      }).on('dragleave', function () {\n\t        $dropzone.removeClass('hover');\n\t        $dropzoneMessage.text(lang.image.dragImageHere);\n\t      });\n\t\n\t      // attach dropImage\n\t      $dropzone.on('drop', function (event) {\n\t        var dataTransfer = event.originalEvent.dataTransfer;\n\t\n\t        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n\t          event.preventDefault();\n\t          $editable.focus();\n\t          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n\t        } else {\n\t          $.each(dataTransfer.types, function (idx, type) {\n\t            var content = dataTransfer.getData(type);\n\t\n\t            if (type.toLowerCase().indexOf('text') > -1) {\n\t              context.invoke('editor.pasteHTML', content);\n\t            } else {\n\t              $(content).each(function () {\n\t                context.invoke('editor.insertNode', this);\n\t              });\n\t            }\n\t          });\n\t        }\n\t      }).on('dragover', false); // prevent default dragover event\n\t    };\n\t\n\t    this.destroy = function () {\n\t      detachDocumentEvent();\n\t    };\n\t  };\n\t\n\t\n\t  var CodeMirror;\n\t  if (agent.hasCodeMirror) {\n\t    if (agent.isSupportAmd) {\n\t      !/* require */(/* empty */function() { var __WEBPACK_AMD_REQUIRE_ARRAY__ = [__webpack_require__(82)]; (function (cm) {\n\t        CodeMirror = cm;\n\t      }.apply(null, __WEBPACK_AMD_REQUIRE_ARRAY__));}());\n\t    } else {\n\t      CodeMirror = window.CodeMirror;\n\t    }\n\t  }\n\t\n\t  /**\n\t   * @class Codeview\n\t   */\n\t  var Codeview = function (context) {\n\t    var $editor = context.layoutInfo.editor;\n\t    var $editable = context.layoutInfo.editable;\n\t    var $codable = context.layoutInfo.codable;\n\t    var options = context.options;\n\t\n\t    this.sync = function () {\n\t      var isCodeview = this.isActivated();\n\t      if (isCodeview && agent.hasCodeMirror) {\n\t        $codable.data('cmEditor').save();\n\t      }\n\t    };\n\t\n\t    /**\n\t     * @return {Boolean}\n\t     */\n\t    this.isActivated = function () {\n\t      return $editor.hasClass('codeview');\n\t    };\n\t\n\t    /**\n\t     * toggle codeview\n\t     */\n\t    this.toggle = function () {\n\t      if (this.isActivated()) {\n\t        this.deactivate();\n\t      } else {\n\t        this.activate();\n\t      }\n\t      context.triggerEvent('codeview.toggled');\n\t    };\n\t\n\t    /**\n\t     * activate code view\n\t     */\n\t    this.activate = function () {\n\t      $codable.val(dom.html($editable, options.prettifyHtml));\n\t      $codable.height($editable.height());\n\t\n\t      context.invoke('toolbar.updateCodeview', true);\n\t      $editor.addClass('codeview');\n\t      $codable.focus();\n\t\n\t      // activate CodeMirror as codable\n\t      if (agent.hasCodeMirror) {\n\t        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\t\n\t        // CodeMirror TernServer\n\t        if (options.codemirror.tern) {\n\t          var server = new CodeMirror.TernServer(options.codemirror.tern);\n\t          cmEditor.ternServer = server;\n\t          cmEditor.on('cursorActivity', function (cm) {\n\t            server.updateArgHints(cm);\n\t          });\n\t        }\n\t\n\t        // CodeMirror hasn't Padding.\n\t        cmEditor.setSize(null, $editable.outerHeight());\n\t        $codable.data('cmEditor', cmEditor);\n\t      }\n\t    };\n\t\n\t    /**\n\t     * deactivate code view\n\t     */\n\t    this.deactivate = function () {\n\t      // deactivate CodeMirror as codable\n\t      if (agent.hasCodeMirror) {\n\t        var cmEditor = $codable.data('cmEditor');\n\t        $codable.val(cmEditor.getValue());\n\t        cmEditor.toTextArea();\n\t      }\n\t\n\t      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n\t      var isChange = $editable.html() !== value;\n\t\n\t      $editable.html(value);\n\t      $editable.height(options.height ? $codable.height() : 'auto');\n\t      $editor.removeClass('codeview');\n\t\n\t      if (isChange) {\n\t        context.triggerEvent('change', $editable.html(), $editable);\n\t      }\n\t\n\t      $editable.focus();\n\t\n\t      context.invoke('toolbar.updateCodeview', false);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      if (this.isActivated()) {\n\t        this.deactivate();\n\t      }\n\t    };\n\t  };\n\t\n\t  var EDITABLE_PADDING = 24;\n\t\n\t  var Statusbar = function (context) {\n\t    var $document = $(document);\n\t    var $statusbar = context.layoutInfo.statusbar;\n\t    var $editable = context.layoutInfo.editable;\n\t    var options = context.options;\n\t\n\t    this.initialize = function () {\n\t      if (options.airMode || options.disableResizeEditor) {\n\t        return;\n\t      }\n\t\n\t      $statusbar.on('mousedown', function (event) {\n\t        event.preventDefault();\n\t        event.stopPropagation();\n\t\n\t        var editableTop = $editable.offset().top - $document.scrollTop();\n\t\n\t        $document.on('mousemove', function (event) {\n\t          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\t\n\t          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n\t          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\t\n\t          $editable.height(height);\n\t        }).one('mouseup', function () {\n\t          $document.off('mousemove');\n\t        });\n\t      });\n\t    };\n\t\n\t    this.destroy = function () {\n\t      $statusbar.off();\n\t      $statusbar.remove();\n\t    };\n\t  };\n\t\n\t  var Fullscreen = function (context) {\n\t    var $editor = context.layoutInfo.editor;\n\t    var $toolbar = context.layoutInfo.toolbar;\n\t    var $editable = context.layoutInfo.editable;\n\t    var $codable = context.layoutInfo.codable;\n\t\n\t    var $window = $(window);\n\t    var $scrollbar = $('html, body');\n\t\n\t    /**\n\t     * toggle fullscreen\n\t     */\n\t    this.toggle = function () {\n\t      var resize = function (size) {\n\t        $editable.css('height', size.h);\n\t        $codable.css('height', size.h);\n\t        if ($codable.data('cmeditor')) {\n\t          $codable.data('cmeditor').setsize(null, size.h);\n\t        }\n\t      };\n\t\n\t      $editor.toggleClass('fullscreen');\n\t      if (this.isFullscreen()) {\n\t        $editable.data('orgHeight', $editable.css('height'));\n\t\n\t        $window.on('resize', function () {\n\t          resize({\n\t            h: $window.height() - $toolbar.outerHeight()\n\t          });\n\t        }).trigger('resize');\n\t\n\t        $scrollbar.css('overflow', 'hidden');\n\t      } else {\n\t        $window.off('resize');\n\t        resize({\n\t          h: $editable.data('orgHeight')\n\t        });\n\t        $scrollbar.css('overflow', 'visible');\n\t      }\n\t\n\t      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n\t    };\n\t\n\t    this.isFullscreen = function () {\n\t      return $editor.hasClass('fullscreen');\n\t    };\n\t  };\n\t\n\t  var Handle = function (context) {\n\t    var self = this;\n\t\n\t    var $document = $(document);\n\t    var $editingArea = context.layoutInfo.editingArea;\n\t    var options = context.options;\n\t\n\t    this.events = {\n\t      'summernote.mousedown': function (we, e) {\n\t        if (self.update(e.target)) {\n\t          e.preventDefault();\n\t        }\n\t      },\n\t      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n\t        self.update();\n\t      }\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$handle = $([\n\t        '<div class=\"note-handle\">',\n\t        '<div class=\"note-control-selection\">',\n\t        '<div class=\"note-control-selection-bg\"></div>',\n\t        '<div class=\"note-control-holder note-control-nw\"></div>',\n\t        '<div class=\"note-control-holder note-control-ne\"></div>',\n\t        '<div class=\"note-control-holder note-control-sw\"></div>',\n\t        '<div class=\"',\n\t        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n\t        ' note-control-se\"></div>',\n\t        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n\t        '</div>',\n\t        '</div>'\n\t      ].join('')).prependTo($editingArea);\n\t\n\t      this.$handle.on('mousedown', function (event) {\n\t        if (dom.isControlSizing(event.target)) {\n\t          event.preventDefault();\n\t          event.stopPropagation();\n\t\n\t          var $target = self.$handle.find('.note-control-selection').data('target'),\n\t              posStart = $target.offset(),\n\t              scrollTop = $document.scrollTop();\n\t\n\t          $document.on('mousemove', function (event) {\n\t            context.invoke('editor.resizeTo', {\n\t              x: event.clientX - posStart.left,\n\t              y: event.clientY - (posStart.top - scrollTop)\n\t            }, $target, !event.shiftKey);\n\t\n\t            self.update($target[0]);\n\t          }).one('mouseup', function (e) {\n\t            e.preventDefault();\n\t            $document.off('mousemove');\n\t            context.invoke('editor.afterCommand');\n\t          });\n\t\n\t          if (!$target.data('ratio')) { // original ratio.\n\t            $target.data('ratio', $target.height() / $target.width());\n\t          }\n\t        }\n\t      });\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$handle.remove();\n\t    };\n\t\n\t    this.update = function (target) {\n\t      var isImage = dom.isImg(target);\n\t      var $selection = this.$handle.find('.note-control-selection');\n\t\n\t      context.invoke('imagePopover.update', target);\n\t\n\t      if (isImage) {\n\t        var $image = $(target);\n\t        var pos = $image.position();\n\t\n\t        // include margin\n\t        var imageSize = {\n\t          w: $image.outerWidth(true),\n\t          h: $image.outerHeight(true)\n\t        };\n\t\n\t        $selection.css({\n\t          display: 'block',\n\t          left: pos.left,\n\t          top: pos.top,\n\t          width: imageSize.w,\n\t          height: imageSize.h\n\t        }).data('target', $image); // save current image element.\n\t\n\t        var sizingText = imageSize.w + 'x' + imageSize.h;\n\t        $selection.find('.note-control-selection-info').text(sizingText);\n\t        context.invoke('editor.saveTarget', target);\n\t      } else {\n\t        this.hide();\n\t      }\n\t\n\t      return isImage;\n\t    };\n\t\n\t    /**\n\t     * hide\n\t     *\n\t     * @param {jQuery} $handle\n\t     */\n\t    this.hide = function () {\n\t      context.invoke('editor.clearTarget');\n\t      this.$handle.children().hide();\n\t    };\n\t  };\n\t\n\t  var AutoLink = function (context) {\n\t    var self = this;\n\t    var defaultScheme = 'http://';\n\t    var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\t\n\t    this.events = {\n\t      'summernote.keyup': function (we, e) {\n\t        if (!e.isDefaultPrevented()) {\n\t          self.handleKeyup(e);\n\t        }\n\t      },\n\t      'summernote.keydown': function (we, e) {\n\t        self.handleKeydown(e);\n\t      }\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.lastWordRange = null;\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.lastWordRange = null;\n\t    };\n\t\n\t    this.replace = function () {\n\t      if (!this.lastWordRange) {\n\t        return;\n\t      }\n\t\n\t      var keyword = this.lastWordRange.toString();\n\t      var match = keyword.match(linkPattern);\n\t\n\t      if (match && (match[1] || match[2])) {\n\t        var link = match[1] ? keyword : defaultScheme + keyword;\n\t        var node = $('<a />').html(keyword).attr('href', link)[0];\n\t\n\t        this.lastWordRange.insertNode(node);\n\t        this.lastWordRange = null;\n\t        context.invoke('editor.focus');\n\t      }\n\t\n\t    };\n\t\n\t    this.handleKeydown = function (e) {\n\t      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n\t        var wordRange = context.invoke('editor.createRange').getWordRange();\n\t        this.lastWordRange = wordRange;\n\t      }\n\t    };\n\t\n\t    this.handleKeyup = function (e) {\n\t      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n\t        this.replace();\n\t      }\n\t    };\n\t  };\n\t\n\t  /**\n\t   * textarea auto sync.\n\t   */\n\t  var AutoSync = function (context) {\n\t    var $note = context.layoutInfo.note;\n\t\n\t    this.events = {\n\t      'summernote.change': function () {\n\t        $note.val(context.invoke('code'));\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return dom.isTextarea($note[0]);\n\t    };\n\t  };\n\t\n\t  var Placeholder = function (context) {\n\t    var self = this;\n\t    var $editingArea = context.layoutInfo.editingArea;\n\t    var options = context.options;\n\t\n\t    this.events = {\n\t      'summernote.init summernote.change': function () {\n\t        self.update();\n\t      },\n\t      'summernote.codeview.toggled': function () {\n\t        self.update();\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return !!options.placeholder;\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$placeholder = $('<div class=\"note-placeholder\">');\n\t      this.$placeholder.on('click', function () {\n\t        context.invoke('focus');\n\t      }).text(options.placeholder).prependTo($editingArea);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$placeholder.remove();\n\t    };\n\t\n\t    this.update = function () {\n\t      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n\t      this.$placeholder.toggle(isShow);\n\t    };\n\t  };\n\t\n\t  var Buttons = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $toolbar = context.layoutInfo.toolbar;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\t\n\t    var representShortcut = this.representShortcut = function (editorMethod) {\n\t      var shortcut = invertedKeyMap[editorMethod];\n\t      if (!options.shortcuts || !shortcut) {\n\t        return '';\n\t      }\n\t      \n\t      if (agent.isMac) {\n\t        shortcut = shortcut.replace('CMD', '').replace('SHIFT', '');\n\t      }\n\t\n\t      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n\t                         .replace('SLASH', '/')\n\t                         .replace('LEFTBRACKET', '[')\n\t                         .replace('RIGHTBRACKET', ']');\n\t\n\t      return ' (' + shortcut + ')';\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.addToolbarButtons();\n\t      this.addImagePopoverButtons();\n\t      this.addLinkPopoverButtons();\n\t      this.fontInstalledMap = {};\n\t    };\n\t\n\t    this.destroy = function () {\n\t      delete this.fontInstalledMap;\n\t    };\n\t\n\t    this.isFontInstalled = function (name) {\n\t      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n\t        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n\t          list.contains(options.fontNamesIgnoreCheck, name);\n\t      }\n\t\n\t      return self.fontInstalledMap[name];\n\t    };\n\t\n\t    this.addToolbarButtons = function () {\n\t      context.memo('button.style', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.style.style,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdown({\n\t            className: 'dropdown-style',\n\t            items: context.options.styleTags,\n\t            template: function (item) {\n\t\n\t              if (typeof item === 'string') {\n\t                item = { tag: item, title: (lang.style.hasOwnProperty(item) ? lang.style[item] : item) };\n\t              }\n\t\n\t              var tag = item.tag;\n\t              var title = item.title;\n\t              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n\t              var className = item.className ? ' class=\"' + item.className + '\"' : '';\n\t\n\t              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n\t            },\n\t            click: context.createInvokeHandler('editor.formatBlock')\n\t          })\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.bold', function () {\n\t        return ui.button({\n\t          className: 'note-btn-bold',\n\t          contents: ui.icon(options.icons.bold),\n\t          tooltip: lang.font.bold + representShortcut('bold'),\n\t          click: context.createInvokeHandler('editor.bold')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.italic', function () {\n\t        return ui.button({\n\t          className: 'note-btn-italic',\n\t          contents: ui.icon(options.icons.italic),\n\t          tooltip: lang.font.italic + representShortcut('italic'),\n\t          click: context.createInvokeHandler('editor.italic')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.underline', function () {\n\t        return ui.button({\n\t          className: 'note-btn-underline',\n\t          contents: ui.icon(options.icons.underline),\n\t          tooltip: lang.font.underline + representShortcut('underline'),\n\t          click: context.createInvokeHandler('editor.underline')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.clear', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.eraser),\n\t          tooltip: lang.font.clear + representShortcut('removeFormat'),\n\t          click: context.createInvokeHandler('editor.removeFormat')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.strikethrough', function () {\n\t        return ui.button({\n\t          className: 'note-btn-strikethrough',\n\t          contents: ui.icon(options.icons.strikethrough),\n\t          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n\t          click: context.createInvokeHandler('editor.strikethrough')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.superscript', function () {\n\t        return ui.button({\n\t          className: 'note-btn-superscript',\n\t          contents: ui.icon(options.icons.superscript),\n\t          tooltip: lang.font.superscript,\n\t          click: context.createInvokeHandler('editor.superscript')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.subscript', function () {\n\t        return ui.button({\n\t          className: 'note-btn-subscript',\n\t          contents: ui.icon(options.icons.subscript),\n\t          tooltip: lang.font.subscript,\n\t          click: context.createInvokeHandler('editor.subscript')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.fontname', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: '<span class=\"note-current-fontname\"/> ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.font.name,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdownCheck({\n\t            className: 'dropdown-fontname',\n\t            checkClassName: options.icons.menuCheck,\n\t            items: options.fontNames.filter(self.isFontInstalled),\n\t            template: function (item) {\n\t              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n\t            },\n\t            click: context.createInvokeHandler('editor.fontName')\n\t          })\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.fontsize', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: '<span class=\"note-current-fontsize\"/>' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.font.size,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdownCheck({\n\t            className: 'dropdown-fontsize',\n\t            checkClassName: options.icons.menuCheck,\n\t            items: options.fontSizes,\n\t            click: context.createInvokeHandler('editor.fontSize')\n\t          })\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.color', function () {\n\t        return ui.buttonGroup({\n\t          className: 'note-color',\n\t          children: [\n\t            ui.button({\n\t              className: 'note-current-color-button',\n\t              contents: ui.icon(options.icons.font + ' note-recent-color'),\n\t              tooltip: lang.color.recent,\n\t              click: function (e) {\n\t                var $button = $(e.currentTarget);\n\t                context.invoke('editor.color', {\n\t                  backColor: $button.attr('data-backColor'),\n\t                  foreColor: $button.attr('data-foreColor')\n\t                });\n\t              },\n\t              callback: function ($button) {\n\t                var $recentColor = $button.find('.note-recent-color');\n\t                $recentColor.css('background-color', '#FFFF00');\n\t                $button.attr('data-backColor', '#FFFF00');\n\t              }\n\t            }),\n\t            ui.button({\n\t              className: 'dropdown-toggle',\n\t              contents: ui.icon(options.icons.caret, 'span'),\n\t              tooltip: lang.color.more,\n\t              data: {\n\t                toggle: 'dropdown'\n\t              }\n\t            }),\n\t            ui.dropdown({\n\t              items: [\n\t                '<li>',\n\t                '<div class=\"btn-group\">',\n\t                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n\t                '  <div>',\n\t                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"backColor\" data-value=\"inherit\">',\n\t                lang.color.transparent,\n\t                '    </button>',\n\t                '  </div>',\n\t                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n\t                '</div>',\n\t                '<div class=\"btn-group\">',\n\t                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n\t                '  <div>',\n\t                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n\t                lang.color.resetToDefault,\n\t                '    </button>',\n\t                '  </div>',\n\t                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n\t                '</div>',\n\t                '</li>'\n\t              ].join(''),\n\t              callback: function ($dropdown) {\n\t                $dropdown.find('.note-holder').each(function () {\n\t                  var $holder = $(this);\n\t                  $holder.append(ui.palette({\n\t                    colors: options.colors,\n\t                    eventName: $holder.data('event')\n\t                  }).render());\n\t                });\n\t              },\n\t              click: function (event) {\n\t                var $button = $(event.target);\n\t                var eventName = $button.data('event');\n\t                var value = $button.data('value');\n\t\n\t                if (eventName && value) {\n\t                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n\t                  var $color = $button.closest('.note-color').find('.note-recent-color');\n\t                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\t\n\t                  $color.css(key, value);\n\t                  $currentButton.attr('data-' + eventName, value);\n\t                  context.invoke('editor.' + eventName, value);\n\t                }\n\t              }\n\t            })\n\t          ]\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.ul',  function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.unorderedlist),\n\t          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n\t          click: context.createInvokeHandler('editor.insertUnorderedList')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.ol', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.orderedlist),\n\t          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n\t          click:  context.createInvokeHandler('editor.insertOrderedList')\n\t        }).render();\n\t      });\n\t\n\t      var justifyLeft = ui.button({\n\t        contents: ui.icon(options.icons.alignLeft),\n\t        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n\t        click: context.createInvokeHandler('editor.justifyLeft')\n\t      });\n\t\n\t      var justifyCenter = ui.button({\n\t        contents: ui.icon(options.icons.alignCenter),\n\t        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n\t        click: context.createInvokeHandler('editor.justifyCenter')\n\t      });\n\t\n\t      var justifyRight = ui.button({\n\t        contents: ui.icon(options.icons.alignRight),\n\t        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n\t        click: context.createInvokeHandler('editor.justifyRight')\n\t      });\n\t\n\t      var justifyFull = ui.button({\n\t        contents: ui.icon(options.icons.alignJustify),\n\t        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n\t        click: context.createInvokeHandler('editor.justifyFull')\n\t      });\n\t\n\t      var outdent = ui.button({\n\t        contents: ui.icon(options.icons.outdent),\n\t        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n\t        click: context.createInvokeHandler('editor.outdent')\n\t      });\n\t\n\t      var indent = ui.button({\n\t        contents: ui.icon(options.icons.indent),\n\t        tooltip: lang.paragraph.indent + representShortcut('indent'),\n\t        click: context.createInvokeHandler('editor.indent')\n\t      });\n\t\n\t      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n\t      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n\t      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n\t      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n\t      context.memo('button.outdent', func.invoke(outdent, 'render'));\n\t      context.memo('button.indent', func.invoke(indent, 'render'));\n\t\n\t      context.memo('button.paragraph', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.paragraph.paragraph,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdown([\n\t            ui.buttonGroup({\n\t              className: 'note-align',\n\t              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n\t            }),\n\t            ui.buttonGroup({\n\t              className: 'note-list',\n\t              children: [outdent, indent]\n\t            })\n\t          ])\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.height', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.font.height,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdownCheck({\n\t            items: options.lineHeights,\n\t            checkClassName: options.icons.menuCheck,\n\t            className: 'dropdown-line-height',\n\t            click: context.createInvokeHandler('editor.lineHeight')\n\t          })\n\t        ]).render();\n\t      });\n\t\n\t      context.memo('button.table', function () {\n\t        return ui.buttonGroup([\n\t          ui.button({\n\t            className: 'dropdown-toggle',\n\t            contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),\n\t            tooltip: lang.table.table,\n\t            data: {\n\t              toggle: 'dropdown'\n\t            }\n\t          }),\n\t          ui.dropdown({\n\t            className: 'note-table',\n\t            items: [\n\t              '<div class=\"note-dimension-picker\">',\n\t              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n\t              '  <div class=\"note-dimension-picker-highlighted\"/>',\n\t              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n\t              '</div>',\n\t              '<div class=\"note-dimension-display\">1 x 1</div>'\n\t            ].join('')\n\t          })\n\t        ], {\n\t          callback: function ($node) {\n\t            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n\t            $catcher.css({\n\t              width: options.insertTableMaxSize.col + 'em',\n\t              height: options.insertTableMaxSize.row + 'em'\n\t            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n\t              .on('mousemove', self.tableMoveHandler);\n\t          }\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.link', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.link),\n\t          tooltip: lang.link.link + representShortcut('linkDialog.show'),\n\t          click: context.createInvokeHandler('linkDialog.show')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.picture', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.picture),\n\t          tooltip: lang.image.image,\n\t          click: context.createInvokeHandler('imageDialog.show')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.video', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.video),\n\t          tooltip: lang.video.video,\n\t          click: context.createInvokeHandler('videoDialog.show')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.hr', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.minus),\n\t          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n\t          click: context.createInvokeHandler('editor.insertHorizontalRule')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.fullscreen', function () {\n\t        return ui.button({\n\t          className: 'btn-fullscreen',\n\t          contents: ui.icon(options.icons.arrowsAlt),\n\t          tooltip: lang.options.fullscreen,\n\t          click: context.createInvokeHandler('fullscreen.toggle')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.codeview', function () {\n\t        return ui.button({\n\t          className: 'btn-codeview',\n\t          contents: ui.icon(options.icons.code),\n\t          tooltip: lang.options.codeview,\n\t          click: context.createInvokeHandler('codeview.toggle')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.redo', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.redo),\n\t          tooltip: lang.history.redo + representShortcut('redo'),\n\t          click: context.createInvokeHandler('editor.redo')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.undo', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.undo),\n\t          tooltip: lang.history.undo + representShortcut('undo'),\n\t          click: context.createInvokeHandler('editor.undo')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.help', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.question),\n\t          tooltip: lang.options.help,\n\t          click: context.createInvokeHandler('helpDialog.show')\n\t        }).render();\n\t      });\n\t    };\n\t\n\t    /**\n\t     * image : [\n\t     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n\t     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n\t     *   ['remove', ['removeMedia']]\n\t     * ],\n\t     */\n\t    this.addImagePopoverButtons = function () {\n\t      // Image Size Buttons\n\t      context.memo('button.imageSize100', function () {\n\t        return ui.button({\n\t          contents: '<span class=\"note-fontsize-10\">100%</span>',\n\t          tooltip: lang.image.resizeFull,\n\t          click: context.createInvokeHandler('editor.resize', '1')\n\t        }).render();\n\t      });\n\t      context.memo('button.imageSize50', function () {\n\t        return  ui.button({\n\t          contents: '<span class=\"note-fontsize-10\">50%</span>',\n\t          tooltip: lang.image.resizeHalf,\n\t          click: context.createInvokeHandler('editor.resize', '0.5')\n\t        }).render();\n\t      });\n\t      context.memo('button.imageSize25', function () {\n\t        return ui.button({\n\t          contents: '<span class=\"note-fontsize-10\">25%</span>',\n\t          tooltip: lang.image.resizeQuarter,\n\t          click: context.createInvokeHandler('editor.resize', '0.25')\n\t        }).render();\n\t      });\n\t\n\t      // Float Buttons\n\t      context.memo('button.floatLeft', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.alignLeft),\n\t          tooltip: lang.image.floatLeft,\n\t          click: context.createInvokeHandler('editor.floatMe', 'left')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.floatRight', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.alignRight),\n\t          tooltip: lang.image.floatRight,\n\t          click: context.createInvokeHandler('editor.floatMe', 'right')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.floatNone', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.alignJustify),\n\t          tooltip: lang.image.floatNone,\n\t          click: context.createInvokeHandler('editor.floatMe', 'none')\n\t        }).render();\n\t      });\n\t\n\t      // Remove Buttons\n\t      context.memo('button.removeMedia', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.trash),\n\t          tooltip: lang.image.remove,\n\t          click: context.createInvokeHandler('editor.removeMedia')\n\t        }).render();\n\t      });\n\t    };\n\t\n\t    this.addLinkPopoverButtons = function () {\n\t      context.memo('button.linkDialogShow', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.link),\n\t          tooltip: lang.link.edit,\n\t          click: context.createInvokeHandler('linkDialog.show')\n\t        }).render();\n\t      });\n\t\n\t      context.memo('button.unlink', function () {\n\t        return ui.button({\n\t          contents: ui.icon(options.icons.unlink),\n\t          tooltip: lang.link.unlink,\n\t          click: context.createInvokeHandler('editor.unlink')\n\t        }).render();\n\t      });\n\t    };\n\t\n\t    this.build = function ($container, groups) {\n\t      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n\t        var group = groups[groupIdx];\n\t        var groupName = group[0];\n\t        var buttons = group[1];\n\t\n\t        var $group = ui.buttonGroup({\n\t          className: 'note-' + groupName\n\t        }).render();\n\t\n\t        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n\t          var button = context.memo('button.' + buttons[idx]);\n\t          if (button) {\n\t            $group.append(typeof button === 'function' ? button(context) : button);\n\t          }\n\t        }\n\t        $group.appendTo($container);\n\t      }\n\t    };\n\t\n\t    this.updateCurrentStyle = function () {\n\t      var styleInfo = context.invoke('editor.currentStyle');\n\t      this.updateBtnStates({\n\t        '.note-btn-bold': function () {\n\t          return styleInfo['font-bold'] === 'bold';\n\t        },\n\t        '.note-btn-italic': function () {\n\t          return styleInfo['font-italic'] === 'italic';\n\t        },\n\t        '.note-btn-underline': function () {\n\t          return styleInfo['font-underline'] === 'underline';\n\t        },\n\t        '.note-btn-subscript': function () {\n\t          return styleInfo['font-subscript'] === 'subscript';\n\t        },\n\t        '.note-btn-superscript': function () {\n\t          return styleInfo['font-superscript'] === 'superscript';\n\t        },\n\t        '.note-btn-strikethrough': function () {\n\t          return styleInfo['font-strikethrough'] === 'strikethrough';\n\t        }\n\t      });\n\t\n\t      if (styleInfo['font-family']) {\n\t        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n\t          return name.replace(/[\\'\\\"]/g, '')\n\t            .replace(/\\s+$/, '')\n\t            .replace(/^\\s+/, '');\n\t        });\n\t        var fontName = list.find(fontNames, self.isFontInstalled);\n\t\n\t        $toolbar.find('.dropdown-fontname li a').each(function () {\n\t          // always compare string to avoid creating another func.\n\t          var isChecked = ($(this).data('value') + '') === (fontName + '');\n\t          this.className = isChecked ? 'checked' : '';\n\t        });\n\t        $toolbar.find('.note-current-fontname').text(fontName);\n\t      }\n\t\n\t      if (styleInfo['font-size']) {\n\t        var fontSize = styleInfo['font-size'];\n\t        $toolbar.find('.dropdown-fontsize li a').each(function () {\n\t          // always compare with string to avoid creating another func.\n\t          var isChecked = ($(this).data('value') + '') === (fontSize + '');\n\t          this.className = isChecked ? 'checked' : '';\n\t        });\n\t        $toolbar.find('.note-current-fontsize').text(fontSize);\n\t      }\n\t\n\t      if (styleInfo['line-height']) {\n\t        var lineHeight = styleInfo['line-height'];\n\t        $toolbar.find('.dropdown-line-height li a').each(function () {\n\t          // always compare with string to avoid creating another func.\n\t          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n\t          this.className = isChecked ? 'checked' : '';\n\t        });\n\t      }\n\t    };\n\t\n\t    this.updateBtnStates = function (infos) {\n\t      $.each(infos, function (selector, pred) {\n\t        ui.toggleBtnActive($toolbar.find(selector), pred());\n\t      });\n\t    };\n\t\n\t    this.tableMoveHandler = function (event) {\n\t      var PX_PER_EM = 18;\n\t      var $picker = $(event.target.parentNode); // target is mousecatcher\n\t      var $dimensionDisplay = $picker.next();\n\t      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n\t      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n\t      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\t\n\t      var posOffset;\n\t      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n\t      if (event.offsetX === undefined) {\n\t        var posCatcher = $(event.target).offset();\n\t        posOffset = {\n\t          x: event.pageX - posCatcher.left,\n\t          y: event.pageY - posCatcher.top\n\t        };\n\t      } else {\n\t        posOffset = {\n\t          x: event.offsetX,\n\t          y: event.offsetY\n\t        };\n\t      }\n\t\n\t      var dim = {\n\t        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n\t        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n\t      };\n\t\n\t      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n\t      $catcher.data('value', dim.c + 'x' + dim.r);\n\t\n\t      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n\t        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n\t      }\n\t\n\t      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n\t        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n\t      }\n\t\n\t      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n\t    };\n\t  };\n\t\n\t  var Toolbar = function (context) {\n\t    var ui = $.summernote.ui;\n\t\n\t    var $note = context.layoutInfo.note;\n\t    var $toolbar = context.layoutInfo.toolbar;\n\t    var options = context.options;\n\t\n\t    this.shouldInitialize = function () {\n\t      return !options.airMode;\n\t    };\n\t\n\t    this.initialize = function () {\n\t      options.toolbar = options.toolbar || [];\n\t\n\t      if (!options.toolbar.length) {\n\t        $toolbar.hide();\n\t      } else {\n\t        context.invoke('buttons.build', $toolbar, options.toolbar);\n\t      }\n\t\n\t      if (options.toolbarContainer) {\n\t        $toolbar.appendTo(options.toolbarContainer);\n\t      }\n\t\n\t      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n\t        context.invoke('buttons.updateCurrentStyle');\n\t      });\n\t\n\t      context.invoke('buttons.updateCurrentStyle');\n\t    };\n\t\n\t    this.destroy = function () {\n\t      $toolbar.children().remove();\n\t    };\n\t\n\t    this.updateFullscreen = function (isFullscreen) {\n\t      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n\t    };\n\t\n\t    this.updateCodeview = function (isCodeview) {\n\t      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n\t      if (isCodeview) {\n\t        this.deactivate();\n\t      } else {\n\t        this.activate();\n\t      }\n\t    };\n\t\n\t    this.activate = function (isIncludeCodeview) {\n\t      var $btn = $toolbar.find('button');\n\t      if (!isIncludeCodeview) {\n\t        $btn = $btn.not('.btn-codeview');\n\t      }\n\t      ui.toggleBtn($btn, true);\n\t    };\n\t\n\t    this.deactivate = function (isIncludeCodeview) {\n\t      var $btn = $toolbar.find('button');\n\t      if (!isIncludeCodeview) {\n\t        $btn = $btn.not('.btn-codeview');\n\t      }\n\t      ui.toggleBtn($btn, false);\n\t    };\n\t  };\n\t\n\t  var LinkDialog = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $editor = context.layoutInfo.editor;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t\n\t      var body = '<div class=\"form-group\">' +\n\t                   '<label>' + lang.link.textToDisplay + '</label>' +\n\t                   '<input class=\"note-link-text form-control\" type=\"text\" />' +\n\t                 '</div>' +\n\t                 '<div class=\"form-group\">' +\n\t                   '<label>' + lang.link.url + '</label>' +\n\t                   '<input class=\"note-link-url form-control\" type=\"text\" value=\"http://\" />' +\n\t                 '</div>' +\n\t                 (!options.disableLinkTarget ?\n\t                   '<div class=\"checkbox\">' +\n\t                     '<label>' + '<input type=\"checkbox\" checked> ' + lang.link.openInNewWindow + '</label>' +\n\t                   '</div>' : ''\n\t                 );\n\t      var footer = '<button href=\"#\" class=\"btn btn-primary note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\t\n\t      this.$dialog = ui.dialog({\n\t        className: 'link-dialog',\n\t        title: lang.link.insert,\n\t        fade: options.dialogsFade,\n\t        body: body,\n\t        footer: footer\n\t      }).render().appendTo($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(this.$dialog);\n\t      this.$dialog.remove();\n\t    };\n\t\n\t    this.bindEnterKey = function ($input, $btn) {\n\t      $input.on('keypress', function (event) {\n\t        if (event.keyCode === key.code.ENTER) {\n\t          $btn.trigger('click');\n\t        }\n\t      });\n\t    };\n\t\n\t    /**\n\t     * toggle update button\n\t     */\n\t    this.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {\n\t      ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n\t    };\n\t\n\t    /**\n\t     * Show link dialog and set event handlers on dialog controls.\n\t     *\n\t     * @param {Object} linkInfo\n\t     * @return {Promise}\n\t     */\n\t    this.showLinkDialog = function (linkInfo) {\n\t      return $.Deferred(function (deferred) {\n\t        var $linkText = self.$dialog.find('.note-link-text'),\n\t        $linkUrl = self.$dialog.find('.note-link-url'),\n\t        $linkBtn = self.$dialog.find('.note-link-btn'),\n\t        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\t\n\t        ui.onDialogShown(self.$dialog, function () {\n\t          context.triggerEvent('dialog.shown');\n\t\n\t          // if no url was given, copy text to url\n\t          if (!linkInfo.url) {\n\t            linkInfo.url = linkInfo.text;\n\t          }\n\t\n\t          $linkText.val(linkInfo.text);\n\t\n\t          var handleLinkTextUpdate = function () {\n\t            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n\t            // if linktext was modified by keyup,\n\t            // stop cloning text from linkUrl\n\t            linkInfo.text = $linkText.val();\n\t          };\n\t\n\t          $linkText.on('input', handleLinkTextUpdate).on('paste', function () {\n\t            setTimeout(handleLinkTextUpdate, 0);\n\t          });\n\t\n\t          var handleLinkUrlUpdate = function () {\n\t            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n\t            // display same link on `Text to display` input\n\t            // when create a new link\n\t            if (!linkInfo.text) {\n\t              $linkText.val($linkUrl.val());\n\t            }\n\t          };\n\t\n\t          $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {\n\t            setTimeout(handleLinkUrlUpdate, 0);\n\t          }).val(linkInfo.url).trigger('focus');\n\t\n\t          self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n\t          self.bindEnterKey($linkUrl, $linkBtn);\n\t          self.bindEnterKey($linkText, $linkBtn);\n\t\n\t          $openInNewWindow.prop('checked', linkInfo.isNewWindow);\n\t\n\t          $linkBtn.one('click', function (event) {\n\t            event.preventDefault();\n\t\n\t            deferred.resolve({\n\t              range: linkInfo.range,\n\t              url: $linkUrl.val(),\n\t              text: $linkText.val(),\n\t              isNewWindow: $openInNewWindow.is(':checked')\n\t            });\n\t            self.$dialog.modal('hide');\n\t          });\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function () {\n\t          // detach events\n\t          $linkText.off('input paste keypress');\n\t          $linkUrl.off('input paste keypress');\n\t          $linkBtn.off('click');\n\t\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      }).promise();\n\t    };\n\t\n\t    /**\n\t     * @param {Object} layoutInfo\n\t     */\n\t    this.show = function () {\n\t      var linkInfo = context.invoke('editor.getLinkInfo');\n\t\n\t      context.invoke('editor.saveRange');\n\t      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n\t        context.invoke('editor.restoreRange');\n\t        context.invoke('editor.createLink', linkInfo);\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n\t  };\n\t\n\t  var LinkPopover = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var options = context.options;\n\t\n\t    this.events = {\n\t      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n\t        self.update();\n\t      },\n\t      'summernote.dialog.shown': function () {\n\t        self.hide();\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return !list.isEmpty(options.popover.link);\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$popover = ui.popover({\n\t        className: 'note-link-popover',\n\t        callback: function ($node) {\n\t          var $content = $node.find('.popover-content');\n\t          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n\t        }\n\t      }).render().appendTo('body');\n\t      var $content = this.$popover.find('.popover-content');\n\t\n\t      context.invoke('buttons.build', $content, options.popover.link);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$popover.remove();\n\t    };\n\t\n\t    this.update = function () {\n\t      // Prevent focusing on editable when invoke('code') is executed\n\t      if (!context.invoke('editor.hasFocus')) {\n\t        this.hide();\n\t        return;\n\t      }\n\t\n\t      var rng = context.invoke('editor.createRange');\n\t      if (rng.isCollapsed() && rng.isOnAnchor()) {\n\t        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n\t        var href = $(anchor).attr('href');\n\t        this.$popover.find('a').attr('href', href).html(href);\n\t\n\t        var pos = dom.posFromPlaceholder(anchor);\n\t        this.$popover.css({\n\t          display: 'block',\n\t          left: pos.left,\n\t          top: pos.top\n\t        });\n\t      } else {\n\t        this.hide();\n\t      }\n\t    };\n\t\n\t    this.hide = function () {\n\t      this.$popover.hide();\n\t    };\n\t  };\n\t\n\t  var ImageDialog = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $editor = context.layoutInfo.editor;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t\n\t      var imageLimitation = '';\n\t      if (options.maximumImageFileSize) {\n\t        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n\t        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n\t                           ' ' + ' KMGTP'[unit] + 'B';\n\t        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n\t      }\n\t\n\t      var body = '<div class=\"form-group note-group-select-from-files\">' +\n\t                   '<label>' + lang.image.selectFromFiles + '</label>' +\n\t                   '<input class=\"note-image-input form-control\" type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n\t                   imageLimitation +\n\t                 '</div>' +\n\t                 '<div class=\"form-group note-group-image-url\" style=\"overflow:auto;\">' +\n\t                   '<label>' + lang.image.url + '</label>' +\n\t                   '<input class=\"note-image-url form-control col-md-12\" type=\"text\" />' +\n\t                 '</div>';\n\t      var footer = '<button href=\"#\" class=\"btn btn-primary note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\t\n\t      this.$dialog = ui.dialog({\n\t        title: lang.image.insert,\n\t        fade: options.dialogsFade,\n\t        body: body,\n\t        footer: footer\n\t      }).render().appendTo($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(this.$dialog);\n\t      this.$dialog.remove();\n\t    };\n\t\n\t    this.bindEnterKey = function ($input, $btn) {\n\t      $input.on('keypress', function (event) {\n\t        if (event.keyCode === key.code.ENTER) {\n\t          $btn.trigger('click');\n\t        }\n\t      });\n\t    };\n\t\n\t    this.show = function () {\n\t      context.invoke('editor.saveRange');\n\t      this.showImageDialog().then(function (data) {\n\t        // [workaround] hide dialog before restore range for IE range focus\n\t        ui.hideDialog(self.$dialog);\n\t        context.invoke('editor.restoreRange');\n\t\n\t        if (typeof data === 'string') { // image url\n\t          context.invoke('editor.insertImage', data);\n\t        } else { // array of files\n\t          context.invoke('editor.insertImagesOrCallback', data);\n\t        }\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t\n\t    /**\n\t     * show image dialog\n\t     *\n\t     * @param {jQuery} $dialog\n\t     * @return {Promise}\n\t     */\n\t    this.showImageDialog = function () {\n\t      return $.Deferred(function (deferred) {\n\t        var $imageInput = self.$dialog.find('.note-image-input'),\n\t            $imageUrl = self.$dialog.find('.note-image-url'),\n\t            $imageBtn = self.$dialog.find('.note-image-btn');\n\t\n\t        ui.onDialogShown(self.$dialog, function () {\n\t          context.triggerEvent('dialog.shown');\n\t\n\t          // Cloning imageInput to clear element.\n\t          $imageInput.replaceWith($imageInput.clone()\n\t            .on('change', function () {\n\t              deferred.resolve(this.files || this.value);\n\t            })\n\t            .val('')\n\t          );\n\t\n\t          $imageBtn.click(function (event) {\n\t            event.preventDefault();\n\t\n\t            deferred.resolve($imageUrl.val());\n\t          });\n\t\n\t          $imageUrl.on('keyup paste', function () {\n\t            var url = $imageUrl.val();\n\t            ui.toggleBtn($imageBtn, url);\n\t          }).val('').trigger('focus');\n\t          self.bindEnterKey($imageUrl, $imageBtn);\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function () {\n\t          $imageInput.off('change');\n\t          $imageUrl.off('keyup paste keypress');\n\t          $imageBtn.off('click');\n\t\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      });\n\t    };\n\t  };\n\t\n\t  var ImagePopover = function (context) {\n\t    var ui = $.summernote.ui;\n\t\n\t    var options = context.options;\n\t\n\t    this.shouldInitialize = function () {\n\t      return !list.isEmpty(options.popover.image);\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$popover = ui.popover({\n\t        className: 'note-image-popover'\n\t      }).render().appendTo('body');\n\t      var $content = this.$popover.find('.popover-content');\n\t\n\t      context.invoke('buttons.build', $content, options.popover.image);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$popover.remove();\n\t    };\n\t\n\t    this.update = function (target) {\n\t      if (dom.isImg(target)) {\n\t        var pos = dom.posFromPlaceholder(target);\n\t        this.$popover.css({\n\t          display: 'block',\n\t          left: pos.left,\n\t          top: pos.top\n\t        });\n\t      } else {\n\t        this.hide();\n\t      }\n\t    };\n\t\n\t    this.hide = function () {\n\t      this.$popover.hide();\n\t    };\n\t  };\n\t\n\t  var VideoDialog = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $editor = context.layoutInfo.editor;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t\n\t      var body = '<div class=\"form-group row-fluid\">' +\n\t          '<label>' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n\t          '<input class=\"note-video-url form-control span12\" type=\"text\" />' +\n\t          '</div>';\n\t      var footer = '<button href=\"#\" class=\"btn btn-primary note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\t\n\t      this.$dialog = ui.dialog({\n\t        title: lang.video.insert,\n\t        fade: options.dialogsFade,\n\t        body: body,\n\t        footer: footer\n\t      }).render().appendTo($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(this.$dialog);\n\t      this.$dialog.remove();\n\t    };\n\t\n\t    this.bindEnterKey = function ($input, $btn) {\n\t      $input.on('keypress', function (event) {\n\t        if (event.keyCode === key.code.ENTER) {\n\t          $btn.trigger('click');\n\t        }\n\t      });\n\t    };\n\t\n\t    this.createVideoNode = function (url) {\n\t      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n\t      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n\t      var ytMatch = url.match(ytRegExp);\n\t\n\t      var igRegExp = /(?:www\\.|\\/\\/)instagram\\.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n\t      var igMatch = url.match(igRegExp);\n\t\n\t      var vRegExp = /\\/\\/vine\\.co\\/v\\/([a-zA-Z0-9]+)/;\n\t      var vMatch = url.match(vRegExp);\n\t\n\t      var vimRegExp = /\\/\\/(player\\.)?vimeo\\.com\\/([a-z]*\\/)*([0-9]{6,11})[?]?.*/;\n\t      var vimMatch = url.match(vimRegExp);\n\t\n\t      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n\t      var dmMatch = url.match(dmRegExp);\n\t\n\t      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n\t      var youkuMatch = url.match(youkuRegExp);\n\t\n\t      var mp4RegExp = /^.+.(mp4|m4v)$/;\n\t      var mp4Match = url.match(mp4RegExp);\n\t\n\t      var oggRegExp = /^.+.(ogg|ogv)$/;\n\t      var oggMatch = url.match(oggRegExp);\n\t\n\t      var webmRegExp = /^.+.(webm)$/;\n\t      var webmMatch = url.match(webmRegExp);\n\t\n\t      var $video;\n\t      if (ytMatch && ytMatch[1].length === 11) {\n\t        var youtubeId = ytMatch[1];\n\t        $video = $('<iframe>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n\t            .attr('width', '640').attr('height', '360');\n\t      } else if (igMatch && igMatch[0].length) {\n\t        $video = $('<iframe>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/')\n\t            .attr('width', '612').attr('height', '710')\n\t            .attr('scrolling', 'no')\n\t            .attr('allowtransparency', 'true');\n\t      } else if (vMatch && vMatch[0].length) {\n\t        $video = $('<iframe>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', vMatch[0] + '/embed/simple')\n\t            .attr('width', '600').attr('height', '600')\n\t            .attr('class', 'vine-embed');\n\t      } else if (vimMatch && vimMatch[3].length) {\n\t        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n\t            .attr('width', '640').attr('height', '360');\n\t      } else if (dmMatch && dmMatch[2].length) {\n\t        $video = $('<iframe>')\n\t            .attr('frameborder', 0)\n\t            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n\t            .attr('width', '640').attr('height', '360');\n\t      } else if (youkuMatch && youkuMatch[1].length) {\n\t        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n\t            .attr('frameborder', 0)\n\t            .attr('height', '498')\n\t            .attr('width', '510')\n\t            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n\t      } else if (mp4Match || oggMatch || webmMatch) {\n\t        $video = $('<video controls>')\n\t            .attr('src', url)\n\t            .attr('width', '640').attr('height', '360');\n\t      } else {\n\t        // this is not a known video link. Now what, Cat? Now what?\n\t        return false;\n\t      }\n\t\n\t      $video.addClass('note-video-clip');\n\t\n\t      return $video[0];\n\t    };\n\t\n\t    this.show = function () {\n\t      var text = context.invoke('editor.getSelectedText');\n\t      context.invoke('editor.saveRange');\n\t      this.showVideoDialog(text).then(function (url) {\n\t        // [workaround] hide dialog before restore range for IE range focus\n\t        ui.hideDialog(self.$dialog);\n\t        context.invoke('editor.restoreRange');\n\t\n\t        // build node\n\t        var $node = self.createVideoNode(url);\n\t\n\t        if ($node) {\n\t          // insert video node\n\t          context.invoke('editor.insertNode', $node);\n\t        }\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t\n\t    /**\n\t     * show image dialog\n\t     *\n\t     * @param {jQuery} $dialog\n\t     * @return {Promise}\n\t     */\n\t    this.showVideoDialog = function (text) {\n\t      return $.Deferred(function (deferred) {\n\t        var $videoUrl = self.$dialog.find('.note-video-url'),\n\t            $videoBtn = self.$dialog.find('.note-video-btn');\n\t\n\t        ui.onDialogShown(self.$dialog, function () {\n\t          context.triggerEvent('dialog.shown');\n\t\n\t          $videoUrl.val(text).on('input', function () {\n\t            ui.toggleBtn($videoBtn, $videoUrl.val());\n\t          }).trigger('focus');\n\t\n\t          $videoBtn.click(function (event) {\n\t            event.preventDefault();\n\t\n\t            deferred.resolve($videoUrl.val());\n\t          });\n\t\n\t          self.bindEnterKey($videoUrl, $videoBtn);\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function () {\n\t          $videoUrl.off('input');\n\t          $videoBtn.off('click');\n\t\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      });\n\t    };\n\t  };\n\t\n\t  var HelpDialog = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var $editor = context.layoutInfo.editor;\n\t    var options = context.options;\n\t    var lang = options.langInfo;\n\t\n\t    this.createShortCutList = function () {\n\t      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n\t      return Object.keys(keyMap).map(function (key) {\n\t        var command = keyMap[key];\n\t        var $row = $('<div><div class=\"help-list-item\"/></div>');\n\t        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n\t          'width': 180,\n\t          'margin-right': 10\n\t        })).append($('<span/>').html(context.memo('help.' + command) || command));\n\t        return $row.html();\n\t      }).join('');\n\t    };\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t\n\t      var body = [\n\t        '<p class=\"text-center\">',\n\t        '<a href=\"http://summernote.org/\" target=\"_blank\">Summernote 0.8.2</a>  ',\n\t        '<a href=\"https://github.com/summernote/summernote\" target=\"_blank\">Project</a>  ',\n\t        '<a href=\"https://github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n\t        '</p>'\n\t      ].join('');\n\t\n\t      this.$dialog = ui.dialog({\n\t        title: lang.options.help,\n\t        fade: options.dialogsFade,\n\t        body: this.createShortCutList(),\n\t        footer: body,\n\t        callback: function ($node) {\n\t          $node.find('.modal-body').css({\n\t            'max-height': 300,\n\t            'overflow': 'scroll'\n\t          });\n\t        }\n\t      }).render().appendTo($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(this.$dialog);\n\t      this.$dialog.remove();\n\t    };\n\t\n\t    /**\n\t     * show help dialog\n\t     *\n\t     * @return {Promise}\n\t     */\n\t    this.showHelpDialog = function () {\n\t      return $.Deferred(function (deferred) {\n\t        ui.onDialogShown(self.$dialog, function () {\n\t          context.triggerEvent('dialog.shown');\n\t          deferred.resolve();\n\t        });\n\t        ui.showDialog(self.$dialog);\n\t      }).promise();\n\t    };\n\t\n\t    this.show = function () {\n\t      context.invoke('editor.saveRange');\n\t      this.showHelpDialog().then(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t  };\n\t\n\t  var AirPopover = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var options = context.options;\n\t\n\t    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\t\n\t    this.events = {\n\t      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n\t        self.update();\n\t      },\n\t      'summernote.change summernote.dialog.shown': function () {\n\t        self.hide();\n\t      },\n\t      'summernote.focusout': function (we, e) {\n\t        // [workaround] Firefox doesn't support relatedTarget on focusout\n\t        //  - Ignore hide action on focus out in FF.\n\t        if (agent.isFF) {\n\t          return;\n\t        }\n\t\n\t        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n\t          self.hide();\n\t        }\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return options.airMode && !list.isEmpty(options.popover.air);\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.$popover = ui.popover({\n\t        className: 'note-air-popover'\n\t      }).render().appendTo('body');\n\t      var $content = this.$popover.find('.popover-content');\n\t\n\t      context.invoke('buttons.build', $content, options.popover.air);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$popover.remove();\n\t    };\n\t\n\t    this.update = function () {\n\t      var styleInfo = context.invoke('editor.currentStyle');\n\t      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n\t        var rect = list.last(styleInfo.range.getClientRects());\n\t        if (rect) {\n\t          var bnd = func.rect2bnd(rect);\n\t          this.$popover.css({\n\t            display: 'block',\n\t            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n\t            top: bnd.top + bnd.height\n\t          });\n\t        }\n\t      } else {\n\t        this.hide();\n\t      }\n\t    };\n\t\n\t    this.hide = function () {\n\t      this.$popover.hide();\n\t    };\n\t  };\n\t\n\t  var HintPopover = function (context) {\n\t    var self = this;\n\t    var ui = $.summernote.ui;\n\t\n\t    var POPOVER_DIST = 5;\n\t    var hint = context.options.hint || [];\n\t    var direction = context.options.hintDirection || 'bottom';\n\t    var hints = $.isArray(hint) ? hint : [hint];\n\t\n\t    this.events = {\n\t      'summernote.keyup': function (we, e) {\n\t        if (!e.isDefaultPrevented()) {\n\t          self.handleKeyup(e);\n\t        }\n\t      },\n\t      'summernote.keydown': function (we, e) {\n\t        self.handleKeydown(e);\n\t      },\n\t      'summernote.dialog.shown': function () {\n\t        self.hide();\n\t      }\n\t    };\n\t\n\t    this.shouldInitialize = function () {\n\t      return hints.length > 0;\n\t    };\n\t\n\t    this.initialize = function () {\n\t      this.lastWordRange = null;\n\t      this.$popover = ui.popover({\n\t        className: 'note-hint-popover',\n\t        hideArrow: true,\n\t        direction: ''\n\t      }).render().appendTo('body');\n\t\n\t      this.$popover.hide();\n\t\n\t      this.$content = this.$popover.find('.popover-content');\n\t\n\t      this.$content.on('click', '.note-hint-item', function () {\n\t        self.$content.find('.active').removeClass('active');\n\t        $(this).addClass('active');\n\t        self.replace();\n\t      });\n\t    };\n\t\n\t    this.destroy = function () {\n\t      this.$popover.remove();\n\t    };\n\t\n\t    this.selectItem = function ($item) {\n\t      this.$content.find('.active').removeClass('active');\n\t      $item.addClass('active');\n\t\n\t      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n\t    };\n\t\n\t    this.moveDown = function () {\n\t      var $current = this.$content.find('.note-hint-item.active');\n\t      var $next = $current.next();\n\t\n\t      if ($next.length) {\n\t        this.selectItem($next);\n\t      } else {\n\t        var $nextGroup = $current.parent().next();\n\t\n\t        if (!$nextGroup.length) {\n\t          $nextGroup = this.$content.find('.note-hint-group').first();\n\t        }\n\t\n\t        this.selectItem($nextGroup.find('.note-hint-item').first());\n\t      }\n\t    };\n\t\n\t    this.moveUp = function () {\n\t      var $current = this.$content.find('.note-hint-item.active');\n\t      var $prev = $current.prev();\n\t\n\t      if ($prev.length) {\n\t        this.selectItem($prev);\n\t      } else {\n\t        var $prevGroup = $current.parent().prev();\n\t\n\t        if (!$prevGroup.length) {\n\t          $prevGroup = this.$content.find('.note-hint-group').last();\n\t        }\n\t\n\t        this.selectItem($prevGroup.find('.note-hint-item').last());\n\t      }\n\t    };\n\t\n\t    this.replace = function () {\n\t      var $item = this.$content.find('.note-hint-item.active');\n\t\n\t      if ($item.length) {\n\t        var node = this.nodeFromItem($item);\n\t        this.lastWordRange.insertNode(node);\n\t        range.createFromNode(node).collapse().select();\n\t\n\t        this.lastWordRange = null;\n\t        this.hide();\n\t        context.invoke('editor.focus');\n\t      }\n\t\n\t    };\n\t\n\t    this.nodeFromItem = function ($item) {\n\t      var hint = hints[$item.data('index')];\n\t      var item = $item.data('item');\n\t      var node = hint.content ? hint.content(item) : item;\n\t      if (typeof node === 'string') {\n\t        node = dom.createText(node);\n\t      }\n\t      return node;\n\t    };\n\t\n\t    this.createItemTemplates = function (hintIdx, items) {\n\t      var hint = hints[hintIdx];\n\t      return items.map(function (item, idx) {\n\t        var $item = $('<div class=\"note-hint-item\"/>');\n\t        $item.append(hint.template ? hint.template(item) : item + '');\n\t        $item.data({\n\t          'index': hintIdx,\n\t          'item': item\n\t        });\n\t\n\t        if (hintIdx === 0 && idx === 0) {\n\t          $item.addClass('active');\n\t        }\n\t        return $item;\n\t      });\n\t    };\n\t\n\t    this.handleKeydown = function (e) {\n\t      if (!this.$popover.is(':visible')) {\n\t        return;\n\t      }\n\t\n\t      if (e.keyCode === key.code.ENTER) {\n\t        e.preventDefault();\n\t        this.replace();\n\t      } else if (e.keyCode === key.code.UP) {\n\t        e.preventDefault();\n\t        this.moveUp();\n\t      } else if (e.keyCode === key.code.DOWN) {\n\t        e.preventDefault();\n\t        this.moveDown();\n\t      }\n\t    };\n\t\n\t    this.searchKeyword = function (index, keyword, callback) {\n\t      var hint = hints[index];\n\t      if (hint && hint.match.test(keyword) && hint.search) {\n\t        var matches = hint.match.exec(keyword);\n\t        hint.search(matches[1], callback);\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t\n\t    this.createGroup = function (idx, keyword) {\n\t      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n\t      this.searchKeyword(idx, keyword, function (items) {\n\t        items = items || [];\n\t        if (items.length) {\n\t          $group.html(self.createItemTemplates(idx, items));\n\t          self.show();\n\t        }\n\t      });\n\t\n\t      return $group;\n\t    };\n\t\n\t    this.handleKeyup = function (e) {\n\t      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n\t        if (e.keyCode === key.code.ENTER) {\n\t          if (this.$popover.is(':visible')) {\n\t            return;\n\t          }\n\t        }\n\t      } else {\n\t        var wordRange = context.invoke('editor.createRange').getWordRange();\n\t        var keyword = wordRange.toString();\n\t        if (hints.length && keyword) {\n\t          this.$content.empty();\n\t\n\t          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n\t          if (bnd) {\n\t\n\t            this.$popover.hide();\n\t\n\t            this.lastWordRange = wordRange;\n\t\n\t            hints.forEach(function (hint, idx) {\n\t              if (hint.match.test(keyword)) {\n\t                self.createGroup(idx, keyword).appendTo(self.$content);\n\t              }\n\t            });\n\t\n\t            // set position for popover after group is created\n\t            if (direction === 'top') {\n\t              this.$popover.css({\n\t                left: bnd.left,\n\t                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n\t              });\n\t            } else {\n\t              this.$popover.css({\n\t                left: bnd.left,\n\t                top: bnd.top + bnd.height + POPOVER_DIST\n\t              });\n\t            }\n\t\n\t          }\n\t        } else {\n\t          this.hide();\n\t        }\n\t      }\n\t    };\n\t\n\t    this.show = function () {\n\t      this.$popover.show();\n\t    };\n\t\n\t    this.hide = function () {\n\t      this.$popover.hide();\n\t    };\n\t  };\n\t\n\t\n\t  $.summernote = $.extend($.summernote, {\n\t    version: '0.8.2',\n\t    ui: ui,\n\t    dom: dom,\n\t\n\t    plugins: {},\n\t\n\t    options: {\n\t      modules: {\n\t        'editor': Editor,\n\t        'clipboard': Clipboard,\n\t        'dropzone': Dropzone,\n\t        'codeview': Codeview,\n\t        'statusbar': Statusbar,\n\t        'fullscreen': Fullscreen,\n\t        'handle': Handle,\n\t        // FIXME: HintPopover must be front of autolink\n\t        //  - Script error about range when Enter key is pressed on hint popover\n\t        'hintPopover': HintPopover,\n\t        'autoLink': AutoLink,\n\t        'autoSync': AutoSync,\n\t        'placeholder': Placeholder,\n\t        'buttons': Buttons,\n\t        'toolbar': Toolbar,\n\t        'linkDialog': LinkDialog,\n\t        'linkPopover': LinkPopover,\n\t        'imageDialog': ImageDialog,\n\t        'imagePopover': ImagePopover,\n\t        'videoDialog': VideoDialog,\n\t        'helpDialog': HelpDialog,\n\t        'airPopover': AirPopover\n\t      },\n\t\n\t      buttons: {},\n\t      \n\t      lang: 'en-US',\n\t\n\t      // toolbar\n\t      toolbar: [\n\t        ['style', ['style']],\n\t        ['font', ['bold', 'underline', 'clear']],\n\t        ['fontname', ['fontname']],\n\t        ['color', ['color']],\n\t        ['para', ['ul', 'ol', 'paragraph']],\n\t        ['table', ['table']],\n\t        ['insert', ['link', 'picture', 'video']],\n\t        ['view', ['fullscreen', 'codeview', 'help']]\n\t      ],\n\t\n\t      // popover\n\t      popover: {\n\t        image: [\n\t          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n\t          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n\t          ['remove', ['removeMedia']]\n\t        ],\n\t        link: [\n\t          ['link', ['linkDialogShow', 'unlink']]\n\t        ],\n\t        air: [\n\t          ['color', ['color']],\n\t          ['font', ['bold', 'underline', 'clear']],\n\t          ['para', ['ul', 'paragraph']],\n\t          ['table', ['table']],\n\t          ['insert', ['link', 'picture']]\n\t        ]\n\t      },\n\t\n\t      // air mode: inline editor\n\t      airMode: false,\n\t\n\t      width: null,\n\t      height: null,\n\t\n\t      focus: false,\n\t      tabSize: 4,\n\t      styleWithSpan: true,\n\t      shortcuts: true,\n\t      textareaAutoSync: true,\n\t      direction: null,\n\t\n\t      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\t\n\t      fontNames: [\n\t        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n\t        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n\t        'Tahoma', 'Times New Roman', 'Verdana'\n\t      ],\n\t\n\t      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\t\n\t      // pallete colors(n x n)\n\t      colors: [\n\t        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n\t        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n\t        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n\t        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n\t        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n\t        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n\t        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n\t        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n\t      ],\n\t\n\t      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\t\n\t      tableClassName: 'table table-bordered',\n\t\n\t      insertTableMaxSize: {\n\t        col: 10,\n\t        row: 10\n\t      },\n\t\n\t      dialogsInBody: false,\n\t      dialogsFade: false,\n\t\n\t      maximumImageFileSize: null,\n\t\n\t      callbacks: {\n\t        onInit: null,\n\t        onFocus: null,\n\t        onBlur: null,\n\t        onEnter: null,\n\t        onKeyup: null,\n\t        onKeydown: null,\n\t        onImageUpload: null,\n\t        onImageUploadError: null\n\t      },\n\t\n\t      codemirror: {\n\t        mode: 'text/html',\n\t        htmlMode: true,\n\t        lineNumbers: true\n\t      },\n\t\n\t      keyMap: {\n\t        pc: {\n\t          'ENTER': 'insertParagraph',\n\t          'CTRL+Z': 'undo',\n\t          'CTRL+Y': 'redo',\n\t          'TAB': 'tab',\n\t          'SHIFT+TAB': 'untab',\n\t          'CTRL+B': 'bold',\n\t          'CTRL+I': 'italic',\n\t          'CTRL+U': 'underline',\n\t          'CTRL+SHIFT+S': 'strikethrough',\n\t          'CTRL+BACKSLASH': 'removeFormat',\n\t          'CTRL+SHIFT+L': 'justifyLeft',\n\t          'CTRL+SHIFT+E': 'justifyCenter',\n\t          'CTRL+SHIFT+R': 'justifyRight',\n\t          'CTRL+SHIFT+J': 'justifyFull',\n\t          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n\t          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n\t          'CTRL+LEFTBRACKET': 'outdent',\n\t          'CTRL+RIGHTBRACKET': 'indent',\n\t          'CTRL+NUM0': 'formatPara',\n\t          'CTRL+NUM1': 'formatH1',\n\t          'CTRL+NUM2': 'formatH2',\n\t          'CTRL+NUM3': 'formatH3',\n\t          'CTRL+NUM4': 'formatH4',\n\t          'CTRL+NUM5': 'formatH5',\n\t          'CTRL+NUM6': 'formatH6',\n\t          'CTRL+ENTER': 'insertHorizontalRule',\n\t          'CTRL+K': 'linkDialog.show'\n\t        },\n\t\n\t        mac: {\n\t          'ENTER': 'insertParagraph',\n\t          'CMD+Z': 'undo',\n\t          'CMD+SHIFT+Z': 'redo',\n\t          'TAB': 'tab',\n\t          'SHIFT+TAB': 'untab',\n\t          'CMD+B': 'bold',\n\t          'CMD+I': 'italic',\n\t          'CMD+U': 'underline',\n\t          'CMD+SHIFT+S': 'strikethrough',\n\t          'CMD+BACKSLASH': 'removeFormat',\n\t          'CMD+SHIFT+L': 'justifyLeft',\n\t          'CMD+SHIFT+E': 'justifyCenter',\n\t          'CMD+SHIFT+R': 'justifyRight',\n\t          'CMD+SHIFT+J': 'justifyFull',\n\t          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n\t          'CMD+SHIFT+NUM8': 'insertOrderedList',\n\t          'CMD+LEFTBRACKET': 'outdent',\n\t          'CMD+RIGHTBRACKET': 'indent',\n\t          'CMD+NUM0': 'formatPara',\n\t          'CMD+NUM1': 'formatH1',\n\t          'CMD+NUM2': 'formatH2',\n\t          'CMD+NUM3': 'formatH3',\n\t          'CMD+NUM4': 'formatH4',\n\t          'CMD+NUM5': 'formatH5',\n\t          'CMD+NUM6': 'formatH6',\n\t          'CMD+ENTER': 'insertHorizontalRule',\n\t          'CMD+K': 'linkDialog.show'\n\t        }\n\t      },\n\t      icons: {\n\t        'align': 'note-icon-align',\n\t        'alignCenter': 'note-icon-align-center',\n\t        'alignJustify': 'note-icon-align-justify',\n\t        'alignLeft': 'note-icon-align-left',\n\t        'alignRight': 'note-icon-align-right',\n\t        'indent': 'note-icon-align-indent',\n\t        'outdent': 'note-icon-align-outdent',\n\t        'arrowsAlt': 'note-icon-arrows-alt',\n\t        'bold': 'note-icon-bold',\n\t        'caret': 'note-icon-caret',\n\t        'circle': 'note-icon-circle',\n\t        'close': 'note-icon-close',\n\t        'code': 'note-icon-code',\n\t        'eraser': 'note-icon-eraser',\n\t        'font': 'note-icon-font',\n\t        'frame': 'note-icon-frame',\n\t        'italic': 'note-icon-italic',\n\t        'link': 'note-icon-link',\n\t        'unlink': 'note-icon-chain-broken',\n\t        'magic': 'note-icon-magic',\n\t        'menuCheck': 'note-icon-check',\n\t        'minus': 'note-icon-minus',\n\t        'orderedlist': 'note-icon-orderedlist',\n\t        'pencil': 'note-icon-pencil',\n\t        'picture': 'note-icon-picture',\n\t        'question': 'note-icon-question',\n\t        'redo': 'note-icon-redo',\n\t        'square': 'note-icon-square',\n\t        'strikethrough': 'note-icon-strikethrough',\n\t        'subscript': 'note-icon-subscript',\n\t        'superscript': 'note-icon-superscript',\n\t        'table': 'note-icon-table',\n\t        'textHeight': 'note-icon-text-height',\n\t        'trash': 'note-icon-trash',\n\t        'underline': 'note-icon-underline',\n\t        'undo': 'note-icon-undo',\n\t        'unorderedlist': 'note-icon-unorderedlist',\n\t        'video': 'note-icon-video'\n\t      }\n\t    }\n\t  });\n\t\n\t}));\n\n\n/***/ },\n\n/***/ 81:\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;\r\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, {}))\n\n/***/ },\n\n/***/ 82:\n/***/ function(module, exports, __webpack_require__) {\n\n\t// CodeMirror, copyright (c) by Marijn Haverbeke and others\n\t// Distributed under an MIT license: http://codemirror.net/LICENSE\n\t\n\t// This is CodeMirror (http://codemirror.net), a code editor\n\t// implemented in JavaScript on top of the browser's DOM.\n\t//\n\t// You can find some technical background for some of the code below\n\t// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\t\n\t(function(mod) {\n\t  if (true) // CommonJS\n\t    module.exports = mod();\n\t  else if (typeof define == \"function\" && define.amd) // AMD\n\t    return define([], mod);\n\t  else // Plain browser env\n\t    (this || window).CodeMirror = mod();\n\t})(function() {\n\t  \"use strict\";\n\t\n\t  // BROWSER SNIFFING\n\t\n\t  // Kludges for bugs and behavior differences that can't be feature\n\t  // detected are enabled based on userAgent etc sniffing.\n\t  var userAgent = navigator.userAgent;\n\t  var platform = navigator.platform;\n\t\n\t  var gecko = /gecko\\/\\d/i.test(userAgent);\n\t  var ie_upto10 = /MSIE \\d/.test(userAgent);\n\t  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n\t  var ie = ie_upto10 || ie_11up;\n\t  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n\t  var webkit = /WebKit\\//.test(userAgent);\n\t  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n\t  var chrome = /Chrome\\//.test(userAgent);\n\t  var presto = /Opera\\//.test(userAgent);\n\t  var safari = /Apple Computer/.test(navigator.vendor);\n\t  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n\t  var phantom = /PhantomJS/.test(userAgent);\n\t\n\t  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n\t  // This is woefully incomplete. Suggestions for alternative methods welcome.\n\t  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n\t  var mac = ios || /Mac/.test(platform);\n\t  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n\t  var windows = /win/i.test(platform);\n\t\n\t  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\t  if (presto_version) presto_version = Number(presto_version[1]);\n\t  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n\t  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\t  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n\t  var captureRightClick = gecko || (ie && ie_version >= 9);\n\t\n\t  // Optimize some code when these features are not used.\n\t  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\t\n\t  // EDITOR CONSTRUCTOR\n\t\n\t  // A CodeMirror instance represents an editor. This is the object\n\t  // that user code is usually dealing with.\n\t\n\t  function CodeMirror(place, options) {\n\t    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\t\n\t    this.options = options = options ? copyObj(options) : {};\n\t    // Determine effective options based on given values and defaults.\n\t    copyObj(defaults, options, false);\n\t    setGuttersForLineNumbers(options);\n\t\n\t    var doc = options.value;\n\t    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n\t    this.doc = doc;\n\t\n\t    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n\t    var display = this.display = new Display(place, doc, input);\n\t    display.wrapper.CodeMirror = this;\n\t    updateGutters(this);\n\t    themeChanged(this);\n\t    if (options.lineWrapping)\n\t      this.display.wrapper.className += \" CodeMirror-wrap\";\n\t    if (options.autofocus && !mobile) display.input.focus();\n\t    initScrollbars(this);\n\t\n\t    this.state = {\n\t      keyMaps: [],  // stores maps added by addKeyMap\n\t      overlays: [], // highlighting overlays, as added by addOverlay\n\t      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n\t      overwrite: false,\n\t      delayingBlurEvent: false,\n\t      focused: false,\n\t      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n\t      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n\t      selectingText: false,\n\t      draggingText: false,\n\t      highlight: new Delayed(), // stores highlight worker timeout\n\t      keySeq: null,  // Unfinished key sequence\n\t      specialChars: null\n\t    };\n\t\n\t    var cm = this;\n\t\n\t    // Override magic textarea content restore that IE sometimes does\n\t    // on our hidden textarea on reload\n\t    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\t\n\t    registerEventHandlers(this);\n\t    ensureGlobalHandlers();\n\t\n\t    startOperation(this);\n\t    this.curOp.forceUpdate = true;\n\t    attachDoc(this, doc);\n\t\n\t    if ((options.autofocus && !mobile) || cm.hasFocus())\n\t      setTimeout(bind(onFocus, this), 20);\n\t    else\n\t      onBlur(this);\n\t\n\t    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n\t      optionHandlers[opt](this, options[opt], Init);\n\t    maybeUpdateLineNumberWidth(this);\n\t    if (options.finishInit) options.finishInit(this);\n\t    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n\t    endOperation(this);\n\t    // Suppress optimizelegibility in Webkit, since it breaks text\n\t    // measuring on line wrapping boundaries.\n\t    if (webkit && options.lineWrapping &&\n\t        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n\t      display.lineDiv.style.textRendering = \"auto\";\n\t  }\n\t\n\t  // DISPLAY CONSTRUCTOR\n\t\n\t  // The display handles the DOM integration, both for input reading\n\t  // and content drawing. It holds references to DOM nodes and\n\t  // display-related state.\n\t\n\t  function Display(place, doc, input) {\n\t    var d = this;\n\t    this.input = input;\n\t\n\t    // Covers bottom-right square when both scrollbars are present.\n\t    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n\t    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n\t    // and h scrollbar is present.\n\t    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n\t    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n\t    // Will contain the actual code, positioned to cover the viewport.\n\t    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n\t    // Elements are added to these to represent selection and cursors.\n\t    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n\t    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n\t    // A visibility: hidden element used to find the size of things.\n\t    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // When lines outside of the viewport are measured, they are drawn in this.\n\t    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n\t    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\t    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n\t                      null, \"position: relative; outline: none\");\n\t    // Moved around its parent to cover visible view.\n\t    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n\t    // Set to the height of the document, allowing scrolling.\n\t    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n\t    d.sizerWidth = null;\n\t    // Behavior of elts with overflow: auto and padding is\n\t    // inconsistent across browsers. This is used to ensure the\n\t    // scrollable area is big enough.\n\t    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n\t    // Will contain the gutters, if any.\n\t    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n\t    d.lineGutter = null;\n\t    // Actual scrollable element.\n\t    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n\t    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n\t    // The element in which the editor lives.\n\t    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\t\n\t    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n\t    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n\t    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\t\n\t    if (place) {\n\t      if (place.appendChild) place.appendChild(d.wrapper);\n\t      else place(d.wrapper);\n\t    }\n\t\n\t    // Current rendered range (may be bigger than the view window).\n\t    d.viewFrom = d.viewTo = doc.first;\n\t    d.reportedViewFrom = d.reportedViewTo = doc.first;\n\t    // Information about the rendered lines.\n\t    d.view = [];\n\t    d.renderedView = null;\n\t    // Holds info about a single rendered line when it was rendered\n\t    // for measurement, while not in view.\n\t    d.externalMeasured = null;\n\t    // Empty space (in pixels) above the view\n\t    d.viewOffset = 0;\n\t    d.lastWrapHeight = d.lastWrapWidth = 0;\n\t    d.updateLineNumbers = null;\n\t\n\t    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n\t    d.scrollbarsClipped = false;\n\t\n\t    // Used to only resize the line number gutter when necessary (when\n\t    // the amount of lines crosses a boundary that makes its width change)\n\t    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n\t    // Set to true when a non-horizontal-scrolling line widget is\n\t    // added. As an optimization, line widget aligning is skipped when\n\t    // this is false.\n\t    d.alignWidgets = false;\n\t\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t\n\t    // Tracks the maximum line length so that the horizontal scrollbar\n\t    // can be kept static when scrolling.\n\t    d.maxLine = null;\n\t    d.maxLineLength = 0;\n\t    d.maxLineChanged = false;\n\t\n\t    // Used for measuring wheel scrolling granularity\n\t    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\t\n\t    // True when shift is held down.\n\t    d.shift = false;\n\t\n\t    // Used to track whether anything happened since the context menu\n\t    // was opened.\n\t    d.selForContextMenu = null;\n\t\n\t    d.activeTouch = null;\n\t\n\t    input.init(d);\n\t  }\n\t\n\t  // STATE UPDATES\n\t\n\t  // Used to get the editor into a consistent state again when options change.\n\t\n\t  function loadMode(cm) {\n\t    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n\t    resetModeState(cm);\n\t  }\n\t\n\t  function resetModeState(cm) {\n\t    cm.doc.iter(function(line) {\n\t      if (line.stateAfter) line.stateAfter = null;\n\t      if (line.styles) line.styles = null;\n\t    });\n\t    cm.doc.frontier = cm.doc.first;\n\t    startWorker(cm, 100);\n\t    cm.state.modeGen++;\n\t    if (cm.curOp) regChange(cm);\n\t  }\n\t\n\t  function wrappingChanged(cm) {\n\t    if (cm.options.lineWrapping) {\n\t      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      cm.display.sizer.style.minWidth = \"\";\n\t      cm.display.sizerWidth = null;\n\t    } else {\n\t      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n\t      findMaxLine(cm);\n\t    }\n\t    estimateLineHeights(cm);\n\t    regChange(cm);\n\t    clearCaches(cm);\n\t    setTimeout(function(){updateScrollbars(cm);}, 100);\n\t  }\n\t\n\t  // Returns a function that estimates the height of a line, to use as\n\t  // first approximation until the line becomes visible (and is thus\n\t  // properly measurable).\n\t  function estimateHeight(cm) {\n\t    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n\t    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n\t    return function(line) {\n\t      if (lineIsHidden(cm.doc, line)) return 0;\n\t\n\t      var widgetsHeight = 0;\n\t      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n\t        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n\t      }\n\t\n\t      if (wrapping)\n\t        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n\t      else\n\t        return widgetsHeight + th;\n\t    };\n\t  }\n\t\n\t  function estimateLineHeights(cm) {\n\t    var doc = cm.doc, est = estimateHeight(cm);\n\t    doc.iter(function(line) {\n\t      var estHeight = est(line);\n\t      if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t    });\n\t  }\n\t\n\t  function themeChanged(cm) {\n\t    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n\t      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n\t    clearCaches(cm);\n\t  }\n\t\n\t  function guttersChanged(cm) {\n\t    updateGutters(cm);\n\t    regChange(cm);\n\t    setTimeout(function(){alignHorizontally(cm);}, 20);\n\t  }\n\t\n\t  // Rebuild the gutter elements, ensure the margin to the left of the\n\t  // code matches their width.\n\t  function updateGutters(cm) {\n\t    var gutters = cm.display.gutters, specs = cm.options.gutters;\n\t    removeChildren(gutters);\n\t    for (var i = 0; i < specs.length; ++i) {\n\t      var gutterClass = specs[i];\n\t      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n\t      if (gutterClass == \"CodeMirror-linenumbers\") {\n\t        cm.display.lineGutter = gElt;\n\t        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n\t      }\n\t    }\n\t    gutters.style.display = i ? \"\" : \"none\";\n\t    updateGutterSpace(cm);\n\t  }\n\t\n\t  function updateGutterSpace(cm) {\n\t    var width = cm.display.gutters.offsetWidth;\n\t    cm.display.sizer.style.marginLeft = width + \"px\";\n\t  }\n\t\n\t  // Compute the character length of a line, taking into account\n\t  // collapsed ranges (see markText) that might hide parts, and join\n\t  // other lines onto it.\n\t  function lineLength(line) {\n\t    if (line.height == 0) return 0;\n\t    var len = line.text.length, merged, cur = line;\n\t    while (merged = collapsedSpanAtStart(cur)) {\n\t      var found = merged.find(0, true);\n\t      cur = found.from.line;\n\t      len += found.from.ch - found.to.ch;\n\t    }\n\t    cur = line;\n\t    while (merged = collapsedSpanAtEnd(cur)) {\n\t      var found = merged.find(0, true);\n\t      len -= cur.text.length - found.from.ch;\n\t      cur = found.to.line;\n\t      len += cur.text.length - found.to.ch;\n\t    }\n\t    return len;\n\t  }\n\t\n\t  // Find the longest line in the document.\n\t  function findMaxLine(cm) {\n\t    var d = cm.display, doc = cm.doc;\n\t    d.maxLine = getLine(doc, doc.first);\n\t    d.maxLineLength = lineLength(d.maxLine);\n\t    d.maxLineChanged = true;\n\t    doc.iter(function(line) {\n\t      var len = lineLength(line);\n\t      if (len > d.maxLineLength) {\n\t        d.maxLineLength = len;\n\t        d.maxLine = line;\n\t      }\n\t    });\n\t  }\n\t\n\t  // Make sure the gutters options contains the element\n\t  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n\t  function setGuttersForLineNumbers(options) {\n\t    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n\t    if (found == -1 && options.lineNumbers) {\n\t      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n\t    } else if (found > -1 && !options.lineNumbers) {\n\t      options.gutters = options.gutters.slice(0);\n\t      options.gutters.splice(found, 1);\n\t    }\n\t  }\n\t\n\t  // SCROLLBARS\n\t\n\t  // Prepare DOM reads needed to update the scrollbars. Done in one\n\t  // shot to minimize update/measure roundtrips.\n\t  function measureForScrollbars(cm) {\n\t    var d = cm.display, gutterW = d.gutters.offsetWidth;\n\t    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n\t    return {\n\t      clientHeight: d.scroller.clientHeight,\n\t      viewHeight: d.wrapper.clientHeight,\n\t      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n\t      viewWidth: d.wrapper.clientWidth,\n\t      barLeft: cm.options.fixedGutter ? gutterW : 0,\n\t      docHeight: docH,\n\t      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n\t      nativeBarWidth: d.nativeBarWidth,\n\t      gutterWidth: gutterW\n\t    };\n\t  }\n\t\n\t  function NativeScrollbars(place, scroll, cm) {\n\t    this.cm = cm;\n\t    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n\t    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n\t    place(vert); place(horiz);\n\t\n\t    on(vert, \"scroll\", function() {\n\t      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n\t    });\n\t    on(horiz, \"scroll\", function() {\n\t      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n\t    });\n\t\n\t    this.checkedZeroWidth = false;\n\t    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\t    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n\t  }\n\t\n\t  NativeScrollbars.prototype = copyObj({\n\t    update: function(measure) {\n\t      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n\t      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n\t      var sWidth = measure.nativeBarWidth;\n\t\n\t      if (needsV) {\n\t        this.vert.style.display = \"block\";\n\t        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n\t        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n\t        // A bug in IE8 can cause this value to be negative, so guard it.\n\t        this.vert.firstChild.style.height =\n\t          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n\t      } else {\n\t        this.vert.style.display = \"\";\n\t        this.vert.firstChild.style.height = \"0\";\n\t      }\n\t\n\t      if (needsH) {\n\t        this.horiz.style.display = \"block\";\n\t        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n\t        this.horiz.style.left = measure.barLeft + \"px\";\n\t        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n\t        this.horiz.firstChild.style.width =\n\t          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n\t      } else {\n\t        this.horiz.style.display = \"\";\n\t        this.horiz.firstChild.style.width = \"0\";\n\t      }\n\t\n\t      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n\t        if (sWidth == 0) this.zeroWidthHack();\n\t        this.checkedZeroWidth = true;\n\t      }\n\t\n\t      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n\t    },\n\t    setScrollLeft: function(pos) {\n\t      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n\t      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n\t    },\n\t    setScrollTop: function(pos) {\n\t      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n\t      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n\t    },\n\t    zeroWidthHack: function() {\n\t      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n\t      this.horiz.style.height = this.vert.style.width = w;\n\t      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n\t      this.disableHoriz = new Delayed;\n\t      this.disableVert = new Delayed;\n\t    },\n\t    enableZeroWidthBar: function(bar, delay) {\n\t      bar.style.pointerEvents = \"auto\";\n\t      function maybeDisable() {\n\t        // To find out whether the scrollbar is still visible, we\n\t        // check whether the element under the pixel in the bottom\n\t        // left corner of the scrollbar box is the scrollbar box\n\t        // itself (when the bar is still visible) or its filler child\n\t        // (when the bar is hidden). If it is still visible, we keep\n\t        // it enabled, if it's hidden, we disable pointer events.\n\t        var box = bar.getBoundingClientRect();\n\t        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n\t        if (elt != bar) bar.style.pointerEvents = \"none\";\n\t        else delay.set(1000, maybeDisable);\n\t      }\n\t      delay.set(1000, maybeDisable);\n\t    },\n\t    clear: function() {\n\t      var parent = this.horiz.parentNode;\n\t      parent.removeChild(this.horiz);\n\t      parent.removeChild(this.vert);\n\t    }\n\t  }, NativeScrollbars.prototype);\n\t\n\t  function NullScrollbars() {}\n\t\n\t  NullScrollbars.prototype = copyObj({\n\t    update: function() { return {bottom: 0, right: 0}; },\n\t    setScrollLeft: function() {},\n\t    setScrollTop: function() {},\n\t    clear: function() {}\n\t  }, NullScrollbars.prototype);\n\t\n\t  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\t\n\t  function initScrollbars(cm) {\n\t    if (cm.display.scrollbars) {\n\t      cm.display.scrollbars.clear();\n\t      if (cm.display.scrollbars.addClass)\n\t        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t    }\n\t\n\t    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n\t      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n\t      // Prevent clicks in the scrollbars from killing focus\n\t      on(node, \"mousedown\", function() {\n\t        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n\t      });\n\t      node.setAttribute(\"cm-not-content\", \"true\");\n\t    }, function(pos, axis) {\n\t      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n\t      else setScrollTop(cm, pos);\n\t    }, cm);\n\t    if (cm.display.scrollbars.addClass)\n\t      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n\t  }\n\t\n\t  function updateScrollbars(cm, measure) {\n\t    if (!measure) measure = measureForScrollbars(cm);\n\t    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n\t    updateScrollbarsInner(cm, measure);\n\t    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n\t      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n\t        updateHeightsInViewport(cm);\n\t      updateScrollbarsInner(cm, measureForScrollbars(cm));\n\t      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n\t    }\n\t  }\n\t\n\t  // Re-synchronize the fake scrollbars with the actual size of the\n\t  // content.\n\t  function updateScrollbarsInner(cm, measure) {\n\t    var d = cm.display;\n\t    var sizes = d.scrollbars.update(measure);\n\t\n\t    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n\t    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n\t    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\"\n\t\n\t    if (sizes.right && sizes.bottom) {\n\t      d.scrollbarFiller.style.display = \"block\";\n\t      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n\t      d.scrollbarFiller.style.width = sizes.right + \"px\";\n\t    } else d.scrollbarFiller.style.display = \"\";\n\t    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n\t      d.gutterFiller.style.display = \"block\";\n\t      d.gutterFiller.style.height = sizes.bottom + \"px\";\n\t      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n\t    } else d.gutterFiller.style.display = \"\";\n\t  }\n\t\n\t  // Compute the lines that are visible in a given viewport (defaults\n\t  // the the current scroll position). viewport may contain top,\n\t  // height, and ensure (see op.scrollToPos) properties.\n\t  function visibleLines(display, doc, viewport) {\n\t    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n\t    top = Math.floor(top - paddingTop(display));\n\t    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\t\n\t    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n\t    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n\t    // forces those lines into the viewport (if possible).\n\t    if (viewport && viewport.ensure) {\n\t      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n\t      if (ensureFrom < from) {\n\t        from = ensureFrom;\n\t        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n\t      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n\t        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n\t        to = ensureTo;\n\t      }\n\t    }\n\t    return {from: from, to: Math.max(to, from + 1)};\n\t  }\n\t\n\t  // LINE NUMBERS\n\t\n\t  // Re-align line numbers and gutter marks to compensate for\n\t  // horizontal scrolling.\n\t  function alignHorizontally(cm) {\n\t    var display = cm.display, view = display.view;\n\t    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n\t    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n\t    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n\t    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n\t      if (cm.options.fixedGutter) {\n\t        if (view[i].gutter)\n\t          view[i].gutter.style.left = left;\n\t        if (view[i].gutterBackground)\n\t          view[i].gutterBackground.style.left = left;\n\t      }\n\t      var align = view[i].alignable;\n\t      if (align) for (var j = 0; j < align.length; j++)\n\t        align[j].style.left = left;\n\t    }\n\t    if (cm.options.fixedGutter)\n\t      display.gutters.style.left = (comp + gutterW) + \"px\";\n\t  }\n\t\n\t  // Used to ensure that the line number gutter is still the right\n\t  // size for the current document size. Returns true when an update\n\t  // is needed.\n\t  function maybeUpdateLineNumberWidth(cm) {\n\t    if (!cm.options.lineNumbers) return false;\n\t    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n\t    if (last.length != display.lineNumChars) {\n\t      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n\t                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n\t      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n\t      display.lineGutter.style.width = \"\";\n\t      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n\t      display.lineNumWidth = display.lineNumInnerWidth + padding;\n\t      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n\t      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n\t      updateGutterSpace(cm);\n\t      return true;\n\t    }\n\t    return false;\n\t  }\n\t\n\t  function lineNumberFor(options, i) {\n\t    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n\t  }\n\t\n\t  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n\t  // but using getBoundingClientRect to get a sub-pixel-accurate\n\t  // result.\n\t  function compensateForHScroll(display) {\n\t    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n\t  }\n\t\n\t  // DISPLAY DRAWING\n\t\n\t  function DisplayUpdate(cm, viewport, force) {\n\t    var display = cm.display;\n\t\n\t    this.viewport = viewport;\n\t    // Store some values that we'll need later (but don't want to force a relayout for)\n\t    this.visible = visibleLines(display, cm.doc, viewport);\n\t    this.editorIsHidden = !display.wrapper.offsetWidth;\n\t    this.wrapperHeight = display.wrapper.clientHeight;\n\t    this.wrapperWidth = display.wrapper.clientWidth;\n\t    this.oldDisplayWidth = displayWidth(cm);\n\t    this.force = force;\n\t    this.dims = getDimensions(cm);\n\t    this.events = [];\n\t  }\n\t\n\t  DisplayUpdate.prototype.signal = function(emitter, type) {\n\t    if (hasHandler(emitter, type))\n\t      this.events.push(arguments);\n\t  };\n\t  DisplayUpdate.prototype.finish = function() {\n\t    for (var i = 0; i < this.events.length; i++)\n\t      signal.apply(null, this.events[i]);\n\t  };\n\t\n\t  function maybeClipScrollbars(cm) {\n\t    var display = cm.display;\n\t    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n\t      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n\t      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n\t      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n\t      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n\t      display.scrollbarsClipped = true;\n\t    }\n\t  }\n\t\n\t  // Does the actual updating of the line display. Bails out\n\t  // (returning false) when there is nothing to be done and forced is\n\t  // false.\n\t  function updateDisplayIfNeeded(cm, update) {\n\t    var display = cm.display, doc = cm.doc;\n\t\n\t    if (update.editorIsHidden) {\n\t      resetView(cm);\n\t      return false;\n\t    }\n\t\n\t    // Bail out if the visible area is already rendered and nothing changed.\n\t    if (!update.force &&\n\t        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n\t        display.renderedView == display.view && countDirtyView(cm) == 0)\n\t      return false;\n\t\n\t    if (maybeUpdateLineNumberWidth(cm)) {\n\t      resetView(cm);\n\t      update.dims = getDimensions(cm);\n\t    }\n\t\n\t    // Compute a suitable new viewport (from & to)\n\t    var end = doc.first + doc.size;\n\t    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n\t    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n\t    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n\t    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n\t    if (sawCollapsedSpans) {\n\t      from = visualLineNo(cm.doc, from);\n\t      to = visualLineEndNo(cm.doc, to);\n\t    }\n\t\n\t    var different = from != display.viewFrom || to != display.viewTo ||\n\t      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n\t    adjustView(cm, from, to);\n\t\n\t    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n\t    // Position the mover div to align with the current scroll position\n\t    cm.display.mover.style.top = display.viewOffset + \"px\";\n\t\n\t    var toUpdate = countDirtyView(cm);\n\t    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n\t      return false;\n\t\n\t    // For big changes, we hide the enclosing element during the\n\t    // update, since that speeds up the operations on most browsers.\n\t    var focused = activeElt();\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n\t    patchDisplay(cm, display.updateLineNumbers, update.dims);\n\t    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n\t    display.renderedView = display.view;\n\t    // There might have been a widget with a focused element that got\n\t    // hidden or updated, if so re-focus it.\n\t    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\t\n\t    // Prevent selection and cursors from interfering with the scroll\n\t    // width and height.\n\t    removeChildren(display.cursorDiv);\n\t    removeChildren(display.selectionDiv);\n\t    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\t\n\t    if (different) {\n\t      display.lastWrapHeight = update.wrapperHeight;\n\t      display.lastWrapWidth = update.wrapperWidth;\n\t      startWorker(cm, 400);\n\t    }\n\t\n\t    display.updateLineNumbers = null;\n\t\n\t    return true;\n\t  }\n\t\n\t  function postUpdateDisplay(cm, update) {\n\t    var viewport = update.viewport;\n\t\n\t    for (var first = true;; first = false) {\n\t      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n\t        // Clip forced viewport to actual scrollable area.\n\t        if (viewport && viewport.top != null)\n\t          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n\t        // Updated line heights might result in the drawn area not\n\t        // actually covering the viewport. Keep looping until it does.\n\t        update.visible = visibleLines(cm.display, cm.doc, viewport);\n\t        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n\t          break;\n\t      }\n\t      if (!updateDisplayIfNeeded(cm, update)) break;\n\t      updateHeightsInViewport(cm);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      updateScrollbars(cm, barMeasure);\n\t      setDocumentHeight(cm, barMeasure);\n\t    }\n\t\n\t    update.signal(cm, \"update\", cm);\n\t    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n\t      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n\t      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n\t    }\n\t  }\n\t\n\t  function updateDisplaySimple(cm, viewport) {\n\t    var update = new DisplayUpdate(cm, viewport);\n\t    if (updateDisplayIfNeeded(cm, update)) {\n\t      updateHeightsInViewport(cm);\n\t      postUpdateDisplay(cm, update);\n\t      var barMeasure = measureForScrollbars(cm);\n\t      updateSelection(cm);\n\t      updateScrollbars(cm, barMeasure);\n\t      setDocumentHeight(cm, barMeasure);\n\t      update.finish();\n\t    }\n\t  }\n\t\n\t  function setDocumentHeight(cm, measure) {\n\t    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n\t    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n\t    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n\t  }\n\t\n\t  // Read the actual heights of the rendered lines, and update their\n\t  // stored heights to match.\n\t  function updateHeightsInViewport(cm) {\n\t    var display = cm.display;\n\t    var prevBottom = display.lineDiv.offsetTop;\n\t    for (var i = 0; i < display.view.length; i++) {\n\t      var cur = display.view[i], height;\n\t      if (cur.hidden) continue;\n\t      if (ie && ie_version < 8) {\n\t        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n\t        height = bot - prevBottom;\n\t        prevBottom = bot;\n\t      } else {\n\t        var box = cur.node.getBoundingClientRect();\n\t        height = box.bottom - box.top;\n\t      }\n\t      var diff = cur.line.height - height;\n\t      if (height < 2) height = textHeight(display);\n\t      if (diff > .001 || diff < -.001) {\n\t        updateLineHeight(cur.line, height);\n\t        updateWidgetHeight(cur.line);\n\t        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n\t          updateWidgetHeight(cur.rest[j]);\n\t      }\n\t    }\n\t  }\n\t\n\t  // Read and store the height of line widgets associated with the\n\t  // given line.\n\t  function updateWidgetHeight(line) {\n\t    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n\t      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;\n\t  }\n\t\n\t  // Do a bulk-read of the DOM positions and sizes needed to draw the\n\t  // view, so that we don't interleave reading and writing to the DOM.\n\t  function getDimensions(cm) {\n\t    var d = cm.display, left = {}, width = {};\n\t    var gutterLeft = d.gutters.clientLeft;\n\t    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n\t      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n\t      width[cm.options.gutters[i]] = n.clientWidth;\n\t    }\n\t    return {fixedPos: compensateForHScroll(d),\n\t            gutterTotalWidth: d.gutters.offsetWidth,\n\t            gutterLeft: left,\n\t            gutterWidth: width,\n\t            wrapperWidth: d.wrapper.clientWidth};\n\t  }\n\t\n\t  // Sync the actual display DOM structure with display.view, removing\n\t  // nodes for lines that are no longer in view, and creating the ones\n\t  // that are not there yet, and updating the ones that are out of\n\t  // date.\n\t  function patchDisplay(cm, updateNumbersFrom, dims) {\n\t    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n\t    var container = display.lineDiv, cur = container.firstChild;\n\t\n\t    function rm(node) {\n\t      var next = node.nextSibling;\n\t      // Works around a throw-scroll bug in OS X Webkit\n\t      if (webkit && mac && cm.display.currentWheelTarget == node)\n\t        node.style.display = \"none\";\n\t      else\n\t        node.parentNode.removeChild(node);\n\t      return next;\n\t    }\n\t\n\t    var view = display.view, lineN = display.viewFrom;\n\t    // Loop over the elements in the view, syncing cur (the DOM nodes\n\t    // in display.lineDiv) with the view as we go.\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (lineView.hidden) {\n\t      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n\t        var node = buildLineElement(cm, lineView, lineN, dims);\n\t        container.insertBefore(node, cur);\n\t      } else { // Already drawn\n\t        while (cur != lineView.node) cur = rm(cur);\n\t        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n\t          updateNumbersFrom <= lineN && lineView.lineNumber;\n\t        if (lineView.changes) {\n\t          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n\t          updateLineForChanges(cm, lineView, lineN, dims);\n\t        }\n\t        if (updateNumber) {\n\t          removeChildren(lineView.lineNumber);\n\t          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n\t        }\n\t        cur = lineView.node.nextSibling;\n\t      }\n\t      lineN += lineView.size;\n\t    }\n\t    while (cur) cur = rm(cur);\n\t  }\n\t\n\t  // When an aspect of a line changes, a string is added to\n\t  // lineView.changes. This updates the relevant part of the line's\n\t  // DOM structure.\n\t  function updateLineForChanges(cm, lineView, lineN, dims) {\n\t    for (var j = 0; j < lineView.changes.length; j++) {\n\t      var type = lineView.changes[j];\n\t      if (type == \"text\") updateLineText(cm, lineView);\n\t      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n\t      else if (type == \"class\") updateLineClasses(lineView);\n\t      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n\t    }\n\t    lineView.changes = null;\n\t  }\n\t\n\t  // Lines with gutter elements, widgets or a background class need to\n\t  // be wrapped, and have the extra elements added to the wrapper div\n\t  function ensureLineWrapped(lineView) {\n\t    if (lineView.node == lineView.text) {\n\t      lineView.node = elt(\"div\", null, null, \"position: relative\");\n\t      if (lineView.text.parentNode)\n\t        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n\t      lineView.node.appendChild(lineView.text);\n\t      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n\t    }\n\t    return lineView.node;\n\t  }\n\t\n\t  function updateLineBackground(lineView) {\n\t    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n\t    if (cls) cls += \" CodeMirror-linebackground\";\n\t    if (lineView.background) {\n\t      if (cls) lineView.background.className = cls;\n\t      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n\t    } else if (cls) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n\t    }\n\t  }\n\t\n\t  // Wrapper around buildLineContent which will reuse the structure\n\t  // in display.externalMeasured when possible.\n\t  function getLineContent(cm, lineView) {\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && ext.line == lineView.line) {\n\t      cm.display.externalMeasured = null;\n\t      lineView.measure = ext.measure;\n\t      return ext.built;\n\t    }\n\t    return buildLineContent(cm, lineView);\n\t  }\n\t\n\t  // Redraw the line's text. Interacts with the background and text\n\t  // classes because the mode may output tokens that influence these\n\t  // classes.\n\t  function updateLineText(cm, lineView) {\n\t    var cls = lineView.text.className;\n\t    var built = getLineContent(cm, lineView);\n\t    if (lineView.text == lineView.node) lineView.node = built.pre;\n\t    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n\t    lineView.text = built.pre;\n\t    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n\t      lineView.bgClass = built.bgClass;\n\t      lineView.textClass = built.textClass;\n\t      updateLineClasses(lineView);\n\t    } else if (cls) {\n\t      lineView.text.className = cls;\n\t    }\n\t  }\n\t\n\t  function updateLineClasses(lineView) {\n\t    updateLineBackground(lineView);\n\t    if (lineView.line.wrapClass)\n\t      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n\t    else if (lineView.node != lineView.text)\n\t      lineView.node.className = \"\";\n\t    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n\t    lineView.text.className = textClass || \"\";\n\t  }\n\t\n\t  function updateLineGutter(cm, lineView, lineN, dims) {\n\t    if (lineView.gutter) {\n\t      lineView.node.removeChild(lineView.gutter);\n\t      lineView.gutter = null;\n\t    }\n\t    if (lineView.gutterBackground) {\n\t      lineView.node.removeChild(lineView.gutterBackground);\n\t      lineView.gutterBackground = null;\n\t    }\n\t    if (lineView.line.gutterClass) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n\t                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n\t                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n\t      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n\t    }\n\t    var markers = lineView.line.gutterMarkers;\n\t    if (cm.options.lineNumbers || markers) {\n\t      var wrap = ensureLineWrapped(lineView);\n\t      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n\t                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n\t      cm.display.input.setUneditable(gutterWrap);\n\t      wrap.insertBefore(gutterWrap, lineView.text);\n\t      if (lineView.line.gutterClass)\n\t        gutterWrap.className += \" \" + lineView.line.gutterClass;\n\t      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n\t        lineView.lineNumber = gutterWrap.appendChild(\n\t          elt(\"div\", lineNumberFor(cm.options, lineN),\n\t              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n\t              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n\t              + cm.display.lineNumInnerWidth + \"px\"));\n\t      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n\t        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n\t        if (found)\n\t          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n\t                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n\t      }\n\t    }\n\t  }\n\t\n\t  function updateLineWidgets(cm, lineView, dims) {\n\t    if (lineView.alignable) lineView.alignable = null;\n\t    for (var node = lineView.node.firstChild, next; node; node = next) {\n\t      var next = node.nextSibling;\n\t      if (node.className == \"CodeMirror-linewidget\")\n\t        lineView.node.removeChild(node);\n\t    }\n\t    insertLineWidgets(cm, lineView, dims);\n\t  }\n\t\n\t  // Build a line's DOM representation from scratch\n\t  function buildLineElement(cm, lineView, lineN, dims) {\n\t    var built = getLineContent(cm, lineView);\n\t    lineView.text = lineView.node = built.pre;\n\t    if (built.bgClass) lineView.bgClass = built.bgClass;\n\t    if (built.textClass) lineView.textClass = built.textClass;\n\t\n\t    updateLineClasses(lineView);\n\t    updateLineGutter(cm, lineView, lineN, dims);\n\t    insertLineWidgets(cm, lineView, dims);\n\t    return lineView.node;\n\t  }\n\t\n\t  // A lineView may contain multiple logical lines (when merged by\n\t  // collapsed spans). The widgets for all of them need to be drawn.\n\t  function insertLineWidgets(cm, lineView, dims) {\n\t    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n\t    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n\t  }\n\t\n\t  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n\t    if (!line.widgets) return;\n\t    var wrap = ensureLineWrapped(lineView);\n\t    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n\t      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n\t      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      positionLineWidget(widget, node, lineView, dims);\n\t      cm.display.input.setUneditable(node);\n\t      if (allowAbove && widget.above)\n\t        wrap.insertBefore(node, lineView.gutter || lineView.text);\n\t      else\n\t        wrap.appendChild(node);\n\t      signalLater(widget, \"redraw\");\n\t    }\n\t  }\n\t\n\t  function positionLineWidget(widget, node, lineView, dims) {\n\t    if (widget.noHScroll) {\n\t      (lineView.alignable || (lineView.alignable = [])).push(node);\n\t      var width = dims.wrapperWidth;\n\t      node.style.left = dims.fixedPos + \"px\";\n\t      if (!widget.coverGutter) {\n\t        width -= dims.gutterTotalWidth;\n\t        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n\t      }\n\t      node.style.width = width + \"px\";\n\t    }\n\t    if (widget.coverGutter) {\n\t      node.style.zIndex = 5;\n\t      node.style.position = \"relative\";\n\t      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n\t    }\n\t  }\n\t\n\t  // POSITION OBJECT\n\t\n\t  // A Pos instance represents a position within the text.\n\t  var Pos = CodeMirror.Pos = function(line, ch) {\n\t    if (!(this instanceof Pos)) return new Pos(line, ch);\n\t    this.line = line; this.ch = ch;\n\t  };\n\t\n\t  // Compare two positions, return 0 if they are the same, a negative\n\t  // number when a is less, and a positive number otherwise.\n\t  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\t\n\t  function copyPos(x) {return Pos(x.line, x.ch);}\n\t  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n\t  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\t\n\t  // INPUT HANDLING\n\t\n\t  function ensureFocus(cm) {\n\t    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n\t  }\n\t\n\t  // This will be set to a {lineWise: bool, text: [string]} object, so\n\t  // that, when pasting, we know what kind of selections the copied\n\t  // text was made out of.\n\t  var lastCopied = null;\n\t\n\t  function applyTextInput(cm, inserted, deleted, sel, origin) {\n\t    var doc = cm.doc;\n\t    cm.display.shift = false;\n\t    if (!sel) sel = doc.sel;\n\t\n\t    var paste = cm.state.pasteIncoming || origin == \"paste\";\n\t    var textLines = doc.splitLines(inserted), multiPaste = null\n\t    // When pasing N lines into N selections, insert one line per selection\n\t    if (paste && sel.ranges.length > 1) {\n\t      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n\t        if (sel.ranges.length % lastCopied.text.length == 0) {\n\t          multiPaste = [];\n\t          for (var i = 0; i < lastCopied.text.length; i++)\n\t            multiPaste.push(doc.splitLines(lastCopied.text[i]));\n\t        }\n\t      } else if (textLines.length == sel.ranges.length) {\n\t        multiPaste = map(textLines, function(l) { return [l]; });\n\t      }\n\t    }\n\t\n\t    // Normal behavior is to insert the new text into every selection\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      var from = range.from(), to = range.to();\n\t      if (range.empty()) {\n\t        if (deleted && deleted > 0) // Handle deletion\n\t          from = Pos(from.line, from.ch - deleted);\n\t        else if (cm.state.overwrite && !paste) // Handle overwrite\n\t          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n\t        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n\t          from = to = Pos(from.line, 0)\n\t      }\n\t      var updateInput = cm.curOp.updateInput;\n\t      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n\t                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n\t      makeChange(cm.doc, changeEvent);\n\t      signalLater(cm, \"inputRead\", cm, changeEvent);\n\t    }\n\t    if (inserted && !paste)\n\t      triggerElectric(cm, inserted);\n\t\n\t    ensureCursorVisible(cm);\n\t    cm.curOp.updateInput = updateInput;\n\t    cm.curOp.typing = true;\n\t    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n\t  }\n\t\n\t  function handlePaste(e, cm) {\n\t    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n\t    if (pasted) {\n\t      e.preventDefault();\n\t      if (!cm.isReadOnly() && !cm.options.disableInput)\n\t        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n\t      return true;\n\t    }\n\t  }\n\t\n\t  function triggerElectric(cm, inserted) {\n\t    // When an 'electric' character is inserted, immediately trigger a reindent\n\t    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n\t    var sel = cm.doc.sel;\n\t\n\t    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n\t      var range = sel.ranges[i];\n\t      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n\t      var mode = cm.getModeAt(range.head);\n\t      var indented = false;\n\t      if (mode.electricChars) {\n\t        for (var j = 0; j < mode.electricChars.length; j++)\n\t          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n\t            indented = indentLine(cm, range.head.line, \"smart\");\n\t            break;\n\t          }\n\t      } else if (mode.electricInput) {\n\t        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n\t          indented = indentLine(cm, range.head.line, \"smart\");\n\t      }\n\t      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n\t    }\n\t  }\n\t\n\t  function copyableRanges(cm) {\n\t    var text = [], ranges = [];\n\t    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n\t      var line = cm.doc.sel.ranges[i].head.line;\n\t      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n\t      ranges.push(lineRange);\n\t      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n\t    }\n\t    return {text: text, ranges: ranges};\n\t  }\n\t\n\t  function disableBrowserMagic(field, spellcheck) {\n\t    field.setAttribute(\"autocorrect\", \"off\");\n\t    field.setAttribute(\"autocapitalize\", \"off\");\n\t    field.setAttribute(\"spellcheck\", !!spellcheck);\n\t  }\n\t\n\t  // TEXTAREA INPUT STYLE\n\t\n\t  function TextareaInput(cm) {\n\t    this.cm = cm;\n\t    // See input.poll and input.reset\n\t    this.prevInput = \"\";\n\t\n\t    // Flag that indicates whether we expect input to appear real soon\n\t    // now (after some event like 'keypress' or 'input') and are\n\t    // polling intensively.\n\t    this.pollingFast = false;\n\t    // Self-resetting timeout for the poller\n\t    this.polling = new Delayed();\n\t    // Tracks when input.reset has punted to just putting a short\n\t    // string into the textarea instead of the full selection.\n\t    this.inaccurateSelection = false;\n\t    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n\t    this.hasSelection = false;\n\t    this.composing = null;\n\t  };\n\t\n\t  function hiddenTextarea() {\n\t    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n\t    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n\t    // The textarea is kept positioned near the cursor to prevent the\n\t    // fact that it'll be scrolled into view on input from scrolling\n\t    // our fake cursor out of view. On webkit, when wrap=off, paste is\n\t    // very slow. So make the area wide instead.\n\t    if (webkit) te.style.width = \"1000px\";\n\t    else te.setAttribute(\"wrap\", \"off\");\n\t    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n\t    if (ios) te.style.border = \"1px solid black\";\n\t    disableBrowserMagic(te);\n\t    return div;\n\t  }\n\t\n\t  TextareaInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = this.cm;\n\t\n\t      // Wraps and hides input textarea\n\t      var div = this.wrapper = hiddenTextarea();\n\t      // The semihidden textarea that is focused when the editor is\n\t      // focused, and receives input.\n\t      var te = this.textarea = div.firstChild;\n\t      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\t\n\t      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n\t      if (ios) te.style.width = \"0px\";\n\t\n\t      on(te, \"input\", function() {\n\t        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n\t        input.poll();\n\t      });\n\t\n\t      on(te, \"paste\", function(e) {\n\t        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n\t\n\t        cm.state.pasteIncoming = true;\n\t        input.fastPoll();\n\t      });\n\t\n\t      function prepareCopyCut(e) {\n\t        if (signalDOMEvent(cm, e)) return\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = {lineWise: false, text: cm.getSelections()};\n\t          if (input.inaccurateSelection) {\n\t            input.prevInput = \"\";\n\t            input.inaccurateSelection = false;\n\t            te.value = lastCopied.text.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = {lineWise: true, text: ranges.text};\n\t          if (e.type == \"cut\") {\n\t            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n\t          } else {\n\t            input.prevInput = \"\";\n\t            te.value = ranges.text.join(\"\\n\");\n\t            selectInput(te);\n\t          }\n\t        }\n\t        if (e.type == \"cut\") cm.state.cutIncoming = true;\n\t      }\n\t      on(te, \"cut\", prepareCopyCut);\n\t      on(te, \"copy\", prepareCopyCut);\n\t\n\t      on(display.scroller, \"paste\", function(e) {\n\t        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;\n\t        cm.state.pasteIncoming = true;\n\t        input.focus();\n\t      });\n\t\n\t      // Prevent normal selection in the editor (we handle our own)\n\t      on(display.lineSpace, \"selectstart\", function(e) {\n\t        if (!eventInWidget(display, e)) e_preventDefault(e);\n\t      });\n\t\n\t      on(te, \"compositionstart\", function() {\n\t        var start = cm.getCursor(\"from\");\n\t        if (input.composing) input.composing.range.clear()\n\t        input.composing = {\n\t          start: start,\n\t          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n\t        };\n\t      });\n\t      on(te, \"compositionend\", function() {\n\t        if (input.composing) {\n\t          input.poll();\n\t          input.composing.range.clear();\n\t          input.composing = null;\n\t        }\n\t      });\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      // Redraw the selection and/or cursor\n\t      var cm = this.cm, display = cm.display, doc = cm.doc;\n\t      var result = prepareSelection(cm);\n\t\n\t      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\t      if (cm.options.moveInputWithCursor) {\n\t        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n\t        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n\t        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n\t                                            headPos.top + lineOff.top - wrapOff.top));\n\t        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n\t                                             headPos.left + lineOff.left - wrapOff.left));\n\t      }\n\t\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(drawn) {\n\t      var cm = this.cm, display = cm.display;\n\t      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n\t      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n\t      if (drawn.teTop != null) {\n\t        this.wrapper.style.top = drawn.teTop + \"px\";\n\t        this.wrapper.style.left = drawn.teLeft + \"px\";\n\t      }\n\t    },\n\t\n\t    // Reset the input to correspond to the selection (or to be empty,\n\t    // when not typing and nothing is selected)\n\t    reset: function(typing) {\n\t      if (this.contextMenuPending) return;\n\t      var minimal, selected, cm = this.cm, doc = cm.doc;\n\t      if (cm.somethingSelected()) {\n\t        this.prevInput = \"\";\n\t        var range = doc.sel.primary();\n\t        minimal = hasCopyEvent &&\n\t          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n\t        var content = minimal ? \"-\" : selected || cm.getSelection();\n\t        this.textarea.value = content;\n\t        if (cm.state.focused) selectInput(this.textarea);\n\t        if (ie && ie_version >= 9) this.hasSelection = content;\n\t      } else if (!typing) {\n\t        this.prevInput = this.textarea.value = \"\";\n\t        if (ie && ie_version >= 9) this.hasSelection = null;\n\t      }\n\t      this.inaccurateSelection = minimal;\n\t    },\n\t\n\t    getField: function() { return this.textarea; },\n\t\n\t    supportsTouch: function() { return false; },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n\t        try { this.textarea.focus(); }\n\t        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n\t      }\n\t    },\n\t\n\t    blur: function() { this.textarea.blur(); },\n\t\n\t    resetPosition: function() {\n\t      this.wrapper.style.top = this.wrapper.style.left = 0;\n\t    },\n\t\n\t    receivedFocus: function() { this.slowPoll(); },\n\t\n\t    // Poll for input changes, using the normal rate of polling. This\n\t    // runs as long as the editor is focused.\n\t    slowPoll: function() {\n\t      var input = this;\n\t      if (input.pollingFast) return;\n\t      input.polling.set(this.cm.options.pollInterval, function() {\n\t        input.poll();\n\t        if (input.cm.state.focused) input.slowPoll();\n\t      });\n\t    },\n\t\n\t    // When an event has just come in that is likely to add or change\n\t    // something in the input textarea, we poll faster, to ensure that\n\t    // the change appears on the screen quickly.\n\t    fastPoll: function() {\n\t      var missed = false, input = this;\n\t      input.pollingFast = true;\n\t      function p() {\n\t        var changed = input.poll();\n\t        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n\t        else {input.pollingFast = false; input.slowPoll();}\n\t      }\n\t      input.polling.set(20, p);\n\t    },\n\t\n\t    // Read input from the textarea, and update the document to match.\n\t    // When something is selected, it is present in the textarea, and\n\t    // selected (unless it is huge, in which case a placeholder is\n\t    // used). When nothing is selected, the cursor sits after previously\n\t    // seen text (can be empty), which is stored in prevInput (we must\n\t    // not reset the textarea when typing, because that breaks IME).\n\t    poll: function() {\n\t      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n\t      // Since this is called a *lot*, try to bail out as cheaply as\n\t      // possible when it is clear that nothing happened. hasSelection\n\t      // will be the case when there is a lot of text in the textarea,\n\t      // in which case reading its value would be expensive.\n\t      if (this.contextMenuPending || !cm.state.focused ||\n\t          (hasSelection(input) && !prevInput && !this.composing) ||\n\t          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n\t        return false;\n\t\n\t      var text = input.value;\n\t      // If nothing changed, bail.\n\t      if (text == prevInput && !cm.somethingSelected()) return false;\n\t      // Work around nonsensical selection resetting in IE9/10, and\n\t      // inexplicable appearance of private area unicode characters on\n\t      // some key combos in Mac (#2689).\n\t      if (ie && ie_version >= 9 && this.hasSelection === text ||\n\t          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n\t        cm.display.input.reset();\n\t        return false;\n\t      }\n\t\n\t      if (cm.doc.sel == cm.display.selForContextMenu) {\n\t        var first = text.charCodeAt(0);\n\t        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n\t        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n\t      }\n\t      // Find the part of the input that is actually new\n\t      var same = 0, l = Math.min(prevInput.length, text.length);\n\t      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\t\n\t      var self = this;\n\t      runInOp(cm, function() {\n\t        applyTextInput(cm, text.slice(same), prevInput.length - same,\n\t                       null, self.composing ? \"*compose\" : null);\n\t\n\t        // Don't leave long text in the textarea, since it makes further polling slow\n\t        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n\t        else self.prevInput = text;\n\t\n\t        if (self.composing) {\n\t          self.composing.range.clear();\n\t          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n\t                                             {className: \"CodeMirror-composing\"});\n\t        }\n\t      });\n\t      return true;\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      if (this.pollingFast && this.poll()) this.pollingFast = false;\n\t    },\n\t\n\t    onKeyPress: function() {\n\t      if (ie && ie_version >= 9) this.hasSelection = null;\n\t      this.fastPoll();\n\t    },\n\t\n\t    onContextMenu: function(e) {\n\t      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n\t      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n\t      if (!pos || presto) return; // Opera is difficult.\n\t\n\t      // Reset the current text selection only if the click is done outside of the selection\n\t      // and 'resetSelectionOnContextMenu' option is true.\n\t      var reset = cm.options.resetSelectionOnContextMenu;\n\t      if (reset && cm.doc.sel.contains(pos) == -1)\n\t        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\t\n\t      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n\t      input.wrapper.style.cssText = \"position: absolute\"\n\t      var wrapperBox = input.wrapper.getBoundingClientRect()\n\t      te.style.cssText = \"position: absolute; width: 30px; height: 30px; top: \" + (e.clientY - wrapperBox.top - 5) +\n\t        \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px; z-index: 1000; background: \" +\n\t        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n\t        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n\t      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n\t      display.input.focus();\n\t      if (webkit) window.scrollTo(null, oldScrollY);\n\t      display.input.reset();\n\t      // Adds \"Select all\" to context menu in FF\n\t      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n\t      input.contextMenuPending = true;\n\t      display.selForContextMenu = cm.doc.sel;\n\t      clearTimeout(display.detectingSelectAll);\n\t\n\t      // Select-all will be greyed out if there's nothing to select, so\n\t      // this adds a zero-width space so that we can later check whether\n\t      // it got selected.\n\t      function prepareSelectAllHack() {\n\t        if (te.selectionStart != null) {\n\t          var selected = cm.somethingSelected();\n\t          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n\t          te.value = \"\\u21da\"; // Used to catch context-menu undo\n\t          te.value = extval;\n\t          input.prevInput = selected ? \"\" : \"\\u200b\";\n\t          te.selectionStart = 1; te.selectionEnd = extval.length;\n\t          // Re-set this, in case some other handler touched the\n\t          // selection in the meantime.\n\t          display.selForContextMenu = cm.doc.sel;\n\t        }\n\t      }\n\t      function rehide() {\n\t        input.contextMenuPending = false;\n\t        input.wrapper.style.cssText = oldWrapperCSS\n\t        te.style.cssText = oldCSS;\n\t        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\t\n\t        // Try to detect the user choosing select-all\n\t        if (te.selectionStart != null) {\n\t          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n\t          var i = 0, poll = function() {\n\t            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n\t                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n\t              operation(cm, commands.selectAll)(cm);\n\t            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n\t            else display.input.reset();\n\t          };\n\t          display.detectingSelectAll = setTimeout(poll, 200);\n\t        }\n\t      }\n\t\n\t      if (ie && ie_version >= 9) prepareSelectAllHack();\n\t      if (captureRightClick) {\n\t        e_stop(e);\n\t        var mouseup = function() {\n\t          off(window, \"mouseup\", mouseup);\n\t          setTimeout(rehide, 20);\n\t        };\n\t        on(window, \"mouseup\", mouseup);\n\t      } else {\n\t        setTimeout(rehide, 50);\n\t      }\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      if (!val) this.reset();\n\t    },\n\t\n\t    setUneditable: nothing,\n\t\n\t    needsContentAttribute: false\n\t  }, TextareaInput.prototype);\n\t\n\t  // CONTENTEDITABLE INPUT STYLE\n\t\n\t  function ContentEditableInput(cm) {\n\t    this.cm = cm;\n\t    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n\t    this.polling = new Delayed();\n\t    this.gracePeriod = false;\n\t  }\n\t\n\t  ContentEditableInput.prototype = copyObj({\n\t    init: function(display) {\n\t      var input = this, cm = input.cm;\n\t      var div = input.div = display.lineDiv;\n\t      disableBrowserMagic(div, cm.options.spellcheck);\n\t\n\t      on(div, \"paste\", function(e) {\n\t        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n\t        // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n\t        if (ie_version <= 11) setTimeout(operation(cm, function() {\n\t          if (!input.pollContent()) regChange(cm);\n\t        }), 20)\n\t      })\n\t\n\t      on(div, \"compositionstart\", function(e) {\n\t        var data = e.data;\n\t        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n\t        if (!data) return;\n\t        var prim = cm.doc.sel.primary();\n\t        var line = cm.getLine(prim.head.line);\n\t        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n\t        if (found > -1 && found <= prim.head.ch)\n\t          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n\t                                                Pos(prim.head.line, found + data.length));\n\t      });\n\t      on(div, \"compositionupdate\", function(e) {\n\t        input.composing.data = e.data;\n\t      });\n\t      on(div, \"compositionend\", function(e) {\n\t        var ours = input.composing;\n\t        if (!ours) return;\n\t        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n\t          ours.data = e.data;\n\t        // Need a small delay to prevent other code (input event,\n\t        // selection polling) from doing damage when fired right after\n\t        // compositionend.\n\t        setTimeout(function() {\n\t          if (!ours.handled)\n\t            input.applyComposition(ours);\n\t          if (input.composing == ours)\n\t            input.composing = null;\n\t        }, 50);\n\t      });\n\t\n\t      on(div, \"touchstart\", function() {\n\t        input.forceCompositionEnd();\n\t      });\n\t\n\t      on(div, \"input\", function() {\n\t        if (input.composing) return;\n\t        if (cm.isReadOnly() || !input.pollContent())\n\t          runInOp(input.cm, function() {regChange(cm);});\n\t      });\n\t\n\t      function onCopyCut(e) {\n\t        if (signalDOMEvent(cm, e)) return\n\t        if (cm.somethingSelected()) {\n\t          lastCopied = {lineWise: false, text: cm.getSelections()};\n\t          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n\t        } else if (!cm.options.lineWiseCopyCut) {\n\t          return;\n\t        } else {\n\t          var ranges = copyableRanges(cm);\n\t          lastCopied = {lineWise: true, text: ranges.text};\n\t          if (e.type == \"cut\") {\n\t            cm.operation(function() {\n\t              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n\t              cm.replaceSelection(\"\", null, \"cut\");\n\t            });\n\t          }\n\t        }\n\t        if (e.clipboardData) {\n\t          e.clipboardData.clearData();\n\t          var content = lastCopied.text.join(\"\\n\")\n\t          // iOS exposes the clipboard API, but seems to discard content inserted into it\n\t          e.clipboardData.setData(\"Text\", content);\n\t          if (e.clipboardData.getData(\"Text\") == content) {\n\t            e.preventDefault();\n\t            return\n\t          }\n\t        }\n\t        // Old-fashioned briefly-focus-a-textarea hack\n\t        var kludge = hiddenTextarea(), te = kludge.firstChild;\n\t        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n\t        te.value = lastCopied.text.join(\"\\n\");\n\t        var hadFocus = document.activeElement;\n\t        selectInput(te);\n\t        setTimeout(function() {\n\t          cm.display.lineSpace.removeChild(kludge);\n\t          hadFocus.focus();\n\t          if (hadFocus == div) input.showPrimarySelection()\n\t        }, 50);\n\t      }\n\t      on(div, \"copy\", onCopyCut);\n\t      on(div, \"cut\", onCopyCut);\n\t    },\n\t\n\t    prepareSelection: function() {\n\t      var result = prepareSelection(this.cm, false);\n\t      result.focus = this.cm.state.focused;\n\t      return result;\n\t    },\n\t\n\t    showSelection: function(info, takeFocus) {\n\t      if (!info || !this.cm.display.view.length) return;\n\t      if (info.focus || takeFocus) this.showPrimarySelection();\n\t      this.showMultipleSelections(info);\n\t    },\n\t\n\t    showPrimarySelection: function() {\n\t      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n\t      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n\t      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n\t      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n\t          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n\t          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n\t        return;\n\t\n\t      var start = posToDOM(this.cm, prim.from());\n\t      var end = posToDOM(this.cm, prim.to());\n\t      if (!start && !end) return;\n\t\n\t      var view = this.cm.display.view;\n\t      var old = sel.rangeCount && sel.getRangeAt(0);\n\t      if (!start) {\n\t        start = {node: view[0].measure.map[2], offset: 0};\n\t      } else if (!end) { // FIXME dangerously hacky\n\t        var measure = view[view.length - 1].measure;\n\t        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n\t        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n\t      }\n\t\n\t      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n\t      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n\t      if (rng) {\n\t        if (!gecko && this.cm.state.focused) {\n\t          sel.collapse(start.node, start.offset);\n\t          if (!rng.collapsed) sel.addRange(rng);\n\t        } else {\n\t          sel.removeAllRanges();\n\t          sel.addRange(rng);\n\t        }\n\t        if (old && sel.anchorNode == null) sel.addRange(old);\n\t        else if (gecko) this.startGracePeriod();\n\t      }\n\t      this.rememberSelection();\n\t    },\n\t\n\t    startGracePeriod: function() {\n\t      var input = this;\n\t      clearTimeout(this.gracePeriod);\n\t      this.gracePeriod = setTimeout(function() {\n\t        input.gracePeriod = false;\n\t        if (input.selectionChanged())\n\t          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n\t      }, 20);\n\t    },\n\t\n\t    showMultipleSelections: function(info) {\n\t      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n\t      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n\t    },\n\t\n\t    rememberSelection: function() {\n\t      var sel = window.getSelection();\n\t      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n\t      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n\t    },\n\t\n\t    selectionInEditor: function() {\n\t      var sel = window.getSelection();\n\t      if (!sel.rangeCount) return false;\n\t      var node = sel.getRangeAt(0).commonAncestorContainer;\n\t      return contains(this.div, node);\n\t    },\n\t\n\t    focus: function() {\n\t      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n\t    },\n\t    blur: function() { this.div.blur(); },\n\t    getField: function() { return this.div; },\n\t\n\t    supportsTouch: function() { return true; },\n\t\n\t    receivedFocus: function() {\n\t      var input = this;\n\t      if (this.selectionInEditor())\n\t        this.pollSelection();\n\t      else\n\t        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\t\n\t      function poll() {\n\t        if (input.cm.state.focused) {\n\t          input.pollSelection();\n\t          input.polling.set(input.cm.options.pollInterval, poll);\n\t        }\n\t      }\n\t      this.polling.set(this.cm.options.pollInterval, poll);\n\t    },\n\t\n\t    selectionChanged: function() {\n\t      var sel = window.getSelection();\n\t      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n\t        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n\t    },\n\t\n\t    pollSelection: function() {\n\t      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n\t        var sel = window.getSelection(), cm = this.cm;\n\t        this.rememberSelection();\n\t        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n\t        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n\t        if (anchor && head) runInOp(cm, function() {\n\t          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n\t          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n\t        });\n\t      }\n\t    },\n\t\n\t    pollContent: function() {\n\t      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n\t      var from = sel.from(), to = sel.to();\n\t      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\t\n\t      var fromIndex;\n\t      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n\t        var fromLine = lineNo(display.view[0].line);\n\t        var fromNode = display.view[0].node;\n\t      } else {\n\t        var fromLine = lineNo(display.view[fromIndex].line);\n\t        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n\t      }\n\t      var toIndex = findViewIndex(cm, to.line);\n\t      if (toIndex == display.view.length - 1) {\n\t        var toLine = display.viewTo - 1;\n\t        var toNode = display.lineDiv.lastChild;\n\t      } else {\n\t        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n\t        var toNode = display.view[toIndex + 1].node.previousSibling;\n\t      }\n\t\n\t      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n\t      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n\t      while (newText.length > 1 && oldText.length > 1) {\n\t        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n\t        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n\t        else break;\n\t      }\n\t\n\t      var cutFront = 0, cutEnd = 0;\n\t      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n\t      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n\t        ++cutFront;\n\t      var newBot = lst(newText), oldBot = lst(oldText);\n\t      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n\t                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n\t      while (cutEnd < maxCutEnd &&\n\t             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n\t        ++cutEnd;\n\t\n\t      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n\t      newText[0] = newText[0].slice(cutFront);\n\t\n\t      var chFrom = Pos(fromLine, cutFront);\n\t      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n\t      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n\t        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n\t        return true;\n\t      }\n\t    },\n\t\n\t    ensurePolled: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    reset: function() {\n\t      this.forceCompositionEnd();\n\t    },\n\t    forceCompositionEnd: function() {\n\t      if (!this.composing || this.composing.handled) return;\n\t      this.applyComposition(this.composing);\n\t      this.composing.handled = true;\n\t      this.div.blur();\n\t      this.div.focus();\n\t    },\n\t    applyComposition: function(composing) {\n\t      if (this.cm.isReadOnly())\n\t        operation(this.cm, regChange)(this.cm)\n\t      else if (composing.data && composing.data != composing.startData)\n\t        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n\t    },\n\t\n\t    setUneditable: function(node) {\n\t      node.contentEditable = \"false\"\n\t    },\n\t\n\t    onKeyPress: function(e) {\n\t      e.preventDefault();\n\t      if (!this.cm.isReadOnly())\n\t        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n\t    },\n\t\n\t    readOnlyChanged: function(val) {\n\t      this.div.contentEditable = String(val != \"nocursor\")\n\t    },\n\t\n\t    onContextMenu: nothing,\n\t    resetPosition: nothing,\n\t\n\t    needsContentAttribute: true\n\t  }, ContentEditableInput.prototype);\n\t\n\t  function posToDOM(cm, pos) {\n\t    var view = findViewForLine(cm, pos.line);\n\t    if (!view || view.hidden) return null;\n\t    var line = getLine(cm.doc, pos.line);\n\t    var info = mapFromLineView(view, line, pos.line);\n\t\n\t    var order = getOrder(line), side = \"left\";\n\t    if (order) {\n\t      var partPos = getBidiPartAt(order, pos.ch);\n\t      side = partPos % 2 ? \"right\" : \"left\";\n\t    }\n\t    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n\t    result.offset = result.collapse == \"right\" ? result.end : result.start;\n\t    return result;\n\t  }\n\t\n\t  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\t\n\t  function domToPos(cm, node, offset) {\n\t    var lineNode;\n\t    if (node == cm.display.lineDiv) {\n\t      lineNode = cm.display.lineDiv.childNodes[offset];\n\t      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n\t      node = null; offset = 0;\n\t    } else {\n\t      for (lineNode = node;; lineNode = lineNode.parentNode) {\n\t        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n\t        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n\t      }\n\t    }\n\t    for (var i = 0; i < cm.display.view.length; i++) {\n\t      var lineView = cm.display.view[i];\n\t      if (lineView.node == lineNode)\n\t        return locateNodeInLineView(lineView, node, offset);\n\t    }\n\t  }\n\t\n\t  function locateNodeInLineView(lineView, node, offset) {\n\t    var wrapper = lineView.text.firstChild, bad = false;\n\t    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n\t    if (node == wrapper) {\n\t      bad = true;\n\t      node = wrapper.childNodes[offset];\n\t      offset = 0;\n\t      if (!node) {\n\t        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n\t        return badPos(Pos(lineNo(line), line.text.length), bad);\n\t      }\n\t    }\n\t\n\t    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n\t    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n\t      textNode = node.firstChild;\n\t      if (offset) offset = textNode.nodeValue.length;\n\t    }\n\t    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n\t    var measure = lineView.measure, maps = measure.maps;\n\t\n\t    function find(textNode, topNode, offset) {\n\t      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n\t        var map = i < 0 ? measure.map : maps[i];\n\t        for (var j = 0; j < map.length; j += 3) {\n\t          var curNode = map[j + 2];\n\t          if (curNode == textNode || curNode == topNode) {\n\t            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n\t            var ch = map[j] + offset;\n\t            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n\t            return Pos(line, ch);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    var found = find(textNode, topNode, offset);\n\t    if (found) return badPos(found, bad);\n\t\n\t    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n\t    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n\t      found = find(after, after.firstChild, 0);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch - dist), bad);\n\t      else\n\t        dist += after.textContent.length;\n\t    }\n\t    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n\t      found = find(before, before.firstChild, -1);\n\t      if (found)\n\t        return badPos(Pos(found.line, found.ch + dist), bad);\n\t      else\n\t        dist += before.textContent.length;\n\t    }\n\t  }\n\t\n\t  function domTextBetween(cm, from, to, fromLine, toLine) {\n\t    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n\t    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n\t    function walk(node) {\n\t      if (node.nodeType == 1) {\n\t        var cmText = node.getAttribute(\"cm-text\");\n\t        if (cmText != null) {\n\t          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n\t          text += cmText;\n\t          return;\n\t        }\n\t        var markerID = node.getAttribute(\"cm-marker\"), range;\n\t        if (markerID) {\n\t          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n\t          if (found.length && (range = found[0].find()))\n\t            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n\t          return;\n\t        }\n\t        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n\t        for (var i = 0; i < node.childNodes.length; i++)\n\t          walk(node.childNodes[i]);\n\t        if (/^(pre|div|p)$/i.test(node.nodeName))\n\t          closing = true;\n\t      } else if (node.nodeType == 3) {\n\t        var val = node.nodeValue;\n\t        if (!val) return;\n\t        if (closing) {\n\t          text += lineSep;\n\t          closing = false;\n\t        }\n\t        text += val;\n\t      }\n\t    }\n\t    for (;;) {\n\t      walk(from);\n\t      if (from == to) break;\n\t      from = from.nextSibling;\n\t    }\n\t    return text;\n\t  }\n\t\n\t  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\t\n\t  // SELECTION / CURSOR\n\t\n\t  // Selection objects are immutable. A new one is created every time\n\t  // the selection changes. A selection is one or more non-overlapping\n\t  // (and non-touching) ranges, sorted, and an integer that indicates\n\t  // which one is the primary selection (the one that's scrolled into\n\t  // view, that getCursor returns, etc).\n\t  function Selection(ranges, primIndex) {\n\t    this.ranges = ranges;\n\t    this.primIndex = primIndex;\n\t  }\n\t\n\t  Selection.prototype = {\n\t    primary: function() { return this.ranges[this.primIndex]; },\n\t    equals: function(other) {\n\t      if (other == this) return true;\n\t      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var here = this.ranges[i], there = other.ranges[i];\n\t        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n\t      }\n\t      return true;\n\t    },\n\t    deepCopy: function() {\n\t      for (var out = [], i = 0; i < this.ranges.length; i++)\n\t        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n\t      return new Selection(out, this.primIndex);\n\t    },\n\t    somethingSelected: function() {\n\t      for (var i = 0; i < this.ranges.length; i++)\n\t        if (!this.ranges[i].empty()) return true;\n\t      return false;\n\t    },\n\t    contains: function(pos, end) {\n\t      if (!end) end = pos;\n\t      for (var i = 0; i < this.ranges.length; i++) {\n\t        var range = this.ranges[i];\n\t        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n\t          return i;\n\t      }\n\t      return -1;\n\t    }\n\t  };\n\t\n\t  function Range(anchor, head) {\n\t    this.anchor = anchor; this.head = head;\n\t  }\n\t\n\t  Range.prototype = {\n\t    from: function() { return minPos(this.anchor, this.head); },\n\t    to: function() { return maxPos(this.anchor, this.head); },\n\t    empty: function() {\n\t      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n\t    }\n\t  };\n\t\n\t  // Take an unsorted, potentially overlapping set of ranges, and\n\t  // build a selection out of it. 'Consumes' ranges array (modifying\n\t  // it).\n\t  function normalizeSelection(ranges, primIndex) {\n\t    var prim = ranges[primIndex];\n\t    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n\t    primIndex = indexOf(ranges, prim);\n\t    for (var i = 1; i < ranges.length; i++) {\n\t      var cur = ranges[i], prev = ranges[i - 1];\n\t      if (cmp(prev.to(), cur.from()) >= 0) {\n\t        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n\t        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n\t        if (i <= primIndex) --primIndex;\n\t        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n\t      }\n\t    }\n\t    return new Selection(ranges, primIndex);\n\t  }\n\t\n\t  function simpleSelection(anchor, head) {\n\t    return new Selection([new Range(anchor, head || anchor)], 0);\n\t  }\n\t\n\t  // Most of the external API clips given positions to make sure they\n\t  // actually exist within the document.\n\t  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n\t  function clipPos(doc, pos) {\n\t    if (pos.line < doc.first) return Pos(doc.first, 0);\n\t    var last = doc.first + doc.size - 1;\n\t    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n\t    return clipToLen(pos, getLine(doc, pos.line).text.length);\n\t  }\n\t  function clipToLen(pos, linelen) {\n\t    var ch = pos.ch;\n\t    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n\t    else if (ch < 0) return Pos(pos.line, 0);\n\t    else return pos;\n\t  }\n\t  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\t  function clipPosArray(doc, array) {\n\t    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n\t    return out;\n\t  }\n\t\n\t  // SELECTION UPDATES\n\t\n\t  // The 'scroll' parameter given to many of these indicated whether\n\t  // the new cursor position should be scrolled into view after\n\t  // modifying the selection.\n\t\n\t  // If shift is held or the extend flag is set, extends a range to\n\t  // include a given position (and optionally a second position).\n\t  // Otherwise, simply returns the range between the given positions.\n\t  // Used for cursor motion and such.\n\t  function extendRange(doc, range, head, other) {\n\t    if (doc.cm && doc.cm.display.shift || doc.extend) {\n\t      var anchor = range.anchor;\n\t      if (other) {\n\t        var posBefore = cmp(head, anchor) < 0;\n\t        if (posBefore != (cmp(other, anchor) < 0)) {\n\t          anchor = head;\n\t          head = other;\n\t        } else if (posBefore != (cmp(head, other) < 0)) {\n\t          head = other;\n\t        }\n\t      }\n\t      return new Range(anchor, head);\n\t    } else {\n\t      return new Range(other || head, head);\n\t    }\n\t  }\n\t\n\t  // Extend the primary selection range, discard the rest.\n\t  function extendSelection(doc, head, other, options) {\n\t    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n\t  }\n\t\n\t  // Extend all selections (pos is an array of selections with length\n\t  // equal the number of selections)\n\t  function extendSelections(doc, heads, options) {\n\t    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n\t      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n\t    var newSel = normalizeSelection(out, doc.sel.primIndex);\n\t    setSelection(doc, newSel, options);\n\t  }\n\t\n\t  // Updates a single range in the selection.\n\t  function replaceOneSelection(doc, i, range, options) {\n\t    var ranges = doc.sel.ranges.slice(0);\n\t    ranges[i] = range;\n\t    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n\t  }\n\t\n\t  // Reset the selection to a single range.\n\t  function setSimpleSelection(doc, anchor, head, options) {\n\t    setSelection(doc, simpleSelection(anchor, head), options);\n\t  }\n\t\n\t  // Give beforeSelectionChange handlers a change to influence a\n\t  // selection update.\n\t  function filterSelectionChange(doc, sel, options) {\n\t    var obj = {\n\t      ranges: sel.ranges,\n\t      update: function(ranges) {\n\t        this.ranges = [];\n\t        for (var i = 0; i < ranges.length; i++)\n\t          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n\t                                     clipPos(doc, ranges[i].head));\n\t      },\n\t      origin: options && options.origin\n\t    };\n\t    signal(doc, \"beforeSelectionChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n\t    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n\t    else return sel;\n\t  }\n\t\n\t  function setSelectionReplaceHistory(doc, sel, options) {\n\t    var done = doc.history.done, last = lst(done);\n\t    if (last && last.ranges) {\n\t      done[done.length - 1] = sel;\n\t      setSelectionNoUndo(doc, sel, options);\n\t    } else {\n\t      setSelection(doc, sel, options);\n\t    }\n\t  }\n\t\n\t  // Set a new selection.\n\t  function setSelection(doc, sel, options) {\n\t    setSelectionNoUndo(doc, sel, options);\n\t    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n\t  }\n\t\n\t  function setSelectionNoUndo(doc, sel, options) {\n\t    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n\t      sel = filterSelectionChange(doc, sel, options);\n\t\n\t    var bias = options && options.bias ||\n\t      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\t\n\t    if (!(options && options.scroll === false) && doc.cm)\n\t      ensureCursorVisible(doc.cm);\n\t  }\n\t\n\t  function setSelectionInner(doc, sel) {\n\t    if (sel.equals(doc.sel)) return;\n\t\n\t    doc.sel = sel;\n\t\n\t    if (doc.cm) {\n\t      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n\t      signalCursorActivity(doc.cm);\n\t    }\n\t    signalLater(doc, \"cursorActivity\", doc);\n\t  }\n\t\n\t  // Verify that the selection does not partially select any atomic\n\t  // marked ranges.\n\t  function reCheckSelection(doc) {\n\t    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n\t  }\n\t\n\t  // Return a selection that does not partially select any atomic\n\t  // ranges.\n\t  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n\t    var out;\n\t    for (var i = 0; i < sel.ranges.length; i++) {\n\t      var range = sel.ranges[i];\n\t      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n\t      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n\t      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n\t      if (out || newAnchor != range.anchor || newHead != range.head) {\n\t        if (!out) out = sel.ranges.slice(0, i);\n\t        out[i] = new Range(newAnchor, newHead);\n\t      }\n\t    }\n\t    return out ? normalizeSelection(out, sel.primIndex) : sel;\n\t  }\n\t\n\t  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n\t    var line = getLine(doc, pos.line);\n\t    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t      var sp = line.markedSpans[i], m = sp.marker;\n\t      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n\t          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n\t        if (mayClear) {\n\t          signal(m, \"beforeCursorEnter\");\n\t          if (m.explicitlyCleared) {\n\t            if (!line.markedSpans) break;\n\t            else {--i; continue;}\n\t          }\n\t        }\n\t        if (!m.atomic) continue;\n\t\n\t        if (oldPos) {\n\t          var near = m.find(dir < 0 ? 1 : -1), diff;\n\t          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n\t            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n\t          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n\t            return skipAtomicInner(doc, near, pos, dir, mayClear);\n\t        }\n\t\n\t        var far = m.find(dir < 0 ? -1 : 1);\n\t        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n\t          far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n\t        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n\t      }\n\t    }\n\t    return pos;\n\t  }\n\t\n\t  // Ensure a given position is not inside an atomic range.\n\t  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n\t    var dir = bias || 1;\n\t    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n\t        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n\t        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n\t        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n\t    if (!found) {\n\t      doc.cantEdit = true;\n\t      return Pos(doc.first, 0);\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function movePos(doc, pos, dir, line) {\n\t    if (dir < 0 && pos.ch == 0) {\n\t      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));\n\t      else return null;\n\t    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n\t      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);\n\t      else return null;\n\t    } else {\n\t      return new Pos(pos.line, pos.ch + dir);\n\t    }\n\t  }\n\t\n\t  // SELECTION DRAWING\n\t\n\t  function updateSelection(cm) {\n\t    cm.display.input.showSelection(cm.display.input.prepareSelection());\n\t  }\n\t\n\t  function prepareSelection(cm, primary) {\n\t    var doc = cm.doc, result = {};\n\t    var curFragment = result.cursors = document.createDocumentFragment();\n\t    var selFragment = result.selection = document.createDocumentFragment();\n\t\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      if (primary === false && i == doc.sel.primIndex) continue;\n\t      var range = doc.sel.ranges[i];\n\t      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;\n\t      var collapsed = range.empty();\n\t      if (collapsed || cm.options.showCursorWhenSelecting)\n\t        drawSelectionCursor(cm, range.head, curFragment);\n\t      if (!collapsed)\n\t        drawSelectionRange(cm, range, selFragment);\n\t    }\n\t    return result;\n\t  }\n\t\n\t  // Draws a cursor for the given range\n\t  function drawSelectionCursor(cm, head, output) {\n\t    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\t\n\t    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n\t    cursor.style.left = pos.left + \"px\";\n\t    cursor.style.top = pos.top + \"px\";\n\t    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\t\n\t    if (pos.other) {\n\t      // Secondary cursor, shown when on a 'jump' in bi-directional text\n\t      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n\t      otherCursor.style.display = \"\";\n\t      otherCursor.style.left = pos.other.left + \"px\";\n\t      otherCursor.style.top = pos.other.top + \"px\";\n\t      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n\t    }\n\t  }\n\t\n\t  // Draws the given range as a highlighted selection\n\t  function drawSelectionRange(cm, range, output) {\n\t    var display = cm.display, doc = cm.doc;\n\t    var fragment = document.createDocumentFragment();\n\t    var padding = paddingH(cm.display), leftSide = padding.left;\n\t    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\t\n\t    function add(left, top, width, bottom) {\n\t      if (top < 0) top = 0;\n\t      top = Math.round(top);\n\t      bottom = Math.round(bottom);\n\t      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n\t                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n\t                               \"px; height: \" + (bottom - top) + \"px\"));\n\t    }\n\t\n\t    function drawForLine(line, fromArg, toArg) {\n\t      var lineObj = getLine(doc, line);\n\t      var lineLen = lineObj.text.length;\n\t      var start, end;\n\t      function coords(ch, bias) {\n\t        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n\t      }\n\t\n\t      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n\t        var leftPos = coords(from, \"left\"), rightPos, left, right;\n\t        if (from == to) {\n\t          rightPos = leftPos;\n\t          left = right = leftPos.left;\n\t        } else {\n\t          rightPos = coords(to - 1, \"right\");\n\t          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n\t          left = leftPos.left;\n\t          right = rightPos.right;\n\t        }\n\t        if (fromArg == null && from == 0) left = leftSide;\n\t        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n\t          add(left, leftPos.top, null, leftPos.bottom);\n\t          left = leftSide;\n\t          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n\t        }\n\t        if (toArg == null && to == lineLen) right = rightSide;\n\t        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n\t          start = leftPos;\n\t        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n\t          end = rightPos;\n\t        if (left < leftSide + 1) left = leftSide;\n\t        add(left, rightPos.top, right - left, rightPos.bottom);\n\t      });\n\t      return {start: start, end: end};\n\t    }\n\t\n\t    var sFrom = range.from(), sTo = range.to();\n\t    if (sFrom.line == sTo.line) {\n\t      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n\t    } else {\n\t      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n\t      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n\t      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n\t      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n\t      if (singleVLine) {\n\t        if (leftEnd.top < rightStart.top - 2) {\n\t          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n\t          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n\t        } else {\n\t          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n\t        }\n\t      }\n\t      if (leftEnd.bottom < rightStart.top)\n\t        add(leftSide, leftEnd.bottom, null, rightStart.top);\n\t    }\n\t\n\t    output.appendChild(fragment);\n\t  }\n\t\n\t  // Cursor-blinking\n\t  function restartBlink(cm) {\n\t    if (!cm.state.focused) return;\n\t    var display = cm.display;\n\t    clearInterval(display.blinker);\n\t    var on = true;\n\t    display.cursorDiv.style.visibility = \"\";\n\t    if (cm.options.cursorBlinkRate > 0)\n\t      display.blinker = setInterval(function() {\n\t        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n\t      }, cm.options.cursorBlinkRate);\n\t    else if (cm.options.cursorBlinkRate < 0)\n\t      display.cursorDiv.style.visibility = \"hidden\";\n\t  }\n\t\n\t  // HIGHLIGHT WORKER\n\t\n\t  function startWorker(cm, time) {\n\t    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n\t      cm.state.highlight.set(time, bind(highlightWorker, cm));\n\t  }\n\t\n\t  function highlightWorker(cm) {\n\t    var doc = cm.doc;\n\t    if (doc.frontier < doc.first) doc.frontier = doc.first;\n\t    if (doc.frontier >= cm.display.viewTo) return;\n\t    var end = +new Date + cm.options.workTime;\n\t    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n\t    var changedLines = [];\n\t\n\t    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n\t      if (doc.frontier >= cm.display.viewFrom) { // Visible\n\t        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n\t        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n\t        line.styles = highlighted.styles;\n\t        var oldCls = line.styleClasses, newCls = highlighted.classes;\n\t        if (newCls) line.styleClasses = newCls;\n\t        else if (oldCls) line.styleClasses = null;\n\t        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n\t          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n\t        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n\t        if (ischange) changedLines.push(doc.frontier);\n\t        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n\t      } else {\n\t        if (line.text.length <= cm.options.maxHighlightLength)\n\t          processLine(cm, line.text, state);\n\t        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n\t      }\n\t      ++doc.frontier;\n\t      if (+new Date > end) {\n\t        startWorker(cm, cm.options.workDelay);\n\t        return true;\n\t      }\n\t    });\n\t    if (changedLines.length) runInOp(cm, function() {\n\t      for (var i = 0; i < changedLines.length; i++)\n\t        regLineChange(cm, changedLines[i], \"text\");\n\t    });\n\t  }\n\t\n\t  // Finds the line to start with when starting a parse. Tries to\n\t  // find a line with a stateAfter, so that it can start with a\n\t  // valid state. If that fails, it returns the line with the\n\t  // smallest indentation, which tends to need the least context to\n\t  // parse correctly.\n\t  function findStartLine(cm, n, precise) {\n\t    var minindent, minline, doc = cm.doc;\n\t    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\t    for (var search = n; search > lim; --search) {\n\t      if (search <= doc.first) return doc.first;\n\t      var line = getLine(doc, search - 1);\n\t      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n\t      var indented = countColumn(line.text, null, cm.options.tabSize);\n\t      if (minline == null || minindent > indented) {\n\t        minline = search - 1;\n\t        minindent = indented;\n\t      }\n\t    }\n\t    return minline;\n\t  }\n\t\n\t  function getStateBefore(cm, n, precise) {\n\t    var doc = cm.doc, display = cm.display;\n\t    if (!doc.mode.startState) return true;\n\t    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n\t    if (!state) state = startState(doc.mode);\n\t    else state = copyState(doc.mode, state);\n\t    doc.iter(pos, n, function(line) {\n\t      processLine(cm, line.text, state);\n\t      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n\t      line.stateAfter = save ? copyState(doc.mode, state) : null;\n\t      ++pos;\n\t    });\n\t    if (precise) doc.frontier = pos;\n\t    return state;\n\t  }\n\t\n\t  // POSITION MEASUREMENT\n\t\n\t  function paddingTop(display) {return display.lineSpace.offsetTop;}\n\t  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n\t  function paddingH(display) {\n\t    if (display.cachedPaddingH) return display.cachedPaddingH;\n\t    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n\t    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n\t    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n\t    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n\t    return data;\n\t  }\n\t\n\t  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n\t  function displayWidth(cm) {\n\t    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n\t  }\n\t  function displayHeight(cm) {\n\t    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n\t  }\n\t\n\t  // Ensure the lineView.wrapping.heights array is populated. This is\n\t  // an array of bottom offsets for the lines that make up a drawn\n\t  // line. When lineWrapping is on, there might be more than one\n\t  // height.\n\t  function ensureLineHeights(cm, lineView, rect) {\n\t    var wrapping = cm.options.lineWrapping;\n\t    var curWidth = wrapping && displayWidth(cm);\n\t    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n\t      var heights = lineView.measure.heights = [];\n\t      if (wrapping) {\n\t        lineView.measure.width = curWidth;\n\t        var rects = lineView.text.firstChild.getClientRects();\n\t        for (var i = 0; i < rects.length - 1; i++) {\n\t          var cur = rects[i], next = rects[i + 1];\n\t          if (Math.abs(cur.bottom - next.bottom) > 2)\n\t            heights.push((cur.bottom + next.top) / 2 - rect.top);\n\t        }\n\t      }\n\t      heights.push(rect.bottom - rect.top);\n\t    }\n\t  }\n\t\n\t  // Find a line map (mapping character offsets to text nodes) and a\n\t  // measurement cache for the given line number. (A line view might\n\t  // contain multiple lines when collapsed ranges are present.)\n\t  function mapFromLineView(lineView, line, lineN) {\n\t    if (lineView.line == line)\n\t      return {map: lineView.measure.map, cache: lineView.measure.cache};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineView.rest[i] == line)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n\t    for (var i = 0; i < lineView.rest.length; i++)\n\t      if (lineNo(lineView.rest[i]) > lineN)\n\t        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n\t  }\n\t\n\t  // Render a line into the hidden node display.externalMeasured. Used\n\t  // when measurement is needed for a line that's not in the viewport.\n\t  function updateExternalMeasurement(cm, line) {\n\t    line = visualLine(line);\n\t    var lineN = lineNo(line);\n\t    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n\t    view.lineN = lineN;\n\t    var built = view.built = buildLineContent(cm, view);\n\t    view.text = built.pre;\n\t    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n\t    return view;\n\t  }\n\t\n\t  // Get a {top, bottom, left, right} box (in line-local coordinates)\n\t  // for a given character.\n\t  function measureChar(cm, line, ch, bias) {\n\t    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n\t  }\n\t\n\t  // Find a line view that corresponds to the given line number.\n\t  function findViewForLine(cm, lineN) {\n\t    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n\t      return cm.display.view[findViewIndex(cm, lineN)];\n\t    var ext = cm.display.externalMeasured;\n\t    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n\t      return ext;\n\t  }\n\t\n\t  // Measurement can be split in two steps, the set-up work that\n\t  // applies to the whole line, and the measurement of the actual\n\t  // character. Functions like coordsChar, that need to do a lot of\n\t  // measurements in a row, can thus ensure that the set-up work is\n\t  // only done once.\n\t  function prepareMeasureForLine(cm, line) {\n\t    var lineN = lineNo(line);\n\t    var view = findViewForLine(cm, lineN);\n\t    if (view && !view.text) {\n\t      view = null;\n\t    } else if (view && view.changes) {\n\t      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n\t      cm.curOp.forceUpdate = true;\n\t    }\n\t    if (!view)\n\t      view = updateExternalMeasurement(cm, line);\n\t\n\t    var info = mapFromLineView(view, line, lineN);\n\t    return {\n\t      line: line, view: view, rect: null,\n\t      map: info.map, cache: info.cache, before: info.before,\n\t      hasHeights: false\n\t    };\n\t  }\n\t\n\t  // Given a prepared measurement object, measures the position of an\n\t  // actual character (or fetches it from the cache).\n\t  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n\t    if (prepared.before) ch = -1;\n\t    var key = ch + (bias || \"\"), found;\n\t    if (prepared.cache.hasOwnProperty(key)) {\n\t      found = prepared.cache[key];\n\t    } else {\n\t      if (!prepared.rect)\n\t        prepared.rect = prepared.view.text.getBoundingClientRect();\n\t      if (!prepared.hasHeights) {\n\t        ensureLineHeights(cm, prepared.view, prepared.rect);\n\t        prepared.hasHeights = true;\n\t      }\n\t      found = measureCharInner(cm, prepared, ch, bias);\n\t      if (!found.bogus) prepared.cache[key] = found;\n\t    }\n\t    return {left: found.left, right: found.right,\n\t            top: varHeight ? found.rtop : found.top,\n\t            bottom: varHeight ? found.rbottom : found.bottom};\n\t  }\n\t\n\t  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\t\n\t  function nodeAndOffsetInLineMap(map, ch, bias) {\n\t    var node, start, end, collapse;\n\t    // First, search the line map for the text node corresponding to,\n\t    // or closest to, the target character.\n\t    for (var i = 0; i < map.length; i += 3) {\n\t      var mStart = map[i], mEnd = map[i + 1];\n\t      if (ch < mStart) {\n\t        start = 0; end = 1;\n\t        collapse = \"left\";\n\t      } else if (ch < mEnd) {\n\t        start = ch - mStart;\n\t        end = start + 1;\n\t      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n\t        end = mEnd - mStart;\n\t        start = end - 1;\n\t        if (ch >= mEnd) collapse = \"right\";\n\t      }\n\t      if (start != null) {\n\t        node = map[i + 2];\n\t        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n\t          collapse = bias;\n\t        if (bias == \"left\" && start == 0)\n\t          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n\t            node = map[(i -= 3) + 2];\n\t            collapse = \"left\";\n\t          }\n\t        if (bias == \"right\" && start == mEnd - mStart)\n\t          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n\t            node = map[(i += 3) + 2];\n\t            collapse = \"right\";\n\t          }\n\t        break;\n\t      }\n\t    }\n\t    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n\t  }\n\t\n\t  function getUsefulRect(rects, bias) {\n\t    var rect = nullRect\n\t    if (bias == \"left\") for (var i = 0; i < rects.length; i++) {\n\t      if ((rect = rects[i]).left != rect.right) break\n\t    } else for (var i = rects.length - 1; i >= 0; i--) {\n\t      if ((rect = rects[i]).left != rect.right) break\n\t    }\n\t    return rect\n\t  }\n\t\n\t  function measureCharInner(cm, prepared, ch, bias) {\n\t    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n\t    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\t\n\t    var rect;\n\t    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n\t      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n\t        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n\t        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n\t        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n\t          rect = node.parentNode.getBoundingClientRect();\n\t        else\n\t          rect = getUsefulRect(range(node, start, end).getClientRects(), bias)\n\t        if (rect.left || rect.right || start == 0) break;\n\t        end = start;\n\t        start = start - 1;\n\t        collapse = \"right\";\n\t      }\n\t      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n\t    } else { // If it is a widget, simply get the box for the whole widget.\n\t      if (start > 0) collapse = bias = \"right\";\n\t      var rects;\n\t      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n\t        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n\t      else\n\t        rect = node.getBoundingClientRect();\n\t    }\n\t    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n\t      var rSpan = node.parentNode.getClientRects()[0];\n\t      if (rSpan)\n\t        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n\t      else\n\t        rect = nullRect;\n\t    }\n\t\n\t    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n\t    var mid = (rtop + rbot) / 2;\n\t    var heights = prepared.view.measure.heights;\n\t    for (var i = 0; i < heights.length - 1; i++)\n\t      if (mid < heights[i]) break;\n\t    var top = i ? heights[i - 1] : 0, bot = heights[i];\n\t    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n\t                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n\t                  top: top, bottom: bot};\n\t    if (!rect.left && !rect.right) result.bogus = true;\n\t    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\t\n\t    return result;\n\t  }\n\t\n\t  // Work around problem with bounding client rects on ranges being\n\t  // returned incorrectly when zoomed on IE10 and below.\n\t  function maybeUpdateRectForZooming(measure, rect) {\n\t    if (!window.screen || screen.logicalXDPI == null ||\n\t        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n\t      return rect;\n\t    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n\t    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n\t    return {left: rect.left * scaleX, right: rect.right * scaleX,\n\t            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n\t  }\n\t\n\t  function clearLineMeasurementCacheFor(lineView) {\n\t    if (lineView.measure) {\n\t      lineView.measure.cache = {};\n\t      lineView.measure.heights = null;\n\t      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n\t        lineView.measure.caches[i] = {};\n\t    }\n\t  }\n\t\n\t  function clearLineMeasurementCache(cm) {\n\t    cm.display.externalMeasure = null;\n\t    removeChildren(cm.display.lineMeasure);\n\t    for (var i = 0; i < cm.display.view.length; i++)\n\t      clearLineMeasurementCacheFor(cm.display.view[i]);\n\t  }\n\t\n\t  function clearCaches(cm) {\n\t    clearLineMeasurementCache(cm);\n\t    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\t    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n\t    cm.display.lineNumChars = null;\n\t  }\n\t\n\t  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n\t  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\t\n\t  // Converts a {top, bottom, left, right} box from line-local\n\t  // coordinates into another coordinate system. Context may be one of\n\t  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n\t  // or \"page\".\n\t  function intoCoordSystem(cm, lineObj, rect, context) {\n\t    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n\t      var size = widgetHeight(lineObj.widgets[i]);\n\t      rect.top += size; rect.bottom += size;\n\t    }\n\t    if (context == \"line\") return rect;\n\t    if (!context) context = \"local\";\n\t    var yOff = heightAtLine(lineObj);\n\t    if (context == \"local\") yOff += paddingTop(cm.display);\n\t    else yOff -= cm.display.viewOffset;\n\t    if (context == \"page\" || context == \"window\") {\n\t      var lOff = cm.display.lineSpace.getBoundingClientRect();\n\t      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n\t      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n\t      rect.left += xOff; rect.right += xOff;\n\t    }\n\t    rect.top += yOff; rect.bottom += yOff;\n\t    return rect;\n\t  }\n\t\n\t  // Coverts a box from \"div\" coords to another coordinate system.\n\t  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n\t  function fromCoordSystem(cm, coords, context) {\n\t    if (context == \"div\") return coords;\n\t    var left = coords.left, top = coords.top;\n\t    // First move into \"page\" coordinate system\n\t    if (context == \"page\") {\n\t      left -= pageScrollX();\n\t      top -= pageScrollY();\n\t    } else if (context == \"local\" || !context) {\n\t      var localBox = cm.display.sizer.getBoundingClientRect();\n\t      left += localBox.left;\n\t      top += localBox.top;\n\t    }\n\t\n\t    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n\t    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n\t  }\n\t\n\t  function charCoords(cm, pos, context, lineObj, bias) {\n\t    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n\t    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n\t  }\n\t\n\t  // Returns a box for a given cursor position, which may have an\n\t  // 'other' property containing the position of the secondary cursor\n\t  // on a bidi boundary.\n\t  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n\t    lineObj = lineObj || getLine(cm.doc, pos.line);\n\t    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t    function get(ch, right) {\n\t      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n\t      if (right) m.left = m.right; else m.right = m.left;\n\t      return intoCoordSystem(cm, lineObj, m, context);\n\t    }\n\t    function getBidi(ch, partPos) {\n\t      var part = order[partPos], right = part.level % 2;\n\t      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n\t        part = order[--partPos];\n\t        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n\t        right = true;\n\t      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n\t        part = order[++partPos];\n\t        ch = bidiLeft(part) - part.level % 2;\n\t        right = false;\n\t      }\n\t      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n\t      return get(ch, right);\n\t    }\n\t    var order = getOrder(lineObj), ch = pos.ch;\n\t    if (!order) return get(ch);\n\t    var partPos = getBidiPartAt(order, ch);\n\t    var val = getBidi(ch, partPos);\n\t    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n\t    return val;\n\t  }\n\t\n\t  // Used to cheaply estimate the coordinates for a position. Used for\n\t  // intermediate scroll updates.\n\t  function estimateCoords(cm, pos) {\n\t    var left = 0, pos = clipPos(cm.doc, pos);\n\t    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n\t    var lineObj = getLine(cm.doc, pos.line);\n\t    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n\t    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n\t  }\n\t\n\t  // Positions returned by coordsChar contain some extra information.\n\t  // xRel is the relative x position of the input coordinates compared\n\t  // to the found position (so xRel > 0 means the coordinates are to\n\t  // the right of the character position, for example). When outside\n\t  // is true, that means the coordinates lie outside the line's\n\t  // vertical range.\n\t  function PosWithInfo(line, ch, outside, xRel) {\n\t    var pos = Pos(line, ch);\n\t    pos.xRel = xRel;\n\t    if (outside) pos.outside = true;\n\t    return pos;\n\t  }\n\t\n\t  // Compute the character position closest to the given coordinates.\n\t  // Input must be lineSpace-local (\"div\" coordinate system).\n\t  function coordsChar(cm, x, y) {\n\t    var doc = cm.doc;\n\t    y += cm.display.viewOffset;\n\t    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n\t    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n\t    if (lineN > last)\n\t      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n\t    if (x < 0) x = 0;\n\t\n\t    var lineObj = getLine(doc, lineN);\n\t    for (;;) {\n\t      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n\t      var merged = collapsedSpanAtEnd(lineObj);\n\t      var mergedPos = merged && merged.find(0, true);\n\t      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n\t        lineN = lineNo(lineObj = mergedPos.to.line);\n\t      else\n\t        return found;\n\t    }\n\t  }\n\t\n\t  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n\t    var innerOff = y - heightAtLine(lineObj);\n\t    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n\t    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\t\n\t    function getX(ch) {\n\t      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n\t      wrongLine = true;\n\t      if (innerOff > sp.bottom) return sp.left - adjust;\n\t      else if (innerOff < sp.top) return sp.left + adjust;\n\t      else wrongLine = false;\n\t      return sp.left;\n\t    }\n\t\n\t    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n\t    var from = lineLeft(lineObj), to = lineRight(lineObj);\n\t    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\t\n\t    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n\t    // Do a binary search between these bounds.\n\t    for (;;) {\n\t      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n\t        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n\t        var outside = ch == from ? fromOutside : toOutside\n\t        var xDiff = x - (ch == from ? fromX : toX);\n\t        // This is a kludge to handle the case where the coordinates\n\t        // are after a line-wrapped line. We should replace it with a\n\t        // more general handling of cursor positions around line\n\t        // breaks. (Issue #4078)\n\t        if (toOutside && !bidi && !/\\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&\n\t            ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {\n\t          var charSize = measureCharPrepared(cm, preparedMeasure, ch, \"right\");\n\t          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {\n\t            outside = false\n\t            ch++\n\t            xDiff = x - charSize.right\n\t          }\n\t        }\n\t        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n\t        var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n\t        return pos;\n\t      }\n\t      var step = Math.ceil(dist / 2), middle = from + step;\n\t      if (bidi) {\n\t        middle = from;\n\t        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n\t      }\n\t      var middleX = getX(middle);\n\t      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n\t      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n\t    }\n\t  }\n\t\n\t  var measureText;\n\t  // Compute the default text height.\n\t  function textHeight(display) {\n\t    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n\t    if (measureText == null) {\n\t      measureText = elt(\"pre\");\n\t      // Measure a bunch of lines, for browsers that compute\n\t      // fractional heights.\n\t      for (var i = 0; i < 49; ++i) {\n\t        measureText.appendChild(document.createTextNode(\"x\"));\n\t        measureText.appendChild(elt(\"br\"));\n\t      }\n\t      measureText.appendChild(document.createTextNode(\"x\"));\n\t    }\n\t    removeChildrenAndAdd(display.measure, measureText);\n\t    var height = measureText.offsetHeight / 50;\n\t    if (height > 3) display.cachedTextHeight = height;\n\t    removeChildren(display.measure);\n\t    return height || 1;\n\t  }\n\t\n\t  // Compute the default character width.\n\t  function charWidth(display) {\n\t    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n\t    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n\t    var pre = elt(\"pre\", [anchor]);\n\t    removeChildrenAndAdd(display.measure, pre);\n\t    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n\t    if (width > 2) display.cachedCharWidth = width;\n\t    return width || 10;\n\t  }\n\t\n\t  // OPERATIONS\n\t\n\t  // Operations are used to wrap a series of changes to the editor\n\t  // state in such a way that each change won't have to update the\n\t  // cursor and display (which would be awkward, slow, and\n\t  // error-prone). Instead, display updates are batched and then all\n\t  // combined and executed at once.\n\t\n\t  var operationGroup = null;\n\t\n\t  var nextOpId = 0;\n\t  // Start a new operation.\n\t  function startOperation(cm) {\n\t    cm.curOp = {\n\t      cm: cm,\n\t      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n\t      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n\t      forceUpdate: false,      // Used to force a redraw\n\t      updateInput: null,       // Whether to reset the input textarea\n\t      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n\t      changeObjs: null,        // Accumulated changes, for firing change events\n\t      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n\t      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n\t      selectionChanged: false, // Whether the selection needs to be redrawn\n\t      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n\t      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n\t      scrollToPos: null,       // Used to scroll to a specific position\n\t      focus: false,\n\t      id: ++nextOpId           // Unique ID\n\t    };\n\t    if (operationGroup) {\n\t      operationGroup.ops.push(cm.curOp);\n\t    } else {\n\t      cm.curOp.ownsGroup = operationGroup = {\n\t        ops: [cm.curOp],\n\t        delayedCallbacks: []\n\t      };\n\t    }\n\t  }\n\t\n\t  function fireCallbacksForOps(group) {\n\t    // Calls delayed callbacks and cursorActivity handlers until no\n\t    // new ones appear\n\t    var callbacks = group.delayedCallbacks, i = 0;\n\t    do {\n\t      for (; i < callbacks.length; i++)\n\t        callbacks[i].call(null);\n\t      for (var j = 0; j < group.ops.length; j++) {\n\t        var op = group.ops[j];\n\t        if (op.cursorActivityHandlers)\n\t          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n\t            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n\t      }\n\t    } while (i < callbacks.length);\n\t  }\n\t\n\t  // Finish an operation, updating the display and signalling delayed events\n\t  function endOperation(cm) {\n\t    var op = cm.curOp, group = op.ownsGroup;\n\t    if (!group) return;\n\t\n\t    try { fireCallbacksForOps(group); }\n\t    finally {\n\t      operationGroup = null;\n\t      for (var i = 0; i < group.ops.length; i++)\n\t        group.ops[i].cm.curOp = null;\n\t      endOperations(group);\n\t    }\n\t  }\n\t\n\t  // The DOM updates done when an operation finishes are batched so\n\t  // that the minimum number of relayouts are required.\n\t  function endOperations(group) {\n\t    var ops = group.ops;\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W1(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_R2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n\t      endOperation_W2(ops[i]);\n\t    for (var i = 0; i < ops.length; i++) // Read DOM\n\t      endOperation_finish(ops[i]);\n\t  }\n\t\n\t  function endOperation_R1(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    maybeClipScrollbars(cm);\n\t    if (op.updateMaxLine) findMaxLine(cm);\n\t\n\t    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n\t      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n\t                         op.scrollToPos.to.line >= display.viewTo) ||\n\t      display.maxLineChanged && cm.options.lineWrapping;\n\t    op.update = op.mustUpdate &&\n\t      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n\t  }\n\t\n\t  function endOperation_W1(op) {\n\t    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n\t  }\n\t\n\t  function endOperation_R2(op) {\n\t    var cm = op.cm, display = cm.display;\n\t    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\t\n\t    op.barMeasure = measureForScrollbars(cm);\n\t\n\t    // If the max line changed since it was last measured, measure it,\n\t    // and ensure the document's width matches it.\n\t    // updateDisplay_W2 will use these properties to do the actual resizing\n\t    if (display.maxLineChanged && !cm.options.lineWrapping) {\n\t      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n\t      cm.display.sizerWidth = op.adjustWidthTo;\n\t      op.barMeasure.scrollWidth =\n\t        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n\t      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n\t    }\n\t\n\t    if (op.updatedDisplay || op.selectionChanged)\n\t      op.preparedSelection = display.input.prepareSelection(op.focus);\n\t  }\n\t\n\t  function endOperation_W2(op) {\n\t    var cm = op.cm;\n\t\n\t    if (op.adjustWidthTo != null) {\n\t      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n\t      if (op.maxScrollLeft < cm.doc.scrollLeft)\n\t        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n\t      cm.display.maxLineChanged = false;\n\t    }\n\t\n\t    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())\n\t    if (op.preparedSelection)\n\t      cm.display.input.showSelection(op.preparedSelection, takeFocus);\n\t    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n\t      updateScrollbars(cm, op.barMeasure);\n\t    if (op.updatedDisplay)\n\t      setDocumentHeight(cm, op.barMeasure);\n\t\n\t    if (op.selectionChanged) restartBlink(cm);\n\t\n\t    if (cm.state.focused && op.updateInput)\n\t      cm.display.input.reset(op.typing);\n\t    if (takeFocus) ensureFocus(op.cm);\n\t  }\n\t\n\t  function endOperation_finish(op) {\n\t    var cm = op.cm, display = cm.display, doc = cm.doc;\n\t\n\t    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\t\n\t    // Abort mouse wheel delta measurement, when scrolling explicitly\n\t    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n\t      display.wheelStartX = display.wheelStartY = null;\n\t\n\t    // Propagate the scroll position to the actual DOM scroller\n\t    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n\t      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n\t      display.scrollbars.setScrollTop(doc.scrollTop);\n\t      display.scroller.scrollTop = doc.scrollTop;\n\t    }\n\t    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n\t      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));\n\t      display.scrollbars.setScrollLeft(doc.scrollLeft);\n\t      display.scroller.scrollLeft = doc.scrollLeft;\n\t      alignHorizontally(cm);\n\t    }\n\t    // If we need to scroll a specific position into view, do so.\n\t    if (op.scrollToPos) {\n\t      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n\t                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n\t      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n\t    }\n\t\n\t    // Fire events for markers that are hidden/unidden by editing or\n\t    // undoing\n\t    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n\t    if (hidden) for (var i = 0; i < hidden.length; ++i)\n\t      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n\t    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n\t      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\t\n\t    if (display.wrapper.offsetHeight)\n\t      doc.scrollTop = cm.display.scroller.scrollTop;\n\t\n\t    // Fire change events, and delayed event handlers\n\t    if (op.changeObjs)\n\t      signal(cm, \"changes\", cm, op.changeObjs);\n\t    if (op.update)\n\t      op.update.finish();\n\t  }\n\t\n\t  // Run the given function in an operation\n\t  function runInOp(cm, f) {\n\t    if (cm.curOp) return f();\n\t    startOperation(cm);\n\t    try { return f(); }\n\t    finally { endOperation(cm); }\n\t  }\n\t  // Wraps a function in an operation. Returns the wrapped function.\n\t  function operation(cm, f) {\n\t    return function() {\n\t      if (cm.curOp) return f.apply(cm, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(cm, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t  // Used to add methods to editor and doc instances, wrapping them in\n\t  // operations.\n\t  function methodOp(f) {\n\t    return function() {\n\t      if (this.curOp) return f.apply(this, arguments);\n\t      startOperation(this);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(this); }\n\t    };\n\t  }\n\t  function docMethodOp(f) {\n\t    return function() {\n\t      var cm = this.cm;\n\t      if (!cm || cm.curOp) return f.apply(this, arguments);\n\t      startOperation(cm);\n\t      try { return f.apply(this, arguments); }\n\t      finally { endOperation(cm); }\n\t    };\n\t  }\n\t\n\t  // VIEW TRACKING\n\t\n\t  // These objects are used to represent the visible (currently drawn)\n\t  // part of the document. A LineView may correspond to multiple\n\t  // logical lines, if those are connected by collapsed ranges.\n\t  function LineView(doc, line, lineN) {\n\t    // The starting line\n\t    this.line = line;\n\t    // Continuing lines, if any\n\t    this.rest = visualLineContinued(line);\n\t    // Number of logical lines in this visual line\n\t    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n\t    this.node = this.text = null;\n\t    this.hidden = lineIsHidden(doc, line);\n\t  }\n\t\n\t  // Create a range of LineView objects for the given lines.\n\t  function buildViewArray(cm, from, to) {\n\t    var array = [], nextPos;\n\t    for (var pos = from; pos < to; pos = nextPos) {\n\t      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n\t      nextPos = pos + view.size;\n\t      array.push(view);\n\t    }\n\t    return array;\n\t  }\n\t\n\t  // Updates the display.view data structure for a given change to the\n\t  // document. From and to are in pre-change coordinates. Lendiff is\n\t  // the amount of lines added or subtracted by the change. This is\n\t  // used for changes that span multiple lines, or change the way\n\t  // lines are divided into visual lines. regLineChange (below)\n\t  // registers single-line changes.\n\t  function regChange(cm, from, to, lendiff) {\n\t    if (from == null) from = cm.doc.first;\n\t    if (to == null) to = cm.doc.first + cm.doc.size;\n\t    if (!lendiff) lendiff = 0;\n\t\n\t    var display = cm.display;\n\t    if (lendiff && to < display.viewTo &&\n\t        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n\t      display.updateLineNumbers = from;\n\t\n\t    cm.curOp.viewChanged = true;\n\t\n\t    if (from >= display.viewTo) { // Change after\n\t      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n\t        resetView(cm);\n\t    } else if (to <= display.viewFrom) { // Change before\n\t      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n\t        resetView(cm);\n\t      } else {\n\t        display.viewFrom += lendiff;\n\t        display.viewTo += lendiff;\n\t      }\n\t    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n\t      resetView(cm);\n\t    } else if (from <= display.viewFrom) { // Top overlap\n\t      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cut) {\n\t        display.view = display.view.slice(cut.index);\n\t        display.viewFrom = cut.lineN;\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else if (to >= display.viewTo) { // Bottom overlap\n\t      var cut = viewCuttingPoint(cm, from, from, -1);\n\t      if (cut) {\n\t        display.view = display.view.slice(0, cut.index);\n\t        display.viewTo = cut.lineN;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    } else { // Gap in the middle\n\t      var cutTop = viewCuttingPoint(cm, from, from, -1);\n\t      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n\t      if (cutTop && cutBot) {\n\t        display.view = display.view.slice(0, cutTop.index)\n\t          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n\t          .concat(display.view.slice(cutBot.index));\n\t        display.viewTo += lendiff;\n\t      } else {\n\t        resetView(cm);\n\t      }\n\t    }\n\t\n\t    var ext = display.externalMeasured;\n\t    if (ext) {\n\t      if (to < ext.lineN)\n\t        ext.lineN += lendiff;\n\t      else if (from < ext.lineN + ext.size)\n\t        display.externalMeasured = null;\n\t    }\n\t  }\n\t\n\t  // Register a change to a single line. Type must be one of \"text\",\n\t  // \"gutter\", \"class\", \"widget\"\n\t  function regLineChange(cm, line, type) {\n\t    cm.curOp.viewChanged = true;\n\t    var display = cm.display, ext = cm.display.externalMeasured;\n\t    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n\t      display.externalMeasured = null;\n\t\n\t    if (line < display.viewFrom || line >= display.viewTo) return;\n\t    var lineView = display.view[findViewIndex(cm, line)];\n\t    if (lineView.node == null) return;\n\t    var arr = lineView.changes || (lineView.changes = []);\n\t    if (indexOf(arr, type) == -1) arr.push(type);\n\t  }\n\t\n\t  // Clear the view.\n\t  function resetView(cm) {\n\t    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n\t    cm.display.view = [];\n\t    cm.display.viewOffset = 0;\n\t  }\n\t\n\t  // Find the view element corresponding to a given line. Return null\n\t  // when the line isn't visible.\n\t  function findViewIndex(cm, n) {\n\t    if (n >= cm.display.viewTo) return null;\n\t    n -= cm.display.viewFrom;\n\t    if (n < 0) return null;\n\t    var view = cm.display.view;\n\t    for (var i = 0; i < view.length; i++) {\n\t      n -= view[i].size;\n\t      if (n < 0) return i;\n\t    }\n\t  }\n\t\n\t  function viewCuttingPoint(cm, oldN, newN, dir) {\n\t    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n\t    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n\t      return {index: index, lineN: newN};\n\t    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n\t      n += view[i].size;\n\t    if (n != oldN) {\n\t      if (dir > 0) {\n\t        if (index == view.length - 1) return null;\n\t        diff = (n + view[index].size) - oldN;\n\t        index++;\n\t      } else {\n\t        diff = n - oldN;\n\t      }\n\t      oldN += diff; newN += diff;\n\t    }\n\t    while (visualLineNo(cm.doc, newN) != newN) {\n\t      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n\t      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n\t      index += dir;\n\t    }\n\t    return {index: index, lineN: newN};\n\t  }\n\t\n\t  // Force the view to cover a given range, adding empty view element\n\t  // or clipping off existing ones as needed.\n\t  function adjustView(cm, from, to) {\n\t    var display = cm.display, view = display.view;\n\t    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n\t      display.view = buildViewArray(cm, from, to);\n\t      display.viewFrom = from;\n\t    } else {\n\t      if (display.viewFrom > from)\n\t        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n\t      else if (display.viewFrom < from)\n\t        display.view = display.view.slice(findViewIndex(cm, from));\n\t      display.viewFrom = from;\n\t      if (display.viewTo < to)\n\t        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n\t      else if (display.viewTo > to)\n\t        display.view = display.view.slice(0, findViewIndex(cm, to));\n\t    }\n\t    display.viewTo = to;\n\t  }\n\t\n\t  // Count the number of lines in the view whose DOM representation is\n\t  // out of date (or nonexistent).\n\t  function countDirtyView(cm) {\n\t    var view = cm.display.view, dirty = 0;\n\t    for (var i = 0; i < view.length; i++) {\n\t      var lineView = view[i];\n\t      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n\t    }\n\t    return dirty;\n\t  }\n\t\n\t  // EVENT HANDLERS\n\t\n\t  // Attach the necessary event handlers when initializing the editor\n\t  function registerEventHandlers(cm) {\n\t    var d = cm.display;\n\t    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n\t    // Older IE's will not fire a second mousedown for a double click\n\t    if (ie && ie_version < 11)\n\t      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n\t        if (signalDOMEvent(cm, e)) return;\n\t        var pos = posFromMouse(cm, e);\n\t        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n\t        e_preventDefault(e);\n\t        var word = cm.findWordAt(pos);\n\t        extendSelection(cm.doc, word.anchor, word.head);\n\t      }));\n\t    else\n\t      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n\t    // Some browsers fire contextmenu *after* opening the menu, at\n\t    // which point we can't mess with it anymore. Context menu is\n\t    // handled in onMouseDown for these browsers.\n\t    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\t\n\t    // Used to suppress mouse event handling when a touch happens\n\t    var touchFinished, prevTouch = {end: 0};\n\t    function finishTouch() {\n\t      if (d.activeTouch) {\n\t        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n\t        prevTouch = d.activeTouch;\n\t        prevTouch.end = +new Date;\n\t      }\n\t    };\n\t    function isMouseLikeTouchEvent(e) {\n\t      if (e.touches.length != 1) return false;\n\t      var touch = e.touches[0];\n\t      return touch.radiusX <= 1 && touch.radiusY <= 1;\n\t    }\n\t    function farAway(touch, other) {\n\t      if (other.left == null) return true;\n\t      var dx = other.left - touch.left, dy = other.top - touch.top;\n\t      return dx * dx + dy * dy > 20 * 20;\n\t    }\n\t    on(d.scroller, \"touchstart\", function(e) {\n\t      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n\t        clearTimeout(touchFinished);\n\t        var now = +new Date;\n\t        d.activeTouch = {start: now, moved: false,\n\t                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n\t        if (e.touches.length == 1) {\n\t          d.activeTouch.left = e.touches[0].pageX;\n\t          d.activeTouch.top = e.touches[0].pageY;\n\t        }\n\t      }\n\t    });\n\t    on(d.scroller, \"touchmove\", function() {\n\t      if (d.activeTouch) d.activeTouch.moved = true;\n\t    });\n\t    on(d.scroller, \"touchend\", function(e) {\n\t      var touch = d.activeTouch;\n\t      if (touch && !eventInWidget(d, e) && touch.left != null &&\n\t          !touch.moved && new Date - touch.start < 300) {\n\t        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n\t        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n\t          range = new Range(pos, pos);\n\t        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n\t          range = cm.findWordAt(pos);\n\t        else // Triple tap\n\t          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n\t        cm.setSelection(range.anchor, range.head);\n\t        cm.focus();\n\t        e_preventDefault(e);\n\t      }\n\t      finishTouch();\n\t    });\n\t    on(d.scroller, \"touchcancel\", finishTouch);\n\t\n\t    // Sync scrolling between fake scrollbars and real scrollable\n\t    // area, ensure viewport is updated when scrolling.\n\t    on(d.scroller, \"scroll\", function() {\n\t      if (d.scroller.clientHeight) {\n\t        setScrollTop(cm, d.scroller.scrollTop);\n\t        setScrollLeft(cm, d.scroller.scrollLeft, true);\n\t        signal(cm, \"scroll\", cm);\n\t      }\n\t    });\n\t\n\t    // Listen to wheel events in order to try and update the viewport on time.\n\t    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n\t    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\t\n\t    // Prevent wrapper from ever scrolling\n\t    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\t\n\t    d.dragFunctions = {\n\t      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n\t      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n\t      start: function(e){onDragStart(cm, e);},\n\t      drop: operation(cm, onDrop),\n\t      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n\t    };\n\t\n\t    var inp = d.input.getField();\n\t    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n\t    on(inp, \"keydown\", operation(cm, onKeyDown));\n\t    on(inp, \"keypress\", operation(cm, onKeyPress));\n\t    on(inp, \"focus\", function (e) { onFocus(cm, e); });\n\t    on(inp, \"blur\", function (e) { onBlur(cm, e); });\n\t  }\n\t\n\t  function dragDropChanged(cm, value, old) {\n\t    var wasOn = old && old != CodeMirror.Init;\n\t    if (!value != !wasOn) {\n\t      var funcs = cm.display.dragFunctions;\n\t      var toggle = value ? on : off;\n\t      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n\t      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n\t      toggle(cm.display.scroller, \"dragover\", funcs.over);\n\t      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n\t      toggle(cm.display.scroller, \"drop\", funcs.drop);\n\t    }\n\t  }\n\t\n\t  // Called when the window resizes\n\t  function onResize(cm) {\n\t    var d = cm.display;\n\t    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n\t      return;\n\t    // Might be a text scaling operation, clear size caches.\n\t    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\t    d.scrollbarsClipped = false;\n\t    cm.setSize();\n\t  }\n\t\n\t  // MOUSE EVENTS\n\t\n\t  // Return true when the given mouse event happened in a widget\n\t  function eventInWidget(display, e) {\n\t    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n\t      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n\t          (n.parentNode == display.sizer && n != display.mover))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // Given a mouse event, find the corresponding position. If liberal\n\t  // is false, it checks whether a gutter or scrollbar was clicked,\n\t  // and returns null if it was. forRect is used by rectangular\n\t  // selections, and tries to estimate a character position even for\n\t  // coordinates beyond the right of the text.\n\t  function posFromMouse(cm, e, liberal, forRect) {\n\t    var display = cm.display;\n\t    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\t\n\t    var x, y, space = display.lineSpace.getBoundingClientRect();\n\t    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\t    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n\t    catch (e) { return null; }\n\t    var coords = coordsChar(cm, x, y), line;\n\t    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n\t      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n\t      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // A mouse down can be a single click, double click, triple click,\n\t  // start of selection drag, start of text drag, new cursor\n\t  // (ctrl-click), rectangle drag (alt-drag), or xwin\n\t  // middle-click-paste. Or it might be a click on something we should\n\t  // not interfere with, such as a scrollbar or widget.\n\t  function onMouseDown(e) {\n\t    var cm = this, display = cm.display;\n\t    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;\n\t    display.shift = e.shiftKey;\n\t\n\t    if (eventInWidget(display, e)) {\n\t      if (!webkit) {\n\t        // Briefly turn off draggability, to allow widgets to do\n\t        // normal dragging things.\n\t        display.scroller.draggable = false;\n\t        setTimeout(function(){display.scroller.draggable = true;}, 100);\n\t      }\n\t      return;\n\t    }\n\t    if (clickInGutter(cm, e)) return;\n\t    var start = posFromMouse(cm, e);\n\t    window.focus();\n\t\n\t    switch (e_button(e)) {\n\t    case 1:\n\t      // #3261: make sure, that we're not starting a second selection\n\t      if (cm.state.selectingText)\n\t        cm.state.selectingText(e);\n\t      else if (start)\n\t        leftButtonDown(cm, e, start);\n\t      else if (e_target(e) == display.scroller)\n\t        e_preventDefault(e);\n\t      break;\n\t    case 2:\n\t      if (webkit) cm.state.lastMiddleDown = +new Date;\n\t      if (start) extendSelection(cm.doc, start);\n\t      setTimeout(function() {display.input.focus();}, 20);\n\t      e_preventDefault(e);\n\t      break;\n\t    case 3:\n\t      if (captureRightClick) onContextMenu(cm, e);\n\t      else delayBlurEvent(cm);\n\t      break;\n\t    }\n\t  }\n\t\n\t  var lastClick, lastDoubleClick;\n\t  function leftButtonDown(cm, e, start) {\n\t    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n\t    else cm.curOp.focus = activeElt();\n\t\n\t    var now = +new Date, type;\n\t    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n\t      type = \"triple\";\n\t    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n\t      type = \"double\";\n\t      lastDoubleClick = {time: now, pos: start};\n\t    } else {\n\t      type = \"single\";\n\t      lastClick = {time: now, pos: start};\n\t    }\n\t\n\t    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n\t    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n\t        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n\t        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n\t        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n\t      leftButtonStartDrag(cm, e, start, modifier);\n\t    else\n\t      leftButtonSelect(cm, e, start, type, modifier);\n\t  }\n\t\n\t  // Start a text drag. When it ends, see if any dragging actually\n\t  // happen, and treat as a click if it didn't.\n\t  function leftButtonStartDrag(cm, e, start, modifier) {\n\t    var display = cm.display, startTime = +new Date;\n\t    var dragEnd = operation(cm, function(e2) {\n\t      if (webkit) display.scroller.draggable = false;\n\t      cm.state.draggingText = false;\n\t      off(document, \"mouseup\", dragEnd);\n\t      off(display.scroller, \"drop\", dragEnd);\n\t      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n\t        e_preventDefault(e2);\n\t        if (!modifier && +new Date - 200 < startTime)\n\t          extendSelection(cm.doc, start);\n\t        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n\t        if (webkit || ie && ie_version == 9)\n\t          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n\t        else\n\t          display.input.focus();\n\t      }\n\t    });\n\t    // Let the drag handler handle this.\n\t    if (webkit) display.scroller.draggable = true;\n\t    cm.state.draggingText = dragEnd;\n\t    dragEnd.copy = mac ? e.altKey : e.ctrlKey\n\t    // IE's approach to draggable\n\t    if (display.scroller.dragDrop) display.scroller.dragDrop();\n\t    on(document, \"mouseup\", dragEnd);\n\t    on(display.scroller, \"drop\", dragEnd);\n\t  }\n\t\n\t  // Normal selection, as opposed to text dragging.\n\t  function leftButtonSelect(cm, e, start, type, addNew) {\n\t    var display = cm.display, doc = cm.doc;\n\t    e_preventDefault(e);\n\t\n\t    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n\t    if (addNew && !e.shiftKey) {\n\t      ourIndex = doc.sel.contains(start);\n\t      if (ourIndex > -1)\n\t        ourRange = ranges[ourIndex];\n\t      else\n\t        ourRange = new Range(start, start);\n\t    } else {\n\t      ourRange = doc.sel.primary();\n\t      ourIndex = doc.sel.primIndex;\n\t    }\n\t\n\t    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\n\t      type = \"rect\";\n\t      if (!addNew) ourRange = new Range(start, start);\n\t      start = posFromMouse(cm, e, true, true);\n\t      ourIndex = -1;\n\t    } else if (type == \"double\") {\n\t      var word = cm.findWordAt(start);\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n\t      else\n\t        ourRange = word;\n\t    } else if (type == \"triple\") {\n\t      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n\t      if (cm.display.shift || doc.extend)\n\t        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n\t      else\n\t        ourRange = line;\n\t    } else {\n\t      ourRange = extendRange(doc, ourRange, start);\n\t    }\n\t\n\t    if (!addNew) {\n\t      ourIndex = 0;\n\t      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n\t      startSel = doc.sel;\n\t    } else if (ourIndex == -1) {\n\t      ourIndex = ranges.length;\n\t      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n\t      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n\t                   {scroll: false, origin: \"*mouse\"});\n\t      startSel = doc.sel;\n\t    } else {\n\t      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n\t    }\n\t\n\t    var lastPos = start;\n\t    function extendTo(pos) {\n\t      if (cmp(lastPos, pos) == 0) return;\n\t      lastPos = pos;\n\t\n\t      if (type == \"rect\") {\n\t        var ranges = [], tabSize = cm.options.tabSize;\n\t        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n\t        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n\t        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n\t        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n\t             line <= end; line++) {\n\t          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n\t          if (left == right)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n\t          else if (text.length > leftPos)\n\t            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n\t        }\n\t        if (!ranges.length) ranges.push(new Range(start, start));\n\t        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n\t                     {origin: \"*mouse\", scroll: false});\n\t        cm.scrollIntoView(pos);\n\t      } else {\n\t        var oldRange = ourRange;\n\t        var anchor = oldRange.anchor, head = pos;\n\t        if (type != \"single\") {\n\t          if (type == \"double\")\n\t            var range = cm.findWordAt(pos);\n\t          else\n\t            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n\t          if (cmp(range.anchor, anchor) > 0) {\n\t            head = range.head;\n\t            anchor = minPos(oldRange.from(), range.anchor);\n\t          } else {\n\t            head = range.anchor;\n\t            anchor = maxPos(oldRange.to(), range.head);\n\t          }\n\t        }\n\t        var ranges = startSel.ranges.slice(0);\n\t        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n\t        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n\t      }\n\t    }\n\t\n\t    var editorSize = display.wrapper.getBoundingClientRect();\n\t    // Used to ensure timeout re-tries don't fire when another extend\n\t    // happened in the meantime (clearTimeout isn't reliable -- at\n\t    // least on Chrome, the timeouts still happen even when cleared,\n\t    // if the clear happens after their scheduled firing time).\n\t    var counter = 0;\n\t\n\t    function extend(e) {\n\t      var curCount = ++counter;\n\t      var cur = posFromMouse(cm, e, true, type == \"rect\");\n\t      if (!cur) return;\n\t      if (cmp(cur, lastPos) != 0) {\n\t        cm.curOp.focus = activeElt();\n\t        extendTo(cur);\n\t        var visible = visibleLines(display, doc);\n\t        if (cur.line >= visible.to || cur.line < visible.from)\n\t          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n\t      } else {\n\t        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\t        if (outside) setTimeout(operation(cm, function() {\n\t          if (counter != curCount) return;\n\t          display.scroller.scrollTop += outside;\n\t          extend(e);\n\t        }), 50);\n\t      }\n\t    }\n\t\n\t    function done(e) {\n\t      cm.state.selectingText = false;\n\t      counter = Infinity;\n\t      e_preventDefault(e);\n\t      display.input.focus();\n\t      off(document, \"mousemove\", move);\n\t      off(document, \"mouseup\", up);\n\t      doc.history.lastSelOrigin = null;\n\t    }\n\t\n\t    var move = operation(cm, function(e) {\n\t      if (!e_button(e)) done(e);\n\t      else extend(e);\n\t    });\n\t    var up = operation(cm, done);\n\t    cm.state.selectingText = up;\n\t    on(document, \"mousemove\", move);\n\t    on(document, \"mouseup\", up);\n\t  }\n\t\n\t  // Determines whether an event happened in the gutter, and fires the\n\t  // handlers for the corresponding event.\n\t  function gutterEvent(cm, e, type, prevent) {\n\t    try { var mX = e.clientX, mY = e.clientY; }\n\t    catch(e) { return false; }\n\t    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n\t    if (prevent) e_preventDefault(e);\n\t\n\t    var display = cm.display;\n\t    var lineBox = display.lineDiv.getBoundingClientRect();\n\t\n\t    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n\t    mY -= lineBox.top - display.viewOffset;\n\t\n\t    for (var i = 0; i < cm.options.gutters.length; ++i) {\n\t      var g = display.gutters.childNodes[i];\n\t      if (g && g.getBoundingClientRect().right >= mX) {\n\t        var line = lineAtHeight(cm.doc, mY);\n\t        var gutter = cm.options.gutters[i];\n\t        signal(cm, type, cm, line, gutter, e);\n\t        return e_defaultPrevented(e);\n\t      }\n\t    }\n\t  }\n\t\n\t  function clickInGutter(cm, e) {\n\t    return gutterEvent(cm, e, \"gutterClick\", true);\n\t  }\n\t\n\t  // Kludge to work around strange IE behavior where it'll sometimes\n\t  // re-fire a series of drag-related events right after the drop (#1551)\n\t  var lastDrop = 0;\n\t\n\t  function onDrop(e) {\n\t    var cm = this;\n\t    clearDragCursor(cm);\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n\t      return;\n\t    e_preventDefault(e);\n\t    if (ie) lastDrop = +new Date;\n\t    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n\t    if (!pos || cm.isReadOnly()) return;\n\t    // Might be a file drop, in which case we simply extract the text\n\t    // and insert it.\n\t    if (files && files.length && window.FileReader && window.File) {\n\t      var n = files.length, text = Array(n), read = 0;\n\t      var loadFile = function(file, i) {\n\t        if (cm.options.allowDropFileTypes &&\n\t            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n\t          return;\n\t\n\t        var reader = new FileReader;\n\t        reader.onload = operation(cm, function() {\n\t          var content = reader.result;\n\t          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n\t          text[i] = content;\n\t          if (++read == n) {\n\t            pos = clipPos(cm.doc, pos);\n\t            var change = {from: pos, to: pos,\n\t                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n\t                          origin: \"paste\"};\n\t            makeChange(cm.doc, change);\n\t            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n\t          }\n\t        });\n\t        reader.readAsText(file);\n\t      };\n\t      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n\t    } else { // Normal drop\n\t      // Don't do a replace if the drop happened inside of the selected text.\n\t      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n\t        cm.state.draggingText(e);\n\t        // Ensure the editor is re-focused\n\t        setTimeout(function() {cm.display.input.focus();}, 20);\n\t        return;\n\t      }\n\t      try {\n\t        var text = e.dataTransfer.getData(\"Text\");\n\t        if (text) {\n\t          if (cm.state.draggingText && !cm.state.draggingText.copy)\n\t            var selected = cm.listSelections();\n\t          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n\t          if (selected) for (var i = 0; i < selected.length; ++i)\n\t            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n\t          cm.replaceSelection(text, \"around\", \"paste\");\n\t          cm.display.input.focus();\n\t        }\n\t      }\n\t      catch(e){}\n\t    }\n\t  }\n\t\n\t  function onDragStart(cm, e) {\n\t    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n\t    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\t\n\t    e.dataTransfer.setData(\"Text\", cm.getSelection());\n\t    e.dataTransfer.effectAllowed = \"copyMove\"\n\t\n\t    // Use dummy image instead of default browsers image.\n\t    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\t    if (e.dataTransfer.setDragImage && !safari) {\n\t      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n\t      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\t      if (presto) {\n\t        img.width = img.height = 1;\n\t        cm.display.wrapper.appendChild(img);\n\t        // Force a relayout, or Opera won't use our image for some obscure reason\n\t        img._top = img.offsetTop;\n\t      }\n\t      e.dataTransfer.setDragImage(img, 0, 0);\n\t      if (presto) img.parentNode.removeChild(img);\n\t    }\n\t  }\n\t\n\t  function onDragOver(cm, e) {\n\t    var pos = posFromMouse(cm, e);\n\t    if (!pos) return;\n\t    var frag = document.createDocumentFragment();\n\t    drawSelectionCursor(cm, pos, frag);\n\t    if (!cm.display.dragCursor) {\n\t      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n\t      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n\t    }\n\t    removeChildrenAndAdd(cm.display.dragCursor, frag);\n\t  }\n\t\n\t  function clearDragCursor(cm) {\n\t    if (cm.display.dragCursor) {\n\t      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n\t      cm.display.dragCursor = null;\n\t    }\n\t  }\n\t\n\t  // SCROLL EVENTS\n\t\n\t  // Sync the scrollable area and scrollbars, ensure the viewport\n\t  // covers the visible area.\n\t  function setScrollTop(cm, val) {\n\t    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n\t    cm.doc.scrollTop = val;\n\t    if (!gecko) updateDisplaySimple(cm, {top: val});\n\t    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n\t    cm.display.scrollbars.setScrollTop(val);\n\t    if (gecko) updateDisplaySimple(cm);\n\t    startWorker(cm, 100);\n\t  }\n\t  // Sync scroller and scrollbar, ensure the gutter elements are\n\t  // aligned.\n\t  function setScrollLeft(cm, val, isScroller) {\n\t    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n\t    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n\t    cm.doc.scrollLeft = val;\n\t    alignHorizontally(cm);\n\t    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n\t    cm.display.scrollbars.setScrollLeft(val);\n\t  }\n\t\n\t  // Since the delta values reported on mouse wheel events are\n\t  // unstandardized between browsers and even browser versions, and\n\t  // generally horribly unpredictable, this code starts by measuring\n\t  // the scroll effect that the first few mouse wheel events have,\n\t  // and, from that, detects the way it can convert deltas to pixel\n\t  // offsets afterwards.\n\t  //\n\t  // The reason we want to know the amount a wheel event will scroll\n\t  // is that it gives us a chance to update the display before the\n\t  // actual scrolling happens, reducing flickering.\n\t\n\t  var wheelSamples = 0, wheelPixelsPerUnit = null;\n\t  // Fill in a browser-detected starting value on browsers where we\n\t  // know one. These don't have to be accurate -- the result of them\n\t  // being wrong would just be a slight flicker on the first wheel\n\t  // scroll (if it is large enough).\n\t  if (ie) wheelPixelsPerUnit = -.53;\n\t  else if (gecko) wheelPixelsPerUnit = 15;\n\t  else if (chrome) wheelPixelsPerUnit = -.7;\n\t  else if (safari) wheelPixelsPerUnit = -1/3;\n\t\n\t  var wheelEventDelta = function(e) {\n\t    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n\t    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n\t    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n\t    else if (dy == null) dy = e.wheelDelta;\n\t    return {x: dx, y: dy};\n\t  };\n\t  CodeMirror.wheelEventPixels = function(e) {\n\t    var delta = wheelEventDelta(e);\n\t    delta.x *= wheelPixelsPerUnit;\n\t    delta.y *= wheelPixelsPerUnit;\n\t    return delta;\n\t  };\n\t\n\t  function onScrollWheel(cm, e) {\n\t    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\t\n\t    var display = cm.display, scroll = display.scroller;\n\t    // Quit if there's nothing to scroll here\n\t    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n\t    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n\t    if (!(dx && canScrollX || dy && canScrollY)) return;\n\t\n\t    // Webkit browsers on OS X abort momentum scrolls when the target\n\t    // of the scroll event is removed from the scrollable element.\n\t    // This hack (see related code in patchDisplay) makes sure the\n\t    // element is kept around.\n\t    if (dy && mac && webkit) {\n\t      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n\t        for (var i = 0; i < view.length; i++) {\n\t          if (view[i].node == cur) {\n\t            cm.display.currentWheelTarget = cur;\n\t            break outer;\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    // On some browsers, horizontal scrolling will cause redraws to\n\t    // happen before the gutter has been realigned, causing it to\n\t    // wriggle around in a most unseemly way. When we have an\n\t    // estimated pixels/delta value, we just handle horizontal\n\t    // scrolling entirely here. It'll be slightly off from native, but\n\t    // better than glitching out.\n\t    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n\t      if (dy && canScrollY)\n\t        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n\t      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n\t      // Only prevent default scrolling if vertical scrolling is\n\t      // actually possible. Otherwise, it causes vertical scroll\n\t      // jitter on OSX trackpads when deltaX is small and deltaY\n\t      // is large (issue #3579)\n\t      if (!dy || (dy && canScrollY))\n\t        e_preventDefault(e);\n\t      display.wheelStartX = null; // Abort measurement, if in progress\n\t      return;\n\t    }\n\t\n\t    // 'Project' the visible viewport to cover the area that is being\n\t    // scrolled into view (if we know enough to estimate it).\n\t    if (dy && wheelPixelsPerUnit != null) {\n\t      var pixels = dy * wheelPixelsPerUnit;\n\t      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n\t      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n\t      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n\t      updateDisplaySimple(cm, {top: top, bottom: bot});\n\t    }\n\t\n\t    if (wheelSamples < 20) {\n\t      if (display.wheelStartX == null) {\n\t        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n\t        display.wheelDX = dx; display.wheelDY = dy;\n\t        setTimeout(function() {\n\t          if (display.wheelStartX == null) return;\n\t          var movedX = scroll.scrollLeft - display.wheelStartX;\n\t          var movedY = scroll.scrollTop - display.wheelStartY;\n\t          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n\t            (movedX && display.wheelDX && movedX / display.wheelDX);\n\t          display.wheelStartX = display.wheelStartY = null;\n\t          if (!sample) return;\n\t          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n\t          ++wheelSamples;\n\t        }, 200);\n\t      } else {\n\t        display.wheelDX += dx; display.wheelDY += dy;\n\t      }\n\t    }\n\t  }\n\t\n\t  // KEY EVENTS\n\t\n\t  // Run a handler that was bound to a key.\n\t  function doHandleBinding(cm, bound, dropShift) {\n\t    if (typeof bound == \"string\") {\n\t      bound = commands[bound];\n\t      if (!bound) return false;\n\t    }\n\t    // Ensure previous input has been read, so that the handler sees a\n\t    // consistent view of the document\n\t    cm.display.input.ensurePolled();\n\t    var prevShift = cm.display.shift, done = false;\n\t    try {\n\t      if (cm.isReadOnly()) cm.state.suppressEdits = true;\n\t      if (dropShift) cm.display.shift = false;\n\t      done = bound(cm) != Pass;\n\t    } finally {\n\t      cm.display.shift = prevShift;\n\t      cm.state.suppressEdits = false;\n\t    }\n\t    return done;\n\t  }\n\t\n\t  function lookupKeyForEditor(cm, name, handle) {\n\t    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n\t      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n\t      if (result) return result;\n\t    }\n\t    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n\t      || lookupKey(name, cm.options.keyMap, handle, cm);\n\t  }\n\t\n\t  var stopSeq = new Delayed;\n\t  function dispatchKey(cm, name, e, handle) {\n\t    var seq = cm.state.keySeq;\n\t    if (seq) {\n\t      if (isModifierKey(name)) return \"handled\";\n\t      stopSeq.set(50, function() {\n\t        if (cm.state.keySeq == seq) {\n\t          cm.state.keySeq = null;\n\t          cm.display.input.reset();\n\t        }\n\t      });\n\t      name = seq + \" \" + name;\n\t    }\n\t    var result = lookupKeyForEditor(cm, name, handle);\n\t\n\t    if (result == \"multi\")\n\t      cm.state.keySeq = name;\n\t    if (result == \"handled\")\n\t      signalLater(cm, \"keyHandled\", cm, name, e);\n\t\n\t    if (result == \"handled\" || result == \"multi\") {\n\t      e_preventDefault(e);\n\t      restartBlink(cm);\n\t    }\n\t\n\t    if (seq && !result && /\\'$/.test(name)) {\n\t      e_preventDefault(e);\n\t      return true;\n\t    }\n\t    return !!result;\n\t  }\n\t\n\t  // Handle a key from the keydown event.\n\t  function handleKeyBinding(cm, e) {\n\t    var name = keyName(e, true);\n\t    if (!name) return false;\n\t\n\t    if (e.shiftKey && !cm.state.keySeq) {\n\t      // First try to resolve full name (including 'Shift-'). Failing\n\t      // that, see if there is a cursor-motion command (starting with\n\t      // 'go') bound to the keyname without 'Shift-'.\n\t      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n\t          || dispatchKey(cm, name, e, function(b) {\n\t               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n\t                 return doHandleBinding(cm, b);\n\t             });\n\t    } else {\n\t      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n\t    }\n\t  }\n\t\n\t  // Handle a key from the keypress event\n\t  function handleCharBinding(cm, e, ch) {\n\t    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n\t                       function(b) { return doHandleBinding(cm, b, true); });\n\t  }\n\t\n\t  var lastStoppedKey = null;\n\t  function onKeyDown(e) {\n\t    var cm = this;\n\t    cm.curOp.focus = activeElt();\n\t    if (signalDOMEvent(cm, e)) return;\n\t    // IE does strange things with escape.\n\t    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n\t    var code = e.keyCode;\n\t    cm.display.shift = code == 16 || e.shiftKey;\n\t    var handled = handleKeyBinding(cm, e);\n\t    if (presto) {\n\t      lastStoppedKey = handled ? code : null;\n\t      // Opera has no cut event... we try to at least catch the key combo\n\t      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n\t        cm.replaceSelection(\"\", null, \"cut\");\n\t    }\n\t\n\t    // Turn mouse into crosshair when Alt is held on Mac.\n\t    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n\t      showCrossHair(cm);\n\t  }\n\t\n\t  function showCrossHair(cm) {\n\t    var lineDiv = cm.display.lineDiv;\n\t    addClass(lineDiv, \"CodeMirror-crosshair\");\n\t\n\t    function up(e) {\n\t      if (e.keyCode == 18 || !e.altKey) {\n\t        rmClass(lineDiv, \"CodeMirror-crosshair\");\n\t        off(document, \"keyup\", up);\n\t        off(document, \"mouseover\", up);\n\t      }\n\t    }\n\t    on(document, \"keyup\", up);\n\t    on(document, \"mouseover\", up);\n\t  }\n\t\n\t  function onKeyUp(e) {\n\t    if (e.keyCode == 16) this.doc.sel.shift = false;\n\t    signalDOMEvent(this, e);\n\t  }\n\t\n\t  function onKeyPress(e) {\n\t    var cm = this;\n\t    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n\t    var keyCode = e.keyCode, charCode = e.charCode;\n\t    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n\t    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n\t    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n\t    if (handleCharBinding(cm, e, ch)) return;\n\t    cm.display.input.onKeyPress(e);\n\t  }\n\t\n\t  // FOCUS/BLUR EVENTS\n\t\n\t  function delayBlurEvent(cm) {\n\t    cm.state.delayingBlurEvent = true;\n\t    setTimeout(function() {\n\t      if (cm.state.delayingBlurEvent) {\n\t        cm.state.delayingBlurEvent = false;\n\t        onBlur(cm);\n\t      }\n\t    }, 100);\n\t  }\n\t\n\t  function onFocus(cm, e) {\n\t    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\t\n\t    if (cm.options.readOnly == \"nocursor\") return;\n\t    if (!cm.state.focused) {\n\t      signal(cm, \"focus\", cm, e);\n\t      cm.state.focused = true;\n\t      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t      // This test prevents this from firing when a context\n\t      // menu is closed (since the input reset would kill the\n\t      // select-all detection hack)\n\t      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n\t        cm.display.input.reset();\n\t        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n\t      }\n\t      cm.display.input.receivedFocus();\n\t    }\n\t    restartBlink(cm);\n\t  }\n\t  function onBlur(cm, e) {\n\t    if (cm.state.delayingBlurEvent) return;\n\t\n\t    if (cm.state.focused) {\n\t      signal(cm, \"blur\", cm, e);\n\t      cm.state.focused = false;\n\t      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n\t    }\n\t    clearInterval(cm.display.blinker);\n\t    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n\t  }\n\t\n\t  // CONTEXT MENU HANDLING\n\t\n\t  // To make the context menu work, we need to briefly unhide the\n\t  // textarea (making it as unobtrusive as possible) to let the\n\t  // right-click take effect on it.\n\t  function onContextMenu(cm, e) {\n\t    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n\t    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n\t    cm.display.input.onContextMenu(e);\n\t  }\n\t\n\t  function contextMenuInGutter(cm, e) {\n\t    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n\t    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n\t  }\n\t\n\t  // UPDATING\n\t\n\t  // Compute the position of the end of a change (its 'to' property\n\t  // refers to the pre-change end).\n\t  var changeEnd = CodeMirror.changeEnd = function(change) {\n\t    if (!change.text) return change.to;\n\t    return Pos(change.from.line + change.text.length - 1,\n\t               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n\t  };\n\t\n\t  // Adjust a position to refer to the post-change position of the\n\t  // same text, or the end of the change if the change covers it.\n\t  function adjustForChange(pos, change) {\n\t    if (cmp(pos, change.from) < 0) return pos;\n\t    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\t\n\t    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n\t    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n\t    return Pos(line, ch);\n\t  }\n\t\n\t  function computeSelAfterChange(doc, change) {\n\t    var out = [];\n\t    for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t      var range = doc.sel.ranges[i];\n\t      out.push(new Range(adjustForChange(range.anchor, change),\n\t                         adjustForChange(range.head, change)));\n\t    }\n\t    return normalizeSelection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  function offsetPos(pos, old, nw) {\n\t    if (pos.line == old.line)\n\t      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n\t    else\n\t      return Pos(nw.line + (pos.line - old.line), pos.ch);\n\t  }\n\t\n\t  // Used by replaceSelections to allow moving the selection to the\n\t  // start or around the replaced test. Hint may be \"start\" or \"around\".\n\t  function computeReplacedSel(doc, changes, hint) {\n\t    var out = [];\n\t    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n\t    for (var i = 0; i < changes.length; i++) {\n\t      var change = changes[i];\n\t      var from = offsetPos(change.from, oldPrev, newPrev);\n\t      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n\t      oldPrev = change.to;\n\t      newPrev = to;\n\t      if (hint == \"around\") {\n\t        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n\t        out[i] = new Range(inv ? to : from, inv ? from : to);\n\t      } else {\n\t        out[i] = new Range(from, from);\n\t      }\n\t    }\n\t    return new Selection(out, doc.sel.primIndex);\n\t  }\n\t\n\t  // Allow \"beforeChange\" event handlers to influence a change\n\t  function filterChange(doc, change, update) {\n\t    var obj = {\n\t      canceled: false,\n\t      from: change.from,\n\t      to: change.to,\n\t      text: change.text,\n\t      origin: change.origin,\n\t      cancel: function() { this.canceled = true; }\n\t    };\n\t    if (update) obj.update = function(from, to, text, origin) {\n\t      if (from) this.from = clipPos(doc, from);\n\t      if (to) this.to = clipPos(doc, to);\n\t      if (text) this.text = text;\n\t      if (origin !== undefined) this.origin = origin;\n\t    };\n\t    signal(doc, \"beforeChange\", doc, obj);\n\t    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\t\n\t    if (obj.canceled) return null;\n\t    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n\t  }\n\t\n\t  // Apply a change to a document, and add it to the document's\n\t  // history, and propagating it to all linked documents.\n\t  function makeChange(doc, change, ignoreReadOnly) {\n\t    if (doc.cm) {\n\t      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n\t      if (doc.cm.state.suppressEdits) return;\n\t    }\n\t\n\t    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n\t      change = filterChange(doc, change, true);\n\t      if (!change) return;\n\t    }\n\t\n\t    // Possibly split or suppress the update based on the presence\n\t    // of read-only spans in its range.\n\t    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\t    if (split) {\n\t      for (var i = split.length - 1; i >= 0; --i)\n\t        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n\t    } else {\n\t      makeChangeInner(doc, change);\n\t    }\n\t  }\n\t\n\t  function makeChangeInner(doc, change) {\n\t    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n\t    var selAfter = computeSelAfterChange(doc, change);\n\t    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\t\n\t    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n\t    var rebased = [];\n\t\n\t    linkedDocs(doc, function(doc, sharedHist) {\n\t      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t        rebaseHist(doc.history, change);\n\t        rebased.push(doc.history);\n\t      }\n\t      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n\t    });\n\t  }\n\t\n\t  // Revert a change stored in a document's history.\n\t  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n\t    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) return;\n\t\n\t    var hist = doc.history, event, selAfter = doc.sel;\n\t    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\t\n\t    // Verify that there is a useable event (so that ctrl-z won't\n\t    // needlessly clear selection events)\n\t    for (var i = 0; i < source.length; i++) {\n\t      event = source[i];\n\t      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n\t        break;\n\t    }\n\t    if (i == source.length) return;\n\t    hist.lastOrigin = hist.lastSelOrigin = null;\n\t\n\t    for (;;) {\n\t      event = source.pop();\n\t      if (event.ranges) {\n\t        pushSelectionToHistory(event, dest);\n\t        if (allowSelectionOnly && !event.equals(doc.sel)) {\n\t          setSelection(doc, event, {clearRedo: false});\n\t          return;\n\t        }\n\t        selAfter = event;\n\t      }\n\t      else break;\n\t    }\n\t\n\t    // Build up a reverse change object to add to the opposite history\n\t    // stack (redo when undoing, and vice versa).\n\t    var antiChanges = [];\n\t    pushSelectionToHistory(selAfter, dest);\n\t    dest.push({changes: antiChanges, generation: hist.generation});\n\t    hist.generation = event.generation || ++hist.maxGeneration;\n\t\n\t    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\t\n\t    for (var i = event.changes.length - 1; i >= 0; --i) {\n\t      var change = event.changes[i];\n\t      change.origin = type;\n\t      if (filter && !filterChange(doc, change, false)) {\n\t        source.length = 0;\n\t        return;\n\t      }\n\t\n\t      antiChanges.push(historyChangeFromChange(doc, change));\n\t\n\t      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n\t      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\t      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n\t      var rebased = [];\n\t\n\t      // Propagate to the linked documents\n\t      linkedDocs(doc, function(doc, sharedHist) {\n\t        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n\t          rebaseHist(doc.history, change);\n\t          rebased.push(doc.history);\n\t        }\n\t        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n\t      });\n\t    }\n\t  }\n\t\n\t  // Sub-views need their line numbers shifted when text is added\n\t  // above or below them in the parent document.\n\t  function shiftDoc(doc, distance) {\n\t    if (distance == 0) return;\n\t    doc.first += distance;\n\t    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n\t      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n\t                       Pos(range.head.line + distance, range.head.ch));\n\t    }), doc.sel.primIndex);\n\t    if (doc.cm) {\n\t      regChange(doc.cm, doc.first, doc.first - distance, distance);\n\t      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n\t        regLineChange(doc.cm, l, \"gutter\");\n\t    }\n\t  }\n\t\n\t  // More lower-level change function, handling only a single document\n\t  // (not linked ones).\n\t  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n\t    if (doc.cm && !doc.cm.curOp)\n\t      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\t\n\t    if (change.to.line < doc.first) {\n\t      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n\t      return;\n\t    }\n\t    if (change.from.line > doc.lastLine()) return;\n\t\n\t    // Clip the change to the size of this doc\n\t    if (change.from.line < doc.first) {\n\t      var shift = change.text.length - 1 - (doc.first - change.from.line);\n\t      shiftDoc(doc, shift);\n\t      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n\t                text: [lst(change.text)], origin: change.origin};\n\t    }\n\t    var last = doc.lastLine();\n\t    if (change.to.line > last) {\n\t      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n\t                text: [change.text[0]], origin: change.origin};\n\t    }\n\t\n\t    change.removed = getBetween(doc, change.from, change.to);\n\t\n\t    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n\t    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n\t    else updateDoc(doc, change, spans);\n\t    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\t  }\n\t\n\t  // Handle the interaction of a change to a document with the editor\n\t  // that this document is part of.\n\t  function makeChangeSingleDocInEditor(cm, change, spans) {\n\t    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\t\n\t    var recomputeMaxLength = false, checkWidthStart = from.line;\n\t    if (!cm.options.lineWrapping) {\n\t      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n\t      doc.iter(checkWidthStart, to.line + 1, function(line) {\n\t        if (line == display.maxLine) {\n\t          recomputeMaxLength = true;\n\t          return true;\n\t        }\n\t      });\n\t    }\n\t\n\t    if (doc.sel.contains(change.from, change.to) > -1)\n\t      signalCursorActivity(cm);\n\t\n\t    updateDoc(doc, change, spans, estimateHeight(cm));\n\t\n\t    if (!cm.options.lineWrapping) {\n\t      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n\t        var len = lineLength(line);\n\t        if (len > display.maxLineLength) {\n\t          display.maxLine = line;\n\t          display.maxLineLength = len;\n\t          display.maxLineChanged = true;\n\t          recomputeMaxLength = false;\n\t        }\n\t      });\n\t      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n\t    }\n\t\n\t    // Adjust frontier, schedule worker\n\t    doc.frontier = Math.min(doc.frontier, from.line);\n\t    startWorker(cm, 400);\n\t\n\t    var lendiff = change.text.length - (to.line - from.line) - 1;\n\t    // Remember that these lines changed, for updating the display\n\t    if (change.full)\n\t      regChange(cm);\n\t    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n\t      regLineChange(cm, from.line, \"text\");\n\t    else\n\t      regChange(cm, from.line, to.line + 1, lendiff);\n\t\n\t    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n\t    if (changeHandler || changesHandler) {\n\t      var obj = {\n\t        from: from, to: to,\n\t        text: change.text,\n\t        removed: change.removed,\n\t        origin: change.origin\n\t      };\n\t      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n\t      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n\t    }\n\t    cm.display.selForContextMenu = null;\n\t  }\n\t\n\t  function replaceRange(doc, code, from, to, origin) {\n\t    if (!to) to = from;\n\t    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n\t    if (typeof code == \"string\") code = doc.splitLines(code);\n\t    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n\t  }\n\t\n\t  // SCROLLING THINGS INTO VIEW\n\t\n\t  // If an editor sits on the top or bottom of the window, partially\n\t  // scrolled out of view, this ensures that the cursor is visible.\n\t  function maybeScrollWindow(cm, coords) {\n\t    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\t\n\t    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n\t    if (coords.top + box.top < 0) doScroll = true;\n\t    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n\t    if (doScroll != null && !phantom) {\n\t      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n\t                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n\t                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n\t                           coords.left + \"px; width: 2px;\");\n\t      cm.display.lineSpace.appendChild(scrollNode);\n\t      scrollNode.scrollIntoView(doScroll);\n\t      cm.display.lineSpace.removeChild(scrollNode);\n\t    }\n\t  }\n\t\n\t  // Scroll a given position into view (immediately), verifying that\n\t  // it actually became visible (as line heights are accurately\n\t  // measured, the position of something may 'drift' during drawing).\n\t  function scrollPosIntoView(cm, pos, end, margin) {\n\t    if (margin == null) margin = 0;\n\t    for (var limit = 0; limit < 5; limit++) {\n\t      var changed = false, coords = cursorCoords(cm, pos);\n\t      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n\t      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n\t                                         Math.min(coords.top, endCoords.top) - margin,\n\t                                         Math.max(coords.left, endCoords.left),\n\t                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n\t      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n\t      if (scrollPos.scrollTop != null) {\n\t        setScrollTop(cm, scrollPos.scrollTop);\n\t        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n\t      }\n\t      if (scrollPos.scrollLeft != null) {\n\t        setScrollLeft(cm, scrollPos.scrollLeft);\n\t        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n\t      }\n\t      if (!changed) break;\n\t    }\n\t    return coords;\n\t  }\n\t\n\t  // Scroll a given set of coordinates into view (immediately).\n\t  function scrollIntoView(cm, x1, y1, x2, y2) {\n\t    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n\t    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n\t    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n\t  }\n\t\n\t  // Calculate a new scroll position needed to scroll the given\n\t  // rectangle into view. Returns an object with scrollTop and\n\t  // scrollLeft properties. When these are undefined, the\n\t  // vertical/horizontal position does not need to be adjusted.\n\t  function calculateScrollPos(cm, x1, y1, x2, y2) {\n\t    var display = cm.display, snapMargin = textHeight(cm.display);\n\t    if (y1 < 0) y1 = 0;\n\t    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n\t    var screen = displayHeight(cm), result = {};\n\t    if (y2 - y1 > screen) y2 = y1 + screen;\n\t    var docBottom = cm.doc.height + paddingVert(display);\n\t    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n\t    if (y1 < screentop) {\n\t      result.scrollTop = atTop ? 0 : y1;\n\t    } else if (y2 > screentop + screen) {\n\t      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n\t      if (newTop != screentop) result.scrollTop = newTop;\n\t    }\n\t\n\t    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n\t    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n\t    var tooWide = x2 - x1 > screenw;\n\t    if (tooWide) x2 = x1 + screenw;\n\t    if (x1 < 10)\n\t      result.scrollLeft = 0;\n\t    else if (x1 < screenleft)\n\t      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n\t    else if (x2 > screenw + screenleft - 3)\n\t      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n\t    return result;\n\t  }\n\t\n\t  // Store a relative adjustment to the scroll position in the current\n\t  // operation (to be applied when the operation finishes).\n\t  function addToScrollPos(cm, left, top) {\n\t    if (left != null || top != null) resolveScrollToPos(cm);\n\t    if (left != null)\n\t      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n\t    if (top != null)\n\t      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n\t  }\n\t\n\t  // Make sure that at the end of the operation the current cursor is\n\t  // shown.\n\t  function ensureCursorVisible(cm) {\n\t    resolveScrollToPos(cm);\n\t    var cur = cm.getCursor(), from = cur, to = cur;\n\t    if (!cm.options.lineWrapping) {\n\t      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n\t      to = Pos(cur.line, cur.ch + 1);\n\t    }\n\t    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n\t  }\n\t\n\t  // When an operation has its scrollToPos property set, and another\n\t  // scroll action is applied before the end of the operation, this\n\t  // 'simulates' scrolling that position into view in a cheap way, so\n\t  // that the effect of intermediate scroll commands is not ignored.\n\t  function resolveScrollToPos(cm) {\n\t    var range = cm.curOp.scrollToPos;\n\t    if (range) {\n\t      cm.curOp.scrollToPos = null;\n\t      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n\t      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n\t                                    Math.min(from.top, to.top) - range.margin,\n\t                                    Math.max(from.right, to.right),\n\t                                    Math.max(from.bottom, to.bottom) + range.margin);\n\t      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t    }\n\t  }\n\t\n\t  // API UTILITIES\n\t\n\t  // Indent the given line. The how parameter can be \"smart\",\n\t  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n\t  // (typically set to true for forced single-line indents), empty\n\t  // lines are not indented, and places where the mode returns Pass\n\t  // are left alone.\n\t  function indentLine(cm, n, how, aggressive) {\n\t    var doc = cm.doc, state;\n\t    if (how == null) how = \"add\";\n\t    if (how == \"smart\") {\n\t      // Fall back to \"prev\" when the mode doesn't have an indentation\n\t      // method.\n\t      if (!doc.mode.indent) how = \"prev\";\n\t      else state = getStateBefore(cm, n);\n\t    }\n\t\n\t    var tabSize = cm.options.tabSize;\n\t    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n\t    if (!aggressive && !/\\S/.test(line.text)) {\n\t      indentation = 0;\n\t      how = \"not\";\n\t    } else if (how == \"smart\") {\n\t      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\t      if (indentation == Pass || indentation > 150) {\n\t        if (!aggressive) return;\n\t        how = \"prev\";\n\t      }\n\t    }\n\t    if (how == \"prev\") {\n\t      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n\t      else indentation = 0;\n\t    } else if (how == \"add\") {\n\t      indentation = curSpace + cm.options.indentUnit;\n\t    } else if (how == \"subtract\") {\n\t      indentation = curSpace - cm.options.indentUnit;\n\t    } else if (typeof how == \"number\") {\n\t      indentation = curSpace + how;\n\t    }\n\t    indentation = Math.max(0, indentation);\n\t\n\t    var indentString = \"\", pos = 0;\n\t    if (cm.options.indentWithTabs)\n\t      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n\t    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\t\n\t    if (indentString != curSpaceString) {\n\t      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\t      line.stateAfter = null;\n\t      return true;\n\t    } else {\n\t      // Ensure that, if the cursor was in the whitespace at the start\n\t      // of the line, it is moved to the end of that space.\n\t      for (var i = 0; i < doc.sel.ranges.length; i++) {\n\t        var range = doc.sel.ranges[i];\n\t        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n\t          var pos = Pos(n, curSpaceString.length);\n\t          replaceOneSelection(doc, i, new Range(pos, pos));\n\t          break;\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // Utility for applying a change to a line by handle or number,\n\t  // returning the number and optionally registering the line as\n\t  // changed.\n\t  function changeLine(doc, handle, changeType, op) {\n\t    var no = handle, line = handle;\n\t    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n\t    else no = lineNo(handle);\n\t    if (no == null) return null;\n\t    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n\t    return line;\n\t  }\n\t\n\t  // Helper for deleting text near the selection(s), used to implement\n\t  // backspace, delete, and similar functionality.\n\t  function deleteNearSelection(cm, compute) {\n\t    var ranges = cm.doc.sel.ranges, kill = [];\n\t    // Build up a set of ranges to kill first, merging overlapping\n\t    // ranges.\n\t    for (var i = 0; i < ranges.length; i++) {\n\t      var toKill = compute(ranges[i]);\n\t      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n\t        var replaced = kill.pop();\n\t        if (cmp(replaced.from, toKill.from) < 0) {\n\t          toKill.from = replaced.from;\n\t          break;\n\t        }\n\t      }\n\t      kill.push(toKill);\n\t    }\n\t    // Next, remove those actual ranges.\n\t    runInOp(cm, function() {\n\t      for (var i = kill.length - 1; i >= 0; i--)\n\t        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n\t      ensureCursorVisible(cm);\n\t    });\n\t  }\n\t\n\t  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n\t  // right), unit can be \"char\", \"column\" (like char, but doesn't\n\t  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n\t  // the start of next group of word or non-word-non-whitespace\n\t  // chars). The visually param controls whether, in right-to-left\n\t  // text, direction 1 means to move towards the next index in the\n\t  // string, or towards the character to the right of the current\n\t  // position. The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosH(doc, pos, dir, unit, visually) {\n\t    var line = pos.line, ch = pos.ch, origDir = dir;\n\t    var lineObj = getLine(doc, line);\n\t    function findNextLine() {\n\t      var l = line + dir;\n\t      if (l < doc.first || l >= doc.first + doc.size) return false\n\t      line = l;\n\t      return lineObj = getLine(doc, l);\n\t    }\n\t    function moveOnce(boundToLine) {\n\t      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n\t      if (next == null) {\n\t        if (!boundToLine && findNextLine()) {\n\t          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n\t          else ch = dir < 0 ? lineObj.text.length : 0;\n\t        } else return false\n\t      } else ch = next;\n\t      return true;\n\t    }\n\t\n\t    if (unit == \"char\") {\n\t      moveOnce()\n\t    } else if (unit == \"column\") {\n\t      moveOnce(true)\n\t    } else if (unit == \"word\" || unit == \"group\") {\n\t      var sawType = null, group = unit == \"group\";\n\t      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n\t      for (var first = true;; first = false) {\n\t        if (dir < 0 && !moveOnce(!first)) break;\n\t        var cur = lineObj.text.charAt(ch) || \"\\n\";\n\t        var type = isWordChar(cur, helper) ? \"w\"\n\t          : group && cur == \"\\n\" ? \"n\"\n\t          : !group || /\\s/.test(cur) ? null\n\t          : \"p\";\n\t        if (group && !first && !type) type = \"s\";\n\t        if (sawType && sawType != type) {\n\t          if (dir < 0) {dir = 1; moveOnce();}\n\t          break;\n\t        }\n\t\n\t        if (type) sawType = type;\n\t        if (dir > 0 && !moveOnce(!first)) break;\n\t      }\n\t    }\n\t    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);\n\t    if (!cmp(pos, result)) result.hitSide = true;\n\t    return result;\n\t  }\n\t\n\t  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n\t  // \"page\" or \"line\". The resulting position will have a hitSide=true\n\t  // property if it reached the end of the document.\n\t  function findPosV(cm, pos, dir, unit) {\n\t    var doc = cm.doc, x = pos.left, y;\n\t    if (unit == \"page\") {\n\t      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n\t      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n\t      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\t    } else if (unit == \"line\") {\n\t      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n\t    }\n\t    for (;;) {\n\t      var target = coordsChar(cm, x, y);\n\t      if (!target.outside) break;\n\t      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n\t      y += dir * 5;\n\t    }\n\t    return target;\n\t  }\n\t\n\t  // EDITOR METHODS\n\t\n\t  // The publicly visible API. Note that methodOp(f) means\n\t  // 'wrap f in an operation, performed on its `this` parameter'.\n\t\n\t  // This is not the complete set of editor methods. Most of the\n\t  // methods defined on the Doc type are also injected into\n\t  // CodeMirror.prototype, for backwards compatibility and\n\t  // convenience.\n\t\n\t  CodeMirror.prototype = {\n\t    constructor: CodeMirror,\n\t    focus: function(){window.focus(); this.display.input.focus();},\n\t\n\t    setOption: function(option, value) {\n\t      var options = this.options, old = options[option];\n\t      if (options[option] == value && option != \"mode\") return;\n\t      options[option] = value;\n\t      if (optionHandlers.hasOwnProperty(option))\n\t        operation(this, optionHandlers[option])(this, value, old);\n\t    },\n\t\n\t    getOption: function(option) {return this.options[option];},\n\t    getDoc: function() {return this.doc;},\n\t\n\t    addKeyMap: function(map, bottom) {\n\t      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n\t    },\n\t    removeKeyMap: function(map) {\n\t      var maps = this.state.keyMaps;\n\t      for (var i = 0; i < maps.length; ++i)\n\t        if (maps[i] == map || maps[i].name == map) {\n\t          maps.splice(i, 1);\n\t          return true;\n\t        }\n\t    },\n\t\n\t    addOverlay: methodOp(function(spec, options) {\n\t      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\t      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n\t      insertSorted(this.state.overlays,\n\t                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n\t                    priority: (options && options.priority) || 0},\n\t                   function(overlay) { return overlay.priority })\n\t      this.state.modeGen++;\n\t      regChange(this);\n\t    }),\n\t    removeOverlay: methodOp(function(spec) {\n\t      var overlays = this.state.overlays;\n\t      for (var i = 0; i < overlays.length; ++i) {\n\t        var cur = overlays[i].modeSpec;\n\t        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n\t          overlays.splice(i, 1);\n\t          this.state.modeGen++;\n\t          regChange(this);\n\t          return;\n\t        }\n\t      }\n\t    }),\n\t\n\t    indentLine: methodOp(function(n, dir, aggressive) {\n\t      if (typeof dir != \"string\" && typeof dir != \"number\") {\n\t        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n\t        else dir = dir ? \"add\" : \"subtract\";\n\t      }\n\t      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n\t    }),\n\t    indentSelection: methodOp(function(how) {\n\t      var ranges = this.doc.sel.ranges, end = -1;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var range = ranges[i];\n\t        if (!range.empty()) {\n\t          var from = range.from(), to = range.to();\n\t          var start = Math.max(end, from.line);\n\t          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n\t          for (var j = start; j < end; ++j)\n\t            indentLine(this, j, how);\n\t          var newRanges = this.doc.sel.ranges;\n\t          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n\t            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n\t        } else if (range.head.line > end) {\n\t          indentLine(this, range.head.line, how, true);\n\t          end = range.head.line;\n\t          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n\t        }\n\t      }\n\t    }),\n\t\n\t    // Fetch the parser token for a given character. Useful for hacks\n\t    // that want to inspect the mode state (say, for completion).\n\t    getTokenAt: function(pos, precise) {\n\t      return takeToken(this, pos, precise);\n\t    },\n\t\n\t    getLineTokens: function(line, precise) {\n\t      return takeToken(this, Pos(line), precise, true);\n\t    },\n\t\n\t    getTokenTypeAt: function(pos) {\n\t      pos = clipPos(this.doc, pos);\n\t      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n\t      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n\t      var type;\n\t      if (ch == 0) type = styles[2];\n\t      else for (;;) {\n\t        var mid = (before + after) >> 1;\n\t        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n\t        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n\t        else { type = styles[mid * 2 + 2]; break; }\n\t      }\n\t      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n\t      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n\t    },\n\t\n\t    getModeAt: function(pos) {\n\t      var mode = this.doc.mode;\n\t      if (!mode.innerMode) return mode;\n\t      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n\t    },\n\t\n\t    getHelper: function(pos, type) {\n\t      return this.getHelpers(pos, type)[0];\n\t    },\n\t\n\t    getHelpers: function(pos, type) {\n\t      var found = [];\n\t      if (!helpers.hasOwnProperty(type)) return found;\n\t      var help = helpers[type], mode = this.getModeAt(pos);\n\t      if (typeof mode[type] == \"string\") {\n\t        if (help[mode[type]]) found.push(help[mode[type]]);\n\t      } else if (mode[type]) {\n\t        for (var i = 0; i < mode[type].length; i++) {\n\t          var val = help[mode[type][i]];\n\t          if (val) found.push(val);\n\t        }\n\t      } else if (mode.helperType && help[mode.helperType]) {\n\t        found.push(help[mode.helperType]);\n\t      } else if (help[mode.name]) {\n\t        found.push(help[mode.name]);\n\t      }\n\t      for (var i = 0; i < help._global.length; i++) {\n\t        var cur = help._global[i];\n\t        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n\t          found.push(cur.val);\n\t      }\n\t      return found;\n\t    },\n\t\n\t    getStateAfter: function(line, precise) {\n\t      var doc = this.doc;\n\t      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n\t      return getStateBefore(this, line + 1, precise);\n\t    },\n\t\n\t    cursorCoords: function(start, mode) {\n\t      var pos, range = this.doc.sel.primary();\n\t      if (start == null) pos = range.head;\n\t      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n\t      else pos = start ? range.from() : range.to();\n\t      return cursorCoords(this, pos, mode || \"page\");\n\t    },\n\t\n\t    charCoords: function(pos, mode) {\n\t      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n\t    },\n\t\n\t    coordsChar: function(coords, mode) {\n\t      coords = fromCoordSystem(this, coords, mode || \"page\");\n\t      return coordsChar(this, coords.left, coords.top);\n\t    },\n\t\n\t    lineAtHeight: function(height, mode) {\n\t      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n\t      return lineAtHeight(this.doc, height + this.display.viewOffset);\n\t    },\n\t    heightAtLine: function(line, mode) {\n\t      var end = false, lineObj;\n\t      if (typeof line == \"number\") {\n\t        var last = this.doc.first + this.doc.size - 1;\n\t        if (line < this.doc.first) line = this.doc.first;\n\t        else if (line > last) { line = last; end = true; }\n\t        lineObj = getLine(this.doc, line);\n\t      } else {\n\t        lineObj = line;\n\t      }\n\t      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n\t        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n\t    },\n\t\n\t    defaultTextHeight: function() { return textHeight(this.display); },\n\t    defaultCharWidth: function() { return charWidth(this.display); },\n\t\n\t    setGutterMarker: methodOp(function(line, gutterID, value) {\n\t      return changeLine(this.doc, line, \"gutter\", function(line) {\n\t        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n\t        markers[gutterID] = value;\n\t        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    clearGutter: methodOp(function(gutterID) {\n\t      var cm = this, doc = cm.doc, i = doc.first;\n\t      doc.iter(function(line) {\n\t        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n\t          line.gutterMarkers[gutterID] = null;\n\t          regLineChange(cm, i, \"gutter\");\n\t          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n\t        }\n\t        ++i;\n\t      });\n\t    }),\n\t\n\t    lineInfo: function(line) {\n\t      if (typeof line == \"number\") {\n\t        if (!isLine(this.doc, line)) return null;\n\t        var n = line;\n\t        line = getLine(this.doc, line);\n\t        if (!line) return null;\n\t      } else {\n\t        var n = lineNo(line);\n\t        if (n == null) return null;\n\t      }\n\t      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n\t              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n\t              widgets: line.widgets};\n\t    },\n\t\n\t    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\t\n\t    addWidget: function(pos, node, scroll, vert, horiz) {\n\t      var display = this.display;\n\t      pos = cursorCoords(this, clipPos(this.doc, pos));\n\t      var top = pos.bottom, left = pos.left;\n\t      node.style.position = \"absolute\";\n\t      node.setAttribute(\"cm-ignore-events\", \"true\");\n\t      this.display.input.setUneditable(node);\n\t      display.sizer.appendChild(node);\n\t      if (vert == \"over\") {\n\t        top = pos.top;\n\t      } else if (vert == \"above\" || vert == \"near\") {\n\t        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n\t        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n\t        // Default to positioning above (if specified and possible); otherwise default to positioning below\n\t        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n\t          top = pos.top - node.offsetHeight;\n\t        else if (pos.bottom + node.offsetHeight <= vspace)\n\t          top = pos.bottom;\n\t        if (left + node.offsetWidth > hspace)\n\t          left = hspace - node.offsetWidth;\n\t      }\n\t      node.style.top = top + \"px\";\n\t      node.style.left = node.style.right = \"\";\n\t      if (horiz == \"right\") {\n\t        left = display.sizer.clientWidth - node.offsetWidth;\n\t        node.style.right = \"0px\";\n\t      } else {\n\t        if (horiz == \"left\") left = 0;\n\t        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n\t        node.style.left = left + \"px\";\n\t      }\n\t      if (scroll)\n\t        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n\t    },\n\t\n\t    triggerOnKeyDown: methodOp(onKeyDown),\n\t    triggerOnKeyPress: methodOp(onKeyPress),\n\t    triggerOnKeyUp: onKeyUp,\n\t\n\t    execCommand: function(cmd) {\n\t      if (commands.hasOwnProperty(cmd))\n\t        return commands[cmd].call(null, this);\n\t    },\n\t\n\t    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\t\n\t    findPosH: function(from, amount, unit, visually) {\n\t      var dir = 1;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        cur = findPosH(this.doc, cur, dir, unit, visually);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveH: methodOp(function(dir, unit) {\n\t      var cm = this;\n\t      cm.extendSelectionsBy(function(range) {\n\t        if (cm.display.shift || cm.doc.extend || range.empty())\n\t          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n\t        else\n\t          return dir < 0 ? range.from() : range.to();\n\t      }, sel_move);\n\t    }),\n\t\n\t    deleteH: methodOp(function(dir, unit) {\n\t      var sel = this.doc.sel, doc = this.doc;\n\t      if (sel.somethingSelected())\n\t        doc.replaceSelection(\"\", null, \"+delete\");\n\t      else\n\t        deleteNearSelection(this, function(range) {\n\t          var other = findPosH(doc, range.head, dir, unit, false);\n\t          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n\t        });\n\t    }),\n\t\n\t    findPosV: function(from, amount, unit, goalColumn) {\n\t      var dir = 1, x = goalColumn;\n\t      if (amount < 0) { dir = -1; amount = -amount; }\n\t      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n\t        var coords = cursorCoords(this, cur, \"div\");\n\t        if (x == null) x = coords.left;\n\t        else coords.left = x;\n\t        cur = findPosV(this, coords, dir, unit);\n\t        if (cur.hitSide) break;\n\t      }\n\t      return cur;\n\t    },\n\t\n\t    moveV: methodOp(function(dir, unit) {\n\t      var cm = this, doc = this.doc, goals = [];\n\t      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n\t      doc.extendSelectionsBy(function(range) {\n\t        if (collapse)\n\t          return dir < 0 ? range.from() : range.to();\n\t        var headPos = cursorCoords(cm, range.head, \"div\");\n\t        if (range.goalColumn != null) headPos.left = range.goalColumn;\n\t        goals.push(headPos.left);\n\t        var pos = findPosV(cm, headPos, dir, unit);\n\t        if (unit == \"page\" && range == doc.sel.primary())\n\t          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n\t        return pos;\n\t      }, sel_move);\n\t      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n\t        doc.sel.ranges[i].goalColumn = goals[i];\n\t    }),\n\t\n\t    // Find the word at the given position (as returned by coordsChar).\n\t    findWordAt: function(pos) {\n\t      var doc = this.doc, line = getLine(doc, pos.line).text;\n\t      var start = pos.ch, end = pos.ch;\n\t      if (line) {\n\t        var helper = this.getHelper(pos, \"wordChars\");\n\t        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n\t        var startChar = line.charAt(start);\n\t        var check = isWordChar(startChar, helper)\n\t          ? function(ch) { return isWordChar(ch, helper); }\n\t          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n\t          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n\t        while (start > 0 && check(line.charAt(start - 1))) --start;\n\t        while (end < line.length && check(line.charAt(end))) ++end;\n\t      }\n\t      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n\t    },\n\t\n\t    toggleOverwrite: function(value) {\n\t      if (value != null && value == this.state.overwrite) return;\n\t      if (this.state.overwrite = !this.state.overwrite)\n\t        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t      else\n\t        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\t\n\t      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n\t    },\n\t    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n\t    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },\n\t\n\t    scrollTo: methodOp(function(x, y) {\n\t      if (x != null || y != null) resolveScrollToPos(this);\n\t      if (x != null) this.curOp.scrollLeft = x;\n\t      if (y != null) this.curOp.scrollTop = y;\n\t    }),\n\t    getScrollInfo: function() {\n\t      var scroller = this.display.scroller;\n\t      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n\t              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n\t              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n\t              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n\t    },\n\t\n\t    scrollIntoView: methodOp(function(range, margin) {\n\t      if (range == null) {\n\t        range = {from: this.doc.sel.primary().head, to: null};\n\t        if (margin == null) margin = this.options.cursorScrollMargin;\n\t      } else if (typeof range == \"number\") {\n\t        range = {from: Pos(range, 0), to: null};\n\t      } else if (range.from == null) {\n\t        range = {from: range, to: null};\n\t      }\n\t      if (!range.to) range.to = range.from;\n\t      range.margin = margin || 0;\n\t\n\t      if (range.from.line != null) {\n\t        resolveScrollToPos(this);\n\t        this.curOp.scrollToPos = range;\n\t      } else {\n\t        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n\t                                      Math.min(range.from.top, range.to.top) - range.margin,\n\t                                      Math.max(range.from.right, range.to.right),\n\t                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n\t        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n\t      }\n\t    }),\n\t\n\t    setSize: methodOp(function(width, height) {\n\t      var cm = this;\n\t      function interpret(val) {\n\t        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n\t      }\n\t      if (width != null) cm.display.wrapper.style.width = interpret(width);\n\t      if (height != null) cm.display.wrapper.style.height = interpret(height);\n\t      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n\t      var lineNo = cm.display.viewFrom;\n\t      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n\t        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n\t          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n\t        ++lineNo;\n\t      });\n\t      cm.curOp.forceUpdate = true;\n\t      signal(cm, \"refresh\", this);\n\t    }),\n\t\n\t    operation: function(f){return runInOp(this, f);},\n\t\n\t    refresh: methodOp(function() {\n\t      var oldHeight = this.display.cachedTextHeight;\n\t      regChange(this);\n\t      this.curOp.forceUpdate = true;\n\t      clearCaches(this);\n\t      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n\t      updateGutterSpace(this);\n\t      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n\t        estimateLineHeights(this);\n\t      signal(this, \"refresh\", this);\n\t    }),\n\t\n\t    swapDoc: methodOp(function(doc) {\n\t      var old = this.doc;\n\t      old.cm = null;\n\t      attachDoc(this, doc);\n\t      clearCaches(this);\n\t      this.display.input.reset();\n\t      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n\t      this.curOp.forceScroll = true;\n\t      signalLater(this, \"swapDoc\", this, old);\n\t      return old;\n\t    }),\n\t\n\t    getInputField: function(){return this.display.input.getField();},\n\t    getWrapperElement: function(){return this.display.wrapper;},\n\t    getScrollerElement: function(){return this.display.scroller;},\n\t    getGutterElement: function(){return this.display.gutters;}\n\t  };\n\t  eventMixin(CodeMirror);\n\t\n\t  // OPTION DEFAULTS\n\t\n\t  // The default configuration options.\n\t  var defaults = CodeMirror.defaults = {};\n\t  // Functions to run when options are changed.\n\t  var optionHandlers = CodeMirror.optionHandlers = {};\n\t\n\t  function option(name, deflt, handle, notOnInit) {\n\t    CodeMirror.defaults[name] = deflt;\n\t    if (handle) optionHandlers[name] =\n\t      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n\t  }\n\t\n\t  // Passed to option handlers when there is no old value.\n\t  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\t\n\t  // These two are, on init, called from the constructor because they\n\t  // have to be initialized before the editor can start at all.\n\t  option(\"value\", \"\", function(cm, val) {\n\t    cm.setValue(val);\n\t  }, true);\n\t  option(\"mode\", null, function(cm, val) {\n\t    cm.doc.modeOption = val;\n\t    loadMode(cm);\n\t  }, true);\n\t\n\t  option(\"indentUnit\", 2, loadMode, true);\n\t  option(\"indentWithTabs\", false);\n\t  option(\"smartIndent\", true);\n\t  option(\"tabSize\", 4, function(cm) {\n\t    resetModeState(cm);\n\t    clearCaches(cm);\n\t    regChange(cm);\n\t  }, true);\n\t  option(\"lineSeparator\", null, function(cm, val) {\n\t    cm.doc.lineSep = val;\n\t    if (!val) return;\n\t    var newBreaks = [], lineNo = cm.doc.first;\n\t    cm.doc.iter(function(line) {\n\t      for (var pos = 0;;) {\n\t        var found = line.text.indexOf(val, pos);\n\t        if (found == -1) break;\n\t        pos = found + val.length;\n\t        newBreaks.push(Pos(lineNo, found));\n\t      }\n\t      lineNo++;\n\t    });\n\t    for (var i = newBreaks.length - 1; i >= 0; i--)\n\t      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n\t  });\n\t  option(\"specialChars\", /[\\u0000-\\u001f\\u007f\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n\t    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\t    if (old != CodeMirror.Init) cm.refresh();\n\t  });\n\t  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n\t  option(\"electricChars\", true);\n\t  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n\t    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n\t  }, true);\n\t  option(\"spellcheck\", false, function(cm, val) {\n\t    cm.getInputField().spellcheck = val\n\t  }, true);\n\t  option(\"rtlMoveVisually\", !windows);\n\t  option(\"wholeLineUpdateBefore\", true);\n\t\n\t  option(\"theme\", \"default\", function(cm) {\n\t    themeChanged(cm);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"keyMap\", \"default\", function(cm, val, old) {\n\t    var next = getKeyMap(val);\n\t    var prev = old != CodeMirror.Init && getKeyMap(old);\n\t    if (prev && prev.detach) prev.detach(cm, next);\n\t    if (next.attach) next.attach(cm, prev || null);\n\t  });\n\t  option(\"extraKeys\", null);\n\t\n\t  option(\"lineWrapping\", false, wrappingChanged, true);\n\t  option(\"gutters\", [], function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"fixedGutter\", true, function(cm, val) {\n\t    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n\t    cm.refresh();\n\t  }, true);\n\t  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n\t  option(\"scrollbarStyle\", \"native\", function(cm) {\n\t    initScrollbars(cm);\n\t    updateScrollbars(cm);\n\t    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n\t    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n\t  }, true);\n\t  option(\"lineNumbers\", false, function(cm) {\n\t    setGuttersForLineNumbers(cm.options);\n\t    guttersChanged(cm);\n\t  }, true);\n\t  option(\"firstLineNumber\", 1, guttersChanged, true);\n\t  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n\t  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\t\n\t  option(\"resetSelectionOnContextMenu\", true);\n\t  option(\"lineWiseCopyCut\", true);\n\t\n\t  option(\"readOnly\", false, function(cm, val) {\n\t    if (val == \"nocursor\") {\n\t      onBlur(cm);\n\t      cm.display.input.blur();\n\t      cm.display.disabled = true;\n\t    } else {\n\t      cm.display.disabled = false;\n\t    }\n\t    cm.display.input.readOnlyChanged(val)\n\t  });\n\t  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n\t  option(\"dragDrop\", true, dragDropChanged);\n\t  option(\"allowDropFileTypes\", null);\n\t\n\t  option(\"cursorBlinkRate\", 530);\n\t  option(\"cursorScrollMargin\", 0);\n\t  option(\"cursorHeight\", 1, updateSelection, true);\n\t  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n\t  option(\"workTime\", 100);\n\t  option(\"workDelay\", 100);\n\t  option(\"flattenSpans\", true, resetModeState, true);\n\t  option(\"addModeClass\", false, resetModeState, true);\n\t  option(\"pollInterval\", 100);\n\t  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n\t  option(\"historyEventDelay\", 1250);\n\t  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n\t  option(\"maxHighlightLength\", 10000, resetModeState, true);\n\t  option(\"moveInputWithCursor\", true, function(cm, val) {\n\t    if (!val) cm.display.input.resetPosition();\n\t  });\n\t\n\t  option(\"tabindex\", null, function(cm, val) {\n\t    cm.display.input.getField().tabIndex = val || \"\";\n\t  });\n\t  option(\"autofocus\", null);\n\t\n\t  // MODE DEFINITION AND QUERYING\n\t\n\t  // Known modes, by name and by MIME\n\t  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\t\n\t  // Extra arguments are stored as the mode's dependencies, which is\n\t  // used by (legacy) mechanisms like loadmode.js to automatically\n\t  // load a mode. (Preferred mechanism is the require/define calls.)\n\t  CodeMirror.defineMode = function(name, mode) {\n\t    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n\t    if (arguments.length > 2)\n\t      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n\t    modes[name] = mode;\n\t  };\n\t\n\t  CodeMirror.defineMIME = function(mime, spec) {\n\t    mimeModes[mime] = spec;\n\t  };\n\t\n\t  // Given a MIME type, a {name, ...options} config object, or a name\n\t  // string, return a mode config object.\n\t  CodeMirror.resolveMode = function(spec) {\n\t    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n\t      spec = mimeModes[spec];\n\t    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n\t      var found = mimeModes[spec.name];\n\t      if (typeof found == \"string\") found = {name: found};\n\t      spec = createObj(found, spec);\n\t      spec.name = found.name;\n\t    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n\t      return CodeMirror.resolveMode(\"application/xml\");\n\t    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n\t      return CodeMirror.resolveMode(\"application/json\");\n\t    }\n\t    if (typeof spec == \"string\") return {name: spec};\n\t    else return spec || {name: \"null\"};\n\t  };\n\t\n\t  // Given a mode spec (anything that resolveMode accepts), find and\n\t  // initialize an actual mode object.\n\t  CodeMirror.getMode = function(options, spec) {\n\t    var spec = CodeMirror.resolveMode(spec);\n\t    var mfactory = modes[spec.name];\n\t    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n\t    var modeObj = mfactory(options, spec);\n\t    if (modeExtensions.hasOwnProperty(spec.name)) {\n\t      var exts = modeExtensions[spec.name];\n\t      for (var prop in exts) {\n\t        if (!exts.hasOwnProperty(prop)) continue;\n\t        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n\t        modeObj[prop] = exts[prop];\n\t      }\n\t    }\n\t    modeObj.name = spec.name;\n\t    if (spec.helperType) modeObj.helperType = spec.helperType;\n\t    if (spec.modeProps) for (var prop in spec.modeProps)\n\t      modeObj[prop] = spec.modeProps[prop];\n\t\n\t    return modeObj;\n\t  };\n\t\n\t  // Minimal default mode.\n\t  CodeMirror.defineMode(\"null\", function() {\n\t    return {token: function(stream) {stream.skipToEnd();}};\n\t  });\n\t  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\t\n\t  // This can be used to attach properties to mode objects from\n\t  // outside the actual mode definition.\n\t  var modeExtensions = CodeMirror.modeExtensions = {};\n\t  CodeMirror.extendMode = function(mode, properties) {\n\t    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n\t    copyObj(properties, exts);\n\t  };\n\t\n\t  // EXTENSIONS\n\t\n\t  CodeMirror.defineExtension = function(name, func) {\n\t    CodeMirror.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineDocExtension = function(name, func) {\n\t    Doc.prototype[name] = func;\n\t  };\n\t  CodeMirror.defineOption = option;\n\t\n\t  var initHooks = [];\n\t  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\t\n\t  var helpers = CodeMirror.helpers = {};\n\t  CodeMirror.registerHelper = function(type, name, value) {\n\t    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n\t    helpers[type][name] = value;\n\t  };\n\t  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n\t    CodeMirror.registerHelper(type, name, value);\n\t    helpers[type]._global.push({pred: predicate, val: value});\n\t  };\n\t\n\t  // MODE STATE HANDLING\n\t\n\t  // Utility functions for working with state. Exported because nested\n\t  // modes need to do this for their inner modes.\n\t\n\t  var copyState = CodeMirror.copyState = function(mode, state) {\n\t    if (state === true) return state;\n\t    if (mode.copyState) return mode.copyState(state);\n\t    var nstate = {};\n\t    for (var n in state) {\n\t      var val = state[n];\n\t      if (val instanceof Array) val = val.concat([]);\n\t      nstate[n] = val;\n\t    }\n\t    return nstate;\n\t  };\n\t\n\t  var startState = CodeMirror.startState = function(mode, a1, a2) {\n\t    return mode.startState ? mode.startState(a1, a2) : true;\n\t  };\n\t\n\t  // Given a mode and a state (for that mode), find the inner mode and\n\t  // state at the position that the state refers to.\n\t  CodeMirror.innerMode = function(mode, state) {\n\t    while (mode.innerMode) {\n\t      var info = mode.innerMode(state);\n\t      if (!info || info.mode == mode) break;\n\t      state = info.state;\n\t      mode = info.mode;\n\t    }\n\t    return info || {mode: mode, state: state};\n\t  };\n\t\n\t  // STANDARD COMMANDS\n\t\n\t  // Commands are parameter-less actions that can be performed on an\n\t  // editor, mostly used for keybindings.\n\t  var commands = CodeMirror.commands = {\n\t    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n\t    singleSelection: function(cm) {\n\t      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n\t    },\n\t    killLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        if (range.empty()) {\n\t          var len = getLine(cm.doc, range.head.line).text.length;\n\t          if (range.head.ch == len && range.head.line < cm.lastLine())\n\t            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n\t          else\n\t            return {from: range.head, to: Pos(range.head.line, len)};\n\t        } else {\n\t          return {from: range.from(), to: range.to()};\n\t        }\n\t      });\n\t    },\n\t    deleteLine: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0),\n\t                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n\t      });\n\t    },\n\t    delLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        return {from: Pos(range.from().line, 0), to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineLeft: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        return {from: leftPos, to: range.from()};\n\t      });\n\t    },\n\t    delWrappedLineRight: function(cm) {\n\t      deleteNearSelection(cm, function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t        return {from: range.from(), to: rightPos };\n\t      });\n\t    },\n\t    undo: function(cm) {cm.undo();},\n\t    redo: function(cm) {cm.redo();},\n\t    undoSelection: function(cm) {cm.undoSelection();},\n\t    redoSelection: function(cm) {cm.redoSelection();},\n\t    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n\t    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n\t    goLineStart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineStartSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        return lineStartSmart(cm, range.head);\n\t      }, {origin: \"+move\", bias: 1});\n\t    },\n\t    goLineEnd: function(cm) {\n\t      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n\t                            {origin: \"+move\", bias: -1});\n\t    },\n\t    goLineRight: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeft: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        return cm.coordsChar({left: 0, top: top}, \"div\");\n\t      }, sel_move);\n\t    },\n\t    goLineLeftSmart: function(cm) {\n\t      cm.extendSelectionsBy(function(range) {\n\t        var top = cm.charCoords(range.head, \"div\").top + 5;\n\t        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n\t        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n\t        return pos;\n\t      }, sel_move);\n\t    },\n\t    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n\t    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n\t    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n\t    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n\t    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n\t    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n\t    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n\t    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n\t    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n\t    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n\t    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n\t    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n\t    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n\t    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n\t    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n\t    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n\t    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n\t    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n\t    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n\t    indentMore: function(cm) {cm.indentSelection(\"add\");},\n\t    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n\t    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n\t    insertSoftTab: function(cm) {\n\t      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var pos = ranges[i].from();\n\t        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n\t        spaces.push(spaceStr(tabSize - col % tabSize));\n\t      }\n\t      cm.replaceSelections(spaces);\n\t    },\n\t    defaultTab: function(cm) {\n\t      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n\t      else cm.execCommand(\"insertTab\");\n\t    },\n\t    transposeChars: function(cm) {\n\t      runInOp(cm, function() {\n\t        var ranges = cm.listSelections(), newSel = [];\n\t        for (var i = 0; i < ranges.length; i++) {\n\t          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n\t          if (line) {\n\t            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n\t            if (cur.ch > 0) {\n\t              cur = new Pos(cur.line, cur.ch + 1);\n\t              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n\t                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n\t            } else if (cur.line > cm.doc.first) {\n\t              var prev = getLine(cm.doc, cur.line - 1).text;\n\t              if (prev)\n\t                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n\t                                prev.charAt(prev.length - 1),\n\t                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n\t            }\n\t          }\n\t          newSel.push(new Range(cur, cur));\n\t        }\n\t        cm.setSelections(newSel);\n\t      });\n\t    },\n\t    newlineAndIndent: function(cm) {\n\t      runInOp(cm, function() {\n\t        var len = cm.listSelections().length;\n\t        for (var i = 0; i < len; i++) {\n\t          var range = cm.listSelections()[i];\n\t          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n\t          cm.indentLine(range.from().line + 1, null, true);\n\t        }\n\t        ensureCursorVisible(cm);\n\t      });\n\t    },\n\t    openLine: function(cm) {cm.replaceSelection(\"\\n\", \"start\")},\n\t    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n\t  };\n\t\n\t\n\t  // STANDARD KEYMAPS\n\t\n\t  var keyMap = CodeMirror.keyMap = {};\n\t\n\t  keyMap.basic = {\n\t    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n\t    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n\t    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n\t    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n\t    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n\t    \"Esc\": \"singleSelection\"\n\t  };\n\t  // Note that the save and find-related commands aren't defined by\n\t  // default. User code or addons can define them. Unknown commands\n\t  // are simply ignored.\n\t  keyMap.pcDefault = {\n\t    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n\t    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n\t    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n\t    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n\t    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n\t    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n\t    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n\t    fallthrough: \"basic\"\n\t  };\n\t  // Very basic readline/emacs-style bindings, which are standard on Mac.\n\t  keyMap.emacsy = {\n\t    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n\t    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n\t    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n\t    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n\t    \"Ctrl-O\": \"openLine\"\n\t  };\n\t  keyMap.macDefault = {\n\t    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n\t    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n\t    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n\t    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n\t    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n\t    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n\t    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n\t    fallthrough: [\"basic\", \"emacsy\"]\n\t  };\n\t  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\t\n\t  // KEYMAP DISPATCH\n\t\n\t  function normalizeKeyName(name) {\n\t    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n\t    var alt, ctrl, shift, cmd;\n\t    for (var i = 0; i < parts.length - 1; i++) {\n\t      var mod = parts[i];\n\t      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n\t      else if (/^a(lt)?$/i.test(mod)) alt = true;\n\t      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n\t      else if (/^s(hift)$/i.test(mod)) shift = true;\n\t      else throw new Error(\"Unrecognized modifier name: \" + mod);\n\t    }\n\t    if (alt) name = \"Alt-\" + name;\n\t    if (ctrl) name = \"Ctrl-\" + name;\n\t    if (cmd) name = \"Cmd-\" + name;\n\t    if (shift) name = \"Shift-\" + name;\n\t    return name;\n\t  }\n\t\n\t  // This is a kludge to keep keymaps mostly working as raw objects\n\t  // (backwards compatibility) while at the same time support features\n\t  // like normalization and multi-stroke key bindings. It compiles a\n\t  // new normalized keymap, and then updates the old object to reflect\n\t  // this.\n\t  CodeMirror.normalizeKeyMap = function(keymap) {\n\t    var copy = {};\n\t    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n\t      var value = keymap[keyname];\n\t      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n\t      if (value == \"...\") { delete keymap[keyname]; continue; }\n\t\n\t      var keys = map(keyname.split(\" \"), normalizeKeyName);\n\t      for (var i = 0; i < keys.length; i++) {\n\t        var val, name;\n\t        if (i == keys.length - 1) {\n\t          name = keys.join(\" \");\n\t          val = value;\n\t        } else {\n\t          name = keys.slice(0, i + 1).join(\" \");\n\t          val = \"...\";\n\t        }\n\t        var prev = copy[name];\n\t        if (!prev) copy[name] = val;\n\t        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n\t      }\n\t      delete keymap[keyname];\n\t    }\n\t    for (var prop in copy) keymap[prop] = copy[prop];\n\t    return keymap;\n\t  };\n\t\n\t  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n\t    map = getKeyMap(map);\n\t    var found = map.call ? map.call(key, context) : map[key];\n\t    if (found === false) return \"nothing\";\n\t    if (found === \"...\") return \"multi\";\n\t    if (found != null && handle(found)) return \"handled\";\n\t\n\t    if (map.fallthrough) {\n\t      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n\t        return lookupKey(key, map.fallthrough, handle, context);\n\t      for (var i = 0; i < map.fallthrough.length; i++) {\n\t        var result = lookupKey(key, map.fallthrough[i], handle, context);\n\t        if (result) return result;\n\t      }\n\t    }\n\t  };\n\t\n\t  // Modifier key presses don't count as 'real' key presses for the\n\t  // purpose of keymap fallthrough.\n\t  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n\t    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n\t    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n\t  };\n\t\n\t  // Look up the name of a key as indicated by an event object.\n\t  var keyName = CodeMirror.keyName = function(event, noShift) {\n\t    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n\t    var base = keyNames[event.keyCode], name = base;\n\t    if (name == null || event.altGraphKey) return false;\n\t    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n\t    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n\t    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n\t    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n\t    return name;\n\t  };\n\t\n\t  function getKeyMap(val) {\n\t    return typeof val == \"string\" ? keyMap[val] : val;\n\t  }\n\t\n\t  // FROMTEXTAREA\n\t\n\t  CodeMirror.fromTextArea = function(textarea, options) {\n\t    options = options ? copyObj(options) : {};\n\t    options.value = textarea.value;\n\t    if (!options.tabindex && textarea.tabIndex)\n\t      options.tabindex = textarea.tabIndex;\n\t    if (!options.placeholder && textarea.placeholder)\n\t      options.placeholder = textarea.placeholder;\n\t    // Set autofocus to true if this textarea is focused, or if it has\n\t    // autofocus and no other element is focused.\n\t    if (options.autofocus == null) {\n\t      var hasFocus = activeElt();\n\t      options.autofocus = hasFocus == textarea ||\n\t        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n\t    }\n\t\n\t    function save() {textarea.value = cm.getValue();}\n\t    if (textarea.form) {\n\t      on(textarea.form, \"submit\", save);\n\t      // Deplorable hack to make the submit method do the right thing.\n\t      if (!options.leaveSubmitMethodAlone) {\n\t        var form = textarea.form, realSubmit = form.submit;\n\t        try {\n\t          var wrappedSubmit = form.submit = function() {\n\t            save();\n\t            form.submit = realSubmit;\n\t            form.submit();\n\t            form.submit = wrappedSubmit;\n\t          };\n\t        } catch(e) {}\n\t      }\n\t    }\n\t\n\t    options.finishInit = function(cm) {\n\t      cm.save = save;\n\t      cm.getTextArea = function() { return textarea; };\n\t      cm.toTextArea = function() {\n\t        cm.toTextArea = isNaN; // Prevent this from being ran twice\n\t        save();\n\t        textarea.parentNode.removeChild(cm.getWrapperElement());\n\t        textarea.style.display = \"\";\n\t        if (textarea.form) {\n\t          off(textarea.form, \"submit\", save);\n\t          if (typeof textarea.form.submit == \"function\")\n\t            textarea.form.submit = realSubmit;\n\t        }\n\t      };\n\t    };\n\t\n\t    textarea.style.display = \"none\";\n\t    var cm = CodeMirror(function(node) {\n\t      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n\t    }, options);\n\t    return cm;\n\t  };\n\t\n\t  // STRING STREAM\n\t\n\t  // Fed to the mode parsers, provides helper functions to make\n\t  // parsers more succinct.\n\t\n\t  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n\t    this.pos = this.start = 0;\n\t    this.string = string;\n\t    this.tabSize = tabSize || 8;\n\t    this.lastColumnPos = this.lastColumnValue = 0;\n\t    this.lineStart = 0;\n\t  };\n\t\n\t  StringStream.prototype = {\n\t    eol: function() {return this.pos >= this.string.length;},\n\t    sol: function() {return this.pos == this.lineStart;},\n\t    peek: function() {return this.string.charAt(this.pos) || undefined;},\n\t    next: function() {\n\t      if (this.pos < this.string.length)\n\t        return this.string.charAt(this.pos++);\n\t    },\n\t    eat: function(match) {\n\t      var ch = this.string.charAt(this.pos);\n\t      if (typeof match == \"string\") var ok = ch == match;\n\t      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n\t      if (ok) {++this.pos; return ch;}\n\t    },\n\t    eatWhile: function(match) {\n\t      var start = this.pos;\n\t      while (this.eat(match)){}\n\t      return this.pos > start;\n\t    },\n\t    eatSpace: function() {\n\t      var start = this.pos;\n\t      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n\t      return this.pos > start;\n\t    },\n\t    skipToEnd: function() {this.pos = this.string.length;},\n\t    skipTo: function(ch) {\n\t      var found = this.string.indexOf(ch, this.pos);\n\t      if (found > -1) {this.pos = found; return true;}\n\t    },\n\t    backUp: function(n) {this.pos -= n;},\n\t    column: function() {\n\t      if (this.lastColumnPos < this.start) {\n\t        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n\t        this.lastColumnPos = this.start;\n\t      }\n\t      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    indentation: function() {\n\t      return countColumn(this.string, null, this.tabSize) -\n\t        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n\t    },\n\t    match: function(pattern, consume, caseInsensitive) {\n\t      if (typeof pattern == \"string\") {\n\t        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n\t        var substr = this.string.substr(this.pos, pattern.length);\n\t        if (cased(substr) == cased(pattern)) {\n\t          if (consume !== false) this.pos += pattern.length;\n\t          return true;\n\t        }\n\t      } else {\n\t        var match = this.string.slice(this.pos).match(pattern);\n\t        if (match && match.index > 0) return null;\n\t        if (match && consume !== false) this.pos += match[0].length;\n\t        return match;\n\t      }\n\t    },\n\t    current: function(){return this.string.slice(this.start, this.pos);},\n\t    hideFirstChars: function(n, inner) {\n\t      this.lineStart += n;\n\t      try { return inner(); }\n\t      finally { this.lineStart -= n; }\n\t    }\n\t  };\n\t\n\t  // TEXTMARKERS\n\t\n\t  // Created with markText and setBookmark methods. A TextMarker is a\n\t  // handle that can be used to clear or find a marked position in the\n\t  // document. Line objects hold arrays (markedSpans) containing\n\t  // {from, to, marker} object pointing to such marker objects, and\n\t  // indicating that such a marker is present on that line. Multiple\n\t  // lines may point to the same marker when it spans across lines.\n\t  // The spans will have null for their from/to properties when the\n\t  // marker continues beyond the start/end of the line. Markers have\n\t  // links back to the lines they currently touch.\n\t\n\t  var nextMarkerId = 0;\n\t\n\t  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n\t    this.lines = [];\n\t    this.type = type;\n\t    this.doc = doc;\n\t    this.id = ++nextMarkerId;\n\t  };\n\t  eventMixin(TextMarker);\n\t\n\t  // Clear the marker.\n\t  TextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n\t    if (withOp) startOperation(cm);\n\t    if (hasHandler(this, \"clear\")) {\n\t      var found = this.find();\n\t      if (found) signalLater(this, \"clear\", found.from, found.to);\n\t    }\n\t    var min = null, max = null;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n\t      else if (cm) {\n\t        if (span.to != null) max = lineNo(line);\n\t        if (span.from != null) min = lineNo(line);\n\t      }\n\t      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\t      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n\t        updateLineHeight(line, textHeight(cm.display));\n\t    }\n\t    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n\t      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n\t      if (len > cm.display.maxLineLength) {\n\t        cm.display.maxLine = visual;\n\t        cm.display.maxLineLength = len;\n\t        cm.display.maxLineChanged = true;\n\t      }\n\t    }\n\t\n\t    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n\t    this.lines.length = 0;\n\t    this.explicitlyCleared = true;\n\t    if (this.atomic && this.doc.cantEdit) {\n\t      this.doc.cantEdit = false;\n\t      if (cm) reCheckSelection(cm.doc);\n\t    }\n\t    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n\t    if (withOp) endOperation(cm);\n\t    if (this.parent) this.parent.clear();\n\t  };\n\t\n\t  // Find the position of the marker in the document. Returns a {from,\n\t  // to} object by default. Side can be passed to get a specific side\n\t  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n\t  // Pos objects returned contain a line object, rather than a line\n\t  // number (used to prevent looking up the same line twice).\n\t  TextMarker.prototype.find = function(side, lineObj) {\n\t    if (side == null && this.type == \"bookmark\") side = 1;\n\t    var from, to;\n\t    for (var i = 0; i < this.lines.length; ++i) {\n\t      var line = this.lines[i];\n\t      var span = getMarkedSpanFor(line.markedSpans, this);\n\t      if (span.from != null) {\n\t        from = Pos(lineObj ? line : lineNo(line), span.from);\n\t        if (side == -1) return from;\n\t      }\n\t      if (span.to != null) {\n\t        to = Pos(lineObj ? line : lineNo(line), span.to);\n\t        if (side == 1) return to;\n\t      }\n\t    }\n\t    return from && {from: from, to: to};\n\t  };\n\t\n\t  // Signals that the marker's widget changed, and surrounding layout\n\t  // should be recomputed.\n\t  TextMarker.prototype.changed = function() {\n\t    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n\t    if (!pos || !cm) return;\n\t    runInOp(cm, function() {\n\t      var line = pos.line, lineN = lineNo(pos.line);\n\t      var view = findViewForLine(cm, lineN);\n\t      if (view) {\n\t        clearLineMeasurementCacheFor(view);\n\t        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n\t      }\n\t      cm.curOp.updateMaxLine = true;\n\t      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n\t        var oldHeight = widget.height;\n\t        widget.height = null;\n\t        var dHeight = widgetHeight(widget) - oldHeight;\n\t        if (dHeight)\n\t          updateLineHeight(line, line.height + dHeight);\n\t      }\n\t    });\n\t  };\n\t\n\t  TextMarker.prototype.attachLine = function(line) {\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n\t        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n\t    }\n\t    this.lines.push(line);\n\t  };\n\t  TextMarker.prototype.detachLine = function(line) {\n\t    this.lines.splice(indexOf(this.lines, line), 1);\n\t    if (!this.lines.length && this.doc.cm) {\n\t      var op = this.doc.cm.curOp;\n\t      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n\t    }\n\t  };\n\t\n\t  // Collapsed markers have unique ids, in order to be able to order\n\t  // them, which is needed for uniquely determining an outer marker\n\t  // when they overlap (they may nest, but not partially overlap).\n\t  var nextMarkerId = 0;\n\t\n\t  // Create a marker, wire it up to the right lines, and\n\t  function markText(doc, from, to, options, type) {\n\t    // Shared markers (across linked documents) are handled separately\n\t    // (markTextShared will call out to this again, once per\n\t    // document).\n\t    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n\t    // Ensure we are in an operation.\n\t    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\t\n\t    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n\t    if (options) copyObj(options, marker, false);\n\t    // Don't connect empty markers unless clearWhenEmpty is false\n\t    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n\t      return marker;\n\t    if (marker.replacedWith) {\n\t      // Showing up as a widget implies collapsed (widget replaces text)\n\t      marker.collapsed = true;\n\t      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\t      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n\t      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n\t    }\n\t    if (marker.collapsed) {\n\t      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n\t          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n\t        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n\t      sawCollapsedSpans = true;\n\t    }\n\t\n\t    if (marker.addToHistory)\n\t      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\t\n\t    var curLine = from.line, cm = doc.cm, updateMaxLine;\n\t    doc.iter(curLine, to.line + 1, function(line) {\n\t      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n\t        updateMaxLine = true;\n\t      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n\t      addMarkedSpan(line, new MarkedSpan(marker,\n\t                                         curLine == from.line ? from.ch : null,\n\t                                         curLine == to.line ? to.ch : null));\n\t      ++curLine;\n\t    });\n\t    // lineIsHidden depends on the presence of the spans, so needs a second pass\n\t    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n\t      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n\t    });\n\t\n\t    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\t\n\t    if (marker.readOnly) {\n\t      sawReadOnlySpans = true;\n\t      if (doc.history.done.length || doc.history.undone.length)\n\t        doc.clearHistory();\n\t    }\n\t    if (marker.collapsed) {\n\t      marker.id = ++nextMarkerId;\n\t      marker.atomic = true;\n\t    }\n\t    if (cm) {\n\t      // Sync editor state\n\t      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n\t      if (marker.collapsed)\n\t        regChange(cm, from.line, to.line + 1);\n\t      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n\t        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n\t      if (marker.atomic) reCheckSelection(cm.doc);\n\t      signalLater(cm, \"markerAdded\", cm, marker);\n\t    }\n\t    return marker;\n\t  }\n\t\n\t  // SHARED TEXTMARKERS\n\t\n\t  // A shared marker spans multiple linked documents. It is\n\t  // implemented as a meta-marker-object controlling multiple normal\n\t  // markers.\n\t  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n\t    this.markers = markers;\n\t    this.primary = primary;\n\t    for (var i = 0; i < markers.length; ++i)\n\t      markers[i].parent = this;\n\t  };\n\t  eventMixin(SharedTextMarker);\n\t\n\t  SharedTextMarker.prototype.clear = function() {\n\t    if (this.explicitlyCleared) return;\n\t    this.explicitlyCleared = true;\n\t    for (var i = 0; i < this.markers.length; ++i)\n\t      this.markers[i].clear();\n\t    signalLater(this, \"clear\");\n\t  };\n\t  SharedTextMarker.prototype.find = function(side, lineObj) {\n\t    return this.primary.find(side, lineObj);\n\t  };\n\t\n\t  function markTextShared(doc, from, to, options, type) {\n\t    options = copyObj(options);\n\t    options.shared = false;\n\t    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n\t    var widget = options.widgetNode;\n\t    linkedDocs(doc, function(doc) {\n\t      if (widget) options.widgetNode = widget.cloneNode(true);\n\t      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n\t      for (var i = 0; i < doc.linked.length; ++i)\n\t        if (doc.linked[i].isParent) return;\n\t      primary = lst(markers);\n\t    });\n\t    return new SharedTextMarker(markers, primary);\n\t  }\n\t\n\t  function findSharedMarkers(doc) {\n\t    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n\t                         function(m) { return m.parent; });\n\t  }\n\t\n\t  function copySharedMarkers(doc, markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], pos = marker.find();\n\t      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n\t      if (cmp(mFrom, mTo)) {\n\t        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n\t        marker.markers.push(subMark);\n\t        subMark.parent = marker;\n\t      }\n\t    }\n\t  }\n\t\n\t  function detachSharedMarkers(markers) {\n\t    for (var i = 0; i < markers.length; i++) {\n\t      var marker = markers[i], linked = [marker.primary.doc];;\n\t      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n\t      for (var j = 0; j < marker.markers.length; j++) {\n\t        var subMarker = marker.markers[j];\n\t        if (indexOf(linked, subMarker.doc) == -1) {\n\t          subMarker.parent = null;\n\t          marker.markers.splice(j--, 1);\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // TEXTMARKER SPANS\n\t\n\t  function MarkedSpan(marker, from, to) {\n\t    this.marker = marker;\n\t    this.from = from; this.to = to;\n\t  }\n\t\n\t  // Search an array of spans for a span matching the given marker.\n\t  function getMarkedSpanFor(spans, marker) {\n\t    if (spans) for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.marker == marker) return span;\n\t    }\n\t  }\n\t  // Remove a span from an array, returning undefined if no spans are\n\t  // left (we don't store arrays for lines without spans).\n\t  function removeMarkedSpan(spans, span) {\n\t    for (var r, i = 0; i < spans.length; ++i)\n\t      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n\t    return r;\n\t  }\n\t  // Add a span to a line.\n\t  function addMarkedSpan(line, span) {\n\t    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n\t    span.marker.attachLine(line);\n\t  }\n\t\n\t  // Used for the algorithm that adjusts markers for a change in the\n\t  // document. These functions cut an array of spans at a given\n\t  // character position, returning an array of remaining chunks (or\n\t  // undefined if nothing remains).\n\t  function markedSpansBefore(old, startCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\t      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n\t        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t  function markedSpansAfter(old, endCh, isInsert) {\n\t    if (old) for (var i = 0, nw; i < old.length; ++i) {\n\t      var span = old[i], marker = span.marker;\n\t      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\t      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n\t        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n\t        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n\t                                              span.to == null ? null : span.to - endCh));\n\t      }\n\t    }\n\t    return nw;\n\t  }\n\t\n\t  // Given a change object, compute the new set of marker spans that\n\t  // cover the line in which the change took place. Removes spans\n\t  // entirely within the change, reconnects spans belonging to the\n\t  // same marker that appear on both sides of the change, and cuts off\n\t  // spans partially within the change. Returns an array of span\n\t  // arrays with one element for each line in (after) the change.\n\t  function stretchSpansOverChange(doc, change) {\n\t    if (change.full) return null;\n\t    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n\t    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\t    if (!oldFirst && !oldLast) return null;\n\t\n\t    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n\t    // Get the spans that 'stick out' on both sides\n\t    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n\t    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\t\n\t    // Next, merge those two ends\n\t    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n\t    if (first) {\n\t      // Fix up .to properties of first\n\t      for (var i = 0; i < first.length; ++i) {\n\t        var span = first[i];\n\t        if (span.to == null) {\n\t          var found = getMarkedSpanFor(last, span.marker);\n\t          if (!found) span.to = startCh;\n\t          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n\t        }\n\t      }\n\t    }\n\t    if (last) {\n\t      // Fix up .from in last (or move them into first in case of sameLine)\n\t      for (var i = 0; i < last.length; ++i) {\n\t        var span = last[i];\n\t        if (span.to != null) span.to += offset;\n\t        if (span.from == null) {\n\t          var found = getMarkedSpanFor(first, span.marker);\n\t          if (!found) {\n\t            span.from = offset;\n\t            if (sameLine) (first || (first = [])).push(span);\n\t          }\n\t        } else {\n\t          span.from += offset;\n\t          if (sameLine) (first || (first = [])).push(span);\n\t        }\n\t      }\n\t    }\n\t    // Make sure we didn't create any zero-length spans\n\t    if (first) first = clearEmptySpans(first);\n\t    if (last && last != first) last = clearEmptySpans(last);\n\t\n\t    var newMarkers = [first];\n\t    if (!sameLine) {\n\t      // Fill gap with whole-line-spans\n\t      var gap = change.text.length - 2, gapMarkers;\n\t      if (gap > 0 && first)\n\t        for (var i = 0; i < first.length; ++i)\n\t          if (first[i].to == null)\n\t            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n\t      for (var i = 0; i < gap; ++i)\n\t        newMarkers.push(gapMarkers);\n\t      newMarkers.push(last);\n\t    }\n\t    return newMarkers;\n\t  }\n\t\n\t  // Remove spans that are empty and don't have a clearWhenEmpty\n\t  // option of false.\n\t  function clearEmptySpans(spans) {\n\t    for (var i = 0; i < spans.length; ++i) {\n\t      var span = spans[i];\n\t      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n\t        spans.splice(i--, 1);\n\t    }\n\t    if (!spans.length) return null;\n\t    return spans;\n\t  }\n\t\n\t  // Used for un/re-doing changes from the history. Combines the\n\t  // result of computing the existing spans with the set of spans that\n\t  // existed in the history (so that deleting around a span and then\n\t  // undoing brings back the span).\n\t  function mergeOldSpans(doc, change) {\n\t    var old = getOldSpans(doc, change);\n\t    var stretched = stretchSpansOverChange(doc, change);\n\t    if (!old) return stretched;\n\t    if (!stretched) return old;\n\t\n\t    for (var i = 0; i < old.length; ++i) {\n\t      var oldCur = old[i], stretchCur = stretched[i];\n\t      if (oldCur && stretchCur) {\n\t        spans: for (var j = 0; j < stretchCur.length; ++j) {\n\t          var span = stretchCur[j];\n\t          for (var k = 0; k < oldCur.length; ++k)\n\t            if (oldCur[k].marker == span.marker) continue spans;\n\t          oldCur.push(span);\n\t        }\n\t      } else if (stretchCur) {\n\t        old[i] = stretchCur;\n\t      }\n\t    }\n\t    return old;\n\t  }\n\t\n\t  // Used to 'clip' out readOnly ranges when making a change.\n\t  function removeReadOnlyRanges(doc, from, to) {\n\t    var markers = null;\n\t    doc.iter(from.line, to.line + 1, function(line) {\n\t      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n\t        var mark = line.markedSpans[i].marker;\n\t        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n\t          (markers || (markers = [])).push(mark);\n\t      }\n\t    });\n\t    if (!markers) return null;\n\t    var parts = [{from: from, to: to}];\n\t    for (var i = 0; i < markers.length; ++i) {\n\t      var mk = markers[i], m = mk.find(0);\n\t      for (var j = 0; j < parts.length; ++j) {\n\t        var p = parts[j];\n\t        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n\t        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n\t        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n\t          newParts.push({from: p.from, to: m.from});\n\t        if (dto > 0 || !mk.inclusiveRight && !dto)\n\t          newParts.push({from: m.to, to: p.to});\n\t        parts.splice.apply(parts, newParts);\n\t        j += newParts.length - 1;\n\t      }\n\t    }\n\t    return parts;\n\t  }\n\t\n\t  // Connect or disconnect spans from a line.\n\t  function detachMarkedSpans(line) {\n\t    var spans = line.markedSpans;\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.detachLine(line);\n\t    line.markedSpans = null;\n\t  }\n\t  function attachMarkedSpans(line, spans) {\n\t    if (!spans) return;\n\t    for (var i = 0; i < spans.length; ++i)\n\t      spans[i].marker.attachLine(line);\n\t    line.markedSpans = spans;\n\t  }\n\t\n\t  // Helpers used when computing which overlapping collapsed span\n\t  // counts as the larger one.\n\t  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n\t  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\t\n\t  // Returns a number indicating which of two overlapping collapsed\n\t  // spans is larger (and thus includes the other). Falls back to\n\t  // comparing ids when the spans cover exactly the same range.\n\t  function compareCollapsedMarkers(a, b) {\n\t    var lenDiff = a.lines.length - b.lines.length;\n\t    if (lenDiff != 0) return lenDiff;\n\t    var aPos = a.find(), bPos = b.find();\n\t    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\t    if (fromCmp) return -fromCmp;\n\t    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\t    if (toCmp) return toCmp;\n\t    return b.id - a.id;\n\t  }\n\t\n\t  // Find out whether a line ends or starts in a collapsed span. If\n\t  // so, return the marker for that span.\n\t  function collapsedSpanAtSide(line, start) {\n\t    var sps = sawCollapsedSpans && line.markedSpans, found;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n\t          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n\t        found = sp.marker;\n\t    }\n\t    return found;\n\t  }\n\t  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n\t  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\t\n\t  // Test whether there exists a collapsed span that partially\n\t  // overlaps (covers the start or end, but not both) of a new span.\n\t  // Such overlap is not allowed.\n\t  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n\t    var line = getLine(doc, lineNo);\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var i = 0; i < sps.length; ++i) {\n\t      var sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      var found = sp.marker.find(0);\n\t      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n\t      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\t      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n\t      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n\t          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n\t        return true;\n\t    }\n\t  }\n\t\n\t  // A visual line is a line as drawn on the screen. Folding, for\n\t  // example, can cause multiple logical lines to appear on the same\n\t  // visual line. This finds the start of the visual line that the\n\t  // given line is part of (usually that is the line itself).\n\t  function visualLine(line) {\n\t    var merged;\n\t    while (merged = collapsedSpanAtStart(line))\n\t      line = merged.find(-1, true).line;\n\t    return line;\n\t  }\n\t\n\t  // Returns an array of logical lines that continue the visual line\n\t  // started by the argument, or undefined if there are no such lines.\n\t  function visualLineContinued(line) {\n\t    var merged, lines;\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      (lines || (lines = [])).push(line);\n\t    }\n\t    return lines;\n\t  }\n\t\n\t  // Get the line number of the start of the visual line that the\n\t  // given line number is part of.\n\t  function visualLineNo(doc, lineN) {\n\t    var line = getLine(doc, lineN), vis = visualLine(line);\n\t    if (line == vis) return lineN;\n\t    return lineNo(vis);\n\t  }\n\t  // Get the line number of the start of the next visual line after\n\t  // the given line.\n\t  function visualLineEndNo(doc, lineN) {\n\t    if (lineN > doc.lastLine()) return lineN;\n\t    var line = getLine(doc, lineN), merged;\n\t    if (!lineIsHidden(doc, line)) return lineN;\n\t    while (merged = collapsedSpanAtEnd(line))\n\t      line = merged.find(1, true).line;\n\t    return lineNo(line) + 1;\n\t  }\n\t\n\t  // Compute whether a line is hidden. Lines count as hidden when they\n\t  // are part of a visual line that starts with another line, or when\n\t  // they are entirely covered by collapsed, non-widget span.\n\t  function lineIsHidden(doc, line) {\n\t    var sps = sawCollapsedSpans && line.markedSpans;\n\t    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n\t      sp = sps[i];\n\t      if (!sp.marker.collapsed) continue;\n\t      if (sp.from == null) return true;\n\t      if (sp.marker.widgetNode) continue;\n\t      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n\t        return true;\n\t    }\n\t  }\n\t  function lineIsHiddenInner(doc, line, span) {\n\t    if (span.to == null) {\n\t      var end = span.marker.find(1, true);\n\t      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n\t    }\n\t    if (span.marker.inclusiveRight && span.to == line.text.length)\n\t      return true;\n\t    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n\t      sp = line.markedSpans[i];\n\t      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n\t          (sp.to == null || sp.to != span.from) &&\n\t          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n\t          lineIsHiddenInner(doc, line, sp)) return true;\n\t    }\n\t  }\n\t\n\t  // LINE WIDGETS\n\t\n\t  // Line widgets are block elements displayed above or below a line.\n\t\n\t  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n\t    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n\t      this[opt] = options[opt];\n\t    this.doc = doc;\n\t    this.node = node;\n\t  };\n\t  eventMixin(LineWidget);\n\t\n\t  function adjustScrollWhenAboveVisible(cm, line, diff) {\n\t    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n\t      addToScrollPos(cm, null, diff);\n\t  }\n\t\n\t  LineWidget.prototype.clear = function() {\n\t    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n\t    if (no == null || !ws) return;\n\t    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n\t    if (!ws.length) line.widgets = null;\n\t    var height = widgetHeight(this);\n\t    updateLineHeight(line, Math.max(0, line.height - height));\n\t    if (cm) runInOp(cm, function() {\n\t      adjustScrollWhenAboveVisible(cm, line, -height);\n\t      regLineChange(cm, no, \"widget\");\n\t    });\n\t  };\n\t  LineWidget.prototype.changed = function() {\n\t    var oldH = this.height, cm = this.doc.cm, line = this.line;\n\t    this.height = null;\n\t    var diff = widgetHeight(this) - oldH;\n\t    if (!diff) return;\n\t    updateLineHeight(line, line.height + diff);\n\t    if (cm) runInOp(cm, function() {\n\t      cm.curOp.forceUpdate = true;\n\t      adjustScrollWhenAboveVisible(cm, line, diff);\n\t    });\n\t  };\n\t\n\t  function widgetHeight(widget) {\n\t    if (widget.height != null) return widget.height;\n\t    var cm = widget.doc.cm;\n\t    if (!cm) return 0;\n\t    if (!contains(document.body, widget.node)) {\n\t      var parentStyle = \"position: relative;\";\n\t      if (widget.coverGutter)\n\t        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n\t      if (widget.noHScroll)\n\t        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n\t      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n\t    }\n\t    return widget.height = widget.node.parentNode.offsetHeight;\n\t  }\n\t\n\t  function addLineWidget(doc, handle, node, options) {\n\t    var widget = new LineWidget(doc, node, options);\n\t    var cm = doc.cm;\n\t    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n\t    changeLine(doc, handle, \"widget\", function(line) {\n\t      var widgets = line.widgets || (line.widgets = []);\n\t      if (widget.insertAt == null) widgets.push(widget);\n\t      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n\t      widget.line = line;\n\t      if (cm && !lineIsHidden(doc, line)) {\n\t        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n\t        updateLineHeight(line, line.height + widgetHeight(widget));\n\t        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n\t        cm.curOp.forceUpdate = true;\n\t      }\n\t      return true;\n\t    });\n\t    return widget;\n\t  }\n\t\n\t  // LINE DATA STRUCTURE\n\t\n\t  // Line objects. These hold state related to a line, including\n\t  // highlighting info (the styles array).\n\t  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n\t    this.text = text;\n\t    attachMarkedSpans(this, markedSpans);\n\t    this.height = estimateHeight ? estimateHeight(this) : 1;\n\t  };\n\t  eventMixin(Line);\n\t  Line.prototype.lineNo = function() { return lineNo(this); };\n\t\n\t  // Change the content (text, markers) of a line. Automatically\n\t  // invalidates cached information and tries to re-estimate the\n\t  // line's height.\n\t  function updateLine(line, text, markedSpans, estimateHeight) {\n\t    line.text = text;\n\t    if (line.stateAfter) line.stateAfter = null;\n\t    if (line.styles) line.styles = null;\n\t    if (line.order != null) line.order = null;\n\t    detachMarkedSpans(line);\n\t    attachMarkedSpans(line, markedSpans);\n\t    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\t    if (estHeight != line.height) updateLineHeight(line, estHeight);\n\t  }\n\t\n\t  // Detach a line from the document tree and its markers.\n\t  function cleanUpLine(line) {\n\t    line.parent = null;\n\t    detachMarkedSpans(line);\n\t  }\n\t\n\t  function extractLineClasses(type, output) {\n\t    if (type) for (;;) {\n\t      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\t      if (!lineClass) break;\n\t      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n\t      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\t      if (output[prop] == null)\n\t        output[prop] = lineClass[2];\n\t      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n\t        output[prop] += \" \" + lineClass[2];\n\t    }\n\t    return type;\n\t  }\n\t\n\t  function callBlankLine(mode, state) {\n\t    if (mode.blankLine) return mode.blankLine(state);\n\t    if (!mode.innerMode) return;\n\t    var inner = CodeMirror.innerMode(mode, state);\n\t    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n\t  }\n\t\n\t  function readToken(mode, stream, state, inner) {\n\t    for (var i = 0; i < 10; i++) {\n\t      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n\t      var style = mode.token(stream, state);\n\t      if (stream.pos > stream.start) return style;\n\t    }\n\t    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n\t  }\n\t\n\t  // Utility for getTokenAt and getLineTokens\n\t  function takeToken(cm, pos, precise, asArray) {\n\t    function getObj(copy) {\n\t      return {start: stream.start, end: stream.pos,\n\t              string: stream.current(),\n\t              type: style || null,\n\t              state: copy ? copyState(doc.mode, state) : state};\n\t    }\n\t\n\t    var doc = cm.doc, mode = doc.mode, style;\n\t    pos = clipPos(doc, pos);\n\t    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n\t    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n\t    if (asArray) tokens = [];\n\t    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n\t      stream.start = stream.pos;\n\t      style = readToken(mode, stream, state);\n\t      if (asArray) tokens.push(getObj(true));\n\t    }\n\t    return asArray ? tokens : getObj();\n\t  }\n\t\n\t  // Run the given mode's parser over a line, calling f for each token.\n\t  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n\t    var flattenSpans = mode.flattenSpans;\n\t    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n\t    var curStart = 0, curStyle = null;\n\t    var stream = new StringStream(text, cm.options.tabSize), style;\n\t    var inner = cm.options.addModeClass && [null];\n\t    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n\t    while (!stream.eol()) {\n\t      if (stream.pos > cm.options.maxHighlightLength) {\n\t        flattenSpans = false;\n\t        if (forceToEnd) processLine(cm, text, state, stream.pos);\n\t        stream.pos = text.length;\n\t        style = null;\n\t      } else {\n\t        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n\t      }\n\t      if (inner) {\n\t        var mName = inner[0].name;\n\t        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n\t      }\n\t      if (!flattenSpans || curStyle != style) {\n\t        while (curStart < stream.start) {\n\t          curStart = Math.min(stream.start, curStart + 5000);\n\t          f(curStart, curStyle);\n\t        }\n\t        curStyle = style;\n\t      }\n\t      stream.start = stream.pos;\n\t    }\n\t    while (curStart < stream.pos) {\n\t      // Webkit seems to refuse to render text nodes longer than 57444\n\t      // characters, and returns inaccurate measurements in nodes\n\t      // starting around 5000 chars.\n\t      var pos = Math.min(stream.pos, curStart + 5000);\n\t      f(pos, curStyle);\n\t      curStart = pos;\n\t    }\n\t  }\n\t\n\t  // Compute a style array (an array starting with a mode generation\n\t  // -- for invalidation -- followed by pairs of end positions and\n\t  // style strings), which is used to highlight the tokens on the\n\t  // line.\n\t  function highlightLine(cm, line, state, forceToEnd) {\n\t    // A styles array always starts with a number identifying the\n\t    // mode/overlays that it is based on (for easy invalidation).\n\t    var st = [cm.state.modeGen], lineClasses = {};\n\t    // Compute the base array of styles\n\t    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n\t      st.push(end, style);\n\t    }, lineClasses, forceToEnd);\n\t\n\t    // Run overlays, adjust style array.\n\t    for (var o = 0; o < cm.state.overlays.length; ++o) {\n\t      var overlay = cm.state.overlays[o], i = 1, at = 0;\n\t      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n\t        var start = i;\n\t        // Ensure there's a token end at the current position, and that i points at it\n\t        while (at < end) {\n\t          var i_end = st[i];\n\t          if (i_end > end)\n\t            st.splice(i, 1, end, st[i+1], i_end);\n\t          i += 2;\n\t          at = Math.min(end, i_end);\n\t        }\n\t        if (!style) return;\n\t        if (overlay.opaque) {\n\t          st.splice(start, i - start, end, \"cm-overlay \" + style);\n\t          i = start + 2;\n\t        } else {\n\t          for (; start < i; start += 2) {\n\t            var cur = st[start+1];\n\t            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n\t          }\n\t        }\n\t      }, lineClasses);\n\t    }\n\t\n\t    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n\t  }\n\t\n\t  function getLineStyles(cm, line, updateFrontier) {\n\t    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n\t      var state = getStateBefore(cm, lineNo(line));\n\t      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n\t      line.stateAfter = state;\n\t      line.styles = result.styles;\n\t      if (result.classes) line.styleClasses = result.classes;\n\t      else if (line.styleClasses) line.styleClasses = null;\n\t      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n\t    }\n\t    return line.styles;\n\t  }\n\t\n\t  // Lightweight form of highlight -- proceed over this line and\n\t  // update state, but don't save a style array. Used for lines that\n\t  // aren't currently visible.\n\t  function processLine(cm, text, state, startAt) {\n\t    var mode = cm.doc.mode;\n\t    var stream = new StringStream(text, cm.options.tabSize);\n\t    stream.start = stream.pos = startAt || 0;\n\t    if (text == \"\") callBlankLine(mode, state);\n\t    while (!stream.eol()) {\n\t      readToken(mode, stream, state);\n\t      stream.start = stream.pos;\n\t    }\n\t  }\n\t\n\t  // Convert a style as returned by a mode (either null, or a string\n\t  // containing one or more styles) to a CSS style. This is cached,\n\t  // and also looks for line-wide styles.\n\t  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n\t  function interpretTokenStyle(style, options) {\n\t    if (!style || /^\\s*$/.test(style)) return null;\n\t    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n\t    return cache[style] ||\n\t      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n\t  }\n\t\n\t  // Render the DOM representation of the text of a line. Also builds\n\t  // up a 'line map', which points at the DOM nodes that represent\n\t  // specific stretches of text, and is used by the measuring code.\n\t  // The returned object contains the DOM node, this map, and\n\t  // information about line-wide styles that were set by the mode.\n\t  function buildLineContent(cm, lineView) {\n\t    // The padding-right forces the element to have a 'border', which\n\t    // is needed on Webkit to be able to get line-level bounding\n\t    // rectangles for it (in measureChar).\n\t    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n\t    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n\t                   col: 0, pos: 0, cm: cm,\n\t                   trailingSpace: false,\n\t                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n\t    lineView.measure = {};\n\t\n\t    // Iterate over the logical lines that make up this visual line.\n\t    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n\t      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n\t      builder.pos = 0;\n\t      builder.addToken = buildToken;\n\t      // Optionally wire in some hacks into the token-rendering\n\t      // algorithm, to deal with browser quirks.\n\t      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n\t        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n\t      builder.map = [];\n\t      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n\t      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n\t      if (line.styleClasses) {\n\t        if (line.styleClasses.bgClass)\n\t          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n\t        if (line.styleClasses.textClass)\n\t          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n\t      }\n\t\n\t      // Ensure at least a single node is present, for measuring.\n\t      if (builder.map.length == 0)\n\t        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\t\n\t      // Store the map and a cache object for the current logical line\n\t      if (i == 0) {\n\t        lineView.measure.map = builder.map;\n\t        lineView.measure.cache = {};\n\t      } else {\n\t        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n\t        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n\t      }\n\t    }\n\t\n\t    // See issue #2901\n\t    if (webkit) {\n\t      var last = builder.content.lastChild\n\t      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n\t        builder.content.className = \"cm-tab-wrap-hack\";\n\t    }\n\t\n\t    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n\t    if (builder.pre.className)\n\t      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\t\n\t    return builder;\n\t  }\n\t\n\t  function defaultSpecialCharPlaceholder(ch) {\n\t    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n\t    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n\t    token.setAttribute(\"aria-label\", token.title);\n\t    return token;\n\t  }\n\t\n\t  // Build up the DOM representation for a single token, and add it to\n\t  // the line map. Takes care to render special characters separately.\n\t  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n\t    if (!text) return;\n\t    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text\n\t    var special = builder.cm.state.specialChars, mustWrap = false;\n\t    if (!special.test(text)) {\n\t      builder.col += text.length;\n\t      var content = document.createTextNode(displayText);\n\t      builder.map.push(builder.pos, builder.pos + text.length, content);\n\t      if (ie && ie_version < 9) mustWrap = true;\n\t      builder.pos += text.length;\n\t    } else {\n\t      var content = document.createDocumentFragment(), pos = 0;\n\t      while (true) {\n\t        special.lastIndex = pos;\n\t        var m = special.exec(text);\n\t        var skipped = m ? m.index - pos : text.length - pos;\n\t        if (skipped) {\n\t          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.map.push(builder.pos, builder.pos + skipped, txt);\n\t          builder.col += skipped;\n\t          builder.pos += skipped;\n\t        }\n\t        if (!m) break;\n\t        pos += skipped + 1;\n\t        if (m[0] == \"\\t\") {\n\t          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n\t          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n\t          txt.setAttribute(\"role\", \"presentation\");\n\t          txt.setAttribute(\"cm-text\", \"\\t\");\n\t          builder.col += tabWidth;\n\t        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n\t          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          builder.col += 1;\n\t        } else {\n\t          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n\t          txt.setAttribute(\"cm-text\", m[0]);\n\t          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n\t          else content.appendChild(txt);\n\t          builder.col += 1;\n\t        }\n\t        builder.map.push(builder.pos, builder.pos + 1, txt);\n\t        builder.pos++;\n\t      }\n\t    }\n\t    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32\n\t    if (style || startStyle || endStyle || mustWrap || css) {\n\t      var fullStyle = style || \"\";\n\t      if (startStyle) fullStyle += startStyle;\n\t      if (endStyle) fullStyle += endStyle;\n\t      var token = elt(\"span\", [content], fullStyle, css);\n\t      if (title) token.title = title;\n\t      return builder.content.appendChild(token);\n\t    }\n\t    builder.content.appendChild(content);\n\t  }\n\t\n\t  function splitSpaces(text, trailingBefore) {\n\t    if (text.length > 1 && !/  /.test(text)) return text\n\t    var spaceBefore = trailingBefore, result = \"\"\n\t    for (var i = 0; i < text.length; i++) {\n\t      var ch = text.charAt(i)\n\t      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n\t        ch = \"\\u00a0\"\n\t      result += ch\n\t      spaceBefore = ch == \" \"\n\t    }\n\t    return result\n\t  }\n\t\n\t  // Work around nonsense dimensions being reported for stretches of\n\t  // right-to-left text.\n\t  function buildTokenBadBidi(inner, order) {\n\t    return function(builder, text, style, startStyle, endStyle, title, css) {\n\t      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n\t      var start = builder.pos, end = start + text.length;\n\t      for (;;) {\n\t        // Find the part that overlaps with the start of this text\n\t        for (var i = 0; i < order.length; i++) {\n\t          var part = order[i];\n\t          if (part.to > start && part.from <= start) break;\n\t        }\n\t        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n\t        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n\t        startStyle = null;\n\t        text = text.slice(part.to - start);\n\t        start = part.to;\n\t      }\n\t    };\n\t  }\n\t\n\t  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n\t    var widget = !ignoreWidget && marker.widgetNode;\n\t    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n\t    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n\t      if (!widget)\n\t        widget = builder.content.appendChild(document.createElement(\"span\"));\n\t      widget.setAttribute(\"cm-marker\", marker.id);\n\t    }\n\t    if (widget) {\n\t      builder.cm.display.input.setUneditable(widget);\n\t      builder.content.appendChild(widget);\n\t    }\n\t    builder.pos += size;\n\t    builder.trailingSpace = false\n\t  }\n\t\n\t  // Outputs a number of spans to make up a line, taking highlighting\n\t  // and marked text into account.\n\t  function insertLineContent(line, builder, styles) {\n\t    var spans = line.markedSpans, allText = line.text, at = 0;\n\t    if (!spans) {\n\t      for (var i = 1; i < styles.length; i+=2)\n\t        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n\t      return;\n\t    }\n\t\n\t    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n\t    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n\t    for (;;) {\n\t      if (nextChange == pos) { // Update current marker set\n\t        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n\t        collapsed = null; nextChange = Infinity;\n\t        var foundBookmarks = [], endStyles\n\t        for (var j = 0; j < spans.length; ++j) {\n\t          var sp = spans[j], m = sp.marker;\n\t          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n\t            foundBookmarks.push(m);\n\t          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n\t            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n\t              nextChange = sp.to;\n\t              spanEndStyle = \"\";\n\t            }\n\t            if (m.className) spanStyle += \" \" + m.className;\n\t            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n\t            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n\t            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\n\t            if (m.title && !title) title = m.title;\n\t            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n\t              collapsed = sp;\n\t          } else if (sp.from > pos && nextChange > sp.from) {\n\t            nextChange = sp.from;\n\t          }\n\t        }\n\t        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\n\t          if (endStyles[j + 1] == nextChange) spanEndStyle += \" \" + endStyles[j]\n\t\n\t        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\n\t          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n\t        if (collapsed && (collapsed.from || 0) == pos) {\n\t          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n\t                             collapsed.marker, collapsed.from == null);\n\t          if (collapsed.to == null) return;\n\t          if (collapsed.to == pos) collapsed = false;\n\t        }\n\t      }\n\t      if (pos >= len) break;\n\t\n\t      var upto = Math.min(len, nextChange);\n\t      while (true) {\n\t        if (text) {\n\t          var end = pos + text.length;\n\t          if (!collapsed) {\n\t            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n\t            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n\t                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n\t          }\n\t          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n\t          pos = end;\n\t          spanStartStyle = \"\";\n\t        }\n\t        text = allText.slice(at, at = styles[i++]);\n\t        style = interpretTokenStyle(styles[i++], builder.cm.options);\n\t      }\n\t    }\n\t  }\n\t\n\t  // DOCUMENT DATA STRUCTURE\n\t\n\t  // By default, updates that start and end at the beginning of a line\n\t  // are treated specially, in order to make the association of line\n\t  // widgets and marker elements with the text behave more intuitive.\n\t  function isWholeLineUpdate(doc, change) {\n\t    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n\t      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n\t  }\n\t\n\t  // Perform a change on the document data structure.\n\t  function updateDoc(doc, change, markedSpans, estimateHeight) {\n\t    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n\t    function update(line, text, spans) {\n\t      updateLine(line, text, spans, estimateHeight);\n\t      signalLater(line, \"change\", line, change);\n\t    }\n\t    function linesFor(start, end) {\n\t      for (var i = start, result = []; i < end; ++i)\n\t        result.push(new Line(text[i], spansFor(i), estimateHeight));\n\t      return result;\n\t    }\n\t\n\t    var from = change.from, to = change.to, text = change.text;\n\t    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n\t    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\t\n\t    // Adjust the line structure\n\t    if (change.full) {\n\t      doc.insert(0, linesFor(0, text.length));\n\t      doc.remove(text.length, doc.size - text.length);\n\t    } else if (isWholeLineUpdate(doc, change)) {\n\t      // This is a whole-line replace. Treated specially to make\n\t      // sure line objects move the way they are supposed to.\n\t      var added = linesFor(0, text.length - 1);\n\t      update(lastLine, lastLine.text, lastSpans);\n\t      if (nlines) doc.remove(from.line, nlines);\n\t      if (added.length) doc.insert(from.line, added);\n\t    } else if (firstLine == lastLine) {\n\t      if (text.length == 1) {\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n\t      } else {\n\t        var added = linesFor(1, text.length - 1);\n\t        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n\t        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t        doc.insert(from.line + 1, added);\n\t      }\n\t    } else if (text.length == 1) {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n\t      doc.remove(from.line + 1, nlines);\n\t    } else {\n\t      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n\t      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n\t      var added = linesFor(1, text.length - 1);\n\t      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n\t      doc.insert(from.line + 1, added);\n\t    }\n\t\n\t    signalLater(doc, \"change\", doc, change);\n\t  }\n\t\n\t  // The document is represented as a BTree consisting of leaves, with\n\t  // chunk of lines in them, and branches, with up to ten leaves or\n\t  // other branch nodes below them. The top node is always a branch\n\t  // node, and is the document object itself (meaning it has\n\t  // additional methods and properties).\n\t  //\n\t  // All nodes have parent links. The tree is used both to go from\n\t  // line numbers to line objects, and to go from objects to numbers.\n\t  // It also indexes by height, and is used to convert between height\n\t  // and line object, and to find the total height of the document.\n\t  //\n\t  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\t\n\t  function LeafChunk(lines) {\n\t    this.lines = lines;\n\t    this.parent = null;\n\t    for (var i = 0, height = 0; i < lines.length; ++i) {\n\t      lines[i].parent = this;\n\t      height += lines[i].height;\n\t    }\n\t    this.height = height;\n\t  }\n\t\n\t  LeafChunk.prototype = {\n\t    chunkSize: function() { return this.lines.length; },\n\t    // Remove the n lines at offset 'at'.\n\t    removeInner: function(at, n) {\n\t      for (var i = at, e = at + n; i < e; ++i) {\n\t        var line = this.lines[i];\n\t        this.height -= line.height;\n\t        cleanUpLine(line);\n\t        signalLater(line, \"delete\");\n\t      }\n\t      this.lines.splice(at, n);\n\t    },\n\t    // Helper used to collapse a small branch into a single leaf.\n\t    collapse: function(lines) {\n\t      lines.push.apply(lines, this.lines);\n\t    },\n\t    // Insert the given array of lines at offset 'at', count them as\n\t    // having the given height.\n\t    insertInner: function(at, lines, height) {\n\t      this.height += height;\n\t      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\t      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n\t    },\n\t    // Used to iterate over a part of the tree.\n\t    iterN: function(at, n, op) {\n\t      for (var e = at + n; at < e; ++at)\n\t        if (op(this.lines[at])) return true;\n\t    }\n\t  };\n\t\n\t  function BranchChunk(children) {\n\t    this.children = children;\n\t    var size = 0, height = 0;\n\t    for (var i = 0; i < children.length; ++i) {\n\t      var ch = children[i];\n\t      size += ch.chunkSize(); height += ch.height;\n\t      ch.parent = this;\n\t    }\n\t    this.size = size;\n\t    this.height = height;\n\t    this.parent = null;\n\t  }\n\t\n\t  BranchChunk.prototype = {\n\t    chunkSize: function() { return this.size; },\n\t    removeInner: function(at, n) {\n\t      this.size -= n;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var rm = Math.min(n, sz - at), oldHeight = child.height;\n\t          child.removeInner(at, rm);\n\t          this.height -= oldHeight - child.height;\n\t          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n\t          if ((n -= rm) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t      // If the result is smaller than 25 lines, ensure that it is a\n\t      // single leaf node.\n\t      if (this.size - n < 25 &&\n\t          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n\t        var lines = [];\n\t        this.collapse(lines);\n\t        this.children = [new LeafChunk(lines)];\n\t        this.children[0].parent = this;\n\t      }\n\t    },\n\t    collapse: function(lines) {\n\t      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n\t    },\n\t    insertInner: function(at, lines, height) {\n\t      this.size += lines.length;\n\t      this.height += height;\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at <= sz) {\n\t          child.insertInner(at, lines, height);\n\t          if (child.lines && child.lines.length > 50) {\n\t            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n\t            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n\t            var remaining = child.lines.length % 25 + 25\n\t            for (var pos = remaining; pos < child.lines.length;) {\n\t              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n\t              child.height -= leaf.height;\n\t              this.children.splice(++i, 0, leaf);\n\t              leaf.parent = this;\n\t            }\n\t            child.lines = child.lines.slice(0, remaining);\n\t            this.maybeSpill();\n\t          }\n\t          break;\n\t        }\n\t        at -= sz;\n\t      }\n\t    },\n\t    // When a node has grown, check whether it should be split.\n\t    maybeSpill: function() {\n\t      if (this.children.length <= 10) return;\n\t      var me = this;\n\t      do {\n\t        var spilled = me.children.splice(me.children.length - 5, 5);\n\t        var sibling = new BranchChunk(spilled);\n\t        if (!me.parent) { // Become the parent node\n\t          var copy = new BranchChunk(me.children);\n\t          copy.parent = me;\n\t          me.children = [copy, sibling];\n\t          me = copy;\n\t       } else {\n\t          me.size -= sibling.size;\n\t          me.height -= sibling.height;\n\t          var myIndex = indexOf(me.parent.children, me);\n\t          me.parent.children.splice(myIndex + 1, 0, sibling);\n\t        }\n\t        sibling.parent = me.parent;\n\t      } while (me.children.length > 10);\n\t      me.parent.maybeSpill();\n\t    },\n\t    iterN: function(at, n, op) {\n\t      for (var i = 0; i < this.children.length; ++i) {\n\t        var child = this.children[i], sz = child.chunkSize();\n\t        if (at < sz) {\n\t          var used = Math.min(n, sz - at);\n\t          if (child.iterN(at, used, op)) return true;\n\t          if ((n -= used) == 0) break;\n\t          at = 0;\n\t        } else at -= sz;\n\t      }\n\t    }\n\t  };\n\t\n\t  var nextDocId = 0;\n\t  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n\t    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n\t    if (firstLine == null) firstLine = 0;\n\t\n\t    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n\t    this.first = firstLine;\n\t    this.scrollTop = this.scrollLeft = 0;\n\t    this.cantEdit = false;\n\t    this.cleanGeneration = 1;\n\t    this.frontier = firstLine;\n\t    var start = Pos(firstLine, 0);\n\t    this.sel = simpleSelection(start);\n\t    this.history = new History(null);\n\t    this.id = ++nextDocId;\n\t    this.modeOption = mode;\n\t    this.lineSep = lineSep;\n\t    this.extend = false;\n\t\n\t    if (typeof text == \"string\") text = this.splitLines(text);\n\t    updateDoc(this, {from: start, to: start, text: text});\n\t    setSelection(this, simpleSelection(start), sel_dontScroll);\n\t  };\n\t\n\t  Doc.prototype = createObj(BranchChunk.prototype, {\n\t    constructor: Doc,\n\t    // Iterate over the document. Supports two forms -- with only one\n\t    // argument, it calls that for each line in the document. With\n\t    // three, it iterates over the range given by the first two (with\n\t    // the second being non-inclusive).\n\t    iter: function(from, to, op) {\n\t      if (op) this.iterN(from - this.first, to - from, op);\n\t      else this.iterN(this.first, this.first + this.size, from);\n\t    },\n\t\n\t    // Non-public interface for adding and removing lines.\n\t    insert: function(at, lines) {\n\t      var height = 0;\n\t      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n\t      this.insertInner(at - this.first, lines, height);\n\t    },\n\t    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\t\n\t    // From here, the methods are part of the public interface. Most\n\t    // are also available from CodeMirror (editor) instances.\n\t\n\t    getValue: function(lineSep) {\n\t      var lines = getLines(this, this.first, this.first + this.size);\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    setValue: docMethodOp(function(code) {\n\t      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n\t      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n\t                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n\t      setSelection(this, simpleSelection(top));\n\t    }),\n\t    replaceRange: function(code, from, to, origin) {\n\t      from = clipPos(this, from);\n\t      to = to ? clipPos(this, to) : from;\n\t      replaceRange(this, code, from, to, origin);\n\t    },\n\t    getRange: function(from, to, lineSep) {\n\t      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n\t      if (lineSep === false) return lines;\n\t      return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t\n\t    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\t\n\t    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n\t    getLineNumber: function(line) {return lineNo(line);},\n\t\n\t    getLineHandleVisualStart: function(line) {\n\t      if (typeof line == \"number\") line = getLine(this, line);\n\t      return visualLine(line);\n\t    },\n\t\n\t    lineCount: function() {return this.size;},\n\t    firstLine: function() {return this.first;},\n\t    lastLine: function() {return this.first + this.size - 1;},\n\t\n\t    clipPos: function(pos) {return clipPos(this, pos);},\n\t\n\t    getCursor: function(start) {\n\t      var range = this.sel.primary(), pos;\n\t      if (start == null || start == \"head\") pos = range.head;\n\t      else if (start == \"anchor\") pos = range.anchor;\n\t      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n\t      else pos = range.from();\n\t      return pos;\n\t    },\n\t    listSelections: function() { return this.sel.ranges; },\n\t    somethingSelected: function() {return this.sel.somethingSelected();},\n\t\n\t    setCursor: docMethodOp(function(line, ch, options) {\n\t      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n\t    }),\n\t    setSelection: docMethodOp(function(anchor, head, options) {\n\t      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n\t    }),\n\t    extendSelection: docMethodOp(function(head, other, options) {\n\t      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n\t    }),\n\t    extendSelections: docMethodOp(function(heads, options) {\n\t      extendSelections(this, clipPosArray(this, heads), options);\n\t    }),\n\t    extendSelectionsBy: docMethodOp(function(f, options) {\n\t      var heads = map(this.sel.ranges, f);\n\t      extendSelections(this, clipPosArray(this, heads), options);\n\t    }),\n\t    setSelections: docMethodOp(function(ranges, primary, options) {\n\t      if (!ranges.length) return;\n\t      for (var i = 0, out = []; i < ranges.length; i++)\n\t        out[i] = new Range(clipPos(this, ranges[i].anchor),\n\t                           clipPos(this, ranges[i].head));\n\t      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n\t      setSelection(this, normalizeSelection(out, primary), options);\n\t    }),\n\t    addSelection: docMethodOp(function(anchor, head, options) {\n\t      var ranges = this.sel.ranges.slice(0);\n\t      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n\t      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n\t    }),\n\t\n\t    getSelection: function(lineSep) {\n\t      var ranges = this.sel.ranges, lines;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        lines = lines ? lines.concat(sel) : sel;\n\t      }\n\t      if (lineSep === false) return lines;\n\t      else return lines.join(lineSep || this.lineSeparator());\n\t    },\n\t    getSelections: function(lineSep) {\n\t      var parts = [], ranges = this.sel.ranges;\n\t      for (var i = 0; i < ranges.length; i++) {\n\t        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\t        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n\t        parts[i] = sel;\n\t      }\n\t      return parts;\n\t    },\n\t    replaceSelection: function(code, collapse, origin) {\n\t      var dup = [];\n\t      for (var i = 0; i < this.sel.ranges.length; i++)\n\t        dup[i] = code;\n\t      this.replaceSelections(dup, collapse, origin || \"+input\");\n\t    },\n\t    replaceSelections: docMethodOp(function(code, collapse, origin) {\n\t      var changes = [], sel = this.sel;\n\t      for (var i = 0; i < sel.ranges.length; i++) {\n\t        var range = sel.ranges[i];\n\t        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n\t      }\n\t      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n\t      for (var i = changes.length - 1; i >= 0; i--)\n\t        makeChange(this, changes[i]);\n\t      if (newSel) setSelectionReplaceHistory(this, newSel);\n\t      else if (this.cm) ensureCursorVisible(this.cm);\n\t    }),\n\t    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n\t    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n\t    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n\t    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\t\n\t    setExtending: function(val) {this.extend = val;},\n\t    getExtending: function() {return this.extend;},\n\t\n\t    historySize: function() {\n\t      var hist = this.history, done = 0, undone = 0;\n\t      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n\t      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n\t      return {undo: done, redo: undone};\n\t    },\n\t    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\t\n\t    markClean: function() {\n\t      this.cleanGeneration = this.changeGeneration(true);\n\t    },\n\t    changeGeneration: function(forceSplit) {\n\t      if (forceSplit)\n\t        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n\t      return this.history.generation;\n\t    },\n\t    isClean: function (gen) {\n\t      return this.history.generation == (gen || this.cleanGeneration);\n\t    },\n\t\n\t    getHistory: function() {\n\t      return {done: copyHistoryArray(this.history.done),\n\t              undone: copyHistoryArray(this.history.undone)};\n\t    },\n\t    setHistory: function(histData) {\n\t      var hist = this.history = new History(this.history.maxGeneration);\n\t      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n\t      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n\t    },\n\t\n\t    addLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        if (!line[prop]) line[prop] = cls;\n\t        else if (classTest(cls).test(line[prop])) return false;\n\t        else line[prop] += \" \" + cls;\n\t        return true;\n\t      });\n\t    }),\n\t    removeLineClass: docMethodOp(function(handle, where, cls) {\n\t      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n\t        var prop = where == \"text\" ? \"textClass\"\n\t                 : where == \"background\" ? \"bgClass\"\n\t                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\t        var cur = line[prop];\n\t        if (!cur) return false;\n\t        else if (cls == null) line[prop] = null;\n\t        else {\n\t          var found = cur.match(classTest(cls));\n\t          if (!found) return false;\n\t          var end = found.index + found[0].length;\n\t          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n\t        }\n\t        return true;\n\t      });\n\t    }),\n\t\n\t    addLineWidget: docMethodOp(function(handle, node, options) {\n\t      return addLineWidget(this, handle, node, options);\n\t    }),\n\t    removeLineWidget: function(widget) { widget.clear(); },\n\t\n\t    markText: function(from, to, options) {\n\t      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n\t    },\n\t    setBookmark: function(pos, options) {\n\t      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n\t                      insertLeft: options && options.insertLeft,\n\t                      clearWhenEmpty: false, shared: options && options.shared,\n\t                      handleMouseEvents: options && options.handleMouseEvents};\n\t      pos = clipPos(this, pos);\n\t      return markText(this, pos, pos, realOpts, \"bookmark\");\n\t    },\n\t    findMarksAt: function(pos) {\n\t      pos = clipPos(this, pos);\n\t      var markers = [], spans = getLine(this, pos.line).markedSpans;\n\t      if (spans) for (var i = 0; i < spans.length; ++i) {\n\t        var span = spans[i];\n\t        if ((span.from == null || span.from <= pos.ch) &&\n\t            (span.to == null || span.to >= pos.ch))\n\t          markers.push(span.marker.parent || span.marker);\n\t      }\n\t      return markers;\n\t    },\n\t    findMarks: function(from, to, filter) {\n\t      from = clipPos(this, from); to = clipPos(this, to);\n\t      var found = [], lineNo = from.line;\n\t      this.iter(from.line, to.line + 1, function(line) {\n\t        var spans = line.markedSpans;\n\t        if (spans) for (var i = 0; i < spans.length; i++) {\n\t          var span = spans[i];\n\t          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n\t                span.from == null && lineNo != from.line ||\n\t                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n\t              (!filter || filter(span.marker)))\n\t            found.push(span.marker.parent || span.marker);\n\t        }\n\t        ++lineNo;\n\t      });\n\t      return found;\n\t    },\n\t    getAllMarks: function() {\n\t      var markers = [];\n\t      this.iter(function(line) {\n\t        var sps = line.markedSpans;\n\t        if (sps) for (var i = 0; i < sps.length; ++i)\n\t          if (sps[i].from != null) markers.push(sps[i].marker);\n\t      });\n\t      return markers;\n\t    },\n\t\n\t    posFromIndex: function(off) {\n\t      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n\t      this.iter(function(line) {\n\t        var sz = line.text.length + sepSize;\n\t        if (sz > off) { ch = off; return true; }\n\t        off -= sz;\n\t        ++lineNo;\n\t      });\n\t      return clipPos(this, Pos(lineNo, ch));\n\t    },\n\t    indexFromPos: function (coords) {\n\t      coords = clipPos(this, coords);\n\t      var index = coords.ch;\n\t      if (coords.line < this.first || coords.ch < 0) return 0;\n\t      var sepSize = this.lineSeparator().length;\n\t      this.iter(this.first, coords.line, function (line) {\n\t        index += line.text.length + sepSize;\n\t      });\n\t      return index;\n\t    },\n\t\n\t    copy: function(copyHistory) {\n\t      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n\t                        this.modeOption, this.first, this.lineSep);\n\t      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n\t      doc.sel = this.sel;\n\t      doc.extend = false;\n\t      if (copyHistory) {\n\t        doc.history.undoDepth = this.history.undoDepth;\n\t        doc.setHistory(this.getHistory());\n\t      }\n\t      return doc;\n\t    },\n\t\n\t    linkedDoc: function(options) {\n\t      if (!options) options = {};\n\t      var from = this.first, to = this.first + this.size;\n\t      if (options.from != null && options.from > from) from = options.from;\n\t      if (options.to != null && options.to < to) to = options.to;\n\t      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n\t      if (options.sharedHist) copy.history = this.history;\n\t      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n\t      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n\t      copySharedMarkers(copy, findSharedMarkers(this));\n\t      return copy;\n\t    },\n\t    unlinkDoc: function(other) {\n\t      if (other instanceof CodeMirror) other = other.doc;\n\t      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n\t        var link = this.linked[i];\n\t        if (link.doc != other) continue;\n\t        this.linked.splice(i, 1);\n\t        other.unlinkDoc(this);\n\t        detachSharedMarkers(findSharedMarkers(this));\n\t        break;\n\t      }\n\t      // If the histories were shared, split them again\n\t      if (other.history == this.history) {\n\t        var splitIds = [other.id];\n\t        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n\t        other.history = new History(null);\n\t        other.history.done = copyHistoryArray(this.history.done, splitIds);\n\t        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n\t      }\n\t    },\n\t    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\t\n\t    getMode: function() {return this.mode;},\n\t    getEditor: function() {return this.cm;},\n\t\n\t    splitLines: function(str) {\n\t      if (this.lineSep) return str.split(this.lineSep);\n\t      return splitLinesAuto(str);\n\t    },\n\t    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n\t  });\n\t\n\t  // Public alias.\n\t  Doc.prototype.eachLine = Doc.prototype.iter;\n\t\n\t  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n\t  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n\t  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n\t    CodeMirror.prototype[prop] = (function(method) {\n\t      return function() {return method.apply(this.doc, arguments);};\n\t    })(Doc.prototype[prop]);\n\t\n\t  eventMixin(Doc);\n\t\n\t  // Call f for all linked documents.\n\t  function linkedDocs(doc, f, sharedHistOnly) {\n\t    function propagate(doc, skip, sharedHist) {\n\t      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n\t        var rel = doc.linked[i];\n\t        if (rel.doc == skip) continue;\n\t        var shared = sharedHist && rel.sharedHist;\n\t        if (sharedHistOnly && !shared) continue;\n\t        f(rel.doc, shared);\n\t        propagate(rel.doc, doc, shared);\n\t      }\n\t    }\n\t    propagate(doc, null, true);\n\t  }\n\t\n\t  // Attach a document to an editor.\n\t  function attachDoc(cm, doc) {\n\t    if (doc.cm) throw new Error(\"This document is already in use.\");\n\t    cm.doc = doc;\n\t    doc.cm = cm;\n\t    estimateLineHeights(cm);\n\t    loadMode(cm);\n\t    if (!cm.options.lineWrapping) findMaxLine(cm);\n\t    cm.options.mode = doc.modeOption;\n\t    regChange(cm);\n\t  }\n\t\n\t  // LINE UTILITIES\n\t\n\t  // Find the line object corresponding to the given line number.\n\t  function getLine(doc, n) {\n\t    n -= doc.first;\n\t    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n\t    for (var chunk = doc; !chunk.lines;) {\n\t      for (var i = 0;; ++i) {\n\t        var child = chunk.children[i], sz = child.chunkSize();\n\t        if (n < sz) { chunk = child; break; }\n\t        n -= sz;\n\t      }\n\t    }\n\t    return chunk.lines[n];\n\t  }\n\t\n\t  // Get the part of a document between two positions, as an array of\n\t  // strings.\n\t  function getBetween(doc, start, end) {\n\t    var out = [], n = start.line;\n\t    doc.iter(start.line, end.line + 1, function(line) {\n\t      var text = line.text;\n\t      if (n == end.line) text = text.slice(0, end.ch);\n\t      if (n == start.line) text = text.slice(start.ch);\n\t      out.push(text);\n\t      ++n;\n\t    });\n\t    return out;\n\t  }\n\t  // Get the lines between from and to, as array of strings.\n\t  function getLines(doc, from, to) {\n\t    var out = [];\n\t    doc.iter(from, to, function(line) { out.push(line.text); });\n\t    return out;\n\t  }\n\t\n\t  // Update the height of a line, propagating the height change\n\t  // upwards to parent nodes.\n\t  function updateLineHeight(line, height) {\n\t    var diff = height - line.height;\n\t    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n\t  }\n\t\n\t  // Given a line object, find its line number by walking up through\n\t  // its parent links.\n\t  function lineNo(line) {\n\t    if (line.parent == null) return null;\n\t    var cur = line.parent, no = indexOf(cur.lines, line);\n\t    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n\t      for (var i = 0;; ++i) {\n\t        if (chunk.children[i] == cur) break;\n\t        no += chunk.children[i].chunkSize();\n\t      }\n\t    }\n\t    return no + cur.first;\n\t  }\n\t\n\t  // Find the line at the given vertical position, using the height\n\t  // information in the document tree.\n\t  function lineAtHeight(chunk, h) {\n\t    var n = chunk.first;\n\t    outer: do {\n\t      for (var i = 0; i < chunk.children.length; ++i) {\n\t        var child = chunk.children[i], ch = child.height;\n\t        if (h < ch) { chunk = child; continue outer; }\n\t        h -= ch;\n\t        n += child.chunkSize();\n\t      }\n\t      return n;\n\t    } while (!chunk.lines);\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i], lh = line.height;\n\t      if (h < lh) break;\n\t      h -= lh;\n\t    }\n\t    return n + i;\n\t  }\n\t\n\t\n\t  // Find the height above the given line.\n\t  function heightAtLine(lineObj) {\n\t    lineObj = visualLine(lineObj);\n\t\n\t    var h = 0, chunk = lineObj.parent;\n\t    for (var i = 0; i < chunk.lines.length; ++i) {\n\t      var line = chunk.lines[i];\n\t      if (line == lineObj) break;\n\t      else h += line.height;\n\t    }\n\t    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n\t      for (var i = 0; i < p.children.length; ++i) {\n\t        var cur = p.children[i];\n\t        if (cur == chunk) break;\n\t        else h += cur.height;\n\t      }\n\t    }\n\t    return h;\n\t  }\n\t\n\t  // Get the bidi ordering for the given line (and cache it). Returns\n\t  // false for lines that are fully left-to-right, and an array of\n\t  // BidiSpan objects otherwise.\n\t  function getOrder(line) {\n\t    var order = line.order;\n\t    if (order == null) order = line.order = bidiOrdering(line.text);\n\t    return order;\n\t  }\n\t\n\t  // HISTORY\n\t\n\t  function History(startGen) {\n\t    // Arrays of change events and selections. Doing something adds an\n\t    // event to done and clears undo. Undoing moves events from done\n\t    // to undone, redoing moves them in the other direction.\n\t    this.done = []; this.undone = [];\n\t    this.undoDepth = Infinity;\n\t    // Used to track when changes can be merged into a single undo\n\t    // event\n\t    this.lastModTime = this.lastSelTime = 0;\n\t    this.lastOp = this.lastSelOp = null;\n\t    this.lastOrigin = this.lastSelOrigin = null;\n\t    // Used by the isClean() method\n\t    this.generation = this.maxGeneration = startGen || 1;\n\t  }\n\t\n\t  // Create a history change event from an updateDoc-style change\n\t  // object.\n\t  function historyChangeFromChange(doc, change) {\n\t    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n\t    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n\t    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n\t    return histChange;\n\t  }\n\t\n\t  // Pop all selection events off the end of a history array. Stop at\n\t  // a change event.\n\t  function clearSelectionEvents(array) {\n\t    while (array.length) {\n\t      var last = lst(array);\n\t      if (last.ranges) array.pop();\n\t      else break;\n\t    }\n\t  }\n\t\n\t  // Find the top change event in the history. Pop off selection\n\t  // events that are in the way.\n\t  function lastChangeEvent(hist, force) {\n\t    if (force) {\n\t      clearSelectionEvents(hist.done);\n\t      return lst(hist.done);\n\t    } else if (hist.done.length && !lst(hist.done).ranges) {\n\t      return lst(hist.done);\n\t    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n\t      hist.done.pop();\n\t      return lst(hist.done);\n\t    }\n\t  }\n\t\n\t  // Register a change in the history. Merges changes that are within\n\t  // a single operation, or are close together with an origin that\n\t  // allows merging (starting with \"+\") into a single event.\n\t  function addChangeToHistory(doc, change, selAfter, opId) {\n\t    var hist = doc.history;\n\t    hist.undone.length = 0;\n\t    var time = +new Date, cur;\n\t\n\t    if ((hist.lastOp == opId ||\n\t         hist.lastOrigin == change.origin && change.origin &&\n\t         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n\t          change.origin.charAt(0) == \"*\")) &&\n\t        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n\t      // Merge this change into the last event\n\t      var last = lst(cur.changes);\n\t      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n\t        // Optimized case for simple insertion -- don't want to add\n\t        // new changesets for every character typed\n\t        last.to = changeEnd(change);\n\t      } else {\n\t        // Add new sub-event\n\t        cur.changes.push(historyChangeFromChange(doc, change));\n\t      }\n\t    } else {\n\t      // Can not be merged, start a new event.\n\t      var before = lst(hist.done);\n\t      if (!before || !before.ranges)\n\t        pushSelectionToHistory(doc.sel, hist.done);\n\t      cur = {changes: [historyChangeFromChange(doc, change)],\n\t             generation: hist.generation};\n\t      hist.done.push(cur);\n\t      while (hist.done.length > hist.undoDepth) {\n\t        hist.done.shift();\n\t        if (!hist.done[0].ranges) hist.done.shift();\n\t      }\n\t    }\n\t    hist.done.push(selAfter);\n\t    hist.generation = ++hist.maxGeneration;\n\t    hist.lastModTime = hist.lastSelTime = time;\n\t    hist.lastOp = hist.lastSelOp = opId;\n\t    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\t\n\t    if (!last) signal(doc, \"historyAdded\");\n\t  }\n\t\n\t  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n\t    var ch = origin.charAt(0);\n\t    return ch == \"*\" ||\n\t      ch == \"+\" &&\n\t      prev.ranges.length == sel.ranges.length &&\n\t      prev.somethingSelected() == sel.somethingSelected() &&\n\t      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n\t  }\n\t\n\t  // Called whenever the selection changes, sets the new selection as\n\t  // the pending selection in the history, and pushes the old pending\n\t  // selection into the 'done' array when it was significantly\n\t  // different (in number of selected ranges, emptiness, or time).\n\t  function addSelectionToHistory(doc, sel, opId, options) {\n\t    var hist = doc.history, origin = options && options.origin;\n\t\n\t    // A new event is started when the previous origin does not match\n\t    // the current, or the origins don't allow matching. Origins\n\t    // starting with * are always merged, those starting with + are\n\t    // merged when similar and close together in time.\n\t    if (opId == hist.lastSelOp ||\n\t        (origin && hist.lastSelOrigin == origin &&\n\t         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n\t          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n\t      hist.done[hist.done.length - 1] = sel;\n\t    else\n\t      pushSelectionToHistory(sel, hist.done);\n\t\n\t    hist.lastSelTime = +new Date;\n\t    hist.lastSelOrigin = origin;\n\t    hist.lastSelOp = opId;\n\t    if (options && options.clearRedo !== false)\n\t      clearSelectionEvents(hist.undone);\n\t  }\n\t\n\t  function pushSelectionToHistory(sel, dest) {\n\t    var top = lst(dest);\n\t    if (!(top && top.ranges && top.equals(sel)))\n\t      dest.push(sel);\n\t  }\n\t\n\t  // Used to store marked span information in the history.\n\t  function attachLocalSpans(doc, change, from, to) {\n\t    var existing = change[\"spans_\" + doc.id], n = 0;\n\t    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n\t      if (line.markedSpans)\n\t        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n\t      ++n;\n\t    });\n\t  }\n\t\n\t  // When un/re-doing restores text containing marked spans, those\n\t  // that have been explicitly cleared should not be restored.\n\t  function removeClearedSpans(spans) {\n\t    if (!spans) return null;\n\t    for (var i = 0, out; i < spans.length; ++i) {\n\t      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n\t      else if (out) out.push(spans[i]);\n\t    }\n\t    return !out ? spans : out.length ? out : null;\n\t  }\n\t\n\t  // Retrieve and filter the old marked spans stored in a change event.\n\t  function getOldSpans(doc, change) {\n\t    var found = change[\"spans_\" + doc.id];\n\t    if (!found) return null;\n\t    for (var i = 0, nw = []; i < change.text.length; ++i)\n\t      nw.push(removeClearedSpans(found[i]));\n\t    return nw;\n\t  }\n\t\n\t  // Used both to provide a JSON-safe object in .getHistory, and, when\n\t  // detaching a document, to split the history in two\n\t  function copyHistoryArray(events, newGroup, instantiateSel) {\n\t    for (var i = 0, copy = []; i < events.length; ++i) {\n\t      var event = events[i];\n\t      if (event.ranges) {\n\t        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n\t        continue;\n\t      }\n\t      var changes = event.changes, newChanges = [];\n\t      copy.push({changes: newChanges});\n\t      for (var j = 0; j < changes.length; ++j) {\n\t        var change = changes[j], m;\n\t        newChanges.push({from: change.from, to: change.to, text: change.text});\n\t        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n\t          if (indexOf(newGroup, Number(m[1])) > -1) {\n\t            lst(newChanges)[prop] = change[prop];\n\t            delete change[prop];\n\t          }\n\t        }\n\t      }\n\t    }\n\t    return copy;\n\t  }\n\t\n\t  // Rebasing/resetting history to deal with externally-sourced changes\n\t\n\t  function rebaseHistSelSingle(pos, from, to, diff) {\n\t    if (to < pos.line) {\n\t      pos.line += diff;\n\t    } else if (from < pos.line) {\n\t      pos.line = from;\n\t      pos.ch = 0;\n\t    }\n\t  }\n\t\n\t  // Tries to rebase an array of history events given a change in the\n\t  // document. If the change touches the same lines as the event, the\n\t  // event, and everything 'behind' it, is discarded. If the change is\n\t  // before the event, the event's positions are updated. Uses a\n\t  // copy-on-write scheme for the positions, to avoid having to\n\t  // reallocate them all on every rebase, but also avoid problems with\n\t  // shared position objects being unsafely updated.\n\t  function rebaseHistArray(array, from, to, diff) {\n\t    for (var i = 0; i < array.length; ++i) {\n\t      var sub = array[i], ok = true;\n\t      if (sub.ranges) {\n\t        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n\t        for (var j = 0; j < sub.ranges.length; j++) {\n\t          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n\t          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n\t        }\n\t        continue;\n\t      }\n\t      for (var j = 0; j < sub.changes.length; ++j) {\n\t        var cur = sub.changes[j];\n\t        if (to < cur.from.line) {\n\t          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n\t          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n\t        } else if (from <= cur.to.line) {\n\t          ok = false;\n\t          break;\n\t        }\n\t      }\n\t      if (!ok) {\n\t        array.splice(0, i + 1);\n\t        i = 0;\n\t      }\n\t    }\n\t  }\n\t\n\t  function rebaseHist(hist, change) {\n\t    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n\t    rebaseHistArray(hist.done, from, to, diff);\n\t    rebaseHistArray(hist.undone, from, to, diff);\n\t  }\n\t\n\t  // EVENT UTILITIES\n\t\n\t  // Due to the fact that we still support jurassic IE versions, some\n\t  // compatibility wrappers are needed.\n\t\n\t  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n\t    if (e.preventDefault) e.preventDefault();\n\t    else e.returnValue = false;\n\t  };\n\t  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n\t    if (e.stopPropagation) e.stopPropagation();\n\t    else e.cancelBubble = true;\n\t  };\n\t  function e_defaultPrevented(e) {\n\t    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n\t  }\n\t  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\t\n\t  function e_target(e) {return e.target || e.srcElement;}\n\t  function e_button(e) {\n\t    var b = e.which;\n\t    if (b == null) {\n\t      if (e.button & 1) b = 1;\n\t      else if (e.button & 2) b = 3;\n\t      else if (e.button & 4) b = 2;\n\t    }\n\t    if (mac && e.ctrlKey && b == 1) b = 3;\n\t    return b;\n\t  }\n\t\n\t  // EVENT HANDLING\n\t\n\t  // Lightweight event framework. on/off also work on DOM nodes,\n\t  // registering native DOM handlers.\n\t\n\t  var on = CodeMirror.on = function(emitter, type, f) {\n\t    if (emitter.addEventListener)\n\t      emitter.addEventListener(type, f, false);\n\t    else if (emitter.attachEvent)\n\t      emitter.attachEvent(\"on\" + type, f);\n\t    else {\n\t      var map = emitter._handlers || (emitter._handlers = {});\n\t      var arr = map[type] || (map[type] = []);\n\t      arr.push(f);\n\t    }\n\t  };\n\t\n\t  var noHandlers = []\n\t  function getHandlers(emitter, type, copy) {\n\t    var arr = emitter._handlers && emitter._handlers[type]\n\t    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n\t    else return arr || noHandlers\n\t  }\n\t\n\t  var off = CodeMirror.off = function(emitter, type, f) {\n\t    if (emitter.removeEventListener)\n\t      emitter.removeEventListener(type, f, false);\n\t    else if (emitter.detachEvent)\n\t      emitter.detachEvent(\"on\" + type, f);\n\t    else {\n\t      var handlers = getHandlers(emitter, type, false)\n\t      for (var i = 0; i < handlers.length; ++i)\n\t        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n\t    }\n\t  };\n\t\n\t  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n\t    var handlers = getHandlers(emitter, type, true)\n\t    if (!handlers.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2);\n\t    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n\t  };\n\t\n\t  var orphanDelayedCallbacks = null;\n\t\n\t  // Often, we want to signal events at a point where we are in the\n\t  // middle of some work, but don't want the handler to start calling\n\t  // other methods on the editor, which might be in an inconsistent\n\t  // state or simply not expect any other events to happen.\n\t  // signalLater looks whether there are any handlers, and schedules\n\t  // them to be executed when the last operation ends, or, if no\n\t  // operation is active, when a timeout fires.\n\t  function signalLater(emitter, type /*, values...*/) {\n\t    var arr = getHandlers(emitter, type, false)\n\t    if (!arr.length) return;\n\t    var args = Array.prototype.slice.call(arguments, 2), list;\n\t    if (operationGroup) {\n\t      list = operationGroup.delayedCallbacks;\n\t    } else if (orphanDelayedCallbacks) {\n\t      list = orphanDelayedCallbacks;\n\t    } else {\n\t      list = orphanDelayedCallbacks = [];\n\t      setTimeout(fireOrphanDelayed, 0);\n\t    }\n\t    function bnd(f) {return function(){f.apply(null, args);};};\n\t    for (var i = 0; i < arr.length; ++i)\n\t      list.push(bnd(arr[i]));\n\t  }\n\t\n\t  function fireOrphanDelayed() {\n\t    var delayed = orphanDelayedCallbacks;\n\t    orphanDelayedCallbacks = null;\n\t    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n\t  }\n\t\n\t  // The DOM events that CodeMirror handles can be overridden by\n\t  // registering a (non-DOM) handler on the editor for the event name,\n\t  // and preventDefault-ing the event in that handler.\n\t  function signalDOMEvent(cm, e, override) {\n\t    if (typeof e == \"string\")\n\t      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n\t    signal(cm, override || e.type, cm, e);\n\t    return e_defaultPrevented(e) || e.codemirrorIgnore;\n\t  }\n\t\n\t  function signalCursorActivity(cm) {\n\t    var arr = cm._handlers && cm._handlers.cursorActivity;\n\t    if (!arr) return;\n\t    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n\t    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n\t      set.push(arr[i]);\n\t  }\n\t\n\t  function hasHandler(emitter, type) {\n\t    return getHandlers(emitter, type).length > 0\n\t  }\n\t\n\t  // Add on and off methods to a constructor's prototype, to make\n\t  // registering events on such objects more convenient.\n\t  function eventMixin(ctor) {\n\t    ctor.prototype.on = function(type, f) {on(this, type, f);};\n\t    ctor.prototype.off = function(type, f) {off(this, type, f);};\n\t  }\n\t\n\t  // MISC UTILITIES\n\t\n\t  // Number of pixels added to scroller and sizer to hide scrollbar\n\t  var scrollerGap = 30;\n\t\n\t  // Returned or thrown by various protocols to signal 'I'm not\n\t  // handling this'.\n\t  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\t\n\t  // Reused option objects for setSelection & friends\n\t  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\t\n\t  function Delayed() {this.id = null;}\n\t  Delayed.prototype.set = function(ms, f) {\n\t    clearTimeout(this.id);\n\t    this.id = setTimeout(f, ms);\n\t  };\n\t\n\t  // Counts the column offset in a string, taking tabs into account.\n\t  // Used mostly to find indentation.\n\t  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n\t    if (end == null) {\n\t      end = string.search(/[^\\s\\u00a0]/);\n\t      if (end == -1) end = string.length;\n\t    }\n\t    for (var i = startIndex || 0, n = startValue || 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", i);\n\t      if (nextTab < 0 || nextTab >= end)\n\t        return n + (end - i);\n\t      n += nextTab - i;\n\t      n += tabSize - (n % tabSize);\n\t      i = nextTab + 1;\n\t    }\n\t  };\n\t\n\t  // The inverse of countColumn -- find the offset that corresponds to\n\t  // a particular column.\n\t  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n\t    for (var pos = 0, col = 0;;) {\n\t      var nextTab = string.indexOf(\"\\t\", pos);\n\t      if (nextTab == -1) nextTab = string.length;\n\t      var skipped = nextTab - pos;\n\t      if (nextTab == string.length || col + skipped >= goal)\n\t        return pos + Math.min(skipped, goal - col);\n\t      col += nextTab - pos;\n\t      col += tabSize - (col % tabSize);\n\t      pos = nextTab + 1;\n\t      if (col >= goal) return pos;\n\t    }\n\t  }\n\t\n\t  var spaceStrs = [\"\"];\n\t  function spaceStr(n) {\n\t    while (spaceStrs.length <= n)\n\t      spaceStrs.push(lst(spaceStrs) + \" \");\n\t    return spaceStrs[n];\n\t  }\n\t\n\t  function lst(arr) { return arr[arr.length-1]; }\n\t\n\t  var selectInput = function(node) { node.select(); };\n\t  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n\t    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n\t  else if (ie) // Suppress mysterious IE10 errors\n\t    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\t\n\t  function indexOf(array, elt) {\n\t    for (var i = 0; i < array.length; ++i)\n\t      if (array[i] == elt) return i;\n\t    return -1;\n\t  }\n\t  function map(array, f) {\n\t    var out = [];\n\t    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n\t    return out;\n\t  }\n\t\n\t  function insertSorted(array, value, score) {\n\t    var pos = 0, priority = score(value)\n\t    while (pos < array.length && score(array[pos]) <= priority) pos++\n\t    array.splice(pos, 0, value)\n\t  }\n\t\n\t  function nothing() {}\n\t\n\t  function createObj(base, props) {\n\t    var inst;\n\t    if (Object.create) {\n\t      inst = Object.create(base);\n\t    } else {\n\t      nothing.prototype = base;\n\t      inst = new nothing();\n\t    }\n\t    if (props) copyObj(props, inst);\n\t    return inst;\n\t  };\n\t\n\t  function copyObj(obj, target, overwrite) {\n\t    if (!target) target = {};\n\t    for (var prop in obj)\n\t      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n\t        target[prop] = obj[prop];\n\t    return target;\n\t  }\n\t\n\t  function bind(f) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    return function(){return f.apply(null, args);};\n\t  }\n\t\n\t  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\t  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n\t    return /\\w/.test(ch) || ch > \"\\x80\" &&\n\t      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n\t  };\n\t  function isWordChar(ch, helper) {\n\t    if (!helper) return isWordCharBasic(ch);\n\t    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n\t    return helper.test(ch);\n\t  }\n\t\n\t  function isEmpty(obj) {\n\t    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n\t    return true;\n\t  }\n\t\n\t  // Extending unicode characters. A series of a non-extending char +\n\t  // any number of extending chars is treated as a single unit as far\n\t  // as editing and measuring is concerned. This is not fully correct,\n\t  // since some scripts/fonts/browsers also treat other configurations\n\t  // of code points as a group.\n\t  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\t  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\t\n\t  // DOM UTILITIES\n\t\n\t  function elt(tag, content, className, style) {\n\t    var e = document.createElement(tag);\n\t    if (className) e.className = className;\n\t    if (style) e.style.cssText = style;\n\t    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n\t    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n\t    return e;\n\t  }\n\t\n\t  var range;\n\t  if (document.createRange) range = function(node, start, end, endNode) {\n\t    var r = document.createRange();\n\t    r.setEnd(endNode || node, end);\n\t    r.setStart(node, start);\n\t    return r;\n\t  };\n\t  else range = function(node, start, end) {\n\t    var r = document.body.createTextRange();\n\t    try { r.moveToElementText(node.parentNode); }\n\t    catch(e) { return r; }\n\t    r.collapse(true);\n\t    r.moveEnd(\"character\", end);\n\t    r.moveStart(\"character\", start);\n\t    return r;\n\t  };\n\t\n\t  function removeChildren(e) {\n\t    for (var count = e.childNodes.length; count > 0; --count)\n\t      e.removeChild(e.firstChild);\n\t    return e;\n\t  }\n\t\n\t  function removeChildrenAndAdd(parent, e) {\n\t    return removeChildren(parent).appendChild(e);\n\t  }\n\t\n\t  var contains = CodeMirror.contains = function(parent, child) {\n\t    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n\t      child = child.parentNode;\n\t    if (parent.contains)\n\t      return parent.contains(child);\n\t    do {\n\t      if (child.nodeType == 11) child = child.host;\n\t      if (child == parent) return true;\n\t    } while (child = child.parentNode);\n\t  };\n\t\n\t  function activeElt() {\n\t    var activeElement = document.activeElement;\n\t    while (activeElement && activeElement.root && activeElement.root.activeElement)\n\t      activeElement = activeElement.root.activeElement;\n\t    return activeElement;\n\t  }\n\t  // Older versions of IE throws unspecified error when touching\n\t  // document.activeElement in some cases (during loading, in iframe)\n\t  if (ie && ie_version < 11) activeElt = function() {\n\t    try { return document.activeElement; }\n\t    catch(e) { return document.body; }\n\t  };\n\t\n\t  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n\t  var rmClass = CodeMirror.rmClass = function(node, cls) {\n\t    var current = node.className;\n\t    var match = classTest(cls).exec(current);\n\t    if (match) {\n\t      var after = current.slice(match.index + match[0].length);\n\t      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n\t    }\n\t  };\n\t  var addClass = CodeMirror.addClass = function(node, cls) {\n\t    var current = node.className;\n\t    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n\t  };\n\t  function joinClasses(a, b) {\n\t    var as = a.split(\" \");\n\t    for (var i = 0; i < as.length; i++)\n\t      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n\t    return b;\n\t  }\n\t\n\t  // WINDOW-WIDE EVENTS\n\t\n\t  // These must be handled carefully, because naively registering a\n\t  // handler for each editor will cause the editors to never be\n\t  // garbage collected.\n\t\n\t  function forEachCodeMirror(f) {\n\t    if (!document.body.getElementsByClassName) return;\n\t    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n\t    for (var i = 0; i < byClass.length; i++) {\n\t      var cm = byClass[i].CodeMirror;\n\t      if (cm) f(cm);\n\t    }\n\t  }\n\t\n\t  var globalsRegistered = false;\n\t  function ensureGlobalHandlers() {\n\t    if (globalsRegistered) return;\n\t    registerGlobalHandlers();\n\t    globalsRegistered = true;\n\t  }\n\t  function registerGlobalHandlers() {\n\t    // When the window resizes, we need to refresh active editors.\n\t    var resizeTimer;\n\t    on(window, \"resize\", function() {\n\t      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n\t        resizeTimer = null;\n\t        forEachCodeMirror(onResize);\n\t      }, 100);\n\t    });\n\t    // When the window loses focus, we want to show the editor as blurred\n\t    on(window, \"blur\", function() {\n\t      forEachCodeMirror(onBlur);\n\t    });\n\t  }\n\t\n\t  // FEATURE DETECTION\n\t\n\t  // Detect drag-and-drop\n\t  var dragAndDrop = function() {\n\t    // There is *some* kind of drag-and-drop support in IE6-8, but I\n\t    // couldn't get it to work yet.\n\t    if (ie && ie_version < 9) return false;\n\t    var div = elt('div');\n\t    return \"draggable\" in div || \"dragDrop\" in div;\n\t  }();\n\t\n\t  var zwspSupported;\n\t  function zeroWidthElement(measure) {\n\t    if (zwspSupported == null) {\n\t      var test = elt(\"span\", \"\\u200b\");\n\t      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\t      if (measure.firstChild.offsetHeight != 0)\n\t        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n\t    }\n\t    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n\t      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n\t    node.setAttribute(\"cm-text\", \"\");\n\t    return node;\n\t  }\n\t\n\t  // Feature-detect IE's crummy client rect reporting for bidi text\n\t  var badBidiRects;\n\t  function hasBadBidiRects(measure) {\n\t    if (badBidiRects != null) return badBidiRects;\n\t    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n\t    var r0 = range(txt, 0, 1).getBoundingClientRect();\n\t    var r1 = range(txt, 1, 2).getBoundingClientRect();\n\t    removeChildren(measure);\n\t    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n\t    return badBidiRects = (r1.right - r0.right < 3);\n\t  }\n\t\n\t  // See if \"\".split is the broken IE version, if so, provide an\n\t  // alternative way to split lines.\n\t  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n\t    var pos = 0, result = [], l = string.length;\n\t    while (pos <= l) {\n\t      var nl = string.indexOf(\"\\n\", pos);\n\t      if (nl == -1) nl = string.length;\n\t      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n\t      var rt = line.indexOf(\"\\r\");\n\t      if (rt != -1) {\n\t        result.push(line.slice(0, rt));\n\t        pos += rt + 1;\n\t      } else {\n\t        result.push(line);\n\t        pos = nl + 1;\n\t      }\n\t    }\n\t    return result;\n\t  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\t\n\t  var hasSelection = window.getSelection ? function(te) {\n\t    try { return te.selectionStart != te.selectionEnd; }\n\t    catch(e) { return false; }\n\t  } : function(te) {\n\t    try {var range = te.ownerDocument.selection.createRange();}\n\t    catch(e) {}\n\t    if (!range || range.parentElement() != te) return false;\n\t    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n\t  };\n\t\n\t  var hasCopyEvent = (function() {\n\t    var e = elt(\"div\");\n\t    if (\"oncopy\" in e) return true;\n\t    e.setAttribute(\"oncopy\", \"return;\");\n\t    return typeof e.oncopy == \"function\";\n\t  })();\n\t\n\t  var badZoomedRects = null;\n\t  function hasBadZoomedRects(measure) {\n\t    if (badZoomedRects != null) return badZoomedRects;\n\t    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n\t    var normal = node.getBoundingClientRect();\n\t    var fromRange = range(node, 0, 1).getBoundingClientRect();\n\t    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n\t  }\n\t\n\t  // KEY NAMES\n\t\n\t  var keyNames = CodeMirror.keyNames = {\n\t    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n\t    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n\t    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n\t    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n\t    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n\t    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n\t    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n\t    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n\t  };\n\t  (function() {\n\t    // Number keys\n\t    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n\t    // Alphabetic keys\n\t    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n\t    // Function keys\n\t    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n\t  })();\n\t\n\t  // BIDI HELPERS\n\t\n\t  function iterateBidiSections(order, from, to, f) {\n\t    if (!order) return f(from, to, \"ltr\");\n\t    var found = false;\n\t    for (var i = 0; i < order.length; ++i) {\n\t      var part = order[i];\n\t      if (part.from < to && part.to > from || from == to && part.to == from) {\n\t        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n\t        found = true;\n\t      }\n\t    }\n\t    if (!found) f(from, to, \"ltr\");\n\t  }\n\t\n\t  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n\t  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\t\n\t  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n\t  function lineRight(line) {\n\t    var order = getOrder(line);\n\t    if (!order) return line.text.length;\n\t    return bidiRight(lst(order));\n\t  }\n\t\n\t  function lineStart(cm, lineN) {\n\t    var line = getLine(cm.doc, lineN);\n\t    var visual = visualLine(line);\n\t    if (visual != line) lineN = lineNo(visual);\n\t    var order = getOrder(visual);\n\t    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n\t    return Pos(lineN, ch);\n\t  }\n\t  function lineEnd(cm, lineN) {\n\t    var merged, line = getLine(cm.doc, lineN);\n\t    while (merged = collapsedSpanAtEnd(line)) {\n\t      line = merged.find(1, true).line;\n\t      lineN = null;\n\t    }\n\t    var order = getOrder(line);\n\t    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n\t    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n\t  }\n\t  function lineStartSmart(cm, pos) {\n\t    var start = lineStart(cm, pos.line);\n\t    var line = getLine(cm.doc, start.line);\n\t    var order = getOrder(line);\n\t    if (!order || order[0].level == 0) {\n\t      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n\t      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n\t      return Pos(start.line, inWS ? 0 : firstNonWS);\n\t    }\n\t    return start;\n\t  }\n\t\n\t  function compareBidiLevel(order, a, b) {\n\t    var linedir = order[0].level;\n\t    if (a == linedir) return true;\n\t    if (b == linedir) return false;\n\t    return a < b;\n\t  }\n\t  var bidiOther;\n\t  function getBidiPartAt(order, pos) {\n\t    bidiOther = null;\n\t    for (var i = 0, found; i < order.length; ++i) {\n\t      var cur = order[i];\n\t      if (cur.from < pos && cur.to > pos) return i;\n\t      if ((cur.from == pos || cur.to == pos)) {\n\t        if (found == null) {\n\t          found = i;\n\t        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n\t          if (cur.from != cur.to) bidiOther = found;\n\t          return i;\n\t        } else {\n\t          if (cur.from != cur.to) bidiOther = i;\n\t          return found;\n\t        }\n\t      }\n\t    }\n\t    return found;\n\t  }\n\t\n\t  function moveInLine(line, pos, dir, byUnit) {\n\t    if (!byUnit) return pos + dir;\n\t    do pos += dir;\n\t    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n\t    return pos;\n\t  }\n\t\n\t  // This is needed in order to move 'visually' through bi-directional\n\t  // text -- i.e., pressing left should make the cursor go left, even\n\t  // when in RTL text. The tricky part is the 'jumps', where RTL and\n\t  // LTR text touch each other. This often requires the cursor offset\n\t  // to move more than one unit, in order to visually move one unit.\n\t  function moveVisually(line, start, dir, byUnit) {\n\t    var bidi = getOrder(line);\n\t    if (!bidi) return moveLogically(line, start, dir, byUnit);\n\t    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n\t    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\t\n\t    for (;;) {\n\t      if (target > part.from && target < part.to) return target;\n\t      if (target == part.from || target == part.to) {\n\t        if (getBidiPartAt(bidi, target) == pos) return target;\n\t        part = bidi[pos += dir];\n\t        return (dir > 0) == part.level % 2 ? part.to : part.from;\n\t      } else {\n\t        part = bidi[pos += dir];\n\t        if (!part) return null;\n\t        if ((dir > 0) == part.level % 2)\n\t          target = moveInLine(line, part.to, -1, byUnit);\n\t        else\n\t          target = moveInLine(line, part.from, 1, byUnit);\n\t      }\n\t    }\n\t  }\n\t\n\t  function moveLogically(line, start, dir, byUnit) {\n\t    var target = start + dir;\n\t    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n\t    return target < 0 || target > line.text.length ? null : target;\n\t  }\n\t\n\t  // Bidirectional ordering algorithm\n\t  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n\t  // that this (partially) implements.\n\t\n\t  // One-char codes used for character types:\n\t  // L (L):   Left-to-Right\n\t  // R (R):   Right-to-Left\n\t  // r (AL):  Right-to-Left Arabic\n\t  // 1 (EN):  European Number\n\t  // + (ES):  European Number Separator\n\t  // % (ET):  European Number Terminator\n\t  // n (AN):  Arabic Number\n\t  // , (CS):  Common Number Separator\n\t  // m (NSM): Non-Spacing Mark\n\t  // b (BN):  Boundary Neutral\n\t  // s (B):   Paragraph Separator\n\t  // t (S):   Segment Separator\n\t  // w (WS):  Whitespace\n\t  // N (ON):  Other Neutrals\n\t\n\t  // Returns null if characters are ordered as they appear\n\t  // (left-to-right), or an array of sections ({from, to, level}\n\t  // objects) in the order in which they occur visually.\n\t  var bidiOrdering = (function() {\n\t    // Character types for codepoints 0 to 0xff\n\t    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n\t    // Character types for codepoints 0x600 to 0x6ff\n\t    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n\t    function charType(code) {\n\t      if (code <= 0xf7) return lowTypes.charAt(code);\n\t      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n\t      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n\t      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n\t      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n\t      else if (code == 0x200c) return \"b\";\n\t      else return \"L\";\n\t    }\n\t\n\t    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n\t    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\t    // Browsers seem to always treat the boundaries of block elements as being L.\n\t    var outerType = \"L\";\n\t\n\t    function BidiSpan(level, from, to) {\n\t      this.level = level;\n\t      this.from = from; this.to = to;\n\t    }\n\t\n\t    return function(str) {\n\t      if (!bidiRE.test(str)) return false;\n\t      var len = str.length, types = [];\n\t      for (var i = 0, type; i < len; ++i)\n\t        types.push(type = charType(str.charCodeAt(i)));\n\t\n\t      // W1. Examine each non-spacing mark (NSM) in the level run, and\n\t      // change the type of the NSM to the type of the previous\n\t      // character. If the NSM is at the start of the level run, it will\n\t      // get the type of sor.\n\t      for (var i = 0, prev = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"m\") types[i] = prev;\n\t        else prev = type;\n\t      }\n\t\n\t      // W2. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, AL, or sor) is found. If an\n\t      // AL is found, change the type of the European number to Arabic\n\t      // number.\n\t      // W3. Change all ALs to R.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n\t        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n\t      }\n\t\n\t      // W4. A single European separator between two European numbers\n\t      // changes to a European number. A single common separator between\n\t      // two numbers of the same type changes to that type.\n\t      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n\t        var type = types[i];\n\t        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n\t        else if (type == \",\" && prev == types[i+1] &&\n\t                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n\t        prev = type;\n\t      }\n\t\n\t      // W5. A sequence of European terminators adjacent to European\n\t      // numbers changes to all European numbers.\n\t      // W6. Otherwise, separators and terminators change to Other\n\t      // Neutral.\n\t      for (var i = 0; i < len; ++i) {\n\t        var type = types[i];\n\t        if (type == \",\") types[i] = \"N\";\n\t        else if (type == \"%\") {\n\t          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n\t          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // W7. Search backwards from each instance of a European number\n\t      // until the first strong type (R, L, or sor) is found. If an L is\n\t      // found, then change the type of the European number to L.\n\t      for (var i = 0, cur = outerType; i < len; ++i) {\n\t        var type = types[i];\n\t        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n\t        else if (isStrong.test(type)) cur = type;\n\t      }\n\t\n\t      // N1. A sequence of neutrals takes the direction of the\n\t      // surrounding strong text if the text on both sides has the same\n\t      // direction. European and Arabic numbers act as if they were R in\n\t      // terms of their influence on neutrals. Start-of-level-run (sor)\n\t      // and end-of-level-run (eor) are used at level run boundaries.\n\t      // N2. Any remaining neutrals take the embedding direction.\n\t      for (var i = 0; i < len; ++i) {\n\t        if (isNeutral.test(types[i])) {\n\t          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n\t          var before = (i ? types[i-1] : outerType) == \"L\";\n\t          var after = (end < len ? types[end] : outerType) == \"L\";\n\t          var replace = before || after ? \"L\" : \"R\";\n\t          for (var j = i; j < end; ++j) types[j] = replace;\n\t          i = end - 1;\n\t        }\n\t      }\n\t\n\t      // Here we depart from the documented algorithm, in order to avoid\n\t      // building up an actual levels array. Since there are only three\n\t      // levels (0, 1, 2) in an implementation that doesn't take\n\t      // explicit embedding into account, we can build up the order on\n\t      // the fly, without following the level-based algorithm.\n\t      var order = [], m;\n\t      for (var i = 0; i < len;) {\n\t        if (countsAsLeft.test(types[i])) {\n\t          var start = i;\n\t          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n\t          order.push(new BidiSpan(0, start, i));\n\t        } else {\n\t          var pos = i, at = order.length;\n\t          for (++i; i < len && types[i] != \"L\"; ++i) {}\n\t          for (var j = pos; j < i;) {\n\t            if (countsAsNum.test(types[j])) {\n\t              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n\t              var nstart = j;\n\t              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n\t              order.splice(at, 0, new BidiSpan(2, nstart, j));\n\t              pos = j;\n\t            } else ++j;\n\t          }\n\t          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n\t        }\n\t      }\n\t      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n\t        order[0].from = m[0].length;\n\t        order.unshift(new BidiSpan(0, 0, m[0].length));\n\t      }\n\t      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n\t        lst(order).to -= m[0].length;\n\t        order.push(new BidiSpan(0, len - m[0].length, len));\n\t      }\n\t      if (order[0].level == 2)\n\t        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n\t      if (order[0].level != lst(order).level)\n\t        order.push(new BidiSpan(order[0].level, len, len));\n\t\n\t      return order;\n\t    };\n\t  })();\n\t\n\t  // THE END\n\t\n\t  CodeMirror.version = \"5.19.0\";\n\t\n\t  return CodeMirror;\n\t});\n\n\n/***/ },\n\n/***/ 83:\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(jQuery) {(function ($) {\n\t  $.extend($.summernote.lang, {\n\t    'pt-BR': {\n\t      font: {\n\t        bold: 'Negrito',\n\t        italic: 'Itlico',\n\t        underline: 'Sublinhado',\n\t        clear: 'Remover estilo da fonte',\n\t        height: 'Altura da linha',\n\t        name: 'Fonte',\n\t        strikethrough: 'Riscado',\n\t        size: 'Tamanho da fonte'\n\t      },\n\t      image: {\n\t        image: 'Imagem',\n\t        insert: 'Inserir imagem',\n\t        resizeFull: 'Redimensionar Completamente',\n\t        resizeHalf: 'Redimensionar pela Metade',\n\t        resizeQuarter: 'Redimensionar um Quarto',\n\t        floatLeft: 'Flutuar para Esquerda',\n\t        floatRight: 'Flutuar para Direira',\n\t        floatNone: 'No Flutuar',\n\t        dragImageHere: 'Arraste uma imagem para c',\n\t        selectFromFiles: 'Selecione a partir dos arquivos',\n\t        url: 'URL da imagem'\n\t      },\n\t      video: {\n\t        video: 'Vdeo',\n\t        videoLink: 'Link para vdeo',\n\t        insert: 'Inserir vdeo',\n\t        url: 'URL do vdeo?',\n\t        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion ou Youku)'\n\t      },\n\t      link: {\n\t        link: 'Link',\n\t        insert: 'Inserir link',\n\t        unlink: 'Remover link',\n\t        edit: 'Editar',\n\t        textToDisplay: 'Texto para exibir',\n\t        url: 'Para qual URL esse link leva?',\n\t        openInNewWindow: 'Abrir em uma nova janela'\n\t      },\n\t      table: {\n\t        table: 'Tabela'\n\t      },\n\t      hr: {\n\t        insert: 'Inserir linha horizontal'\n\t      },\n\t      style: {\n\t        style: 'Estilo',\n\t        normal: 'Normal',\n\t        blockquote: 'Citao',\n\t        pre: 'Cdigo',\n\t        h1: 'Ttulo 1',\n\t        h2: 'Ttulo 2',\n\t        h3: 'Ttulo 3',\n\t        h4: 'Ttulo 4',\n\t        h5: 'Ttulo 5',\n\t        h6: 'Ttulo 6'\n\t      },\n\t      lists: {\n\t        unordered: 'Lista com marcadores',\n\t        ordered: 'Lista numerada'\n\t      },\n\t      options: {\n\t        help: 'Ajuda',\n\t        fullscreen: 'Tela cheia',\n\t        codeview: 'Ver cdigo-fonte'\n\t      },\n\t      paragraph: {\n\t        paragraph: 'Pargrafo',\n\t        outdent: 'Menor tabulao',\n\t        indent: 'Maior tabulao',\n\t        left: 'Alinhar  esquerda',\n\t        center: 'Alinhar ao centro',\n\t        right: 'Alinha  direita',\n\t        justify: 'Justificado'\n\t      },\n\t      color: {\n\t        recent: 'Cor recente',\n\t        more: 'Mais cores',\n\t        background: 'Fundo',\n\t        foreground: 'Fonte',\n\t        transparent: 'Transparente',\n\t        setTransparent: 'Fundo transparente',\n\t        reset: 'Restaurar',\n\t        resetToDefault: 'Restaurar padro'\n\t      },\n\t      shortcut: {\n\t        shortcuts: 'Atalhos do teclado',\n\t        close: 'Fechar',\n\t        textFormatting: 'Formatao de texto',\n\t        action: 'Ao',\n\t        paragraphFormatting: 'Formatao de pargrafo',\n\t        documentStyle: 'Estilo de documento'\n\t      },\n\t      history: {\n\t        undo: 'Desfazer',\n\t        redo: 'Refazer'\n\t      },\n\t      help: {\n\t        'insertParagraph': 'Inserir Pargrafo',\n\t        'undo': 'Desfazer o ltimo comando',\n\t        'redo': 'Refazer o ltimo comando',\n\t        'tab': 'Tab',\n\t        'untab': 'Desfazer tab',\n\t        'bold': 'Colocar em negrito',\n\t        'italic': 'Colocar em itlico',\n\t        'underline': 'Sublinhado',\n\t        'strikethrough': 'Tachado',\n\t        'removeFormat': 'Remover estilo',\n\t        'justifyLeft': 'Alinhar  esquerda',\n\t        'justifyCenter': 'Centralizar',\n\t        'justifyRight': 'Alinhar  esquerda',\n\t        'justifyFull': 'Justificar',\n\t        'insertUnorderedList': 'Lista no ordenada',\n\t        'insertOrderedList': 'Lista ordenada',\n\t        'outdent': 'Recuar pargrafo atual',\n\t        'indent': 'Avanar pargrafo atual',\n\t        'formatPara': 'Alterar formato do bloco para pargrafo(tag P)',\n\t        'formatH1': 'Alterar formato do bloco para H1',\n\t        'formatH2': 'Alterar formato do bloco para H2',\n\t        'formatH3': 'Alterar formato do bloco para H3',\n\t        'formatH4': 'Alterar formato do bloco para H4',\n\t        'formatH5': 'Alterar formato do bloco para H5',\n\t        'formatH6': 'Alterar formato do bloco para H6',\n\t        'insertHorizontalRule': 'Inserir rgua horizontal',\n\t        'linkDialog.show': 'Inserir um Hiperlink'\n\t      }\n\t    }\n\t  });\n\t})(jQuery);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n\n/***/ 84:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\t(function (factory) {\n\t  /* global define */\n\t  if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof module === 'object' && module.exports) {\n\t    // Node/CommonJS\n\t    module.exports = factory(require('jquery'));\n\t  } else {\n\t    // Browser globals\n\t    factory(window.jQuery);\n\t  }\n\t})(function ($) {\n\t  var embedToSummernote = function embedToSummernote(context) {\n\t    var self = this;\n\t\n\t    var options = context.options;\n\t    var inToolbar = false;\n\t\n\t    for (var idx in options.toolbar) {\n\t      // toolbar => [groupName, [list of button]]\n\t      var buttons = options.toolbar[idx][1];\n\t      if ($.inArray('oembed', buttons) > -1) {\n\t        inToolbar = true;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!inToolbar) {\n\t      return;\n\t    }\n\t\n\t    var ui = $.summernote.ui;\n\t    var $editor = context.layoutInfo.editor;\n\t    var lang = options.langInfo;\n\t\n\t    var oEmbedOptions = {\n\t      service: 'https://noembed.com/'\n\t    };\n\t\n\t    options.oEmbed = $.extend(oEmbedOptions, options.oEmbed);\n\t\n\t    context.memo('button.oembed', function () {\n\t      var button = ui.button({\n\t        contents: '<i class=\"note-icon-frame\">',\n\t        tooltip: lang.oEmbedButton.tooltip,\n\t        click: function click(event) {\n\t          self.show();\n\t        }\n\t      });\n\t\n\t      return button.render();\n\t    });\n\t\n\t    this.show = function () {\n\t      context.invoke('editor.saveRange');\n\t\n\t      self.showEmbedDialog().then(function showEmbedDialogCb(data) {\n\t        context.invoke('editor.restoreRange');\n\t        self.insertEmbedToEditor(data.uri);\n\t        ui.hideDialog(self.$dialog);\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t\n\t    this.showEmbedDialog = function () {\n\t      self.disableAddButton();\n\t      self.$embedInput.value = '';\n\t\n\t      return $.Deferred(function (deferred) {\n\t        ui.onDialogShown(self.$dialog, function dialogShownCb() {\n\t          context.triggerEvent('dialog.shown');\n\t          self.$embedInput.focus();\n\t\n\t          self.$addBtn.on('click', function addEmbedCb(event) {\n\t            event.preventDefault();\n\t            deferred.resolve({\n\t              uri: self.$embedInput.value\n\t            });\n\t          });\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function dialogHiddenCb() {\n\t          self.$addBtn.off('click');\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      });\n\t    };\n\t\n\t    this.createDialog = function ($container) {\n\t      var dialogOption = {\n\t        title: lang.oEmbedDialog.title,\n\t        body: '<div class=\"form-group\">' + '<label>' + lang.oEmbedDialog.label + '</label>' + '<input id=\"input-autocomplete\" class=\"form-control\" type=\"text\" placeholder=\"' + lang.oEmbedDialog.placeholder + '\" />' + '</div>' + '<div id=\"embed-in-dialog\"></div>',\n\t        footer: '<button href=\"#\" id=\"btn-add\" class=\"btn btn-primary\">' + lang.oEmbedDialog.button + '</button>',\n\t        closeOnEscape: true\n\t      };\n\t\n\t      self.$dialog = ui.dialog(dialogOption).render().appendTo($container);\n\t      self.$addBtn = self.$dialog.find('#btn-add');\n\t      self.$embedInput = self.$dialog.find('#input-autocomplete')[0];\n\t      self.$embedContainer = self.$dialog.find('#embed-in-dialog')[0];\n\t    };\n\t\n\t    this.enableAddButton = function () {\n\t      if (self.$embedInput.value && self.$embedInput.value.length > 0) {\n\t        self.$addBtn.attr(\"disabled\", false);\n\t      }\n\t    };\n\t\n\t    this.disableAddButton = function () {\n\t      self.$addBtn.attr(\"disabled\", true);\n\t    };\n\t\n\t    this.insertEmbedToEditor = function (iframe) {\n\t      var $div = $('<div>');\n\t\n\t      $.getJSON(options.oEmbed.service + '?url=' + iframe).done(function (data) {\n\t        $div.html(self.normalizeEmbed(data.html));\n\t\n\t        context.invoke('editor.insertNode', $div[0]);\n\t        self.$embedContainer.innerHTML = '';\n\t      });\n\t    };\n\t\n\t    this.normalizeEmbed = function (data) {\n\t\n\t      if (data) {\n\t        var $div = $('<div>');\n\t        var $iframe = $(data).find(\"iframe\");\n\t\n\t        $div.css({\n\t          'position': 'relative',\n\t          'padding-top': '25px',\n\t          'padding-bottom': '56.25%',\n\t          'height': '0'\n\t        });\n\t        $iframe.css({\n\t          'position': 'absolute',\n\t          'top': '0',\n\t          'left': '0',\n\t          'width': '100%',\n\t          'height': '100%'\n\t        });\n\t        $iframe.removeAttr(\"width\");\n\t        $iframe.removeAttr(\"height\");\n\t\n\t        $div.html($iframe);\n\t\n\t        return $div;\n\t      } else {\n\t        console.log(lang);\n\t        throw new Error(lang.errorMessage.invalid_provider);\n\t      }\n\t    };\n\t\n\t    this.initOembed = function () {\n\t\n\t      self.$embedInput.addEventListener('input', function (event) {\n\t\n\t        var url = this.value;\n\t\n\t        setTimeout(function () {\n\t          if (options.oEmbed.spinner) {\n\t            self.$embedContainer.innerHTML = options.oEmbed.spinner;\n\t          }\n\t\n\t          $.getJSON(options.oEmbed.service + '?url=' + url).done(function (data) {\n\t\n\t            var content;\n\t            try {\n\t              content = self.normalizeEmbed(data.html);\n\t            } catch (e) {\n\t\n\t              content = e.message;\n\t            }\n\t\n\t            $(self.$embedContainer).html(content);\n\t\n\t            self.enableAddButton();\n\t          });\n\t        }, 1000);\n\t      });\n\t    };\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t      self.createDialog($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(self.$dialog);\n\t      self.$dialog.remove();\n\t    };\n\t\n\t    this.events = {\n\t      // This will be called after modules are initialized.\n\t      'summernote.init': function summernoteInit(we, e) {\n\t        self.initOembed();\n\t      }\n\t    };\n\t  };\n\t\n\t  $.extend(true, $.summernote, {\n\t    lang: {\n\t      'en-US': {\n\t        oEmbedButton: {\n\t          tooltip: \"Embed\"\n\t        },\n\t        oEmbedDialog: {\n\t          title: \"Insert Embed\",\n\t          label: \"Place your embed url link\",\n\t          placeholder: \"E.g. https://www.youtube.com/watch?v=sJ9HR-kcZHg\",\n\t          button: \"Insert\"\n\t        },\n\t        errorMessage: {\n\t          invalid_provider: 'Invalid Provider!'\n\t        }\n\t      },\n\t      'pt-BR': {\n\t        oEmbedButton: {\n\t          tooltip: \"Adicionar Embed\"\n\t        },\n\t        oEmbedDialog: {\n\t          title: \"Inserir Embed\",\n\t          label: \"Coloque a url do seu embed\",\n\t          placeholder: \"Ex.: https://www.youtube.com/watch?v=sJ9HR-kcZHg\",\n\t          button: \"Inserir\"\n\t        },\n\t        errorMessage: {\n\t          invalid_provider: 'Provedor invlido'\n\t        }\n\t      }\n\t    },\n\t    plugins: {\n\t      'oembed': embedToSummernote\n\t    }\n\t  });\n\t});\n\n/***/ },\n\n/***/ 85:\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;'use strict';\n\t\n\t(function (factory) {\n\t  /* global define */\n\t  if (true) {\n\t    // AMD. Register as an anonymous module.\n\t    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(2)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof module === 'object' && module.exports) {\n\t    // Node/CommonJS\n\t    module.exports = factory(require('jquery'));\n\t  } else {\n\t    // Browser globals\n\t    factory(window.jQuery);\n\t  }\n\t})(function ($) {\n\t  'use strict';\n\t\n\t  var summernotePrettyprint = function summernotePrettyprint(context) {\n\t    var self = this;\n\t    var options = context.options;\n\t    var inToolbar = false;\n\t\n\t    for (var idx in options.toolbar) {\n\t      var buttons = options.toolbar[idx][1];\n\t      if ($.inArray('prettyprint', buttons) > -1) {\n\t        inToolbar = true;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (!inToolbar) {\n\t      return;\n\t    }\n\t\n\t    var ui = $.summernote.ui;\n\t    var $editor = context.layoutInfo.editor;\n\t    var lang = options.langInfo;\n\t\n\t    var prettyprintOpitions = {\n\t      languages: ['bsh', 'c', 'cc', 'cpp', 'cs', 'css', 'csh', 'cyc', 'cv', 'html', 'java', 'js', 'm', 'mxml', 'perl', 'pl', 'pm', 'py', 'php', 'rb', 'sh', 'sql', 'xhtml', 'xml', 'xsl']\n\t    };\n\t\n\t    options.prettyprint = $.extend(prettyprintOpitions, options.prettyprint);\n\t\n\t    context.memo('button.prettyprint', function () {\n\t      var button = ui.button({\n\t        contents: '{}',\n\t        tooltip: lang.button.tooltip,\n\t        click: function click(event) {\n\t          self.show();\n\t        }\n\t      });\n\t\n\t      return button.render();\n\t    });\n\t\n\t    this.show = function () {\n\t      context.invoke('editor.saveRange');\n\t\n\t      self.showDialog().then(function showDialogCb(data) {\n\t        context.invoke('editor.restoreRange');\n\t        self.insertToEditor(data);\n\t        ui.hideDialog(self.$dialog);\n\t      }).fail(function () {\n\t        context.invoke('editor.restoreRange');\n\t      });\n\t    };\n\t\n\t    this.showDialog = function () {\n\t      self.disableAddButton();\n\t      self.$code.value = '';\n\t\n\t      return $.Deferred(function (deferred) {\n\t        ui.onDialogShown(self.$dialog, function dialogShownCb() {\n\t          context.triggerEvent('dialog.shown');\n\t          self.$codeLanguage.focus();\n\t\n\t          self.$addBtn.on('click', function addEmbedCb(event) {\n\t            event.preventDefault();\n\t            deferred.resolve({\n\t              language: self.$codeLanguage.value,\n\t              code: self.$code.value\n\t            });\n\t          });\n\t        });\n\t\n\t        ui.onDialogHidden(self.$dialog, function dialogHiddenCb() {\n\t          self.$addBtn.off('click');\n\t          if (deferred.state() === 'pending') {\n\t            deferred.reject();\n\t          }\n\t        });\n\t\n\t        ui.showDialog(self.$dialog);\n\t      });\n\t    };\n\t\n\t    this.createDialog = function ($container) {\n\t\n\t      var select = '<select class=\"form-control\" id=\"code-language\"><option>' + options.prettyprint.languages.join('</option><option>') + '</option></select>';\n\t\n\t      var dialogOption = {\n\t        title: lang.dialogPrettyfi.title,\n\t        body: '<div class=\"form-group\">' + '<label>' + lang.dialogPrettyfi.selectLabel + '</label>' + select + '</div>' + '<div class=\"form-group\">' + '<label>' + lang.dialogPrettyfi.codeLabel + '</label>' + '<textarea class=\"form-control\" id=\"code\" rows=\"7\"></textarea>' + '</div>',\n\t        footer: '<button href=\"#\" id=\"btn-add\" class=\"btn btn-primary\">' + lang.dialogPrettyfi.button + '</button>',\n\t        closeOnEscape: true\n\t      };\n\t\n\t      self.$dialog = ui.dialog(dialogOption).render().appendTo($container);\n\t      self.$addBtn = self.$dialog.find('#btn-add');\n\t      self.$codeLanguage = self.$dialog.find('#code-language')[0];\n\t      self.$code = self.$dialog.find('#code')[0];\n\t    };\n\t\n\t    this.insertToEditor = function (options) {\n\t      var innerOptions = {\n\t        code: '',\n\t        language: ''\n\t      };\n\t\n\t      var _options = $.extend(innerOptions, options);\n\t\n\t      var $node = $('<pre>', {\n\t        'class': 'prettyprint linenums'\n\t      });\n\t      var $code = $('<code>');\n\t      $code.html(_options.code.replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\"));\n\t      $code.addClass('language-' + _options.language);\n\t\n\t      $node.html($code);\n\t\n\t      context.invoke('editor.insertNode', $node[0]);\n\t      self.$code.innerHTML = '';\n\t    };\n\t\n\t    this.enableAddButton = function () {\n\t      if (!!self.$codeLanguage.value && self.$code.value.length > 0) {\n\t        self.$addBtn.attr(\"disabled\", false);\n\t      }\n\t    };\n\t\n\t    this.disableAddButton = function () {\n\t      self.$addBtn.attr(\"disabled\", true);\n\t    };\n\t\n\t    this.init = function () {\n\t      self.$code.addEventListener('input', function (event) {\n\t        self.enableAddButton();\n\t      }, false);\n\t      self.$codeLanguage.addEventListener('change', function (event) {\n\t        self.enableAddButton();\n\t      }, false);\n\t    };\n\t\n\t    this.initialize = function () {\n\t      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\t      self.createDialog($container);\n\t    };\n\t\n\t    this.destroy = function () {\n\t      ui.hideDialog(self.$dialog);\n\t      self.$dialog.remove();\n\t    };\n\t\n\t    this.events = {\n\t      'summernote.init': function summernoteInit(we, e) {\n\t        self.init();\n\t      },\n\t      'summernote.change': function summernoteChange(we, contents) {\n\t        if (window.PR) {\n\t          PR.prettyPrintOne(contents);\n\t        } else {\n\t          prettyPrintOne(contents);\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  $.extend(true, $.summernote, {\n\t    lang: {\n\t      'en-US': {\n\t        dialogPrettyfi: {\n\t          title: 'Insert fragment code into editor',\n\t          selectLabel: 'Choose your language',\n\t          codeLabel: 'Type your code',\n\t          button: 'Insert code'\n\t        },\n\t        button: {\n\t          tooltip: 'Insert code'\n\t        }\n\t      },\n\t      'pt-BR': {\n\t        dialogPrettyfi: {\n\t          title: 'Adicionar fragmento de cdigo ao editor',\n\t          selectLabel: 'Escolha a linguagem',\n\t          codeLabel: 'Digite o seu cdigo aqui',\n\t          button: 'Inserir cdigo'\n\t        },\n\t        button: {\n\t          tooltip: 'Adicionar cdigo'\n\t        }\n\t      }\n\t    },\n\t    plugins: {\n\t      'prettyprint': summernotePrettyprint\n\t    }\n\t  });\n\t});\n\n/***/ }\n\n});\n\n\n/** WEBPACK FOOTER **\n ** vendor.js\n **/","require('./vendor/code-prettify/prettify');\nrequire('summernote');\nrequire('summernote/lang/summernote-pt-BR');\nrequire('./vendor/summernote/plugins/summernote-oembed-plugin');\nrequire('./vendor/summernote/plugins/summernote-prettyprint-plugin');\nrequire('./modules/ideiaEditor');\n\nPR.prettyPrint();\n$('[data-target=\"container-editor\"]').refreshEditors();\n\n\n\n/** WEBPACK FOOTER **\n ** ./vendor.js\n **/","/**\n * @license\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window, define */\n\n\n/**\n * {@type !{\n *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n *   'registerLangHandler': function (function (JobT), Array.<string>),\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_VALUE': string,\n *   'PR_COMMENT': string,\n *   'PR_DECLARATION': string,\n *   'PR_KEYWORD': string,\n *   'PR_LITERAL': string,\n *   'PR_NOCODE': string,\n *   'PR_PLAIN': string,\n *   'PR_PUNCTUATION': string,\n *   'PR_SOURCE': string,\n *   'PR_STRING': string,\n *   'PR_TAG': string,\n *   'PR_TYPE': string,\n *   'prettyPrintOne': function (string, string, number|boolean),\n *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n * }}\n * @const\n */\n/**\n* @typedef {!Array.<number|string>}\n* Alternating indices and the decorations that should be inserted there.\n* The indices are monotonically increasing.\n*/\nvar DecorationsT;\n\n/**\n* @typedef {!{\n*   sourceNode: !Element,\n*   pre: !(number|boolean),\n*   langExtension: ?string,\n*   numberLines: ?(number|boolean),\n*   sourceCode: ?string,\n*   spans: ?(Array.<number|Node>),\n*   basePos: ?number,\n*   decorations: ?DecorationsT\n* }}\n* <dl>\n*  <dt>sourceNode<dd>the element containing the source\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>pre<dd>truthy if white-space in text nodes\n*     should be considered significant.\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n*  <dt>decorations<dd>an array of style classes preceded\n*     by the position at which they start in job.sourceCode in order\n*  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n*     source.\n* </dl>\n*/\nvar JobT;\n\n/**\n* @typedef {!{\n*   sourceCode: string,\n*   spans: !(Array.<number|Node>)\n* }}\n* <dl>\n*  <dt>sourceCode<dd>source as plain text\n*  <dt>spans<dd> alternating span start indices into source\n*     and the text node or element (e.g. {@code <BR>}) corresponding to that\n*     span.\n* </dl>\n*/\nvar SourceSpansT;\n\n/** @define {boolean} */\nvar IN_GLOBAL_SCOPE = false;\n\nvar PR;\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nwindow['PR_SHOULD_USE_CONTINUATION'] = true;\n\n/**\n * Pretty print a chunk of code.\n * @param {string} sourceCodeHtml The HTML to pretty print.\n * @param {string} opt_langExtension The language name to use.\n *     Typically, a filename extension like 'cpp' or 'java'.\n * @param {number|boolean} opt_numberLines True to number lines,\n *     or the 1-indexed number of the first line in sourceCodeHtml.\n * @return {string} code as html, but prettier\n */\nvar prettyPrintOne;\n/**\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n * {@code class=prettyprint} and prettify them.\n *\n * @param {Function} opt_whenDone called when prettifying is done.\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\n *   containing all the elements to pretty print.\n *   Defaults to {@code document.body}.\n */\nvar prettyPrint;\n\n\n(function () {\n  var win = window;\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n      \"double,enum,extern,float,goto,inline,int,long,register,short,signed,\" +\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n      \"mutable,namespace,nullptr,property,reinterpret_cast,static_assert,\" +\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n      \"throws,transient\"];\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,as,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n      \"dynamic,event,finally,fixed,foreach,from,group,implicit,in,interface,\" +\n      \"internal,into,is,let,lock,null,object,out,override,orderby,params,\" +\n      \"partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,\" +\n      \"unchecked,unsafe,ushort,var,virtual,where\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"throw,true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,async,await,constructor,debugger,enum,eval,export,function,\" +\n      \"get,implements,instanceof,interface,let,null,set,undefined,var,with,\" +\n      \"yield,Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n      PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for plain text.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n\n\n  /**\n   * A set of tokens that can precede a regular expression literal in\n   * javascript\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n   * has the full list, but I've removed ones that might be problematic when\n   * seen in languages that don't support regular expression literals.\n   *\n   * <p>Specifically, I've removed any keywords that can't precede a regexp\n   * literal in a syntactically legal javascript program, and I've removed the\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\n   * as a count of inches.\n   *\n   * <p>The link above does not accurately describe EcmaScript rules since\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n   * very well in practice.\n   *\n   * @private\n   * @const\n   */\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n\n  // CAVEAT: this does not properly handle the case where a regular\n  // expression immediately follows another since a regular expression may\n  // have flags for case-sensitivity and the like.  Having regexp tokens\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\n  // TODO: maybe style special characters inside a regexp as punctuation.\n\n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n\n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n\n    var escapeCharToCodeUnit = {\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    };\n\n    function decodeEscape(charsetPart) {\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) {\n        return cc0;\n      }\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) {\n        return cc0;\n      } else if ('0' <= c1 && c1 <= '7') {\n        return parseInt(charsetPart.substring(1), 8);\n      } else if (c1 === 'u' || c1 === 'x') {\n        return parseInt(charsetPart.substring(2), 16);\n      } else {\n        return charsetPart.charCodeAt(1);\n      }\n    }\n\n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n          ? \"\\\\\" + ch : ch;\n    }\n\n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n\n      var out = ['['];\n      if (inverse) { out.push('^'); }\n\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n          out.push(p);\n        } else {\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          } else {\n            end = start;\n          }\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) {\n            if (!(end < 65 || start > 90)) {\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            }\n            if (!(end < 97 || start > 122)) {\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            }\n          }\n        }\n      }\n\n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n\n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n\n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n\n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue) {\n            if (decimalValue <= groupIndex) {\n              capturedGroups[decimalValue] = -1;\n            } else {\n              // Replace with an unambiguous escape sequence so that\n              // an octal escape sequence does not turn into a backreference\n              // to a capturing group from an earlier regex.\n              parts[i] = encodeEscape(decimalValue);\n            }\n          }\n        }\n      }\n\n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (!capturedGroups[groupIndex]) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\n          }\n        }\n      }\n\n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n\n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n\n      return parts.join('');\n    }\n\n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n\n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                     1          2\n   *   //           012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @param {boolean|number} isPreformatted truthy if white-space in\n   *    text nodes should be considered significant.\n   * @return {SourceSpansT} source code and the nodes in which they occur.\n   */\n  function extractSourceSpans(node, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1) {  // Element\n        if (nocode.test(node.className)) { return; }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          walk(child);\n        }\n        var nodeName = node.nodeName.toLowerCase();\n        if ('br' === nodeName || 'li' === nodeName) {\n          chunks[k] = '\\n';\n          spans[k << 1] = length++;\n          spans[(k++ << 1) | 1] = node;\n        }\n      } else if (type == 3 || type == 4) {  // Text\n        var text = node.nodeValue;\n        if (text.length) {\n          if (!isPreformatted) {\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n          } else {\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n          }\n          // TODO: handle tabs here?\n          chunks[k] = text;\n          spans[k << 1] = length;\n          length += text.length;\n          spans[(k++ << 1) | 1] = node;\n        }\n      }\n    }\n\n    walk(node);\n\n    return {\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {!Element} sourceNode\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   * @param {string} sourceCode\n   * @param {function(JobT)} langHandler\n   * @param {DecorationsT} out\n   */\n  function appendDecorations(\n      sourceNode, basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    /** @type {JobT} */\n    var job = {\n      sourceNode: sourceNode,\n      pre: 1,\n      langExtension: null,\n      numberLines: null,\n      sourceCode: sourceCode,\n      spans: null,\n      basePos: basePos,\n      decorations: null\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (JobT)} a function that takes an undecorated job and\n    *   attaches a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and attaches an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @type{function (JobT)}\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      var sourceNode = job.sourceNode;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {DecorationsT}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (JobT)} a function that examines the source code\n    *     in the input job and builds a decoration list which it attaches to\n    *     the job.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        // #include <stdio.h>\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    var regexLiterals = options['regexLiterals'];\n    if (regexLiterals) {\n      /**\n       * @const\n       */\n      var regexExcls = regexLiterals > 1\n        ? ''  // Multiline regex literals\n        : '\\n\\r';\n      /**\n       * @const\n       */\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*' + regexExcls + '])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C' + regexAny\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\n    var punctuation =\n      // The Bash man page says\n\n      // A word is a sequence of characters considered as a single\n      // unit by GRUB. Words are separated by metacharacters,\n      // which are the following plus space, tab, and newline: { }\n      // | & $ ; < >\n      // ...\n\n      // A word beginning with # causes that word and all remaining\n      // characters on that line to be ignored.\n\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n      // comment but empirically\n      // $ echo {#}\n      // {#}\n      // $ echo \\$#\n      // $#\n      // $ echo }#\n      // }#\n\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n      // suggests that this definition is compatible with a\n      // default mode that tries to use a single token definition\n      // to recognize both bash/python style comments and C\n      // preprocessor directives.\n\n      // This definition of punctuation does not include # in the list of\n      // follow-on exclusions, so # will not be broken before if preceeded\n      // by a punctuation character.  We could try to exclude # after\n      // [|&;<>] but that doesn't seem to cause many major problems.\n      // If that does turn out to be a problem, we should change the below\n      // when hc is truthy to include # in the run of punctuation characters\n      // only when not followint [|&;<>].\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n    if (options['regexLiterals']) {\n      punctuation += '(?!\\s*\\/)';\n    }\n\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.\n        // See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   * @param {number|null|boolean} startLineNum\n   *     If truthy, coerced to an integer which is the 1-indexed line number\n   *     of the first line of code.  The number of the first line will be\n   *     attached to the list.\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\n   *     be treated as significant.\n   */\n  function numberLines(node, startLineNum, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n\n    var document = node.ownerDocument;\n\n    var li = document.createElement('li');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1 && !nocode.test(node.className)) {  // Element\n        if ('br' === node.nodeName) {\n          breakAfter(node);\n          // Discard the <BR> since it is now flush against a </LI>.\n          if (node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        } else {\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n        }\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n        var text = node.nodeValue;\n        var match = text.match(lineBreak);\n        if (match) {\n          var firstLine = text.substring(0, match.index);\n          node.nodeValue = firstLine;\n          var tail = text.substring(match.index + match[0].length);\n          if (tail) {\n            var parent = node.parentNode;\n            parent.insertBefore(\n              document.createTextNode(tail), node.nextSibling);\n          }\n          breakAfter(node);\n          if (!firstLine) {\n            // Don't leave blank text nodes in the DOM.\n            node.parentNode.removeChild(node);\n          }\n        }\n      }\n    }\n\n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n\n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n\n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n\n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n\n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n\n    // Make sure numeric indices show correctly.\n    if (startLineNum === (startLineNum|0)) {\n      listItems[0].setAttribute('value', startLineNum);\n    }\n\n    var ol = document.createElement('ol');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n\n    node.appendChild(ol);\n  }\n\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {JobT} job\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n    var newlineRe = /\\n/g;\n\n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n\n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n\n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n\n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n\n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n\n    nDecorations = decorations.length = decPos;\n\n    var sourceNode = job.sourceNode;\n    var oldDisplay = \"\";\n    if (sourceNode) {\n      oldDisplay = sourceNode.style.display;\n      sourceNode.style.display = 'none';\n    }\n    try {\n      var decoration = null;\n      while (spanIndex < nSpans) {\n        var spanStart = spans[spanIndex];\n        var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n            || sourceLength;\n\n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n\n        var end = Math.min(spanEnd, decEnd);\n\n        var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n        var styledText;\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n            // Don't introduce spans around empty text nodes.\n            && (styledText = source.substring(sourceIndex, end))) {\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n          // code to display with spaces instead of line breaks.\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n          // space to appear at the beginning of every line but the first.\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n          if (isIE8OrEarlier) {\n            styledText = styledText.replace(newlineRe, '\\r');\n          }\n          textNode.nodeValue = styledText;\n          var document = textNode.ownerDocument;\n          var span = document.createElement('span');\n          span.className = decorations[decorationIndex + 1];\n          var parentNode = textNode.parentNode;\n          parentNode.replaceChild(span, textNode);\n          span.appendChild(textNode);\n          if (sourceIndex < spanEnd) {  // Split off a text node.\n            spans[spanIndex + 1] = textNode\n                // TODO: Possibly optimize by using '' if there's no flicker.\n                = document.createTextNode(source.substring(end, spanEnd));\n            parentNode.insertBefore(textNode, span.nextSibling);\n          }\n        }\n\n        sourceIndex = end;\n\n        if (sourceIndex >= spanEnd) {\n          spanIndex += 2;\n        }\n        if (sourceIndex >= decEnd) {\n          decorationIndex += 2;\n        }\n      }\n    } finally {\n      if (sourceNode) {\n        sourceNode.style.display = oldDisplay;\n      }\n    }\n  }\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (JobT)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation and attaches the decorations to it.\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (win['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bash', 'bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py', 'python']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': 2  // multiline regex literals\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb', 'ruby']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['javascript', 'js', 'ts', 'typescript']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  /** @param {JobT} job */\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if (win['console']) {\n        console['log'](e && e['stack'] || e);\n      }\n    }\n  }\n\n  /**\n   * Pretty print a chunk of code.\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    /** @type{number|boolean} */\n    var nl = opt_numberLines || false;\n    /** @type{string|null} */\n    var langExtension = opt_langExtension || null;\n    /** @type{!Element} */\n    var container = document.createElement('div');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\n    // when it is injected into a <pre> tag.\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n    container = /** @type{!Element} */(container.firstChild);\n    if (nl) {\n      numberLines(container, nl, true);\n    }\n\n    /** @type{JobT} */\n    var job = {\n      langExtension: langExtension,\n      numberLines: nl,\n      sourceNode: container,\n      pre: 1,\n      sourceCode: null,\n      basePos: null,\n      spans: null,\n      decorations: null\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function} opt_whenDone called when prettifying is done.\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\n    *   containing all the elements to pretty print.\n    *   Defaults to {@code document.body}.\n    */\n  function $prettyPrint(opt_whenDone, opt_root) {\n    var root = opt_root || document.body;\n    var doc = root.ownerDocument || document;\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\n    var preformattedTagNameRe = /pre|xmp/i;\n    var codeRe = /^code$/i;\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n    var EMPTY = {};\n\n    function doWork() {\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n\n        // Look for a preceding comment like\n        // <?prettify lang=\"...\" linenums=\"...\"?>\n        var attrs = EMPTY;\n        {\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\n            var nt = preceder.nodeType;\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\n            // like <!--?foo?-->, but in XML is a processing instruction\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n            if (value\n                ? !/^\\??prettify\\b/.test(value)\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n              // Skip over white-space text nodes but not others.\n              break;\n            }\n            if (value) {\n              attrs = {};\n              value.replace(\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\n                function (_, name, value) { attrs[name] = value; });\n              break;\n            }\n          }\n        }\n\n        var className = cs.className;\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\n            // Don't redo this if we've already done it.\n            // This allows recalling pretty print to just prettyprint elements\n            // that have been added to the page since last call.\n            && !prettyPrintedRe.test(className)) {\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            var tn = p.tagName;\n            if (preCodeXmpRe.test(tn)\n                && p.className && prettyPrintRe.test(p.className)) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Mark done.  If we fail to prettyprint for whatever reason,\n            // we shouldn't try again.\n            cs.className += ' prettyprinted';\n\n            // If the classes includes a language extensions, use it.\n            // Language extensions can be specified like\n            //     <pre class=\"prettyprint lang-cpp\">\n            // the language extension \"cpp\" is used to find a language handler\n            // as passed to PR.registerLangHandler.\n            // HTML5 recommends that a language be specified using \"language-\"\n            // as the prefix instead.  Google Code Prettify supports both.\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n            var langExtension = attrs['lang'];\n            if (!langExtension) {\n              langExtension = className.match(langExtensionRe);\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n              var wrapper;\n              if (!langExtension && (wrapper = childContentWrapper(cs))\n                  && codeRe.test(wrapper.tagName)) {\n                langExtension = wrapper.className.match(langExtensionRe);\n              }\n\n              if (langExtension) { langExtension = langExtension[1]; }\n            }\n\n            var preformatted;\n            if (preformattedTagNameRe.test(cs.tagName)) {\n              preformatted = 1;\n            } else {\n              var currentStyle = cs['currentStyle'];\n              var defaultView = doc.defaultView;\n              var whitespace = (\n                  currentStyle\n                  ? currentStyle['whiteSpace']\n                  : (defaultView\n                     && defaultView.getComputedStyle)\n                  ? defaultView.getComputedStyle(cs, null)\n                  .getPropertyValue('white-space')\n                  : 0);\n              preformatted = whitespace\n                  && 'pre' === whitespace.substring(0, 3);\n            }\n\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = attrs['linenums'];\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n              lineNums =\n                lineNums\n                ? lineNums[1] && lineNums[1].length\n                  ? +lineNums[1] : true\n                : false;\n            }\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\n\n            // do the pretty printing\n            var prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums,\n              pre: preformatted,\n              sourceCode: null,\n              basePos: null,\n              spans: null,\n              decorations: null\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        win.setTimeout(doWork, 250);\n      } else if ('function' === typeof opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  /**\n   * Contains functions for creating and registering new language handlers.\n   * @type {Object}\n   */\n  var PR = win['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE,\n        'prettyPrintOne':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\n             : (prettyPrintOne = $prettyPrintOne),\n        'prettyPrint': prettyPrint =\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrint'] = $prettyPrint)\n             : (prettyPrint = $prettyPrint)\n      };\n\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n  // The Asynchronous Module Definition (AMD) API specifies a\n  // mechanism for defining modules such that the module and its\n  // dependencies can be asynchronously loaded.\n  // ...\n  // To allow a clear indicator that a global define function (as\n  // needed for script src browser loading) conforms to the AMD API,\n  // any global define function SHOULD have a property called \"amd\"\n  // whose value is an object. This helps avoid conflict with any\n  // other existing JavaScript code that could have defined a define()\n  // function that does not conform to the AMD API.\n  var define = win['define'];\n  if (typeof define === \"function\" && define['amd']) {\n    define(\"google-code-prettify\", [], function () {\n      return PR;\n    });\n  }\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./vendor/code-prettify/prettify.js\n **/","/**\n * Super simple wysiwyg editor v0.8.2\n * http://summernote.org/\n *\n * summernote.js\n * Copyright 2013-2016 Alan Hong. and other contributors\n * summernote may be freely distributed under the MIT license./\n *\n * Date: 2016-08-07T05:11Z\n */\n(function (factory) {\n  /* global define */\n  if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define(['jquery'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    // Node/CommonJS\n    module.exports = factory(require('jquery'));\n  } else {\n    // Browser globals\n    factory(window.jQuery);\n  }\n}(function ($) {\n  'use strict';\n\n  /**\n   * @class core.func\n   *\n   * func utils (for high-order func's arg)\n   *\n   * @singleton\n   * @alternateClassName func\n   */\n  var func = (function () {\n    var eq = function (itemA) {\n      return function (itemB) {\n        return itemA === itemB;\n      };\n    };\n\n    var eq2 = function (itemA, itemB) {\n      return itemA === itemB;\n    };\n\n    var peq2 = function (propName) {\n      return function (itemA, itemB) {\n        return itemA[propName] === itemB[propName];\n      };\n    };\n\n    var ok = function () {\n      return true;\n    };\n\n    var fail = function () {\n      return false;\n    };\n\n    var not = function (f) {\n      return function () {\n        return !f.apply(f, arguments);\n      };\n    };\n\n    var and = function (fA, fB) {\n      return function (item) {\n        return fA(item) && fB(item);\n      };\n    };\n\n    var self = function (a) {\n      return a;\n    };\n\n    var invoke = function (obj, method) {\n      return function () {\n        return obj[method].apply(obj, arguments);\n      };\n    };\n\n    var idCounter = 0;\n\n    /**\n     * generate a globally-unique id\n     *\n     * @param {String} [prefix]\n     */\n    var uniqueId = function (prefix) {\n      var id = ++idCounter + '';\n      return prefix ? prefix + id : id;\n    };\n\n    /**\n     * returns bnd (bounds) from rect\n     *\n     * - IE Compatibility Issue: http://goo.gl/sRLOAo\n     * - Scroll Issue: http://goo.gl/sNjUc\n     *\n     * @param {Rect} rect\n     * @return {Object} bounds\n     * @return {Number} bounds.top\n     * @return {Number} bounds.left\n     * @return {Number} bounds.width\n     * @return {Number} bounds.height\n     */\n    var rect2bnd = function (rect) {\n      var $document = $(document);\n      return {\n        top: rect.top + $document.scrollTop(),\n        left: rect.left + $document.scrollLeft(),\n        width: rect.right - rect.left,\n        height: rect.bottom - rect.top\n      };\n    };\n\n    /**\n     * returns a copy of the object where the keys have become the values and the values the keys.\n     * @param {Object} obj\n     * @return {Object}\n     */\n    var invertObject = function (obj) {\n      var inverted = {};\n      for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          inverted[obj[key]] = key;\n        }\n      }\n      return inverted;\n    };\n\n    /**\n     * @param {String} namespace\n     * @param {String} [prefix]\n     * @return {String}\n     */\n    var namespaceToCamel = function (namespace, prefix) {\n      prefix = prefix || '';\n      return prefix + namespace.split('.').map(function (name) {\n        return name.substring(0, 1).toUpperCase() + name.substring(1);\n      }).join('');\n    };\n\n    /**\n     * Returns a function, that, as long as it continues to be invoked, will not\n     * be triggered. The function will be called after it stops being called for\n     * N milliseconds. If `immediate` is passed, trigger the function on the\n     * leading edge, instead of the trailing.\n     * @param {Function} func\n     * @param {Number} wait\n     * @param {Boolean} immediate\n     * @return {Function}\n     */\n    var debounce = function (func, wait, immediate) {\n      var timeout;\n      return function () {\n        var context = this, args = arguments;\n        var later = function () {\n          timeout = null;\n          if (!immediate) {\n            func.apply(context, args);\n          }\n        };\n        var callNow = immediate && !timeout;\n        clearTimeout(timeout);\n        timeout = setTimeout(later, wait);\n        if (callNow) {\n          func.apply(context, args);\n        }\n      };\n    };\n\n    return {\n      eq: eq,\n      eq2: eq2,\n      peq2: peq2,\n      ok: ok,\n      fail: fail,\n      self: self,\n      not: not,\n      and: and,\n      invoke: invoke,\n      uniqueId: uniqueId,\n      rect2bnd: rect2bnd,\n      invertObject: invertObject,\n      namespaceToCamel: namespaceToCamel,\n      debounce: debounce\n    };\n  })();\n\n  /**\n   * @class core.list\n   *\n   * list utils\n   *\n   * @singleton\n   * @alternateClassName list\n   */\n  var list = (function () {\n    /**\n     * returns the first item of an array.\n     *\n     * @param {Array} array\n     */\n    var head = function (array) {\n      return array[0];\n    };\n\n    /**\n     * returns the last item of an array.\n     *\n     * @param {Array} array\n     */\n    var last = function (array) {\n      return array[array.length - 1];\n    };\n\n    /**\n     * returns everything but the last entry of the array.\n     *\n     * @param {Array} array\n     */\n    var initial = function (array) {\n      return array.slice(0, array.length - 1);\n    };\n\n    /**\n     * returns the rest of the items in an array.\n     *\n     * @param {Array} array\n     */\n    var tail = function (array) {\n      return array.slice(1);\n    };\n\n    /**\n     * returns item of array\n     */\n    var find = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        var item = array[idx];\n        if (pred(item)) {\n          return item;\n        }\n      }\n    };\n\n    /**\n     * returns true if all of the values in the array pass the predicate truth test.\n     */\n    var all = function (array, pred) {\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!pred(array[idx])) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /**\n     * returns index of item\n     */\n    var indexOf = function (array, item) {\n      return $.inArray(item, array);\n    };\n\n    /**\n     * returns true if the value is present in the list.\n     */\n    var contains = function (array, item) {\n      return indexOf(array, item) !== -1;\n    };\n\n    /**\n     * get sum from a list\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - iterator\n     */\n    var sum = function (array, fn) {\n      fn = fn || func.self;\n      return array.reduce(function (memo, v) {\n        return memo + fn(v);\n      }, 0);\n    };\n  \n    /**\n     * returns a copy of the collection with array type.\n     * @param {Collection} collection - collection eg) node.childNodes, ...\n     */\n    var from = function (collection) {\n      var result = [], idx = -1, length = collection.length;\n      while (++idx < length) {\n        result[idx] = collection[idx];\n      }\n      return result;\n    };\n\n    /**\n     * returns whether list is empty or not\n     */\n    var isEmpty = function (array) {\n      return !array || !array.length;\n    };\n  \n    /**\n     * cluster elements by predicate function.\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     * @param {Array[]}\n     */\n    var clusterBy = function (array, fn) {\n      if (!array.length) { return []; }\n      var aTail = tail(array);\n      return aTail.reduce(function (memo, v) {\n        var aLast = last(memo);\n        if (fn(last(aLast), v)) {\n          aLast[aLast.length] = v;\n        } else {\n          memo[memo.length] = [v];\n        }\n        return memo;\n      }, [[head(array)]]);\n    };\n  \n    /**\n     * returns a copy of the array with all false values removed\n     *\n     * @param {Array} array - array\n     * @param {Function} fn - predicate function for cluster rule\n     */\n    var compact = function (array) {\n      var aResult = [];\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (array[idx]) { aResult.push(array[idx]); }\n      }\n      return aResult;\n    };\n\n    /**\n     * produces a duplicate-free version of the array\n     *\n     * @param {Array} array\n     */\n    var unique = function (array) {\n      var results = [];\n\n      for (var idx = 0, len = array.length; idx < len; idx ++) {\n        if (!contains(results, array[idx])) {\n          results.push(array[idx]);\n        }\n      }\n\n      return results;\n    };\n\n    /**\n     * returns next item.\n     * @param {Array} array\n     */\n    var next = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx + 1];\n    };\n\n    /**\n     * returns prev item.\n     * @param {Array} array\n     */\n    var prev = function (array, item) {\n      var idx = indexOf(array, item);\n      if (idx === -1) { return null; }\n\n      return array[idx - 1];\n    };\n\n    return { head: head, last: last, initial: initial, tail: tail,\n             prev: prev, next: next, find: find, contains: contains,\n             all: all, sum: sum, from: from, isEmpty: isEmpty,\n             clusterBy: clusterBy, compact: compact, unique: unique };\n  })();\n\n  var isSupportAmd = typeof define === 'function' && define.amd;\n\n  /**\n   * returns whether font is installed or not.\n   *\n   * @param {String} fontName\n   * @return {Boolean}\n   */\n  var isFontInstalled = function (fontName) {\n    var testFontName = fontName === 'Comic Sans MS' ? 'Courier New' : 'Comic Sans MS';\n    var $tester = $('<div>').css({\n      position: 'absolute',\n      left: '-9999px',\n      top: '-9999px',\n      fontSize: '200px'\n    }).text('mmmmmmmmmwwwwwww').appendTo(document.body);\n\n    var originalWidth = $tester.css('fontFamily', testFontName).width();\n    var width = $tester.css('fontFamily', fontName + ',' + testFontName).width();\n\n    $tester.remove();\n\n    return originalWidth !== width;\n  };\n\n  var userAgent = navigator.userAgent;\n  var isMSIE = /MSIE|Trident/i.test(userAgent);\n  var browserVersion;\n  if (isMSIE) {\n    var matches = /MSIE (\\d+[.]\\d+)/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n    matches = /Trident\\/.*rv:([0-9]{1,}[\\.0-9]{0,})/.exec(userAgent);\n    if (matches) {\n      browserVersion = parseFloat(matches[1]);\n    }\n  }\n\n  var isEdge = /Edge\\/\\d+/.test(userAgent);\n\n  var hasCodeMirror = !!window.CodeMirror;\n  if (!hasCodeMirror && isSupportAmd && typeof require !== 'undefined') {\n    if (typeof require.resolve !== 'undefined') {\n      try {\n        // If CodeMirror can't be resolved, `require.resolve` will throw an\n        // exception and `hasCodeMirror` won't be set to `true`.\n        require.resolve('codemirror');\n        hasCodeMirror = true;\n      } catch (e) {\n        // Do nothing.\n      }\n    } else if (typeof eval('require').specified !== 'undefined') {\n      hasCodeMirror = eval('require').specified('codemirror');\n    }\n  }\n\n  /**\n   * @class core.agent\n   *\n   * Object which check platform and agent\n   *\n   * @singleton\n   * @alternateClassName agent\n   */\n  var agent = {\n    isMac: navigator.appVersion.indexOf('Mac') > -1,\n    isMSIE: isMSIE,\n    isEdge: isEdge,\n    isFF: !isEdge && /firefox/i.test(userAgent),\n    isPhantom: /PhantomJS/i.test(userAgent),\n    isWebkit: !isEdge && /webkit/i.test(userAgent),\n    isChrome: !isEdge && /chrome/i.test(userAgent),\n    isSafari: !isEdge && /safari/i.test(userAgent),\n    browserVersion: browserVersion,\n    jqueryVersion: parseFloat($.fn.jquery),\n    isSupportAmd: isSupportAmd,\n    hasCodeMirror: hasCodeMirror,\n    isFontInstalled: isFontInstalled,\n    isW3CRangeSupport: !!document.createRange\n  };\n\n\n  var NBSP_CHAR = String.fromCharCode(160);\n  var ZERO_WIDTH_NBSP_CHAR = '\\ufeff';\n\n  /**\n   * @class core.dom\n   *\n   * Dom functions\n   *\n   * @singleton\n   * @alternateClassName dom\n   */\n  var dom = (function () {\n    /**\n     * @method isEditable\n     *\n     * returns whether node is `note-editable` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEditable = function (node) {\n      return node && $(node).hasClass('note-editable');\n    };\n\n    /**\n     * @method isControlSizing\n     *\n     * returns whether node is `note-control-sizing` or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isControlSizing = function (node) {\n      return node && $(node).hasClass('note-control-sizing');\n    };\n\n    /**\n     * @method makePredByNodeName\n     *\n     * returns predicate which judge whether nodeName is same\n     *\n     * @param {String} nodeName\n     * @return {Function}\n     */\n    var makePredByNodeName = function (nodeName) {\n      nodeName = nodeName.toUpperCase();\n      return function (node) {\n        return node && node.nodeName.toUpperCase() === nodeName;\n      };\n    };\n\n    /**\n     * @method isText\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is text(3)\n     */\n    var isText = function (node) {\n      return node && node.nodeType === 3;\n    };\n\n    /**\n     * @method isElement\n     *\n     *\n     *\n     * @param {Node} node\n     * @return {Boolean} true if node's type is element(1)\n     */\n    var isElement = function (node) {\n      return node && node.nodeType === 1;\n    };\n\n    /**\n     * ex) br, col, embed, hr, img, input, ...\n     * @see http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\n     */\n    var isVoid = function (node) {\n      return node && /^BR|^IMG|^HR|^IFRAME|^BUTTON/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPara = function (node) {\n      if (isEditable(node)) {\n        return false;\n      }\n\n      // Chrome(v31.0), FF(v25.0.1) use DIV for paragraph\n      return node && /^DIV|^P|^LI|^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHeading = function (node) {\n      return node && /^H[1-7]/.test(node.nodeName.toUpperCase());\n    };\n\n    var isPre = makePredByNodeName('PRE');\n\n    var isLi = makePredByNodeName('LI');\n\n    var isPurePara = function (node) {\n      return isPara(node) && !isLi(node);\n    };\n\n    var isTable = makePredByNodeName('TABLE');\n\n    var isData = makePredByNodeName('DATA');\n\n    var isInline = function (node) {\n      return !isBodyContainer(node) &&\n             !isList(node) &&\n             !isHr(node) &&\n             !isPara(node) &&\n             !isTable(node) &&\n             !isBlockquote(node) &&\n             !isData(node);\n    };\n\n    var isList = function (node) {\n      return node && /^UL|^OL/.test(node.nodeName.toUpperCase());\n    };\n\n    var isHr = makePredByNodeName('HR');\n\n    var isCell = function (node) {\n      return node && /^TD|^TH/.test(node.nodeName.toUpperCase());\n    };\n\n    var isBlockquote = makePredByNodeName('BLOCKQUOTE');\n\n    var isBodyContainer = function (node) {\n      return isCell(node) || isBlockquote(node) || isEditable(node);\n    };\n\n    var isAnchor = makePredByNodeName('A');\n\n    var isParaInline = function (node) {\n      return isInline(node) && !!ancestor(node, isPara);\n    };\n\n    var isBodyInline = function (node) {\n      return isInline(node) && !ancestor(node, isPara);\n    };\n\n    var isBody = makePredByNodeName('BODY');\n\n    /**\n     * returns whether nodeB is closest sibling of nodeA\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     * @return {Boolean}\n     */\n    var isClosestSibling = function (nodeA, nodeB) {\n      return nodeA.nextSibling === nodeB ||\n             nodeA.previousSibling === nodeB;\n    };\n\n    /**\n     * returns array of closest siblings with node\n     *\n     * @param {Node} node\n     * @param {function} [pred] - predicate function\n     * @return {Node[]}\n     */\n    var withClosestSiblings = function (node, pred) {\n      pred = pred || func.ok;\n\n      var siblings = [];\n      if (node.previousSibling && pred(node.previousSibling)) {\n        siblings.push(node.previousSibling);\n      }\n      siblings.push(node);\n      if (node.nextSibling && pred(node.nextSibling)) {\n        siblings.push(node.nextSibling);\n      }\n      return siblings;\n    };\n\n    /**\n     * blank HTML for cursor position\n     * - [workaround] old IE only works with &nbsp;\n     * - [workaround] IE11 and other browser works with bogus br\n     */\n    var blankHTML = agent.isMSIE && agent.browserVersion < 11 ? '&nbsp;' : '<br>';\n\n    /**\n     * @method nodeLength\n     *\n     * returns #text's text size or element's childNodes size\n     *\n     * @param {Node} node\n     */\n    var nodeLength = function (node) {\n      if (isText(node)) {\n        return node.nodeValue.length;\n      }\n      \n      if (node) {\n        return node.childNodes.length;\n      }\n      \n      return 0;\n      \n    };\n\n    /**\n     * returns whether node is empty or not.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n    var isEmpty = function (node) {\n      var len = nodeLength(node);\n\n      if (len === 0) {\n        return true;\n      } else if (!isText(node) && len === 1 && node.innerHTML === blankHTML) {\n        // ex) <p><br></p>, <span><br></span>\n        return true;\n      } else if (list.all(node.childNodes, isText) && node.innerHTML === '') {\n        // ex) <p></p>, <span></span>\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * padding blankHTML if node is empty (for cursor position)\n     */\n    var paddingBlankHTML = function (node) {\n      if (!isVoid(node) && !nodeLength(node)) {\n        node.innerHTML = blankHTML;\n      }\n    };\n\n    /**\n     * find nearest ancestor predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var ancestor = function (node, pred) {\n      while (node) {\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * find nearest ancestor only single child blood line and predicate hit\n     *\n     * @param {Node} node\n     * @param {Function} pred - predicate function\n     */\n    var singleChildAncestor = function (node, pred) {\n      node = node.parentNode;\n\n      while (node) {\n        if (nodeLength(node) !== 1) { break; }\n        if (pred(node)) { return node; }\n        if (isEditable(node)) { break; }\n\n        node = node.parentNode;\n      }\n      return null;\n    };\n\n    /**\n     * returns new array of ancestor nodes (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listAncestor = function (node, pred) {\n      pred = pred || func.fail;\n\n      var ancestors = [];\n      ancestor(node, function (el) {\n        if (!isEditable(el)) {\n          ancestors.push(el);\n        }\n\n        return pred(el);\n      });\n      return ancestors;\n    };\n\n    /**\n     * find farthest ancestor predicate hit\n     */\n    var lastAncestor = function (node, pred) {\n      var ancestors = listAncestor(node);\n      return list.last(ancestors.filter(pred));\n    };\n\n    /**\n     * returns common ancestor node between two nodes.\n     *\n     * @param {Node} nodeA\n     * @param {Node} nodeB\n     */\n    var commonAncestor = function (nodeA, nodeB) {\n      var ancestors = listAncestor(nodeA);\n      for (var n = nodeB; n; n = n.parentNode) {\n        if ($.inArray(n, ancestors) > -1) { return n; }\n      }\n      return null; // difference document area\n    };\n\n    /**\n     * listing all previous siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [optional] pred - predicate function\n     */\n    var listPrev = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.previousSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing next siblings (until predicate hit).\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listNext = function (node, pred) {\n      pred = pred || func.fail;\n\n      var nodes = [];\n      while (node) {\n        if (pred(node)) { break; }\n        nodes.push(node);\n        node = node.nextSibling;\n      }\n      return nodes;\n    };\n\n    /**\n     * listing descendant nodes\n     *\n     * @param {Node} node\n     * @param {Function} [pred] - predicate function\n     */\n    var listDescendant = function (node, pred) {\n      var descendants = [];\n      pred = pred || func.ok;\n\n      // start DFS(depth first search) with node\n      (function fnWalk(current) {\n        if (node !== current && pred(current)) {\n          descendants.push(current);\n        }\n        for (var idx = 0, len = current.childNodes.length; idx < len; idx++) {\n          fnWalk(current.childNodes[idx]);\n        }\n      })(node);\n\n      return descendants;\n    };\n\n    /**\n     * wrap node with new tag.\n     *\n     * @param {Node} node\n     * @param {Node} tagName of wrapper\n     * @return {Node} - wrapper\n     */\n    var wrap = function (node, wrapperName) {\n      var parent = node.parentNode;\n      var wrapper = $('<' + wrapperName + '>')[0];\n\n      parent.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n\n      return wrapper;\n    };\n\n    /**\n     * insert node after preceding\n     *\n     * @param {Node} node\n     * @param {Node} preceding - predicate function\n     */\n    var insertAfter = function (node, preceding) {\n      var next = preceding.nextSibling, parent = preceding.parentNode;\n      if (next) {\n        parent.insertBefore(node, next);\n      } else {\n        parent.appendChild(node);\n      }\n      return node;\n    };\n\n    /**\n     * append elements.\n     *\n     * @param {Node} node\n     * @param {Collection} aChild\n     */\n    var appendChildNodes = function (node, aChild) {\n      $.each(aChild, function (idx, child) {\n        node.appendChild(child);\n      });\n      return node;\n    };\n\n    /**\n     * returns whether boundaryPoint is left edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isLeftEdgePoint = function (point) {\n      return point.offset === 0;\n    };\n\n    /**\n     * returns whether boundaryPoint is right edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isRightEdgePoint = function (point) {\n      return point.offset === nodeLength(point.node);\n    };\n\n    /**\n     * returns whether boundaryPoint is edge or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isEdgePoint = function (point) {\n      return isLeftEdgePoint(point) || isRightEdgePoint(point);\n    };\n\n    /**\n     * returns whether node is left edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgeOf = function (node, ancestor) {\n      while (node && node !== ancestor) {\n        if (position(node) !== 0) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether node is right edge of ancestor or not.\n     *\n     * @param {Node} node\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgeOf = function (node, ancestor) {\n      if (!ancestor) {\n        return false;\n      }\n      while (node && node !== ancestor) {\n        if (position(node) !== nodeLength(node.parentNode) - 1) {\n          return false;\n        }\n        node = node.parentNode;\n      }\n\n      return true;\n    };\n\n    /**\n     * returns whether point is left edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isLeftEdgePointOf = function (point, ancestor) {\n      return isLeftEdgePoint(point) && isLeftEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns whether point is right edge of ancestor or not.\n     * @param {BoundaryPoint} point\n     * @param {Node} ancestor\n     * @return {Boolean}\n     */\n    var isRightEdgePointOf = function (point, ancestor) {\n      return isRightEdgePoint(point) && isRightEdgeOf(point.node, ancestor);\n    };\n\n    /**\n     * returns offset from parent.\n     *\n     * @param {Node} node\n     */\n    var position = function (node) {\n      var offset = 0;\n      while ((node = node.previousSibling)) {\n        offset += 1;\n      }\n      return offset;\n    };\n\n    var hasChildren = function (node) {\n      return !!(node && node.childNodes && node.childNodes.length);\n    };\n\n    /**\n     * returns previous boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var prevPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (point.offset === 0) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node);\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset - 1];\n        offset = nodeLength(node);\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? 0 : point.offset - 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns next boundaryPoint\n     *\n     * @param {BoundaryPoint} point\n     * @param {Boolean} isSkipInnerOffset\n     * @return {BoundaryPoint}\n     */\n    var nextPoint = function (point, isSkipInnerOffset) {\n      var node, offset;\n\n      if (nodeLength(point.node) === point.offset) {\n        if (isEditable(point.node)) {\n          return null;\n        }\n\n        node = point.node.parentNode;\n        offset = position(point.node) + 1;\n      } else if (hasChildren(point.node)) {\n        node = point.node.childNodes[point.offset];\n        offset = 0;\n      } else {\n        node = point.node;\n        offset = isSkipInnerOffset ? nodeLength(point.node) : point.offset + 1;\n      }\n\n      return {\n        node: node,\n        offset: offset\n      };\n    };\n\n    /**\n     * returns whether pointA and pointB is same or not.\n     *\n     * @param {BoundaryPoint} pointA\n     * @param {BoundaryPoint} pointB\n     * @return {Boolean}\n     */\n    var isSamePoint = function (pointA, pointB) {\n      return pointA.node === pointB.node && pointA.offset === pointB.offset;\n    };\n\n    /**\n     * returns whether point is visible (can set cursor) or not.\n     *\n     * @param {BoundaryPoint} point\n     * @return {Boolean}\n     */\n    var isVisiblePoint = function (point) {\n      if (isText(point.node) || !hasChildren(point.node) || isEmpty(point.node)) {\n        return true;\n      }\n\n      var leftNode = point.node.childNodes[point.offset - 1];\n      var rightNode = point.node.childNodes[point.offset];\n      if ((!leftNode || isVoid(leftNode)) && (!rightNode || isVoid(rightNode))) {\n        return true;\n      }\n\n      return false;\n    };\n\n    /**\n     * @method prevPointUtil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var prevPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = prevPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * @method nextPointUntil\n     *\n     * @param {BoundaryPoint} point\n     * @param {Function} pred\n     * @return {BoundaryPoint}\n     */\n    var nextPointUntil = function (point, pred) {\n      while (point) {\n        if (pred(point)) {\n          return point;\n        }\n\n        point = nextPoint(point);\n      }\n\n      return null;\n    };\n\n    /**\n     * returns whether point has character or not.\n     *\n     * @param {Point} point\n     * @return {Boolean}\n     */\n    var isCharPoint = function (point) {\n      if (!isText(point.node)) {\n        return false;\n      }\n\n      var ch = point.node.nodeValue.charAt(point.offset - 1);\n      return ch && (ch !== ' ' && ch !== NBSP_CHAR);\n    };\n\n    /**\n     * @method walkPoint\n     *\n     * @param {BoundaryPoint} startPoint\n     * @param {BoundaryPoint} endPoint\n     * @param {Function} handler\n     * @param {Boolean} isSkipInnerOffset\n     */\n    var walkPoint = function (startPoint, endPoint, handler, isSkipInnerOffset) {\n      var point = startPoint;\n\n      while (point) {\n        handler(point);\n\n        if (isSamePoint(point, endPoint)) {\n          break;\n        }\n\n        var isSkipOffset = isSkipInnerOffset &&\n                           startPoint.node !== point.node &&\n                           endPoint.node !== point.node;\n        point = nextPoint(point, isSkipOffset);\n      }\n    };\n\n    /**\n     * @method makeOffsetPath\n     *\n     * return offsetPath(array of offset) from ancestor\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {Node} node\n     */\n    var makeOffsetPath = function (ancestor, node) {\n      var ancestors = listAncestor(node, func.eq(ancestor));\n      return ancestors.map(position).reverse();\n    };\n\n    /**\n     * @method fromOffsetPath\n     *\n     * return element from offsetPath(array of offset)\n     *\n     * @param {Node} ancestor - ancestor node\n     * @param {array} offsets - offsetPath\n     */\n    var fromOffsetPath = function (ancestor, offsets) {\n      var current = ancestor;\n      for (var i = 0, len = offsets.length; i < len; i++) {\n        if (current.childNodes.length <= offsets[i]) {\n          current = current.childNodes[current.childNodes.length - 1];\n        } else {\n          current = current.childNodes[offsets[i]];\n        }\n      }\n      return current;\n    };\n\n    /**\n     * @method splitNode\n     *\n     * split element or #text\n     *\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitNode = function (point, options) {\n      var isSkipPaddingBlankHTML = options && options.isSkipPaddingBlankHTML;\n      var isNotSplitEdgePoint = options && options.isNotSplitEdgePoint;\n\n      // edge case\n      if (isEdgePoint(point) && (isText(point.node) || isNotSplitEdgePoint)) {\n        if (isLeftEdgePoint(point)) {\n          return point.node;\n        } else if (isRightEdgePoint(point)) {\n          return point.node.nextSibling;\n        }\n      }\n\n      // split #text\n      if (isText(point.node)) {\n        return point.node.splitText(point.offset);\n      } else {\n        var childNode = point.node.childNodes[point.offset];\n        var clone = insertAfter(point.node.cloneNode(false), point.node);\n        appendChildNodes(clone, listNext(childNode));\n\n        if (!isSkipPaddingBlankHTML) {\n          paddingBlankHTML(point.node);\n          paddingBlankHTML(clone);\n        }\n\n        return clone;\n      }\n    };\n\n    /**\n     * @method splitTree\n     *\n     * split tree by point\n     *\n     * @param {Node} root - split root\n     * @param {BoundaryPoint} point\n     * @param {Object} [options]\n     * @param {Boolean} [options.isSkipPaddingBlankHTML] - default: false\n     * @param {Boolean} [options.isNotSplitEdgePoint] - default: false\n     * @return {Node} right node of boundaryPoint\n     */\n    var splitTree = function (root, point, options) {\n      // ex) [#text, <span>, <p>]\n      var ancestors = listAncestor(point.node, func.eq(root));\n\n      if (!ancestors.length) {\n        return null;\n      } else if (ancestors.length === 1) {\n        return splitNode(point, options);\n      }\n\n      return ancestors.reduce(function (node, parent) {\n        if (node === point.node) {\n          node = splitNode(point, options);\n        }\n\n        return splitNode({\n          node: parent,\n          offset: node ? dom.position(node) : nodeLength(parent)\n        }, options);\n      });\n    };\n\n    /**\n     * split point\n     *\n     * @param {Point} point\n     * @param {Boolean} isInline\n     * @return {Object}\n     */\n    var splitPoint = function (point, isInline) {\n      // find splitRoot, container\n      //  - inline: splitRoot is a child of paragraph\n      //  - block: splitRoot is a child of bodyContainer\n      var pred = isInline ? isPara : isBodyContainer;\n      var ancestors = listAncestor(point.node, pred);\n      var topAncestor = list.last(ancestors) || point.node;\n\n      var splitRoot, container;\n      if (pred(topAncestor)) {\n        splitRoot = ancestors[ancestors.length - 2];\n        container = topAncestor;\n      } else {\n        splitRoot = topAncestor;\n        container = splitRoot.parentNode;\n      }\n\n      // if splitRoot is exists, split with splitTree\n      var pivot = splitRoot && splitTree(splitRoot, point, {\n        isSkipPaddingBlankHTML: isInline,\n        isNotSplitEdgePoint: isInline\n      });\n\n      // if container is point.node, find pivot with point.offset\n      if (!pivot && container === point.node) {\n        pivot = point.node.childNodes[point.offset];\n      }\n\n      return {\n        rightNode: pivot,\n        container: container\n      };\n    };\n\n    var create = function (nodeName) {\n      return document.createElement(nodeName);\n    };\n\n    var createText = function (text) {\n      return document.createTextNode(text);\n    };\n\n    /**\n     * @method remove\n     *\n     * remove node, (isRemoveChild: remove child or not)\n     *\n     * @param {Node} node\n     * @param {Boolean} isRemoveChild\n     */\n    var remove = function (node, isRemoveChild) {\n      if (!node || !node.parentNode) { return; }\n      if (node.removeNode) { return node.removeNode(isRemoveChild); }\n\n      var parent = node.parentNode;\n      if (!isRemoveChild) {\n        var nodes = [];\n        var i, len;\n        for (i = 0, len = node.childNodes.length; i < len; i++) {\n          nodes.push(node.childNodes[i]);\n        }\n\n        for (i = 0, len = nodes.length; i < len; i++) {\n          parent.insertBefore(nodes[i], node);\n        }\n      }\n\n      parent.removeChild(node);\n    };\n\n    /**\n     * @method removeWhile\n     *\n     * @param {Node} node\n     * @param {Function} pred\n     */\n    var removeWhile = function (node, pred) {\n      while (node) {\n        if (isEditable(node) || !pred(node)) {\n          break;\n        }\n\n        var parent = node.parentNode;\n        remove(node);\n        node = parent;\n      }\n    };\n\n    /**\n     * @method replace\n     *\n     * replace node with provided nodeName\n     *\n     * @param {Node} node\n     * @param {String} nodeName\n     * @return {Node} - new node\n     */\n    var replace = function (node, nodeName) {\n      if (node.nodeName.toUpperCase() === nodeName.toUpperCase()) {\n        return node;\n      }\n\n      var newNode = create(nodeName);\n\n      if (node.style.cssText) {\n        newNode.style.cssText = node.style.cssText;\n      }\n\n      appendChildNodes(newNode, list.from(node.childNodes));\n      insertAfter(newNode, node);\n      remove(node);\n\n      return newNode;\n    };\n\n    var isTextarea = makePredByNodeName('TEXTAREA');\n\n    /**\n     * @param {jQuery} $node\n     * @param {Boolean} [stripLinebreaks] - default: false\n     */\n    var value = function ($node, stripLinebreaks) {\n      var val = isTextarea($node[0]) ? $node.val() : $node.html();\n      if (stripLinebreaks) {\n        return val.replace(/[\\n\\r]/g, '');\n      }\n      return val;\n    };\n\n    /**\n     * @method html\n     *\n     * get the HTML contents of node\n     *\n     * @param {jQuery} $node\n     * @param {Boolean} [isNewlineOnBlock]\n     */\n    var html = function ($node, isNewlineOnBlock) {\n      var markup = value($node);\n\n      if (isNewlineOnBlock) {\n        var regexTag = /<(\\/?)(\\b(?!!)[^>\\s]*)(.*?)(\\s*\\/?>)/g;\n        markup = markup.replace(regexTag, function (match, endSlash, name) {\n          name = name.toUpperCase();\n          var isEndOfInlineContainer = /^DIV|^TD|^TH|^P|^LI|^H[1-7]/.test(name) &&\n                                       !!endSlash;\n          var isBlockNode = /^BLOCKQUOTE|^TABLE|^TBODY|^TR|^HR|^UL|^OL/.test(name);\n\n          return match + ((isEndOfInlineContainer || isBlockNode) ? '\\n' : '');\n        });\n        markup = $.trim(markup);\n      }\n\n      return markup;\n    };\n\n    var posFromPlaceholder = function (placeholder) {\n      var $placeholder = $(placeholder);\n      var pos = $placeholder.offset();\n      var height = $placeholder.outerHeight(true); // include margin\n\n      return {\n        left: pos.left,\n        top: pos.top + height\n      };\n    };\n\n    var attachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.on(key, events[key]);\n      });\n    };\n\n    var detachEvents = function ($node, events) {\n      Object.keys(events).forEach(function (key) {\n        $node.off(key, events[key]);\n      });\n    };\n\n    return {\n      /** @property {String} NBSP_CHAR */\n      NBSP_CHAR: NBSP_CHAR,\n      /** @property {String} ZERO_WIDTH_NBSP_CHAR */\n      ZERO_WIDTH_NBSP_CHAR: ZERO_WIDTH_NBSP_CHAR,\n      /** @property {String} blank */\n      blank: blankHTML,\n      /** @property {String} emptyPara */\n      emptyPara: '<p>' + blankHTML + '</p>',\n      makePredByNodeName: makePredByNodeName,\n      isEditable: isEditable,\n      isControlSizing: isControlSizing,\n      isText: isText,\n      isElement: isElement,\n      isVoid: isVoid,\n      isPara: isPara,\n      isPurePara: isPurePara,\n      isHeading: isHeading,\n      isInline: isInline,\n      isBlock: func.not(isInline),\n      isBodyInline: isBodyInline,\n      isBody: isBody,\n      isParaInline: isParaInline,\n      isPre: isPre,\n      isList: isList,\n      isTable: isTable,\n      isData: isData,\n      isCell: isCell,\n      isBlockquote: isBlockquote,\n      isBodyContainer: isBodyContainer,\n      isAnchor: isAnchor,\n      isDiv: makePredByNodeName('DIV'),\n      isLi: isLi,\n      isBR: makePredByNodeName('BR'),\n      isSpan: makePredByNodeName('SPAN'),\n      isB: makePredByNodeName('B'),\n      isU: makePredByNodeName('U'),\n      isS: makePredByNodeName('S'),\n      isI: makePredByNodeName('I'),\n      isImg: makePredByNodeName('IMG'),\n      isTextarea: isTextarea,\n      isEmpty: isEmpty,\n      isEmptyAnchor: func.and(isAnchor, isEmpty),\n      isClosestSibling: isClosestSibling,\n      withClosestSiblings: withClosestSiblings,\n      nodeLength: nodeLength,\n      isLeftEdgePoint: isLeftEdgePoint,\n      isRightEdgePoint: isRightEdgePoint,\n      isEdgePoint: isEdgePoint,\n      isLeftEdgeOf: isLeftEdgeOf,\n      isRightEdgeOf: isRightEdgeOf,\n      isLeftEdgePointOf: isLeftEdgePointOf,\n      isRightEdgePointOf: isRightEdgePointOf,\n      prevPoint: prevPoint,\n      nextPoint: nextPoint,\n      isSamePoint: isSamePoint,\n      isVisiblePoint: isVisiblePoint,\n      prevPointUntil: prevPointUntil,\n      nextPointUntil: nextPointUntil,\n      isCharPoint: isCharPoint,\n      walkPoint: walkPoint,\n      ancestor: ancestor,\n      singleChildAncestor: singleChildAncestor,\n      listAncestor: listAncestor,\n      lastAncestor: lastAncestor,\n      listNext: listNext,\n      listPrev: listPrev,\n      listDescendant: listDescendant,\n      commonAncestor: commonAncestor,\n      wrap: wrap,\n      insertAfter: insertAfter,\n      appendChildNodes: appendChildNodes,\n      position: position,\n      hasChildren: hasChildren,\n      makeOffsetPath: makeOffsetPath,\n      fromOffsetPath: fromOffsetPath,\n      splitTree: splitTree,\n      splitPoint: splitPoint,\n      create: create,\n      createText: createText,\n      remove: remove,\n      removeWhile: removeWhile,\n      replace: replace,\n      html: html,\n      value: value,\n      posFromPlaceholder: posFromPlaceholder,\n      attachEvents: attachEvents,\n      detachEvents: detachEvents\n    };\n  })();\n\n  /**\n   * @param {jQuery} $note\n   * @param {Object} options\n   * @return {Context}\n   */\n  var Context = function ($note, options) {\n    var self = this;\n\n    var ui = $.summernote.ui;\n    this.memos = {};\n    this.modules = {};\n    this.layoutInfo = {};\n    this.options = options;\n\n    /**\n     * create layout and initialize modules and other resources\n     */\n    this.initialize = function () {\n      this.layoutInfo = ui.createLayout($note, options);\n      this._initialize();\n      $note.hide();\n      return this;\n    };\n\n    /**\n     * destroy modules and other resources and remove layout\n     */\n    this.destroy = function () {\n      this._destroy();\n      $note.removeData('summernote');\n      ui.removeLayout($note, this.layoutInfo);\n    };\n\n    /**\n     * destory modules and other resources and initialize it again\n     */\n    this.reset = function () {\n      var disabled = self.isDisabled();\n      this.code(dom.emptyPara);\n      this._destroy();\n      this._initialize();\n\n      if (disabled) {\n        self.disable();\n      }\n    };\n\n    this._initialize = function () {\n      // add optional buttons\n      var buttons = $.extend({}, this.options.buttons);\n      Object.keys(buttons).forEach(function (key) {\n        self.memo('button.' + key, buttons[key]);\n      });\n\n      var modules = $.extend({}, this.options.modules, $.summernote.plugins || {});\n\n      // add and initialize modules\n      Object.keys(modules).forEach(function (key) {\n        self.module(key, modules[key], true);\n      });\n\n      Object.keys(this.modules).forEach(function (key) {\n        self.initializeModule(key);\n      });\n    };\n\n    this._destroy = function () {\n      // destroy modules with reversed order\n      Object.keys(this.modules).reverse().forEach(function (key) {\n        self.removeModule(key);\n      });\n\n      Object.keys(this.memos).forEach(function (key) {\n        self.removeMemo(key);\n      });\n    };\n\n    this.code = function (html) {\n      var isActivated = this.invoke('codeview.isActivated');\n\n      if (html === undefined) {\n        this.invoke('codeview.sync');\n        return isActivated ? this.layoutInfo.codable.val() : this.layoutInfo.editable.html();\n      } else {\n        if (isActivated) {\n          this.layoutInfo.codable.val(html);\n        } else {\n          this.layoutInfo.editable.html(html);\n        }\n        $note.val(html);\n        this.triggerEvent('change', html);\n      }\n    };\n\n    this.isDisabled = function () {\n      return this.layoutInfo.editable.attr('contenteditable') === 'false';\n    };\n\n    this.enable = function () {\n      this.layoutInfo.editable.attr('contenteditable', true);\n      this.invoke('toolbar.activate', true);\n    };\n\n    this.disable = function () {\n      // close codeview if codeview is opend\n      if (this.invoke('codeview.isActivated')) {\n        this.invoke('codeview.deactivate');\n      }\n      this.layoutInfo.editable.attr('contenteditable', false);\n      this.invoke('toolbar.deactivate', true);\n    };\n\n    this.triggerEvent = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var callback = this.options.callbacks[func.namespaceToCamel(namespace, 'on')];\n      if (callback) {\n        callback.apply($note[0], args);\n      }\n      $note.trigger('summernote.' + namespace, args);\n    };\n\n    this.initializeModule = function (key) {\n      var module = this.modules[key];\n      module.shouldInitialize = module.shouldInitialize || func.ok;\n      if (!module.shouldInitialize()) {\n        return;\n      }\n\n      // initialize module\n      if (module.initialize) {\n        module.initialize();\n      }\n\n      // attach events\n      if (module.events) {\n        dom.attachEvents($note, module.events);\n      }\n    };\n\n    this.module = function (key, ModuleClass, withoutIntialize) {\n      if (arguments.length === 1) {\n        return this.modules[key];\n      }\n\n      this.modules[key] = new ModuleClass(this);\n\n      if (!withoutIntialize) {\n        this.initializeModule(key);\n      }\n    };\n\n    this.removeModule = function (key) {\n      var module = this.modules[key];\n      if (module.shouldInitialize()) {\n        if (module.events) {\n          dom.detachEvents($note, module.events);\n        }\n\n        if (module.destroy) {\n          module.destroy();\n        }\n      }\n\n      delete this.modules[key];\n    };\n\n    this.memo = function (key, obj) {\n      if (arguments.length === 1) {\n        return this.memos[key];\n      }\n      this.memos[key] = obj;\n    };\n\n    this.removeMemo = function (key) {\n      if (this.memos[key] && this.memos[key].destroy) {\n        this.memos[key].destroy();\n      }\n\n      delete this.memos[key];\n    };\n\n    this.createInvokeHandler = function (namespace, value) {\n      return function (event) {\n        event.preventDefault();\n        self.invoke(namespace, value || $(event.target).closest('[data-value]').data('value'));\n      };\n    };\n\n    this.invoke = function () {\n      var namespace = list.head(arguments);\n      var args = list.tail(list.from(arguments));\n\n      var splits = namespace.split('.');\n      var hasSeparator = splits.length > 1;\n      var moduleName = hasSeparator && list.head(splits);\n      var methodName = hasSeparator ? list.last(splits) : list.head(splits);\n\n      var module = this.modules[moduleName || 'editor'];\n      if (!moduleName && this[methodName]) {\n        return this[methodName].apply(this, args);\n      } else if (module && module[methodName] && module.shouldInitialize()) {\n        return module[methodName].apply(module, args);\n      }\n    };\n\n    return this.initialize();\n  };\n\n  $.fn.extend({\n    /**\n     * Summernote API\n     *\n     * @param {Object|String}\n     * @return {this}\n     */\n    summernote: function () {\n      var type = $.type(list.head(arguments));\n      var isExternalAPICalled = type === 'string';\n      var hasInitOptions = type === 'object';\n\n      var options = hasInitOptions ? list.head(arguments) : {};\n\n      options = $.extend({}, $.summernote.options, options);\n      options.langInfo = $.extend(true, {}, $.summernote.lang['en-US'], $.summernote.lang[options.lang]);\n      options.icons = $.extend(true, {}, $.summernote.options.icons, options.icons);\n\n      this.each(function (idx, note) {\n        var $note = $(note);\n        if (!$note.data('summernote')) {\n          var context = new Context($note, options);\n          $note.data('summernote', context);\n          $note.data('summernote').triggerEvent('init', context.layoutInfo);\n        }\n      });\n\n      var $note = this.first();\n      if ($note.length) {\n        var context = $note.data('summernote');\n        if (isExternalAPICalled) {\n          return context.invoke.apply(context, list.from(arguments));\n        } else if (options.focus) {\n          context.invoke('editor.focus');\n        }\n      }\n\n      return this;\n    }\n  });\n\n\n  var Renderer = function (markup, children, options, callback) {\n    this.render = function ($parent) {\n      var $node = $(markup);\n\n      if (options && options.contents) {\n        $node.html(options.contents);\n      }\n\n      if (options && options.className) {\n        $node.addClass(options.className);\n      }\n\n      if (options && options.data) {\n        $.each(options.data, function (k, v) {\n          $node.attr('data-' + k, v);\n        });\n      }\n\n      if (options && options.click) {\n        $node.on('click', options.click);\n      }\n\n      if (children) {\n        var $container = $node.find('.note-children-container');\n        children.forEach(function (child) {\n          child.render($container.length ? $container : $node);\n        });\n      }\n\n      if (callback) {\n        callback($node, options);\n      }\n\n      if (options && options.callback) {\n        options.callback($node);\n      }\n\n      if ($parent) {\n        $parent.append($node);\n      }\n\n      return $node;\n    };\n  };\n\n  var renderer = {\n    create: function (markup, callback) {\n      return function () {\n        var children = $.isArray(arguments[0]) ? arguments[0] : [];\n        var options = typeof arguments[1] === 'object' ? arguments[1] : arguments[0];\n        if (options && options.children) {\n          children = options.children;\n        }\n        return new Renderer(markup, children, options, callback);\n      };\n    }\n  };\n\n  var editor = renderer.create('<div class=\"note-editor note-frame panel panel-default\"/>');\n  var toolbar = renderer.create('<div class=\"note-toolbar panel-heading\"/>');\n  var editingArea = renderer.create('<div class=\"note-editing-area\"/>');\n  var codable = renderer.create('<textarea class=\"note-codable\"/>');\n  var editable = renderer.create('<div class=\"note-editable panel-body\" contentEditable=\"true\"/>');\n  var statusbar = renderer.create([\n    '<div class=\"note-statusbar\">',\n    '  <div class=\"note-resizebar\">',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '    <div class=\"note-icon-bar\"/>',\n    '  </div>',\n    '</div>'\n  ].join(''));\n\n  var airEditor = renderer.create('<div class=\"note-editor\"/>');\n  var airEditable = renderer.create('<div class=\"note-editable\" contentEditable=\"true\"/>');\n\n  var buttonGroup = renderer.create('<div class=\"note-btn-group btn-group\">');\n  var button = renderer.create('<button type=\"button\" class=\"note-btn btn btn-default btn-sm\" tabindex=\"-1\">', function ($node, options) {\n    if (options && options.tooltip) {\n      $node.attr({\n        title: options.tooltip\n      }).tooltip({\n        container: 'body',\n        trigger: 'hover',\n        placement: 'bottom'\n      });\n    }\n  });\n\n  var dropdown = renderer.create('<div class=\"dropdown-menu\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + content + '</a></li>';\n    }).join('') : options.items;\n\n    $node.html(markup);\n  });\n\n  var dropdownCheck = renderer.create('<div class=\"dropdown-menu note-check\">', function ($node, options) {\n    var markup = $.isArray(options.items) ? options.items.map(function (item) {\n      var value = (typeof item === 'string') ? item : (item.value || '');\n      var content = options.template ? options.template(item) : item;\n      return '<li><a href=\"#\" data-value=\"' + value + '\">' + icon(options.checkClassName) + ' ' + content + '</a></li>';\n    }).join('') : options.items;\n    $node.html(markup);\n  });\n\n  var palette = renderer.create('<div class=\"note-color-palette\"/>', function ($node, options) {\n    var contents = [];\n    for (var row = 0, rowSize = options.colors.length; row < rowSize; row++) {\n      var eventName = options.eventName;\n      var colors = options.colors[row];\n      var buttons = [];\n      for (var col = 0, colSize = colors.length; col < colSize; col++) {\n        var color = colors[col];\n        buttons.push([\n          '<button type=\"button\" class=\"note-color-btn\"',\n          'style=\"background-color:', color, '\" ',\n          'data-event=\"', eventName, '\" ',\n          'data-value=\"', color, '\" ',\n          'title=\"', color, '\" ',\n          'data-toggle=\"button\" tabindex=\"-1\"></button>'\n        ].join(''));\n      }\n      contents.push('<div class=\"note-color-row\">' + buttons.join('') + '</div>');\n    }\n    $node.html(contents.join(''));\n\n    $node.find('.note-color-btn').tooltip({\n      container: 'body',\n      trigger: 'hover',\n      placement: 'bottom'\n    });\n  });\n\n  var dialog = renderer.create('<div class=\"modal\" aria-hidden=\"false\" tabindex=\"-1\"/>', function ($node, options) {\n    if (options.fade) {\n      $node.addClass('fade');\n    }\n    $node.html([\n      '<div class=\"modal-dialog\">',\n      '  <div class=\"modal-content\">',\n      (options.title ?\n      '    <div class=\"modal-header\">' +\n      '      <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\"><span aria-hidden=\"true\">&times;</span></button>' +\n      '      <h4 class=\"modal-title\">' + options.title + '</h4>' +\n      '    </div>' : ''\n      ),\n      '    <div class=\"modal-body\">' + options.body + '</div>',\n      (options.footer ?\n      '    <div class=\"modal-footer\">' + options.footer + '</div>' : ''\n      ),\n      '  </div>',\n      '</div>'\n    ].join(''));\n  });\n\n  var popover = renderer.create([\n    '<div class=\"note-popover popover in\">',\n    '  <div class=\"arrow\"/>',\n    '  <div class=\"popover-content note-children-container\"/>',\n    '</div>'\n  ].join(''), function ($node, options) {\n    var direction = typeof options.direction !== 'undefined' ? options.direction : 'bottom';\n\n    $node.addClass(direction);\n\n    if (options.hideArrow) {\n      $node.find('.arrow').hide();\n    }\n  });\n\n  var icon = function (iconClassName, tagName) {\n    tagName = tagName || 'i';\n    return '<' + tagName + ' class=\"' + iconClassName + '\"/>';\n  };\n\n  var ui = {\n    editor: editor,\n    toolbar: toolbar,\n    editingArea: editingArea,\n    codable: codable,\n    editable: editable,\n    statusbar: statusbar,\n    airEditor: airEditor,\n    airEditable: airEditable,\n    buttonGroup: buttonGroup,\n    button: button,\n    dropdown: dropdown,\n    dropdownCheck: dropdownCheck,\n    palette: palette,\n    dialog: dialog,\n    popover: popover,\n    icon: icon,\n\n    toggleBtn: function ($btn, isEnable) {\n      $btn.toggleClass('disabled', !isEnable);\n      $btn.attr('disabled', !isEnable);\n    },\n\n    toggleBtnActive: function ($btn, isActive) {\n      $btn.toggleClass('active', isActive);\n    },\n\n    onDialogShown: function ($dialog, handler) {\n      $dialog.one('shown.bs.modal', handler);\n    },\n\n    onDialogHidden: function ($dialog, handler) {\n      $dialog.one('hidden.bs.modal', handler);\n    },\n\n    showDialog: function ($dialog) {\n      $dialog.modal('show');\n    },\n\n    hideDialog: function ($dialog) {\n      $dialog.modal('hide');\n    },\n\n    createLayout: function ($note, options) {\n      var $editor = (options.airMode ? ui.airEditor([\n        ui.editingArea([\n          ui.airEditable()\n        ])\n      ]) : ui.editor([\n        ui.toolbar(),\n        ui.editingArea([\n          ui.codable(),\n          ui.editable()\n        ]),\n        ui.statusbar()\n      ])).render();\n\n      $editor.insertAfter($note);\n\n      return {\n        note: $note,\n        editor: $editor,\n        toolbar: $editor.find('.note-toolbar'),\n        editingArea: $editor.find('.note-editing-area'),\n        editable: $editor.find('.note-editable'),\n        codable: $editor.find('.note-codable'),\n        statusbar: $editor.find('.note-statusbar')\n      };\n    },\n\n    removeLayout: function ($note, layoutInfo) {\n      $note.html(layoutInfo.editable.html());\n      layoutInfo.editor.remove();\n      $note.show();\n    }\n  };\n\n  $.summernote = $.summernote || {\n    lang: {}\n  };\n\n  $.extend($.summernote.lang, {\n    'en-US': {\n      font: {\n        bold: 'Bold',\n        italic: 'Italic',\n        underline: 'Underline',\n        clear: 'Remove Font Style',\n        height: 'Line Height',\n        name: 'Font Family',\n        strikethrough: 'Strikethrough',\n        subscript: 'Subscript',\n        superscript: 'Superscript',\n        size: 'Font Size'\n      },\n      image: {\n        image: 'Picture',\n        insert: 'Insert Image',\n        resizeFull: 'Resize Full',\n        resizeHalf: 'Resize Half',\n        resizeQuarter: 'Resize Quarter',\n        floatLeft: 'Float Left',\n        floatRight: 'Float Right',\n        floatNone: 'Float None',\n        shapeRounded: 'Shape: Rounded',\n        shapeCircle: 'Shape: Circle',\n        shapeThumbnail: 'Shape: Thumbnail',\n        shapeNone: 'Shape: None',\n        dragImageHere: 'Drag image or text here',\n        dropImage: 'Drop image or Text',\n        selectFromFiles: 'Select from files',\n        maximumFileSize: 'Maximum file size',\n        maximumFileSizeError: 'Maximum file size exceeded.',\n        url: 'Image URL',\n        remove: 'Remove Image'\n      },\n      video: {\n        video: 'Video',\n        videoLink: 'Video Link',\n        insert: 'Insert Video',\n        url: 'Video URL?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion or Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Insert Link',\n        unlink: 'Unlink',\n        edit: 'Edit',\n        textToDisplay: 'Text to display',\n        url: 'To what URL should this link go?',\n        openInNewWindow: 'Open in new window'\n      },\n      table: {\n        table: 'Table'\n      },\n      hr: {\n        insert: 'Insert Horizontal Rule'\n      },\n      style: {\n        style: 'Style',\n        normal: 'Normal',\n        blockquote: 'Quote',\n        pre: 'Code',\n        h1: 'Header 1',\n        h2: 'Header 2',\n        h3: 'Header 3',\n        h4: 'Header 4',\n        h5: 'Header 5',\n        h6: 'Header 6'\n      },\n      lists: {\n        unordered: 'Unordered list',\n        ordered: 'Ordered list'\n      },\n      options: {\n        help: 'Help',\n        fullscreen: 'Full Screen',\n        codeview: 'Code View'\n      },\n      paragraph: {\n        paragraph: 'Paragraph',\n        outdent: 'Outdent',\n        indent: 'Indent',\n        left: 'Align left',\n        center: 'Align center',\n        right: 'Align right',\n        justify: 'Justify full'\n      },\n      color: {\n        recent: 'Recent Color',\n        more: 'More Color',\n        background: 'Background Color',\n        foreground: 'Foreground Color',\n        transparent: 'Transparent',\n        setTransparent: 'Set transparent',\n        reset: 'Reset',\n        resetToDefault: 'Reset to default'\n      },\n      shortcut: {\n        shortcuts: 'Keyboard shortcuts',\n        close: 'Close',\n        textFormatting: 'Text formatting',\n        action: 'Action',\n        paragraphFormatting: 'Paragraph formatting',\n        documentStyle: 'Document Style',\n        extraKeys: 'Extra keys'\n      },\n      help: {\n        'insertParagraph': 'Insert Paragraph',\n        'undo': 'Undoes the last command',\n        'redo': 'Redoes the last command',\n        'tab': 'Tab',\n        'untab': 'Untab',\n        'bold': 'Set a bold style',\n        'italic': 'Set a italic style',\n        'underline': 'Set a underline style',\n        'strikethrough': 'Set a strikethrough style',\n        'removeFormat': 'Clean a style',\n        'justifyLeft': 'Set left align',\n        'justifyCenter': 'Set center align',\n        'justifyRight': 'Set right align',\n        'justifyFull': 'Set full align',\n        'insertUnorderedList': 'Toggle unordered list',\n        'insertOrderedList': 'Toggle ordered list',\n        'outdent': 'Outdent on current paragraph',\n        'indent': 'Indent on current paragraph',\n        'formatPara': 'Change current block\\'s format as a paragraph(P tag)',\n        'formatH1': 'Change current block\\'s format as H1',\n        'formatH2': 'Change current block\\'s format as H2',\n        'formatH3': 'Change current block\\'s format as H3',\n        'formatH4': 'Change current block\\'s format as H4',\n        'formatH5': 'Change current block\\'s format as H5',\n        'formatH6': 'Change current block\\'s format as H6',\n        'insertHorizontalRule': 'Insert horizontal rule',\n        'linkDialog.show': 'Show Link Dialog'\n      },\n      history: {\n        undo: 'Undo',\n        redo: 'Redo'\n      },\n      specialChar: {\n        specialChar: 'SPECIAL CHARACTERS',\n        select: 'Select Special characters'\n      }\n    }\n  });\n\n\n  /**\n   * @class core.key\n   *\n   * Object for keycodes.\n   *\n   * @singleton\n   * @alternateClassName key\n   */\n  var key = (function () {\n    var keyMap = {\n      'BACKSPACE': 8,\n      'TAB': 9,\n      'ENTER': 13,\n      'SPACE': 32,\n\n      // Arrow\n      'LEFT': 37,\n      'UP': 38,\n      'RIGHT': 39,\n      'DOWN': 40,\n\n      // Number: 0-9\n      'NUM0': 48,\n      'NUM1': 49,\n      'NUM2': 50,\n      'NUM3': 51,\n      'NUM4': 52,\n      'NUM5': 53,\n      'NUM6': 54,\n      'NUM7': 55,\n      'NUM8': 56,\n\n      // Alphabet: a-z\n      'B': 66,\n      'E': 69,\n      'I': 73,\n      'J': 74,\n      'K': 75,\n      'L': 76,\n      'R': 82,\n      'S': 83,\n      'U': 85,\n      'V': 86,\n      'Y': 89,\n      'Z': 90,\n\n      'SLASH': 191,\n      'LEFTBRACKET': 219,\n      'BACKSLASH': 220,\n      'RIGHTBRACKET': 221\n    };\n\n    return {\n      /**\n       * @method isEdit\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isEdit: function (keyCode) {\n        return list.contains([\n          keyMap.BACKSPACE,\n          keyMap.TAB,\n          keyMap.ENTER,\n          keyMap.SPACE\n        ], keyCode);\n      },\n      /**\n       * @method isMove\n       *\n       * @param {Number} keyCode\n       * @return {Boolean}\n       */\n      isMove: function (keyCode) {\n        return list.contains([\n          keyMap.LEFT,\n          keyMap.UP,\n          keyMap.RIGHT,\n          keyMap.DOWN\n        ], keyCode);\n      },\n      /**\n       * @property {Object} nameFromCode\n       * @property {String} nameFromCode.8 \"BACKSPACE\"\n       */\n      nameFromCode: func.invertObject(keyMap),\n      code: keyMap\n    };\n  })();\n\n  var range = (function () {\n\n    /**\n     * return boundaryPoint from TextRange, inspired by Andy Na's HuskyRange.js\n     *\n     * @param {TextRange} textRange\n     * @param {Boolean} isStart\n     * @return {BoundaryPoint}\n     *\n     * @see http://msdn.microsoft.com/en-us/library/ie/ms535872(v=vs.85).aspx\n     */\n    var textRangeToPoint = function (textRange, isStart) {\n      var container = textRange.parentElement(), offset;\n  \n      var tester = document.body.createTextRange(), prevContainer;\n      var childNodes = list.from(container.childNodes);\n      for (offset = 0; offset < childNodes.length; offset++) {\n        if (dom.isText(childNodes[offset])) {\n          continue;\n        }\n        tester.moveToElementText(childNodes[offset]);\n        if (tester.compareEndPoints('StartToStart', textRange) >= 0) {\n          break;\n        }\n        prevContainer = childNodes[offset];\n      }\n  \n      if (offset !== 0 && dom.isText(childNodes[offset - 1])) {\n        var textRangeStart = document.body.createTextRange(), curTextNode = null;\n        textRangeStart.moveToElementText(prevContainer || container);\n        textRangeStart.collapse(!prevContainer);\n        curTextNode = prevContainer ? prevContainer.nextSibling : container.firstChild;\n  \n        var pointTester = textRange.duplicate();\n        pointTester.setEndPoint('StartToStart', textRangeStart);\n        var textCount = pointTester.text.replace(/[\\r\\n]/g, '').length;\n  \n        while (textCount > curTextNode.nodeValue.length && curTextNode.nextSibling) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        /* jshint ignore:start */\n        var dummy = curTextNode.nodeValue; // enforce IE to re-reference curTextNode, hack\n        /* jshint ignore:end */\n  \n        if (isStart && curTextNode.nextSibling && dom.isText(curTextNode.nextSibling) &&\n            textCount === curTextNode.nodeValue.length) {\n          textCount -= curTextNode.nodeValue.length;\n          curTextNode = curTextNode.nextSibling;\n        }\n  \n        container = curTextNode;\n        offset = textCount;\n      }\n  \n      return {\n        cont: container,\n        offset: offset\n      };\n    };\n    \n    /**\n     * return TextRange from boundary point (inspired by google closure-library)\n     * @param {BoundaryPoint} point\n     * @return {TextRange}\n     */\n    var pointToTextRange = function (point) {\n      var textRangeInfo = function (container, offset) {\n        var node, isCollapseToStart;\n  \n        if (dom.isText(container)) {\n          var prevTextNodes = dom.listPrev(container, func.not(dom.isText));\n          var prevContainer = list.last(prevTextNodes).previousSibling;\n          node =  prevContainer || container.parentNode;\n          offset += list.sum(list.tail(prevTextNodes), dom.nodeLength);\n          isCollapseToStart = !prevContainer;\n        } else {\n          node = container.childNodes[offset] || container;\n          if (dom.isText(node)) {\n            return textRangeInfo(node, 0);\n          }\n  \n          offset = 0;\n          isCollapseToStart = false;\n        }\n  \n        return {\n          node: node,\n          collapseToStart: isCollapseToStart,\n          offset: offset\n        };\n      };\n  \n      var textRange = document.body.createTextRange();\n      var info = textRangeInfo(point.node, point.offset);\n  \n      textRange.moveToElementText(info.node);\n      textRange.collapse(info.collapseToStart);\n      textRange.moveStart('character', info.offset);\n      return textRange;\n    };\n    \n    /**\n     * Wrapped Range\n     *\n     * @constructor\n     * @param {Node} sc - start container\n     * @param {Number} so - start offset\n     * @param {Node} ec - end container\n     * @param {Number} eo - end offset\n     */\n    var WrappedRange = function (sc, so, ec, eo) {\n      this.sc = sc;\n      this.so = so;\n      this.ec = ec;\n      this.eo = eo;\n  \n      // nativeRange: get nativeRange from sc, so, ec, eo\n      var nativeRange = function () {\n        if (agent.isW3CRangeSupport) {\n          var w3cRange = document.createRange();\n          w3cRange.setStart(sc, so);\n          w3cRange.setEnd(ec, eo);\n\n          return w3cRange;\n        } else {\n          var textRange = pointToTextRange({\n            node: sc,\n            offset: so\n          });\n\n          textRange.setEndPoint('EndToEnd', pointToTextRange({\n            node: ec,\n            offset: eo\n          }));\n\n          return textRange;\n        }\n      };\n\n      this.getPoints = function () {\n        return {\n          sc: sc,\n          so: so,\n          ec: ec,\n          eo: eo\n        };\n      };\n\n      this.getStartPoint = function () {\n        return {\n          node: sc,\n          offset: so\n        };\n      };\n\n      this.getEndPoint = function () {\n        return {\n          node: ec,\n          offset: eo\n        };\n      };\n\n      /**\n       * select update visible range\n       */\n      this.select = function () {\n        var nativeRng = nativeRange();\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (selection.rangeCount > 0) {\n            selection.removeAllRanges();\n          }\n          selection.addRange(nativeRng);\n        } else {\n          nativeRng.select();\n        }\n        \n        return this;\n      };\n\n      /**\n       * Moves the scrollbar to start container(sc) of current range\n       *\n       * @return {WrappedRange}\n       */\n      this.scrollIntoView = function (container) {\n        var height = $(container).height();\n        if (container.scrollTop + height < this.sc.offsetTop) {\n          container.scrollTop += Math.abs(container.scrollTop + height - this.sc.offsetTop);\n        }\n\n        return this;\n      };\n\n      /**\n       * @return {WrappedRange}\n       */\n      this.normalize = function () {\n\n        /**\n         * @param {BoundaryPoint} point\n         * @param {Boolean} isLeftToRight\n         * @return {BoundaryPoint}\n         */\n        var getVisiblePoint = function (point, isLeftToRight) {\n          if ((dom.isVisiblePoint(point) && !dom.isEdgePoint(point)) ||\n              (dom.isVisiblePoint(point) && dom.isRightEdgePoint(point) && !isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isLeftEdgePoint(point) && isLeftToRight) ||\n              (dom.isVisiblePoint(point) && dom.isBlock(point.node) && dom.isEmpty(point.node))) {\n            return point;\n          }\n\n          // point on block's edge\n          var block = dom.ancestor(point.node, dom.isBlock);\n          if (((dom.isLeftEdgePointOf(point, block) || dom.isVoid(dom.prevPoint(point).node)) && !isLeftToRight) ||\n              ((dom.isRightEdgePointOf(point, block) || dom.isVoid(dom.nextPoint(point).node)) && isLeftToRight)) {\n\n            // returns point already on visible point\n            if (dom.isVisiblePoint(point)) {\n              return point;\n            }\n            // reverse direction \n            isLeftToRight = !isLeftToRight;\n          }\n\n          var nextPoint = isLeftToRight ? dom.nextPointUntil(dom.nextPoint(point), dom.isVisiblePoint) :\n                                          dom.prevPointUntil(dom.prevPoint(point), dom.isVisiblePoint);\n          return nextPoint || point;\n        };\n\n        var endPoint = getVisiblePoint(this.getEndPoint(), false);\n        var startPoint = this.isCollapsed() ? endPoint : getVisiblePoint(this.getStartPoint(), true);\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n\n      /**\n       * returns matched nodes on range\n       *\n       * @param {Function} [pred] - predicate function\n       * @param {Object} [options]\n       * @param {Boolean} [options.includeAncestor]\n       * @param {Boolean} [options.fullyContains]\n       * @return {Node[]}\n       */\n      this.nodes = function (pred, options) {\n        pred = pred || func.ok;\n\n        var includeAncestor = options && options.includeAncestor;\n        var fullyContains = options && options.fullyContains;\n\n        // TODO compare points and sort\n        var startPoint = this.getStartPoint();\n        var endPoint = this.getEndPoint();\n\n        var nodes = [];\n        var leftEdgeNodes = [];\n\n        dom.walkPoint(startPoint, endPoint, function (point) {\n          if (dom.isEditable(point.node)) {\n            return;\n          }\n\n          var node;\n          if (fullyContains) {\n            if (dom.isLeftEdgePoint(point)) {\n              leftEdgeNodes.push(point.node);\n            }\n            if (dom.isRightEdgePoint(point) && list.contains(leftEdgeNodes, point.node)) {\n              node = point.node;\n            }\n          } else if (includeAncestor) {\n            node = dom.ancestor(point.node, pred);\n          } else {\n            node = point.node;\n          }\n\n          if (node && pred(node)) {\n            nodes.push(node);\n          }\n        }, true);\n\n        return list.unique(nodes);\n      };\n\n      /**\n       * returns commonAncestor of range\n       * @return {Element} - commonAncestor\n       */\n      this.commonAncestor = function () {\n        return dom.commonAncestor(sc, ec);\n      };\n\n      /**\n       * returns expanded range by pred\n       *\n       * @param {Function} pred - predicate function\n       * @return {WrappedRange}\n       */\n      this.expand = function (pred) {\n        var startAncestor = dom.ancestor(sc, pred);\n        var endAncestor = dom.ancestor(ec, pred);\n\n        if (!startAncestor && !endAncestor) {\n          return new WrappedRange(sc, so, ec, eo);\n        }\n\n        var boundaryPoints = this.getPoints();\n\n        if (startAncestor) {\n          boundaryPoints.sc = startAncestor;\n          boundaryPoints.so = 0;\n        }\n\n        if (endAncestor) {\n          boundaryPoints.ec = endAncestor;\n          boundaryPoints.eo = dom.nodeLength(endAncestor);\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * @param {Boolean} isCollapseToStart\n       * @return {WrappedRange}\n       */\n      this.collapse = function (isCollapseToStart) {\n        if (isCollapseToStart) {\n          return new WrappedRange(sc, so, sc, so);\n        } else {\n          return new WrappedRange(ec, eo, ec, eo);\n        }\n      };\n\n      /**\n       * splitText on range\n       */\n      this.splitText = function () {\n        var isSameContainer = sc === ec;\n        var boundaryPoints = this.getPoints();\n\n        if (dom.isText(ec) && !dom.isEdgePoint(this.getEndPoint())) {\n          ec.splitText(eo);\n        }\n\n        if (dom.isText(sc) && !dom.isEdgePoint(this.getStartPoint())) {\n          boundaryPoints.sc = sc.splitText(so);\n          boundaryPoints.so = 0;\n\n          if (isSameContainer) {\n            boundaryPoints.ec = boundaryPoints.sc;\n            boundaryPoints.eo = eo - so;\n          }\n        }\n\n        return new WrappedRange(\n          boundaryPoints.sc,\n          boundaryPoints.so,\n          boundaryPoints.ec,\n          boundaryPoints.eo\n        );\n      };\n\n      /**\n       * delete contents on range\n       * @return {WrappedRange}\n       */\n      this.deleteContents = function () {\n        if (this.isCollapsed()) {\n          return this;\n        }\n\n        var rng = this.splitText();\n        var nodes = rng.nodes(null, {\n          fullyContains: true\n        });\n\n        // find new cursor point\n        var point = dom.prevPointUntil(rng.getStartPoint(), function (point) {\n          return !list.contains(nodes, point.node);\n        });\n\n        var emptyParents = [];\n        $.each(nodes, function (idx, node) {\n          // find empty parents\n          var parent = node.parentNode;\n          if (point.node !== parent && dom.nodeLength(parent) === 1) {\n            emptyParents.push(parent);\n          }\n          dom.remove(node, false);\n        });\n\n        // remove empty parents\n        $.each(emptyParents, function (idx, node) {\n          dom.remove(node, false);\n        });\n\n        return new WrappedRange(\n          point.node,\n          point.offset,\n          point.node,\n          point.offset\n        ).normalize();\n      };\n      \n      /**\n       * makeIsOn: return isOn(pred) function\n       */\n      var makeIsOn = function (pred) {\n        return function () {\n          var ancestor = dom.ancestor(sc, pred);\n          return !!ancestor && (ancestor === dom.ancestor(ec, pred));\n        };\n      };\n  \n      // isOnEditable: judge whether range is on editable or not\n      this.isOnEditable = makeIsOn(dom.isEditable);\n      // isOnList: judge whether range is on list node or not\n      this.isOnList = makeIsOn(dom.isList);\n      // isOnAnchor: judge whether range is on anchor node or not\n      this.isOnAnchor = makeIsOn(dom.isAnchor);\n      // isOnCell: judge whether range is on cell node or not\n      this.isOnCell = makeIsOn(dom.isCell);\n      // isOnData: judge whether range is on data node or not\n      this.isOnData = makeIsOn(dom.isData);\n\n      /**\n       * @param {Function} pred\n       * @return {Boolean}\n       */\n      this.isLeftEdgeOf = function (pred) {\n        if (!dom.isLeftEdgePoint(this.getStartPoint())) {\n          return false;\n        }\n\n        var node = dom.ancestor(this.sc, pred);\n        return node && dom.isLeftEdgeOf(this.sc, node);\n      };\n\n      /**\n       * returns whether range was collapsed or not\n       */\n      this.isCollapsed = function () {\n        return sc === ec && so === eo;\n      };\n\n      /**\n       * wrap inline nodes which children of body with paragraph\n       *\n       * @return {WrappedRange}\n       */\n      this.wrapBodyInlineWithPara = function () {\n        if (dom.isBodyContainer(sc) && dom.isEmpty(sc)) {\n          sc.innerHTML = dom.emptyPara;\n          return new WrappedRange(sc.firstChild, 0, sc.firstChild, 0);\n        }\n\n        /**\n         * [workaround] firefox often create range on not visible point. so normalize here.\n         *  - firefox: |<p>text</p>|\n         *  - chrome: <p>|text|</p>\n         */\n        var rng = this.normalize();\n        if (dom.isParaInline(sc) || dom.isPara(sc)) {\n          return rng;\n        }\n\n        // find inline top ancestor\n        var topAncestor;\n        if (dom.isInline(rng.sc)) {\n          var ancestors = dom.listAncestor(rng.sc, func.not(dom.isInline));\n          topAncestor = list.last(ancestors);\n          if (!dom.isInline(topAncestor)) {\n            topAncestor = ancestors[ancestors.length - 2] || rng.sc.childNodes[rng.so];\n          }\n        } else {\n          topAncestor = rng.sc.childNodes[rng.so > 0 ? rng.so - 1 : 0];\n        }\n\n        // siblings not in paragraph\n        var inlineSiblings = dom.listPrev(topAncestor, dom.isParaInline).reverse();\n        inlineSiblings = inlineSiblings.concat(dom.listNext(topAncestor.nextSibling, dom.isParaInline));\n\n        // wrap with paragraph\n        if (inlineSiblings.length) {\n          var para = dom.wrap(list.head(inlineSiblings), 'p');\n          dom.appendChildNodes(para, list.tail(inlineSiblings));\n        }\n\n        return this.normalize();\n      };\n\n      /**\n       * insert node at current cursor\n       *\n       * @param {Node} node\n       * @return {Node}\n       */\n      this.insertNode = function (node) {\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n        var info = dom.splitPoint(rng.getStartPoint(), dom.isInline(node));\n\n        if (info.rightNode) {\n          info.rightNode.parentNode.insertBefore(node, info.rightNode);\n        } else {\n          info.container.appendChild(node);\n        }\n\n        return node;\n      };\n\n      /**\n       * insert html at current cursor\n       */\n      this.pasteHTML = function (markup) {\n        var contentsContainer = $('<div></div>').html(markup)[0];\n        var childNodes = list.from(contentsContainer.childNodes);\n\n        var rng = this.wrapBodyInlineWithPara().deleteContents();\n\n        return childNodes.reverse().map(function (childNode) {\n          return rng.insertNode(childNode);\n        }).reverse();\n      };\n  \n      /**\n       * returns text in range\n       *\n       * @return {String}\n       */\n      this.toString = function () {\n        var nativeRng = nativeRange();\n        return agent.isW3CRangeSupport ? nativeRng.toString() : nativeRng.text;\n      };\n\n      /**\n       * returns range for word before cursor\n       *\n       * @param {Boolean} [findAfter] - find after cursor, default: false\n       * @return {WrappedRange}\n       */\n      this.getWordRange = function (findAfter) {\n        var endPoint = this.getEndPoint();\n\n        if (!dom.isCharPoint(endPoint)) {\n          return this;\n        }\n\n        var startPoint = dom.prevPointUntil(endPoint, function (point) {\n          return !dom.isCharPoint(point);\n        });\n\n        if (findAfter) {\n          endPoint = dom.nextPointUntil(endPoint, function (point) {\n            return !dom.isCharPoint(point);\n          });\n        }\n\n        return new WrappedRange(\n          startPoint.node,\n          startPoint.offset,\n          endPoint.node,\n          endPoint.offset\n        );\n      };\n  \n      /**\n       * create offsetPath bookmark\n       *\n       * @param {Node} editable\n       */\n      this.bookmark = function (editable) {\n        return {\n          s: {\n            path: dom.makeOffsetPath(editable, sc),\n            offset: so\n          },\n          e: {\n            path: dom.makeOffsetPath(editable, ec),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * create offsetPath bookmark base on paragraph\n       *\n       * @param {Node[]} paras\n       */\n      this.paraBookmark = function (paras) {\n        return {\n          s: {\n            path: list.tail(dom.makeOffsetPath(list.head(paras), sc)),\n            offset: so\n          },\n          e: {\n            path: list.tail(dom.makeOffsetPath(list.last(paras), ec)),\n            offset: eo\n          }\n        };\n      };\n\n      /**\n       * getClientRects\n       * @return {Rect[]}\n       */\n      this.getClientRects = function () {\n        var nativeRng = nativeRange();\n        return nativeRng.getClientRects();\n      };\n    };\n\n  /**\n   * @class core.range\n   *\n   * Data structure\n   *  * BoundaryPoint: a point of dom tree\n   *  * BoundaryPoints: two boundaryPoints corresponding to the start and the end of the Range\n   *\n   * See to http://www.w3.org/TR/DOM-Level-2-Traversal-Range/ranges.html#Level-2-Range-Position\n   *\n   * @singleton\n   * @alternateClassName range\n   */\n    return {\n      /**\n       * create Range Object From arguments or Browser Selection\n       *\n       * @param {Node} sc - start container\n       * @param {Number} so - start offset\n       * @param {Node} ec - end container\n       * @param {Number} eo - end offset\n       * @return {WrappedRange}\n       */\n      create: function (sc, so, ec, eo) {\n        if (arguments.length === 4) {\n          return new WrappedRange(sc, so, ec, eo);\n        } else if (arguments.length === 2) { //collapsed\n          ec = sc;\n          eo = so;\n          return new WrappedRange(sc, so, ec, eo);\n        } else {\n          var wrappedRange = this.createFromSelection();\n          if (!wrappedRange && arguments.length === 1) {\n            wrappedRange = this.createFromNode(arguments[0]);\n            return wrappedRange.collapse(dom.emptyPara === arguments[0].innerHTML);\n          }\n          return wrappedRange;\n        }\n      },\n\n      createFromSelection: function () {\n        var sc, so, ec, eo;\n        if (agent.isW3CRangeSupport) {\n          var selection = document.getSelection();\n          if (!selection || selection.rangeCount === 0) {\n            return null;\n          } else if (dom.isBody(selection.anchorNode)) {\n            // Firefox: returns entire body as range on initialization.\n            // We won't never need it.\n            return null;\n          }\n\n          var nativeRng = selection.getRangeAt(0);\n          sc = nativeRng.startContainer;\n          so = nativeRng.startOffset;\n          ec = nativeRng.endContainer;\n          eo = nativeRng.endOffset;\n        } else { // IE8: TextRange\n          var textRange = document.selection.createRange();\n          var textRangeEnd = textRange.duplicate();\n          textRangeEnd.collapse(false);\n          var textRangeStart = textRange;\n          textRangeStart.collapse(true);\n\n          var startPoint = textRangeToPoint(textRangeStart, true),\n          endPoint = textRangeToPoint(textRangeEnd, false);\n\n          // same visible point case: range was collapsed.\n          if (dom.isText(startPoint.node) && dom.isLeftEdgePoint(startPoint) &&\n              dom.isTextNode(endPoint.node) && dom.isRightEdgePoint(endPoint) &&\n              endPoint.node.nextSibling === startPoint.node) {\n            startPoint = endPoint;\n          }\n\n          sc = startPoint.cont;\n          so = startPoint.offset;\n          ec = endPoint.cont;\n          eo = endPoint.offset;\n        }\n\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from node\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNode: function (node) {\n        var sc = node;\n        var so = 0;\n        var ec = node;\n        var eo = dom.nodeLength(ec);\n\n        // browsers can't target a picture or void node\n        if (dom.isVoid(sc)) {\n          so = dom.listPrev(sc).length - 1;\n          sc = sc.parentNode;\n        }\n        if (dom.isBR(ec)) {\n          eo = dom.listPrev(ec).length - 1;\n          ec = ec.parentNode;\n        } else if (dom.isVoid(ec)) {\n          eo = dom.listPrev(ec).length;\n          ec = ec.parentNode;\n        }\n\n        return this.create(sc, so, ec, eo);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeBefore: function (node) {\n        return this.createFromNode(node).collapse(true);\n      },\n\n      /**\n       * create WrappedRange from node after position\n       *\n       * @param {Node} node\n       * @return {WrappedRange}\n       */\n      createFromNodeAfter: function (node) {\n        return this.createFromNode(node).collapse();\n      },\n\n      /**\n       * @method \n       * \n       * create WrappedRange from bookmark\n       *\n       * @param {Node} editable\n       * @param {Object} bookmark\n       * @return {WrappedRange}\n       */\n      createFromBookmark: function (editable, bookmark) {\n        var sc = dom.fromOffsetPath(editable, bookmark.s.path);\n        var so = bookmark.s.offset;\n        var ec = dom.fromOffsetPath(editable, bookmark.e.path);\n        var eo = bookmark.e.offset;\n        return new WrappedRange(sc, so, ec, eo);\n      },\n\n      /**\n       * @method \n       *\n       * create WrappedRange from paraBookmark\n       *\n       * @param {Object} bookmark\n       * @param {Node[]} paras\n       * @return {WrappedRange}\n       */\n      createFromParaBookmark: function (bookmark, paras) {\n        var so = bookmark.s.offset;\n        var eo = bookmark.e.offset;\n        var sc = dom.fromOffsetPath(list.head(paras), bookmark.s.path);\n        var ec = dom.fromOffsetPath(list.last(paras), bookmark.e.path);\n\n        return new WrappedRange(sc, so, ec, eo);\n      }\n    };\n  })();\n\n  /**\n   * @class core.async\n   *\n   * Async functions which returns `Promise`\n   *\n   * @singleton\n   * @alternateClassName async\n   */\n  var async = (function () {\n    /**\n     * @method readFileAsDataURL\n     *\n     * read contents of file as representing URL\n     *\n     * @param {File} file\n     * @return {Promise} - then: dataUrl\n     */\n    var readFileAsDataURL = function (file) {\n      return $.Deferred(function (deferred) {\n        $.extend(new FileReader(), {\n          onload: function (e) {\n            var dataURL = e.target.result;\n            deferred.resolve(dataURL);\n          },\n          onerror: function () {\n            deferred.reject(this);\n          }\n        }).readAsDataURL(file);\n      }).promise();\n    };\n  \n    /**\n     * @method createImage\n     *\n     * create `<image>` from url string\n     *\n     * @param {String} url\n     * @return {Promise} - then: $image\n     */\n    var createImage = function (url) {\n      return $.Deferred(function (deferred) {\n        var $img = $('<img>');\n\n        $img.one('load', function () {\n          $img.off('error abort');\n          deferred.resolve($img);\n        }).one('error abort', function () {\n          $img.off('load').detach();\n          deferred.reject($img);\n        }).css({\n          display: 'none'\n        }).appendTo(document.body).attr('src', url);\n      }).promise();\n    };\n\n    return {\n      readFileAsDataURL: readFileAsDataURL,\n      createImage: createImage\n    };\n  })();\n\n  /**\n   * @class editing.History\n   *\n   * Editor History\n   *\n   */\n  var History = function ($editable) {\n    var stack = [], stackOffset = -1;\n    var editable = $editable[0];\n\n    var makeSnapshot = function () {\n      var rng = range.create(editable);\n      var emptyBookmark = {s: {path: [], offset: 0}, e: {path: [], offset: 0}};\n\n      return {\n        contents: $editable.html(),\n        bookmark: (rng ? rng.bookmark(editable) : emptyBookmark)\n      };\n    };\n\n    var applySnapshot = function (snapshot) {\n      if (snapshot.contents !== null) {\n        $editable.html(snapshot.contents);\n      }\n      if (snapshot.bookmark !== null) {\n        range.createFromBookmark(editable, snapshot.bookmark).select();\n      }\n    };\n\n    /**\n    * @method rewind\n    * Rewinds the history stack back to the first snapshot taken.\n    * Leaves the stack intact, so that \"Redo\" can still be used.\n    */\n    this.rewind = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      // Return to the first available snapshot.\n      stackOffset = 0;\n\n      // Apply that snapshot.\n      applySnapshot(stack[stackOffset]);\n    };\n\n    /**\n    * @method reset\n    * Resets the history stack completely; reverting to an empty editor.\n    */\n    this.reset = function () {\n      // Clear the stack.\n      stack = [];\n\n      // Restore stackOffset to its original value.\n      stackOffset = -1;\n\n      // Clear the editable area.\n      $editable.html('');\n\n      // Record our first snapshot (of nothing).\n      this.recordUndo();\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      // Create snap shot if not yet recorded\n      if ($editable.html() !== stack[stackOffset].contents) {\n        this.recordUndo();\n      }\n\n      if (0 < stackOffset) {\n        stackOffset--;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      if (stack.length - 1 > stackOffset) {\n        stackOffset++;\n        applySnapshot(stack[stackOffset]);\n      }\n    };\n\n    /**\n     * recorded undo\n     */\n    this.recordUndo = function () {\n      stackOffset++;\n\n      // Wash out stack after stackOffset\n      if (stack.length > stackOffset) {\n        stack = stack.slice(0, stackOffset);\n      }\n\n      // Create new snapshot and push it to the end\n      stack.push(makeSnapshot());\n    };\n  };\n\n  /**\n   * @class editing.Style\n   *\n   * Style\n   *\n   */\n  var Style = function () {\n    /**\n     * @method jQueryCSS\n     *\n     * [workaround] for old jQuery\n     * passing an array of style properties to .css()\n     * will result in an object of property-value pairs.\n     * (compability with version < 1.9)\n     *\n     * @private\n     * @param  {jQuery} $obj\n     * @param  {Array} propertyNames - An array of one or more CSS properties.\n     * @return {Object}\n     */\n    var jQueryCSS = function ($obj, propertyNames) {\n      if (agent.jqueryVersion < 1.9) {\n        var result = {};\n        $.each(propertyNames, function (idx, propertyName) {\n          result[propertyName] = $obj.css(propertyName);\n        });\n        return result;\n      }\n      return $obj.css.call($obj, propertyNames);\n    };\n\n    /**\n     * returns style object from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.fromNode = function ($node) {\n      var properties = ['font-family', 'font-size', 'text-align', 'list-style-type', 'line-height'];\n      var styleInfo = jQueryCSS($node, properties) || {};\n      styleInfo['font-size'] = parseInt(styleInfo['font-size'], 10);\n      return styleInfo;\n    };\n\n    /**\n     * paragraph level style\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} styleInfo\n     */\n    this.stylePara = function (rng, styleInfo) {\n      $.each(rng.nodes(dom.isPara, {\n        includeAncestor: true\n      }), function (idx, para) {\n        $(para).css(styleInfo);\n      });\n    };\n\n    /**\n     * insert and returns styleNodes on range.\n     *\n     * @param {WrappedRange} rng\n     * @param {Object} [options] - options for styleNodes\n     * @param {String} [options.nodeName] - default: `SPAN`\n     * @param {Boolean} [options.expandClosestSibling] - default: `false`\n     * @param {Boolean} [options.onlyPartialContains] - default: `false`\n     * @return {Node[]}\n     */\n    this.styleNodes = function (rng, options) {\n      rng = rng.splitText();\n\n      var nodeName = options && options.nodeName || 'SPAN';\n      var expandClosestSibling = !!(options && options.expandClosestSibling);\n      var onlyPartialContains = !!(options && options.onlyPartialContains);\n\n      if (rng.isCollapsed()) {\n        return [rng.insertNode(dom.create(nodeName))];\n      }\n\n      var pred = dom.makePredByNodeName(nodeName);\n      var nodes = rng.nodes(dom.isText, {\n        fullyContains: true\n      }).map(function (text) {\n        return dom.singleChildAncestor(text, pred) || dom.wrap(text, nodeName);\n      });\n\n      if (expandClosestSibling) {\n        if (onlyPartialContains) {\n          var nodesInRange = rng.nodes();\n          // compose with partial contains predication\n          pred = func.and(pred, function (node) {\n            return list.contains(nodesInRange, node);\n          });\n        }\n\n        return nodes.map(function (node) {\n          var siblings = dom.withClosestSiblings(node, pred);\n          var head = list.head(siblings);\n          var tails = list.tail(siblings);\n          $.each(tails, function (idx, elem) {\n            dom.appendChildNodes(head, elem.childNodes);\n            dom.remove(elem);\n          });\n          return list.head(siblings);\n        });\n      } else {\n        return nodes;\n      }\n    };\n\n    /**\n     * get current style on cursor\n     *\n     * @param {WrappedRange} rng\n     * @return {Object} - object contains style properties.\n     */\n    this.current = function (rng) {\n      var $cont = $(!dom.isElement(rng.sc) ? rng.sc.parentNode : rng.sc);\n      var styleInfo = this.fromNode($cont);\n\n      // document.queryCommandState for toggle state\n      // [workaround] prevent Firefox nsresult: \"0x80004005 (NS_ERROR_FAILURE)\"\n      try {\n        styleInfo = $.extend(styleInfo, {\n          'font-bold': document.queryCommandState('bold') ? 'bold' : 'normal',\n          'font-italic': document.queryCommandState('italic') ? 'italic' : 'normal',\n          'font-underline': document.queryCommandState('underline') ? 'underline' : 'normal',\n          'font-subscript': document.queryCommandState('subscript') ? 'subscript' : 'normal',\n          'font-superscript': document.queryCommandState('superscript') ? 'superscript' : 'normal',\n          'font-strikethrough': document.queryCommandState('strikethrough') ? 'strikethrough' : 'normal'\n        });\n      } catch (e) {}\n\n      // list-style-type to list-style(unordered, ordered)\n      if (!rng.isOnList()) {\n        styleInfo['list-style'] = 'none';\n      } else {\n        var orderedTypes = ['circle', 'disc', 'disc-leading-zero', 'square'];\n        var isUnordered = $.inArray(styleInfo['list-style-type'], orderedTypes) > -1;\n        styleInfo['list-style'] = isUnordered ? 'unordered' : 'ordered';\n      }\n\n      var para = dom.ancestor(rng.sc, dom.isPara);\n      if (para && para.style['line-height']) {\n        styleInfo['line-height'] = para.style.lineHeight;\n      } else {\n        var lineHeight = parseInt(styleInfo['line-height'], 10) / parseInt(styleInfo['font-size'], 10);\n        styleInfo['line-height'] = lineHeight.toFixed(1);\n      }\n\n      styleInfo.anchor = rng.isOnAnchor() && dom.ancestor(rng.sc, dom.isAnchor);\n      styleInfo.ancestors = dom.listAncestor(rng.sc, dom.isEditable);\n      styleInfo.range = rng;\n\n      return styleInfo;\n    };\n  };\n\n\n  /**\n   * @class editing.Bullet\n   *\n   * @alternateClassName Bullet\n   */\n  var Bullet = function () {\n    var self = this;\n\n    /**\n     * toggle ordered list\n     */\n    this.insertOrderedList = function (editable) {\n      this.toggleList('OL', editable);\n    };\n\n    /**\n     * toggle unordered list\n     */\n    this.insertUnorderedList = function (editable) {\n      this.toggleList('UL', editable);\n    };\n\n    /**\n     * indent\n     */\n    this.indent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.wrapList(paras, head.parentNode.nodeName);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              return (parseInt(val, 10) || 0) + 25;\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * outdent\n     */\n    this.outdent = function (editable) {\n      var self = this;\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        if (dom.isLi(head)) {\n          self.releaseList([paras]);\n        } else {\n          $.each(paras, function (idx, para) {\n            $(para).css('marginLeft', function (idx, val) {\n              val = (parseInt(val, 10) || 0);\n              return val > 25 ? val - 25 : '';\n            });\n          });\n        }\n      });\n\n      rng.select();\n    };\n\n    /**\n     * toggle list\n     *\n     * @param {String} listName - OL or UL\n     */\n    this.toggleList = function (listName, editable) {\n      var rng = range.create(editable).wrapBodyInlineWithPara();\n\n      var paras = rng.nodes(dom.isPara, { includeAncestor: true });\n      var bookmark = rng.paraBookmark(paras);\n      var clustereds = list.clusterBy(paras, func.peq2('parentNode'));\n\n      // paragraph to list\n      if (list.find(paras, dom.isPurePara)) {\n        var wrappedParas = [];\n        $.each(clustereds, function (idx, paras) {\n          wrappedParas = wrappedParas.concat(self.wrapList(paras, listName));\n        });\n        paras = wrappedParas;\n      // list to paragraph or change list style\n      } else {\n        var diffLists = rng.nodes(dom.isList, {\n          includeAncestor: true\n        }).filter(function (listNode) {\n          return !$.nodeName(listNode, listName);\n        });\n\n        if (diffLists.length) {\n          $.each(diffLists, function (idx, listNode) {\n            dom.replace(listNode, listName);\n          });\n        } else {\n          paras = this.releaseList(clustereds, true);\n        }\n      }\n\n      range.createFromParaBookmark(bookmark, paras).select();\n    };\n\n    /**\n     * @param {Node[]} paras\n     * @param {String} listName\n     * @return {Node[]}\n     */\n    this.wrapList = function (paras, listName) {\n      var head = list.head(paras);\n      var last = list.last(paras);\n\n      var prevList = dom.isList(head.previousSibling) && head.previousSibling;\n      var nextList = dom.isList(last.nextSibling) && last.nextSibling;\n\n      var listNode = prevList || dom.insertAfter(dom.create(listName || 'UL'), last);\n\n      // P to LI\n      paras = paras.map(function (para) {\n        return dom.isPurePara(para) ? dom.replace(para, 'LI') : para;\n      });\n\n      // append to list(<ul>, <ol>)\n      dom.appendChildNodes(listNode, paras);\n\n      if (nextList) {\n        dom.appendChildNodes(listNode, list.from(nextList.childNodes));\n        dom.remove(nextList);\n      }\n\n      return paras;\n    };\n\n    /**\n     * @method releaseList\n     *\n     * @param {Array[]} clustereds\n     * @param {Boolean} isEscapseToBody\n     * @return {Node[]}\n     */\n    this.releaseList = function (clustereds, isEscapseToBody) {\n      var releasedParas = [];\n\n      $.each(clustereds, function (idx, paras) {\n        var head = list.head(paras);\n        var last = list.last(paras);\n\n        var headList = isEscapseToBody ? dom.lastAncestor(head, dom.isList) :\n                                         head.parentNode;\n        var lastList = headList.childNodes.length > 1 ? dom.splitTree(headList, {\n          node: last.parentNode,\n          offset: dom.position(last) + 1\n        }, {\n          isSkipPaddingBlankHTML: true\n        }) : null;\n\n        var middleList = dom.splitTree(headList, {\n          node: head.parentNode,\n          offset: dom.position(head)\n        }, {\n          isSkipPaddingBlankHTML: true\n        });\n\n        paras = isEscapseToBody ? dom.listDescendant(middleList, dom.isLi) :\n                                  list.from(middleList.childNodes).filter(dom.isLi);\n\n        // LI to P\n        if (isEscapseToBody || !dom.isList(headList.parentNode)) {\n          paras = paras.map(function (para) {\n            return dom.replace(para, 'P');\n          });\n        }\n\n        $.each(list.from(paras).reverse(), function (idx, para) {\n          dom.insertAfter(para, headList);\n        });\n\n        // remove empty lists\n        var rootLists = list.compact([headList, middleList, lastList]);\n        $.each(rootLists, function (idx, rootList) {\n          var listNodes = [rootList].concat(dom.listDescendant(rootList, dom.isList));\n          $.each(listNodes.reverse(), function (idx, listNode) {\n            if (!dom.nodeLength(listNode)) {\n              dom.remove(listNode, true);\n            }\n          });\n        });\n\n        releasedParas = releasedParas.concat(paras);\n      });\n\n      return releasedParas;\n    };\n  };\n\n\n  /**\n   * @class editing.Typing\n   *\n   * Typing\n   *\n   */\n  var Typing = function () {\n\n    // a Bullet instance to toggle lists off\n    var bullet = new Bullet();\n\n    /**\n     * insert tab\n     *\n     * @param {WrappedRange} rng\n     * @param {Number} tabsize\n     */\n    this.insertTab = function (rng, tabsize) {\n      var tab = dom.createText(new Array(tabsize + 1).join(dom.NBSP_CHAR));\n      rng = rng.deleteContents();\n      rng.insertNode(tab, true);\n\n      rng = range.create(tab, tabsize);\n      rng.select();\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = function (editable) {\n      var rng = range.create(editable);\n\n      // deleteContents on range.\n      rng = rng.deleteContents();\n\n      // Wrap range if it needs to be wrapped by paragraph\n      rng = rng.wrapBodyInlineWithPara();\n\n      // finding paragraph\n      var splitRoot = dom.ancestor(rng.sc, dom.isPara);\n\n      var nextPara;\n      // on paragraph: split paragraph\n      if (splitRoot) {\n        // if it is an empty line with li\n        if (dom.isEmpty(splitRoot) && dom.isLi(splitRoot)) {\n          // toogle UL/OL and escape\n          bullet.toggleList(splitRoot.parentNode.nodeName);\n          return;\n        // if it is an empty line with para on blockquote\n        } else if (dom.isEmpty(splitRoot) && dom.isPara(splitRoot) && dom.isBlockquote(splitRoot.parentNode)) {\n          // escape blockquote\n          dom.insertAfter(splitRoot, splitRoot.parentNode);\n          nextPara = splitRoot;\n        // if new line has content (not a line break)\n        } else {\n          nextPara = dom.splitTree(splitRoot, rng.getStartPoint());\n\n          var emptyAnchors = dom.listDescendant(splitRoot, dom.isEmptyAnchor);\n          emptyAnchors = emptyAnchors.concat(dom.listDescendant(nextPara, dom.isEmptyAnchor));\n\n          $.each(emptyAnchors, function (idx, anchor) {\n            dom.remove(anchor);\n          });\n\n          // replace empty heading or pre with P tag\n          if ((dom.isHeading(nextPara) || dom.isPre(nextPara)) && dom.isEmpty(nextPara)) {\n            nextPara = dom.replace(nextPara, 'p');\n          }\n        }\n      // no paragraph: insert empty paragraph\n      } else {\n        var next = rng.sc.childNodes[rng.so];\n        nextPara = $(dom.emptyPara)[0];\n        if (next) {\n          rng.sc.insertBefore(nextPara, next);\n        } else {\n          rng.sc.appendChild(nextPara);\n        }\n      }\n\n      range.create(nextPara, 0).normalize().select().scrollIntoView(editable);\n    };\n  };\n\n  /**\n   * @class editing.Table\n   *\n   * Table\n   *\n   */\n  var Table = function () {\n    /**\n     * handle tab key\n     *\n     * @param {WrappedRange} rng\n     * @param {Boolean} isShift\n     */\n    this.tab = function (rng, isShift) {\n      var cell = dom.ancestor(rng.commonAncestor(), dom.isCell);\n      var table = dom.ancestor(cell, dom.isTable);\n      var cells = dom.listDescendant(table, dom.isCell);\n\n      var nextCell = list[isShift ? 'prev' : 'next'](cells, cell);\n      if (nextCell) {\n        range.create(nextCell, 0).select();\n      }\n    };\n\n    /**\n     * create empty table element\n     *\n     * @param {Number} rowCount\n     * @param {Number} colCount\n     * @return {Node}\n     */\n    this.createTable = function (colCount, rowCount, options) {\n      var tds = [], tdHTML;\n      for (var idxCol = 0; idxCol < colCount; idxCol++) {\n        tds.push('<td>' + dom.blank + '</td>');\n      }\n      tdHTML = tds.join('');\n\n      var trs = [], trHTML;\n      for (var idxRow = 0; idxRow < rowCount; idxRow++) {\n        trs.push('<tr>' + tdHTML + '</tr>');\n      }\n      trHTML = trs.join('');\n      var $table = $('<table>' + trHTML + '</table>');\n      if (options && options.tableClassName) {\n        $table.addClass(options.tableClassName);\n      }\n\n      return $table[0];\n    };\n  };\n\n\n  var KEY_BOGUS = 'bogus';\n\n  /**\n   * @class Editor\n   */\n  var Editor = function (context) {\n    var self = this;\n\n    var $note = context.layoutInfo.note;\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var editable = $editable[0];\n    var lastRange = null;\n\n    var style = new Style();\n    var table = new Table();\n    var typing = new Typing();\n    var bullet = new Bullet();\n    var history = new History($editable);\n\n    this.initialize = function () {\n      // bind custom events\n      $editable.on('keydown', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          context.triggerEvent('enter', event);\n        }\n        context.triggerEvent('keydown', event);\n\n        if (!event.isDefaultPrevented()) {\n          if (options.shortcuts) {\n            self.handleKeyMap(event);\n          } else {\n            self.preventDefaultEditableShortCuts(event);\n          }\n        }\n      }).on('keyup', function (event) {\n        context.triggerEvent('keyup', event);\n      }).on('focus', function (event) {\n        context.triggerEvent('focus', event);\n      }).on('blur', function (event) {\n        context.triggerEvent('blur', event);\n      }).on('mousedown', function (event) {\n        context.triggerEvent('mousedown', event);\n      }).on('mouseup', function (event) {\n        context.triggerEvent('mouseup', event);\n      }).on('scroll', function (event) {\n        context.triggerEvent('scroll', event);\n      }).on('paste', function (event) {\n        context.triggerEvent('paste', event);\n      });\n\n      // init content before set event\n      $editable.html(dom.html($note) || dom.emptyPara);\n\n      // [workaround] IE doesn't have input events for contentEditable\n      // - see: https://goo.gl/4bfIvA\n      var changeEventName = agent.isMSIE ? 'DOMCharacterDataModified DOMSubtreeModified DOMNodeInserted' : 'input';\n      $editable.on(changeEventName, func.debounce(function () {\n        context.triggerEvent('change', $editable.html());\n      }, 250));\n\n      $editor.on('focusin', function (event) {\n        context.triggerEvent('focusin', event);\n      }).on('focusout', function (event) {\n        context.triggerEvent('focusout', event);\n      });\n\n      if (!options.airMode) {\n        if (options.width) {\n          $editor.outerWidth(options.width);\n        }\n        if (options.height) {\n          $editable.outerHeight(options.height);\n        }\n        if (options.maxHeight) {\n          $editable.css('max-height', options.maxHeight);\n        }\n        if (options.minHeight) {\n          $editable.css('min-height', options.minHeight);\n        }\n      }\n\n      history.recordUndo();\n    };\n\n    this.destroy = function () {\n      $editable.off();\n    };\n\n    this.handleKeyMap = function (event) {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      var keys = [];\n\n      if (event.metaKey) { keys.push('CMD'); }\n      if (event.ctrlKey && !event.altKey) { keys.push('CTRL'); }\n      if (event.shiftKey) { keys.push('SHIFT'); }\n\n      var keyName = key.nameFromCode[event.keyCode];\n      if (keyName) {\n        keys.push(keyName);\n      }\n\n      var eventName = keyMap[keys.join('+')];\n      if (eventName) {\n        event.preventDefault();\n        context.invoke(eventName);\n      } else if (key.isEdit(event.keyCode)) {\n        this.afterCommand();\n      }\n    };\n\n    this.preventDefaultEditableShortCuts = function (event) {\n      // B(Bold, 66) / I(Italic, 73) / U(Underline, 85)\n      if ((event.ctrlKey || event.metaKey) &&\n        list.contains([66, 73, 85], event.keyCode)) {\n        event.preventDefault();\n      }\n    };\n\n    /**\n     * create range\n     * @return {WrappedRange}\n     */\n    this.createRange = function () {\n      this.focus();\n      return range.create(editable);\n    };\n\n    /**\n     * saveRange\n     *\n     * save current range\n     *\n     * @param {Boolean} [thenCollapse=false]\n     */\n    this.saveRange = function (thenCollapse) {\n      lastRange = this.createRange();\n      if (thenCollapse) {\n        lastRange.collapse().select();\n      }\n    };\n\n    /**\n     * restoreRange\n     *\n     * restore lately range\n     */\n    this.restoreRange = function () {\n      if (lastRange) {\n        lastRange.select();\n        this.focus();\n      }\n    };\n\n    this.saveTarget = function (node) {\n      $editable.data('target', node);\n    };\n\n    this.clearTarget = function () {\n      $editable.removeData('target');\n    };\n\n    this.restoreTarget = function () {\n      return $editable.data('target');\n    };\n\n    /**\n     * currentStyle\n     *\n     * current style\n     * @return {Object|Boolean} unfocus\n     */\n    this.currentStyle = function () {\n      var rng = range.create();\n      if (rng) {\n        rng = rng.normalize();\n      }\n      return rng ? style.current(rng) : style.fromNode($editable);\n    };\n\n    /**\n     * style from node\n     *\n     * @param {jQuery} $node\n     * @return {Object}\n     */\n    this.styleFromNode = function ($node) {\n      return style.fromNode($node);\n    };\n\n    /**\n     * undo\n     */\n    this.undo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.undo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.undo', lang.help.undo);\n\n    /**\n     * redo\n     */\n    this.redo = function () {\n      context.triggerEvent('before.command', $editable.html());\n      history.redo();\n      context.triggerEvent('change', $editable.html());\n    };\n    context.memo('help.redo', lang.help.redo);\n\n    /**\n     * before command\n     */\n    var beforeCommand = this.beforeCommand = function () {\n      context.triggerEvent('before.command', $editable.html());\n      // keep focus on editable before command execution\n      self.focus();\n    };\n\n    /**\n     * after command\n     * @param {Boolean} isPreventTrigger\n     */\n    var afterCommand = this.afterCommand = function (isPreventTrigger) {\n      history.recordUndo();\n      if (!isPreventTrigger) {\n        context.triggerEvent('change', $editable.html());\n      }\n    };\n\n    /* jshint ignore:start */\n    // native commands(with execCommand), generate function for execCommand\n    var commands = ['bold', 'italic', 'underline', 'strikethrough', 'superscript', 'subscript',\n                    'justifyLeft', 'justifyCenter', 'justifyRight', 'justifyFull',\n                    'formatBlock', 'removeFormat',\n                    'backColor', 'foreColor', 'fontName'];\n\n    for (var idx = 0, len = commands.length; idx < len; idx ++) {\n      this[commands[idx]] = (function (sCmd) {\n        return function (value) {\n          beforeCommand();\n          document.execCommand(sCmd, false, value);\n          afterCommand(true);\n        };\n      })(commands[idx]);\n      context.memo('help.' + commands[idx], lang.help[commands[idx]]);\n    }\n    /* jshint ignore:end */\n\n    /**\n     * handle tab key\n     */\n    this.tab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng);\n      } else {\n        beforeCommand();\n        typing.insertTab(rng, options.tabSize);\n        afterCommand();\n      }\n    };\n    context.memo('help.tab', lang.help.tab);\n\n    /**\n     * handle shift+tab key\n     */\n    this.untab = function () {\n      var rng = this.createRange();\n      if (rng.isCollapsed() && rng.isOnCell()) {\n        table.tab(rng, true);\n      }\n    };\n    context.memo('help.untab', lang.help.untab);\n\n    /**\n     * run given function between beforeCommand and afterCommand\n     */\n    this.wrapCommand = function (fn) {\n      return function () {\n        beforeCommand();\n        fn.apply(self, arguments);\n        afterCommand();\n      };\n    };\n\n    /**\n     * insert paragraph\n     */\n    this.insertParagraph = this.wrapCommand(function () {\n      typing.insertParagraph(editable);\n    });\n    context.memo('help.insertParagraph', lang.help.insertParagraph);\n\n    this.insertOrderedList = this.wrapCommand(function () {\n      bullet.insertOrderedList(editable);\n    });\n    context.memo('help.insertOrderedList', lang.help.insertOrderedList);\n\n    this.insertUnorderedList = this.wrapCommand(function () {\n      bullet.insertUnorderedList(editable);\n    });\n    context.memo('help.insertUnorderedList', lang.help.insertUnorderedList);\n\n    this.indent = this.wrapCommand(function () {\n      bullet.indent(editable);\n    });\n    context.memo('help.indent', lang.help.indent);\n\n    this.outdent = this.wrapCommand(function () {\n      bullet.outdent(editable);\n    });\n    context.memo('help.outdent', lang.help.outdent);\n\n    /**\n     * insert image\n     *\n     * @param {String} src\n     * @param {String|Function} param\n     * @return {Promise}\n     */\n    this.insertImage = function (src, param) {\n      return async.createImage(src, param).then(function ($image) {\n        beforeCommand();\n\n        if (typeof param === 'function') {\n          param($image);\n        } else {\n          if (typeof param === 'string') {\n            $image.attr('data-filename', param);\n          }\n          $image.css('width', Math.min($editable.width(), $image.width()));\n        }\n\n        $image.show();\n        range.create(editable).insertNode($image[0]);\n        range.createFromNodeAfter($image[0]).select();\n        afterCommand();\n      }).fail(function (e) {\n        context.triggerEvent('image.upload.error', e);\n      });\n    };\n\n    /**\n     * insertImages\n     * @param {File[]} files\n     */\n    this.insertImages = function (files) {\n      $.each(files, function (idx, file) {\n        var filename = file.name;\n        if (options.maximumImageFileSize && options.maximumImageFileSize < file.size) {\n          context.triggerEvent('image.upload.error', lang.image.maximumFileSizeError);\n        } else {\n          async.readFileAsDataURL(file).then(function (dataURL) {\n            return self.insertImage(dataURL, filename);\n          }).fail(function () {\n            context.triggerEvent('image.upload.error');\n          });\n        }\n      });\n    };\n\n    /**\n     * insertImagesOrCallback\n     * @param {File[]} files\n     */\n    this.insertImagesOrCallback = function (files) {\n      var callbacks = options.callbacks;\n\n      // If onImageUpload options setted\n      if (callbacks.onImageUpload) {\n        context.triggerEvent('image.upload', files);\n      // else insert Image as dataURL\n      } else {\n        this.insertImages(files);\n      }\n    };\n\n    /**\n     * insertNode\n     * insert node\n     * @param {Node} node\n     */\n    this.insertNode = this.wrapCommand(function (node) {\n      var rng = this.createRange();\n      rng.insertNode(node);\n      range.createFromNodeAfter(node).select();\n    });\n\n    /**\n     * insert text\n     * @param {String} text\n     */\n    this.insertText = this.wrapCommand(function (text) {\n      var rng = this.createRange();\n      var textNode = rng.insertNode(dom.createText(text));\n      range.create(textNode, dom.nodeLength(textNode)).select();\n    });\n\n    /**\n     * return selected plain text\n     * @return {String} text\n     */\n    this.getSelectedText = function () {\n      var rng = this.createRange();\n\n      // if range on anchor, expand range with anchor\n      if (rng.isOnAnchor()) {\n        rng = range.createFromNode(dom.ancestor(rng.sc, dom.isAnchor));\n      }\n\n      return rng.toString();\n    };\n\n    /**\n     * paste HTML\n     * @param {String} markup\n     */\n    this.pasteHTML = this.wrapCommand(function (markup) {\n      var contents = this.createRange().pasteHTML(markup);\n      range.createFromNodeAfter(list.last(contents)).select();\n    });\n\n    /**\n     * formatBlock\n     *\n     * @param {String} tagName\n     */\n    this.formatBlock = this.wrapCommand(function (tagName) {\n      // [workaround] for MSIE, IE need `<`\n      tagName = agent.isMSIE ? '<' + tagName + '>' : tagName;\n      document.execCommand('FormatBlock', false, tagName);\n    });\n\n    this.formatPara = function () {\n      this.formatBlock('P');\n    };\n    context.memo('help.formatPara', lang.help.formatPara);\n\n    /* jshint ignore:start */\n    for (var idx = 1; idx <= 6; idx ++) {\n      this['formatH' + idx] = function (idx) {\n        return function () {\n          this.formatBlock('H' + idx);\n        };\n      }(idx);\n      context.memo('help.formatH'+idx, lang.help['formatH' + idx]);\n    };\n    /* jshint ignore:end */\n\n    /**\n     * fontSize\n     *\n     * @param {String} value - px\n     */\n    this.fontSize = function (value) {\n      var rng = this.createRange();\n\n      if (rng && rng.isCollapsed()) {\n        var spans = style.styleNodes(rng);\n        var firstSpan = list.head(spans);\n\n        $(spans).css({\n          'font-size': value + 'px'\n        });\n\n        // [workaround] added styled bogus span for style\n        //  - also bogus character needed for cursor position\n        if (firstSpan && !dom.nodeLength(firstSpan)) {\n          firstSpan.innerHTML = dom.ZERO_WIDTH_NBSP_CHAR;\n          range.createFromNodeAfter(firstSpan.firstChild).select();\n          $editable.data(KEY_BOGUS, firstSpan);\n        }\n      } else {\n        beforeCommand();\n        $(style.styleNodes(rng)).css({\n          'font-size': value + 'px'\n        });\n        afterCommand();\n      }\n    };\n\n    /**\n     * insert horizontal rule\n     */\n    this.insertHorizontalRule = this.wrapCommand(function () {\n      var hrNode = this.createRange().insertNode(dom.create('HR'));\n      if (hrNode.nextSibling) {\n        range.create(hrNode.nextSibling, 0).normalize().select();\n      }\n    });\n    context.memo('help.insertHorizontalRule', lang.help.insertHorizontalRule);\n\n    /**\n     * remove bogus node and character\n     */\n    this.removeBogus = function () {\n      var bogusNode = $editable.data(KEY_BOGUS);\n      if (!bogusNode) {\n        return;\n      }\n\n      var textNode = list.find(list.from(bogusNode.childNodes), dom.isText);\n\n      var bogusCharIdx = textNode.nodeValue.indexOf(dom.ZERO_WIDTH_NBSP_CHAR);\n      if (bogusCharIdx !== -1) {\n        textNode.deleteData(bogusCharIdx, 1);\n      }\n\n      if (dom.isEmpty(bogusNode)) {\n        dom.remove(bogusNode);\n      }\n\n      $editable.removeData(KEY_BOGUS);\n    };\n\n    /**\n     * lineHeight\n     * @param {String} value\n     */\n    this.lineHeight = this.wrapCommand(function (value) {\n      style.stylePara(this.createRange(), {\n        lineHeight: value\n      });\n    });\n\n    /**\n     * unlink\n     *\n     * @type command\n     */\n    this.unlink = function () {\n      var rng = this.createRange();\n      if (rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        rng = range.createFromNode(anchor);\n        rng.select();\n\n        beforeCommand();\n        document.execCommand('unlink');\n        afterCommand();\n      }\n    };\n\n    /**\n     * create link (command)\n     *\n     * @param {Object} linkInfo\n     */\n    this.createLink = this.wrapCommand(function (linkInfo) {\n      var linkUrl = linkInfo.url;\n      var linkText = linkInfo.text;\n      var isNewWindow = linkInfo.isNewWindow;\n      var rng = linkInfo.range || this.createRange();\n      var isTextChanged = rng.toString() !== linkText;\n\n      // handle spaced urls from input\n      if (typeof linkUrl === 'string') {\n        linkUrl = linkUrl.trim();\n      }\n\n      if (options.onCreateLink) {\n        linkUrl = options.onCreateLink(linkUrl);\n      }\n\n      var anchors = [];\n      if (isTextChanged) {\n        rng = rng.deleteContents();\n        var anchor = rng.insertNode($('<A>' + linkText + '</A>')[0]);\n        anchors.push(anchor);\n      } else {\n        anchors = style.styleNodes(rng, {\n          nodeName: 'A',\n          expandClosestSibling: true,\n          onlyPartialContains: true\n        });\n      }\n\n      $.each(anchors, function (idx, anchor) {\n        // if url doesn't match an URL schema, set http:// as default\n        linkUrl = /^[A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?/.test(linkUrl) ?\n          linkUrl : 'http://' + linkUrl;\n\n        $(anchor).attr('href', linkUrl);\n        if (isNewWindow) {\n          $(anchor).attr('target', '_blank');\n        } else {\n          $(anchor).removeAttr('target');\n        }\n      });\n\n      var startRange = range.createFromNodeBefore(list.head(anchors));\n      var startPoint = startRange.getStartPoint();\n      var endRange = range.createFromNodeAfter(list.last(anchors));\n      var endPoint = endRange.getEndPoint();\n\n      range.create(\n        startPoint.node,\n        startPoint.offset,\n        endPoint.node,\n        endPoint.offset\n      ).select();\n    });\n\n    /**\n     * returns link info\n     *\n     * @return {Object}\n     * @return {WrappedRange} return.range\n     * @return {String} return.text\n     * @return {Boolean} [return.isNewWindow=true]\n     * @return {String} [return.url=\"\"]\n     */\n    this.getLinkInfo = function () {\n      var rng = this.createRange().expand(dom.isAnchor);\n\n      // Get the first anchor on range(for edit).\n      var $anchor = $(list.head(rng.nodes(dom.isAnchor)));\n\n      return {\n        range: rng,\n        text: rng.toString(),\n        isNewWindow: $anchor.length ? $anchor.attr('target') === '_blank' : false,\n        url: $anchor.length ? $anchor.attr('href') : ''\n      };\n    };\n\n    /**\n     * setting color\n     *\n     * @param {Object} sObjColor  color code\n     * @param {String} sObjColor.foreColor foreground color\n     * @param {String} sObjColor.backColor background color\n     */\n    this.color = this.wrapCommand(function (colorInfo) {\n      var foreColor = colorInfo.foreColor;\n      var backColor = colorInfo.backColor;\n\n      if (foreColor) { document.execCommand('foreColor', false, foreColor); }\n      if (backColor) { document.execCommand('backColor', false, backColor); }\n    });\n\n    /**\n     * insert Table\n     *\n     * @param {String} dimension of table (ex : \"5x5\")\n     */\n    this.insertTable = this.wrapCommand(function (dim) {\n      var dimension = dim.split('x');\n\n      var rng = this.createRange().deleteContents();\n      rng.insertNode(table.createTable(dimension[0], dimension[1], options));\n    });\n\n    /**\n     * float me\n     *\n     * @param {String} value\n     */\n    this.floatMe = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css('float', value);\n    });\n\n    /**\n     * resize overlay element\n     * @param {String} value\n     */\n    this.resize = this.wrapCommand(function (value) {\n      var $target = $(this.restoreTarget());\n      $target.css({\n        width: value * 100 + '%',\n        height: ''\n      });\n    });\n\n    /**\n     * @param {Position} pos\n     * @param {jQuery} $target - target element\n     * @param {Boolean} [bKeepRatio] - keep ratio\n     */\n    this.resizeTo = function (pos, $target, bKeepRatio) {\n      var imageSize;\n      if (bKeepRatio) {\n        var newRatio = pos.y / pos.x;\n        var ratio = $target.data('ratio');\n        imageSize = {\n          width: ratio > newRatio ? pos.x : pos.y / ratio,\n          height: ratio > newRatio ? pos.x * ratio : pos.y\n        };\n      } else {\n        imageSize = {\n          width: pos.x,\n          height: pos.y\n        };\n      }\n\n      $target.css(imageSize);\n    };\n\n    /**\n     * remove media object\n     */\n    this.removeMedia = this.wrapCommand(function () {\n      var $target = $(this.restoreTarget()).detach();\n      context.triggerEvent('media.delete', $target, $editable);\n    });\n\n    /**\n     * returns whether editable area has focus or not.\n     */\n    this.hasFocus = function () {\n      return $editable.is(':focus');\n    };\n\n    /**\n     * set focus\n     */\n    this.focus = function () {\n      // [workaround] Screen will move when page is scolled in IE.\n      //  - do focus when not focused\n      if (!this.hasFocus()) {\n        $editable.focus();\n      }\n    };\n\n    /**\n     * returns whether contents is empty or not.\n     * @return {Boolean}\n     */\n    this.isEmpty = function () {\n      return dom.isEmpty($editable[0]) || dom.emptyPara === $editable.html();\n    };\n\n    /**\n     * Removes all contents and restores the editable instance to an _emptyPara_.\n     */\n    this.empty = function () {\n      context.invoke('code', dom.emptyPara);\n    };\n  };\n\n  var Clipboard = function (context) {\n    var self = this;\n\n    var $editable = context.layoutInfo.editable;\n\n    this.events = {\n      'summernote.keydown': function (we, e) {\n        if (self.needKeydownHook()) {\n          if ((e.ctrlKey || e.metaKey) && e.keyCode === key.code.V) {\n            context.invoke('editor.saveRange');\n            self.$paste.focus();\n\n            setTimeout(function () {\n              self.pasteByHook();\n            }, 0);\n          }\n        }\n      }\n    };\n\n    this.needKeydownHook = function () {\n      return (agent.isMSIE && agent.browserVersion > 10) || agent.isFF;\n    };\n\n    this.initialize = function () {\n      // [workaround] getting image from clipboard\n      //  - IE11 and Firefox: CTRL+v hook\n      //  - Webkit: event.clipboardData\n      if (this.needKeydownHook()) {\n        this.$paste = $('<div tabindex=\"-1\" />').attr('contenteditable', true).css({\n          position: 'absolute',\n          left: -100000,\n          opacity: 0\n        });\n        $editable.before(this.$paste);\n\n        this.$paste.on('paste', function (event) {\n          context.triggerEvent('paste', event);\n        });\n      } else {\n        $editable.on('paste', this.pasteByEvent);\n      }\n    };\n\n    this.destroy = function () {\n      if (this.needKeydownHook()) {\n        this.$paste.remove();\n        this.$paste = null;\n      }\n    };\n\n    this.pasteByHook = function () {\n      var node = this.$paste[0].firstChild;\n\n      if (dom.isImg(node)) {\n        var dataURI = node.src;\n        var decodedData = atob(dataURI.split(',')[1]);\n        var array = new Uint8Array(decodedData.length);\n        for (var i = 0; i < decodedData.length; i++) {\n          array[i] = decodedData.charCodeAt(i);\n        }\n\n        var blob = new Blob([array], { type: 'image/png' });\n        blob.name = 'clipboard.png';\n\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n        context.invoke('editor.insertImagesOrCallback', [blob]);\n      } else {\n        var pasteContent = $('<div />').html(this.$paste.html()).html();\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.focus');\n\n        if (pasteContent) {\n          context.invoke('editor.pasteHTML', pasteContent);\n        }\n      }\n\n      this.$paste.empty();\n    };\n\n    /**\n     * paste by clipboard event\n     *\n     * @param {Event} event\n     */\n    this.pasteByEvent = function (event) {\n      var clipboardData = event.originalEvent.clipboardData;\n      if (clipboardData && clipboardData.items && clipboardData.items.length) {\n        var item = list.head(clipboardData.items);\n        if (item.kind === 'file' && item.type.indexOf('image/') !== -1) {\n          context.invoke('editor.insertImagesOrCallback', [item.getAsFile()]);\n        }\n        context.invoke('editor.afterCommand');\n      }\n    };\n  };\n\n  var Dropzone = function (context) {\n    var $document = $(document);\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n    var lang = options.langInfo;\n    var documentEventHandlers = {};\n\n    var $dropzone = $([\n      '<div class=\"note-dropzone\">',\n      '  <div class=\"note-dropzone-message\"/>',\n      '</div>'\n    ].join('')).prependTo($editor);\n\n    var detachDocumentEvent = function () {\n      Object.keys(documentEventHandlers).forEach(function (key) {\n        $document.off(key.substr(2).toLowerCase(), documentEventHandlers[key]);\n      });\n      documentEventHandlers = {};\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.initialize = function () {\n      if (options.disableDragAndDrop) {\n        // prevent default drop event\n        documentEventHandlers.onDrop = function (e) {\n          e.preventDefault();\n        };\n        $document.on('drop', documentEventHandlers.onDrop);\n      } else {\n        this.attachDragAndDropEvent();\n      }\n    };\n\n    /**\n     * attach Drag and Drop Events\n     */\n    this.attachDragAndDropEvent = function () {\n      var collection = $(),\n          $dropzoneMessage = $dropzone.find('.note-dropzone-message');\n\n      documentEventHandlers.onDragenter = function (e) {\n        var isCodeview = context.invoke('codeview.isActivated');\n        var hasEditorSize = $editor.width() > 0 && $editor.height() > 0;\n        if (!isCodeview && !collection.length && hasEditorSize) {\n          $editor.addClass('dragover');\n          $dropzone.width($editor.width());\n          $dropzone.height($editor.height());\n          $dropzoneMessage.text(lang.image.dragImageHere);\n        }\n        collection = collection.add(e.target);\n      };\n\n      documentEventHandlers.onDragleave = function (e) {\n        collection = collection.not(e.target);\n        if (!collection.length) {\n          $editor.removeClass('dragover');\n        }\n      };\n\n      documentEventHandlers.onDrop = function () {\n        collection = $();\n        $editor.removeClass('dragover');\n      };\n\n      // show dropzone on dragenter when dragging a object to document\n      // -but only if the editor is visible, i.e. has a positive width and height\n      $document.on('dragenter', documentEventHandlers.onDragenter)\n        .on('dragleave', documentEventHandlers.onDragleave)\n        .on('drop', documentEventHandlers.onDrop);\n\n      // change dropzone's message on hover.\n      $dropzone.on('dragenter', function () {\n        $dropzone.addClass('hover');\n        $dropzoneMessage.text(lang.image.dropImage);\n      }).on('dragleave', function () {\n        $dropzone.removeClass('hover');\n        $dropzoneMessage.text(lang.image.dragImageHere);\n      });\n\n      // attach dropImage\n      $dropzone.on('drop', function (event) {\n        var dataTransfer = event.originalEvent.dataTransfer;\n\n        if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {\n          event.preventDefault();\n          $editable.focus();\n          context.invoke('editor.insertImagesOrCallback', dataTransfer.files);\n        } else {\n          $.each(dataTransfer.types, function (idx, type) {\n            var content = dataTransfer.getData(type);\n\n            if (type.toLowerCase().indexOf('text') > -1) {\n              context.invoke('editor.pasteHTML', content);\n            } else {\n              $(content).each(function () {\n                context.invoke('editor.insertNode', this);\n              });\n            }\n          });\n        }\n      }).on('dragover', false); // prevent default dragover event\n    };\n\n    this.destroy = function () {\n      detachDocumentEvent();\n    };\n  };\n\n\n  var CodeMirror;\n  if (agent.hasCodeMirror) {\n    if (agent.isSupportAmd) {\n      require(['codemirror'], function (cm) {\n        CodeMirror = cm;\n      });\n    } else {\n      CodeMirror = window.CodeMirror;\n    }\n  }\n\n  /**\n   * @class Codeview\n   */\n  var Codeview = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n    var options = context.options;\n\n    this.sync = function () {\n      var isCodeview = this.isActivated();\n      if (isCodeview && agent.hasCodeMirror) {\n        $codable.data('cmEditor').save();\n      }\n    };\n\n    /**\n     * @return {Boolean}\n     */\n    this.isActivated = function () {\n      return $editor.hasClass('codeview');\n    };\n\n    /**\n     * toggle codeview\n     */\n    this.toggle = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n      context.triggerEvent('codeview.toggled');\n    };\n\n    /**\n     * activate code view\n     */\n    this.activate = function () {\n      $codable.val(dom.html($editable, options.prettifyHtml));\n      $codable.height($editable.height());\n\n      context.invoke('toolbar.updateCodeview', true);\n      $editor.addClass('codeview');\n      $codable.focus();\n\n      // activate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = CodeMirror.fromTextArea($codable[0], options.codemirror);\n\n        // CodeMirror TernServer\n        if (options.codemirror.tern) {\n          var server = new CodeMirror.TernServer(options.codemirror.tern);\n          cmEditor.ternServer = server;\n          cmEditor.on('cursorActivity', function (cm) {\n            server.updateArgHints(cm);\n          });\n        }\n\n        // CodeMirror hasn't Padding.\n        cmEditor.setSize(null, $editable.outerHeight());\n        $codable.data('cmEditor', cmEditor);\n      }\n    };\n\n    /**\n     * deactivate code view\n     */\n    this.deactivate = function () {\n      // deactivate CodeMirror as codable\n      if (agent.hasCodeMirror) {\n        var cmEditor = $codable.data('cmEditor');\n        $codable.val(cmEditor.getValue());\n        cmEditor.toTextArea();\n      }\n\n      var value = dom.value($codable, options.prettifyHtml) || dom.emptyPara;\n      var isChange = $editable.html() !== value;\n\n      $editable.html(value);\n      $editable.height(options.height ? $codable.height() : 'auto');\n      $editor.removeClass('codeview');\n\n      if (isChange) {\n        context.triggerEvent('change', $editable.html(), $editable);\n      }\n\n      $editable.focus();\n\n      context.invoke('toolbar.updateCodeview', false);\n    };\n\n    this.destroy = function () {\n      if (this.isActivated()) {\n        this.deactivate();\n      }\n    };\n  };\n\n  var EDITABLE_PADDING = 24;\n\n  var Statusbar = function (context) {\n    var $document = $(document);\n    var $statusbar = context.layoutInfo.statusbar;\n    var $editable = context.layoutInfo.editable;\n    var options = context.options;\n\n    this.initialize = function () {\n      if (options.airMode || options.disableResizeEditor) {\n        return;\n      }\n\n      $statusbar.on('mousedown', function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n\n        var editableTop = $editable.offset().top - $document.scrollTop();\n\n        $document.on('mousemove', function (event) {\n          var height = event.clientY - (editableTop + EDITABLE_PADDING);\n\n          height = (options.minheight > 0) ? Math.max(height, options.minheight) : height;\n          height = (options.maxHeight > 0) ? Math.min(height, options.maxHeight) : height;\n\n          $editable.height(height);\n        }).one('mouseup', function () {\n          $document.off('mousemove');\n        });\n      });\n    };\n\n    this.destroy = function () {\n      $statusbar.off();\n      $statusbar.remove();\n    };\n  };\n\n  var Fullscreen = function (context) {\n    var $editor = context.layoutInfo.editor;\n    var $toolbar = context.layoutInfo.toolbar;\n    var $editable = context.layoutInfo.editable;\n    var $codable = context.layoutInfo.codable;\n\n    var $window = $(window);\n    var $scrollbar = $('html, body');\n\n    /**\n     * toggle fullscreen\n     */\n    this.toggle = function () {\n      var resize = function (size) {\n        $editable.css('height', size.h);\n        $codable.css('height', size.h);\n        if ($codable.data('cmeditor')) {\n          $codable.data('cmeditor').setsize(null, size.h);\n        }\n      };\n\n      $editor.toggleClass('fullscreen');\n      if (this.isFullscreen()) {\n        $editable.data('orgHeight', $editable.css('height'));\n\n        $window.on('resize', function () {\n          resize({\n            h: $window.height() - $toolbar.outerHeight()\n          });\n        }).trigger('resize');\n\n        $scrollbar.css('overflow', 'hidden');\n      } else {\n        $window.off('resize');\n        resize({\n          h: $editable.data('orgHeight')\n        });\n        $scrollbar.css('overflow', 'visible');\n      }\n\n      context.invoke('toolbar.updateFullscreen', this.isFullscreen());\n    };\n\n    this.isFullscreen = function () {\n      return $editor.hasClass('fullscreen');\n    };\n  };\n\n  var Handle = function (context) {\n    var self = this;\n\n    var $document = $(document);\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.mousedown': function (we, e) {\n        if (self.update(e.target)) {\n          e.preventDefault();\n        }\n      },\n      'summernote.keyup summernote.scroll summernote.change summernote.dialog.shown': function () {\n        self.update();\n      }\n    };\n\n    this.initialize = function () {\n      this.$handle = $([\n        '<div class=\"note-handle\">',\n        '<div class=\"note-control-selection\">',\n        '<div class=\"note-control-selection-bg\"></div>',\n        '<div class=\"note-control-holder note-control-nw\"></div>',\n        '<div class=\"note-control-holder note-control-ne\"></div>',\n        '<div class=\"note-control-holder note-control-sw\"></div>',\n        '<div class=\"',\n        (options.disableResizeImage ? 'note-control-holder' : 'note-control-sizing'),\n        ' note-control-se\"></div>',\n        (options.disableResizeImage ? '' : '<div class=\"note-control-selection-info\"></div>'),\n        '</div>',\n        '</div>'\n      ].join('')).prependTo($editingArea);\n\n      this.$handle.on('mousedown', function (event) {\n        if (dom.isControlSizing(event.target)) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          var $target = self.$handle.find('.note-control-selection').data('target'),\n              posStart = $target.offset(),\n              scrollTop = $document.scrollTop();\n\n          $document.on('mousemove', function (event) {\n            context.invoke('editor.resizeTo', {\n              x: event.clientX - posStart.left,\n              y: event.clientY - (posStart.top - scrollTop)\n            }, $target, !event.shiftKey);\n\n            self.update($target[0]);\n          }).one('mouseup', function (e) {\n            e.preventDefault();\n            $document.off('mousemove');\n            context.invoke('editor.afterCommand');\n          });\n\n          if (!$target.data('ratio')) { // original ratio.\n            $target.data('ratio', $target.height() / $target.width());\n          }\n        }\n      });\n    };\n\n    this.destroy = function () {\n      this.$handle.remove();\n    };\n\n    this.update = function (target) {\n      var isImage = dom.isImg(target);\n      var $selection = this.$handle.find('.note-control-selection');\n\n      context.invoke('imagePopover.update', target);\n\n      if (isImage) {\n        var $image = $(target);\n        var pos = $image.position();\n\n        // include margin\n        var imageSize = {\n          w: $image.outerWidth(true),\n          h: $image.outerHeight(true)\n        };\n\n        $selection.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top,\n          width: imageSize.w,\n          height: imageSize.h\n        }).data('target', $image); // save current image element.\n\n        var sizingText = imageSize.w + 'x' + imageSize.h;\n        $selection.find('.note-control-selection-info').text(sizingText);\n        context.invoke('editor.saveTarget', target);\n      } else {\n        this.hide();\n      }\n\n      return isImage;\n    };\n\n    /**\n     * hide\n     *\n     * @param {jQuery} $handle\n     */\n    this.hide = function () {\n      context.invoke('editor.clearTarget');\n      this.$handle.children().hide();\n    };\n  };\n\n  var AutoLink = function (context) {\n    var self = this;\n    var defaultScheme = 'http://';\n    var linkPattern = /^([A-Za-z][A-Za-z0-9+-.]*\\:[\\/\\/]?|mailto:[A-Z0-9._%+-]+@)?(www\\.)?(.+)$/i;\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      }\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n    };\n\n    this.destroy = function () {\n      this.lastWordRange = null;\n    };\n\n    this.replace = function () {\n      if (!this.lastWordRange) {\n        return;\n      }\n\n      var keyword = this.lastWordRange.toString();\n      var match = keyword.match(linkPattern);\n\n      if (match && (match[1] || match[2])) {\n        var link = match[1] ? keyword : defaultScheme + keyword;\n        var node = $('<a />').html(keyword).attr('href', link)[0];\n\n        this.lastWordRange.insertNode(node);\n        this.lastWordRange = null;\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.handleKeydown = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        this.lastWordRange = wordRange;\n      }\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.SPACE], e.keyCode)) {\n        this.replace();\n      }\n    };\n  };\n\n  /**\n   * textarea auto sync.\n   */\n  var AutoSync = function (context) {\n    var $note = context.layoutInfo.note;\n\n    this.events = {\n      'summernote.change': function () {\n        $note.val(context.invoke('code'));\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return dom.isTextarea($note[0]);\n    };\n  };\n\n  var Placeholder = function (context) {\n    var self = this;\n    var $editingArea = context.layoutInfo.editingArea;\n    var options = context.options;\n\n    this.events = {\n      'summernote.init summernote.change': function () {\n        self.update();\n      },\n      'summernote.codeview.toggled': function () {\n        self.update();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !!options.placeholder;\n    };\n\n    this.initialize = function () {\n      this.$placeholder = $('<div class=\"note-placeholder\">');\n      this.$placeholder.on('click', function () {\n        context.invoke('focus');\n      }).text(options.placeholder).prependTo($editingArea);\n    };\n\n    this.destroy = function () {\n      this.$placeholder.remove();\n    };\n\n    this.update = function () {\n      var isShow = !context.invoke('codeview.isActivated') && context.invoke('editor.isEmpty');\n      this.$placeholder.toggle(isShow);\n    };\n  };\n\n  var Buttons = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    var invertedKeyMap = func.invertObject(options.keyMap[agent.isMac ? 'mac' : 'pc']);\n\n    var representShortcut = this.representShortcut = function (editorMethod) {\n      var shortcut = invertedKeyMap[editorMethod];\n      if (!options.shortcuts || !shortcut) {\n        return '';\n      }\n      \n      if (agent.isMac) {\n        shortcut = shortcut.replace('CMD', '').replace('SHIFT', '');\n      }\n\n      shortcut = shortcut.replace('BACKSLASH', '\\\\')\n                         .replace('SLASH', '/')\n                         .replace('LEFTBRACKET', '[')\n                         .replace('RIGHTBRACKET', ']');\n\n      return ' (' + shortcut + ')';\n    };\n\n    this.initialize = function () {\n      this.addToolbarButtons();\n      this.addImagePopoverButtons();\n      this.addLinkPopoverButtons();\n      this.fontInstalledMap = {};\n    };\n\n    this.destroy = function () {\n      delete this.fontInstalledMap;\n    };\n\n    this.isFontInstalled = function (name) {\n      if (!self.fontInstalledMap.hasOwnProperty(name)) {\n        self.fontInstalledMap[name] = agent.isFontInstalled(name) ||\n          list.contains(options.fontNamesIgnoreCheck, name);\n      }\n\n      return self.fontInstalledMap[name];\n    };\n\n    this.addToolbarButtons = function () {\n      context.memo('button.style', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.magic) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.style.style,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'dropdown-style',\n            items: context.options.styleTags,\n            template: function (item) {\n\n              if (typeof item === 'string') {\n                item = { tag: item, title: (lang.style.hasOwnProperty(item) ? lang.style[item] : item) };\n              }\n\n              var tag = item.tag;\n              var title = item.title;\n              var style = item.style ? ' style=\"' + item.style + '\" ' : '';\n              var className = item.className ? ' class=\"' + item.className + '\"' : '';\n\n              return '<' + tag + style + className + '>' + title + '</' + tag +  '>';\n            },\n            click: context.createInvokeHandler('editor.formatBlock')\n          })\n        ]).render();\n      });\n\n      context.memo('button.bold', function () {\n        return ui.button({\n          className: 'note-btn-bold',\n          contents: ui.icon(options.icons.bold),\n          tooltip: lang.font.bold + representShortcut('bold'),\n          click: context.createInvokeHandler('editor.bold')\n        }).render();\n      });\n\n      context.memo('button.italic', function () {\n        return ui.button({\n          className: 'note-btn-italic',\n          contents: ui.icon(options.icons.italic),\n          tooltip: lang.font.italic + representShortcut('italic'),\n          click: context.createInvokeHandler('editor.italic')\n        }).render();\n      });\n\n      context.memo('button.underline', function () {\n        return ui.button({\n          className: 'note-btn-underline',\n          contents: ui.icon(options.icons.underline),\n          tooltip: lang.font.underline + representShortcut('underline'),\n          click: context.createInvokeHandler('editor.underline')\n        }).render();\n      });\n\n      context.memo('button.clear', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.eraser),\n          tooltip: lang.font.clear + representShortcut('removeFormat'),\n          click: context.createInvokeHandler('editor.removeFormat')\n        }).render();\n      });\n\n      context.memo('button.strikethrough', function () {\n        return ui.button({\n          className: 'note-btn-strikethrough',\n          contents: ui.icon(options.icons.strikethrough),\n          tooltip: lang.font.strikethrough + representShortcut('strikethrough'),\n          click: context.createInvokeHandler('editor.strikethrough')\n        }).render();\n      });\n\n      context.memo('button.superscript', function () {\n        return ui.button({\n          className: 'note-btn-superscript',\n          contents: ui.icon(options.icons.superscript),\n          tooltip: lang.font.superscript,\n          click: context.createInvokeHandler('editor.superscript')\n        }).render();\n      });\n\n      context.memo('button.subscript', function () {\n        return ui.button({\n          className: 'note-btn-subscript',\n          contents: ui.icon(options.icons.subscript),\n          tooltip: lang.font.subscript,\n          click: context.createInvokeHandler('editor.subscript')\n        }).render();\n      });\n\n      context.memo('button.fontname', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontname\"/> ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.name,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontname',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontNames.filter(self.isFontInstalled),\n            template: function (item) {\n              return '<span style=\"font-family:' + item + '\">' + item + '</span>';\n            },\n            click: context.createInvokeHandler('editor.fontName')\n          })\n        ]).render();\n      });\n\n      context.memo('button.fontsize', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: '<span class=\"note-current-fontsize\"/>' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.size,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            className: 'dropdown-fontsize',\n            checkClassName: options.icons.menuCheck,\n            items: options.fontSizes,\n            click: context.createInvokeHandler('editor.fontSize')\n          })\n        ]).render();\n      });\n\n      context.memo('button.color', function () {\n        return ui.buttonGroup({\n          className: 'note-color',\n          children: [\n            ui.button({\n              className: 'note-current-color-button',\n              contents: ui.icon(options.icons.font + ' note-recent-color'),\n              tooltip: lang.color.recent,\n              click: function (e) {\n                var $button = $(e.currentTarget);\n                context.invoke('editor.color', {\n                  backColor: $button.attr('data-backColor'),\n                  foreColor: $button.attr('data-foreColor')\n                });\n              },\n              callback: function ($button) {\n                var $recentColor = $button.find('.note-recent-color');\n                $recentColor.css('background-color', '#FFFF00');\n                $button.attr('data-backColor', '#FFFF00');\n              }\n            }),\n            ui.button({\n              className: 'dropdown-toggle',\n              contents: ui.icon(options.icons.caret, 'span'),\n              tooltip: lang.color.more,\n              data: {\n                toggle: 'dropdown'\n              }\n            }),\n            ui.dropdown({\n              items: [\n                '<li>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.background + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"backColor\" data-value=\"inherit\">',\n                lang.color.transparent,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"backColor\"/>',\n                '</div>',\n                '<div class=\"btn-group\">',\n                '  <div class=\"note-palette-title\">' + lang.color.foreground + '</div>',\n                '  <div>',\n                '    <button type=\"button\" class=\"note-color-reset btn btn-default\" data-event=\"removeFormat\" data-value=\"foreColor\">',\n                lang.color.resetToDefault,\n                '    </button>',\n                '  </div>',\n                '  <div class=\"note-holder\" data-event=\"foreColor\"/>',\n                '</div>',\n                '</li>'\n              ].join(''),\n              callback: function ($dropdown) {\n                $dropdown.find('.note-holder').each(function () {\n                  var $holder = $(this);\n                  $holder.append(ui.palette({\n                    colors: options.colors,\n                    eventName: $holder.data('event')\n                  }).render());\n                });\n              },\n              click: function (event) {\n                var $button = $(event.target);\n                var eventName = $button.data('event');\n                var value = $button.data('value');\n\n                if (eventName && value) {\n                  var key = eventName === 'backColor' ? 'background-color' : 'color';\n                  var $color = $button.closest('.note-color').find('.note-recent-color');\n                  var $currentButton = $button.closest('.note-color').find('.note-current-color-button');\n\n                  $color.css(key, value);\n                  $currentButton.attr('data-' + eventName, value);\n                  context.invoke('editor.' + eventName, value);\n                }\n              }\n            })\n          ]\n        }).render();\n      });\n\n      context.memo('button.ul',  function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unorderedlist),\n          tooltip: lang.lists.unordered + representShortcut('insertUnorderedList'),\n          click: context.createInvokeHandler('editor.insertUnorderedList')\n        }).render();\n      });\n\n      context.memo('button.ol', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.orderedlist),\n          tooltip: lang.lists.ordered + representShortcut('insertOrderedList'),\n          click:  context.createInvokeHandler('editor.insertOrderedList')\n        }).render();\n      });\n\n      var justifyLeft = ui.button({\n        contents: ui.icon(options.icons.alignLeft),\n        tooltip: lang.paragraph.left + representShortcut('justifyLeft'),\n        click: context.createInvokeHandler('editor.justifyLeft')\n      });\n\n      var justifyCenter = ui.button({\n        contents: ui.icon(options.icons.alignCenter),\n        tooltip: lang.paragraph.center + representShortcut('justifyCenter'),\n        click: context.createInvokeHandler('editor.justifyCenter')\n      });\n\n      var justifyRight = ui.button({\n        contents: ui.icon(options.icons.alignRight),\n        tooltip: lang.paragraph.right + representShortcut('justifyRight'),\n        click: context.createInvokeHandler('editor.justifyRight')\n      });\n\n      var justifyFull = ui.button({\n        contents: ui.icon(options.icons.alignJustify),\n        tooltip: lang.paragraph.justify + representShortcut('justifyFull'),\n        click: context.createInvokeHandler('editor.justifyFull')\n      });\n\n      var outdent = ui.button({\n        contents: ui.icon(options.icons.outdent),\n        tooltip: lang.paragraph.outdent + representShortcut('outdent'),\n        click: context.createInvokeHandler('editor.outdent')\n      });\n\n      var indent = ui.button({\n        contents: ui.icon(options.icons.indent),\n        tooltip: lang.paragraph.indent + representShortcut('indent'),\n        click: context.createInvokeHandler('editor.indent')\n      });\n\n      context.memo('button.justifyLeft', func.invoke(justifyLeft, 'render'));\n      context.memo('button.justifyCenter', func.invoke(justifyCenter, 'render'));\n      context.memo('button.justifyRight', func.invoke(justifyRight, 'render'));\n      context.memo('button.justifyFull', func.invoke(justifyFull, 'render'));\n      context.memo('button.outdent', func.invoke(outdent, 'render'));\n      context.memo('button.indent', func.invoke(indent, 'render'));\n\n      context.memo('button.paragraph', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.alignLeft) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.paragraph.paragraph,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown([\n            ui.buttonGroup({\n              className: 'note-align',\n              children: [justifyLeft, justifyCenter, justifyRight, justifyFull]\n            }),\n            ui.buttonGroup({\n              className: 'note-list',\n              children: [outdent, indent]\n            })\n          ])\n        ]).render();\n      });\n\n      context.memo('button.height', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.textHeight) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.font.height,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdownCheck({\n            items: options.lineHeights,\n            checkClassName: options.icons.menuCheck,\n            className: 'dropdown-line-height',\n            click: context.createInvokeHandler('editor.lineHeight')\n          })\n        ]).render();\n      });\n\n      context.memo('button.table', function () {\n        return ui.buttonGroup([\n          ui.button({\n            className: 'dropdown-toggle',\n            contents: ui.icon(options.icons.table) + ' ' + ui.icon(options.icons.caret, 'span'),\n            tooltip: lang.table.table,\n            data: {\n              toggle: 'dropdown'\n            }\n          }),\n          ui.dropdown({\n            className: 'note-table',\n            items: [\n              '<div class=\"note-dimension-picker\">',\n              '  <div class=\"note-dimension-picker-mousecatcher\" data-event=\"insertTable\" data-value=\"1x1\"/>',\n              '  <div class=\"note-dimension-picker-highlighted\"/>',\n              '  <div class=\"note-dimension-picker-unhighlighted\"/>',\n              '</div>',\n              '<div class=\"note-dimension-display\">1 x 1</div>'\n            ].join('')\n          })\n        ], {\n          callback: function ($node) {\n            var $catcher = $node.find('.note-dimension-picker-mousecatcher');\n            $catcher.css({\n              width: options.insertTableMaxSize.col + 'em',\n              height: options.insertTableMaxSize.row + 'em'\n            }).mousedown(context.createInvokeHandler('editor.insertTable'))\n              .on('mousemove', self.tableMoveHandler);\n          }\n        }).render();\n      });\n\n      context.memo('button.link', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.link + representShortcut('linkDialog.show'),\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.picture', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.picture),\n          tooltip: lang.image.image,\n          click: context.createInvokeHandler('imageDialog.show')\n        }).render();\n      });\n\n      context.memo('button.video', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.video),\n          tooltip: lang.video.video,\n          click: context.createInvokeHandler('videoDialog.show')\n        }).render();\n      });\n\n      context.memo('button.hr', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.minus),\n          tooltip: lang.hr.insert + representShortcut('insertHorizontalRule'),\n          click: context.createInvokeHandler('editor.insertHorizontalRule')\n        }).render();\n      });\n\n      context.memo('button.fullscreen', function () {\n        return ui.button({\n          className: 'btn-fullscreen',\n          contents: ui.icon(options.icons.arrowsAlt),\n          tooltip: lang.options.fullscreen,\n          click: context.createInvokeHandler('fullscreen.toggle')\n        }).render();\n      });\n\n      context.memo('button.codeview', function () {\n        return ui.button({\n          className: 'btn-codeview',\n          contents: ui.icon(options.icons.code),\n          tooltip: lang.options.codeview,\n          click: context.createInvokeHandler('codeview.toggle')\n        }).render();\n      });\n\n      context.memo('button.redo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.redo),\n          tooltip: lang.history.redo + representShortcut('redo'),\n          click: context.createInvokeHandler('editor.redo')\n        }).render();\n      });\n\n      context.memo('button.undo', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.undo),\n          tooltip: lang.history.undo + representShortcut('undo'),\n          click: context.createInvokeHandler('editor.undo')\n        }).render();\n      });\n\n      context.memo('button.help', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.question),\n          tooltip: lang.options.help,\n          click: context.createInvokeHandler('helpDialog.show')\n        }).render();\n      });\n    };\n\n    /**\n     * image : [\n     *   ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n     *   ['float', ['floatLeft', 'floatRight', 'floatNone' ]],\n     *   ['remove', ['removeMedia']]\n     * ],\n     */\n    this.addImagePopoverButtons = function () {\n      // Image Size Buttons\n      context.memo('button.imageSize100', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">100%</span>',\n          tooltip: lang.image.resizeFull,\n          click: context.createInvokeHandler('editor.resize', '1')\n        }).render();\n      });\n      context.memo('button.imageSize50', function () {\n        return  ui.button({\n          contents: '<span class=\"note-fontsize-10\">50%</span>',\n          tooltip: lang.image.resizeHalf,\n          click: context.createInvokeHandler('editor.resize', '0.5')\n        }).render();\n      });\n      context.memo('button.imageSize25', function () {\n        return ui.button({\n          contents: '<span class=\"note-fontsize-10\">25%</span>',\n          tooltip: lang.image.resizeQuarter,\n          click: context.createInvokeHandler('editor.resize', '0.25')\n        }).render();\n      });\n\n      // Float Buttons\n      context.memo('button.floatLeft', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignLeft),\n          tooltip: lang.image.floatLeft,\n          click: context.createInvokeHandler('editor.floatMe', 'left')\n        }).render();\n      });\n\n      context.memo('button.floatRight', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignRight),\n          tooltip: lang.image.floatRight,\n          click: context.createInvokeHandler('editor.floatMe', 'right')\n        }).render();\n      });\n\n      context.memo('button.floatNone', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.alignJustify),\n          tooltip: lang.image.floatNone,\n          click: context.createInvokeHandler('editor.floatMe', 'none')\n        }).render();\n      });\n\n      // Remove Buttons\n      context.memo('button.removeMedia', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.trash),\n          tooltip: lang.image.remove,\n          click: context.createInvokeHandler('editor.removeMedia')\n        }).render();\n      });\n    };\n\n    this.addLinkPopoverButtons = function () {\n      context.memo('button.linkDialogShow', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.link),\n          tooltip: lang.link.edit,\n          click: context.createInvokeHandler('linkDialog.show')\n        }).render();\n      });\n\n      context.memo('button.unlink', function () {\n        return ui.button({\n          contents: ui.icon(options.icons.unlink),\n          tooltip: lang.link.unlink,\n          click: context.createInvokeHandler('editor.unlink')\n        }).render();\n      });\n    };\n\n    this.build = function ($container, groups) {\n      for (var groupIdx = 0, groupLen = groups.length; groupIdx < groupLen; groupIdx++) {\n        var group = groups[groupIdx];\n        var groupName = group[0];\n        var buttons = group[1];\n\n        var $group = ui.buttonGroup({\n          className: 'note-' + groupName\n        }).render();\n\n        for (var idx = 0, len = buttons.length; idx < len; idx++) {\n          var button = context.memo('button.' + buttons[idx]);\n          if (button) {\n            $group.append(typeof button === 'function' ? button(context) : button);\n          }\n        }\n        $group.appendTo($container);\n      }\n    };\n\n    this.updateCurrentStyle = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      this.updateBtnStates({\n        '.note-btn-bold': function () {\n          return styleInfo['font-bold'] === 'bold';\n        },\n        '.note-btn-italic': function () {\n          return styleInfo['font-italic'] === 'italic';\n        },\n        '.note-btn-underline': function () {\n          return styleInfo['font-underline'] === 'underline';\n        },\n        '.note-btn-subscript': function () {\n          return styleInfo['font-subscript'] === 'subscript';\n        },\n        '.note-btn-superscript': function () {\n          return styleInfo['font-superscript'] === 'superscript';\n        },\n        '.note-btn-strikethrough': function () {\n          return styleInfo['font-strikethrough'] === 'strikethrough';\n        }\n      });\n\n      if (styleInfo['font-family']) {\n        var fontNames = styleInfo['font-family'].split(',').map(function (name) {\n          return name.replace(/[\\'\\\"]/g, '')\n            .replace(/\\s+$/, '')\n            .replace(/^\\s+/, '');\n        });\n        var fontName = list.find(fontNames, self.isFontInstalled);\n\n        $toolbar.find('.dropdown-fontname li a').each(function () {\n          // always compare string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontName + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontname').text(fontName);\n      }\n\n      if (styleInfo['font-size']) {\n        var fontSize = styleInfo['font-size'];\n        $toolbar.find('.dropdown-fontsize li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (fontSize + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n        $toolbar.find('.note-current-fontsize').text(fontSize);\n      }\n\n      if (styleInfo['line-height']) {\n        var lineHeight = styleInfo['line-height'];\n        $toolbar.find('.dropdown-line-height li a').each(function () {\n          // always compare with string to avoid creating another func.\n          var isChecked = ($(this).data('value') + '') === (lineHeight + '');\n          this.className = isChecked ? 'checked' : '';\n        });\n      }\n    };\n\n    this.updateBtnStates = function (infos) {\n      $.each(infos, function (selector, pred) {\n        ui.toggleBtnActive($toolbar.find(selector), pred());\n      });\n    };\n\n    this.tableMoveHandler = function (event) {\n      var PX_PER_EM = 18;\n      var $picker = $(event.target.parentNode); // target is mousecatcher\n      var $dimensionDisplay = $picker.next();\n      var $catcher = $picker.find('.note-dimension-picker-mousecatcher');\n      var $highlighted = $picker.find('.note-dimension-picker-highlighted');\n      var $unhighlighted = $picker.find('.note-dimension-picker-unhighlighted');\n\n      var posOffset;\n      // HTML5 with jQuery - e.offsetX is undefined in Firefox\n      if (event.offsetX === undefined) {\n        var posCatcher = $(event.target).offset();\n        posOffset = {\n          x: event.pageX - posCatcher.left,\n          y: event.pageY - posCatcher.top\n        };\n      } else {\n        posOffset = {\n          x: event.offsetX,\n          y: event.offsetY\n        };\n      }\n\n      var dim = {\n        c: Math.ceil(posOffset.x / PX_PER_EM) || 1,\n        r: Math.ceil(posOffset.y / PX_PER_EM) || 1\n      };\n\n      $highlighted.css({ width: dim.c + 'em', height: dim.r + 'em' });\n      $catcher.data('value', dim.c + 'x' + dim.r);\n\n      if (3 < dim.c && dim.c < options.insertTableMaxSize.col) {\n        $unhighlighted.css({ width: dim.c + 1 + 'em'});\n      }\n\n      if (3 < dim.r && dim.r < options.insertTableMaxSize.row) {\n        $unhighlighted.css({ height: dim.r + 1 + 'em'});\n      }\n\n      $dimensionDisplay.html(dim.c + ' x ' + dim.r);\n    };\n  };\n\n  var Toolbar = function (context) {\n    var ui = $.summernote.ui;\n\n    var $note = context.layoutInfo.note;\n    var $toolbar = context.layoutInfo.toolbar;\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !options.airMode;\n    };\n\n    this.initialize = function () {\n      options.toolbar = options.toolbar || [];\n\n      if (!options.toolbar.length) {\n        $toolbar.hide();\n      } else {\n        context.invoke('buttons.build', $toolbar, options.toolbar);\n      }\n\n      if (options.toolbarContainer) {\n        $toolbar.appendTo(options.toolbarContainer);\n      }\n\n      $note.on('summernote.keyup summernote.mouseup summernote.change', function () {\n        context.invoke('buttons.updateCurrentStyle');\n      });\n\n      context.invoke('buttons.updateCurrentStyle');\n    };\n\n    this.destroy = function () {\n      $toolbar.children().remove();\n    };\n\n    this.updateFullscreen = function (isFullscreen) {\n      ui.toggleBtnActive($toolbar.find('.btn-fullscreen'), isFullscreen);\n    };\n\n    this.updateCodeview = function (isCodeview) {\n      ui.toggleBtnActive($toolbar.find('.btn-codeview'), isCodeview);\n      if (isCodeview) {\n        this.deactivate();\n      } else {\n        this.activate();\n      }\n    };\n\n    this.activate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, true);\n    };\n\n    this.deactivate = function (isIncludeCodeview) {\n      var $btn = $toolbar.find('button');\n      if (!isIncludeCodeview) {\n        $btn = $btn.not('.btn-codeview');\n      }\n      ui.toggleBtn($btn, false);\n    };\n  };\n\n  var LinkDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group\">' +\n                   '<label>' + lang.link.textToDisplay + '</label>' +\n                   '<input class=\"note-link-text form-control\" type=\"text\" />' +\n                 '</div>' +\n                 '<div class=\"form-group\">' +\n                   '<label>' + lang.link.url + '</label>' +\n                   '<input class=\"note-link-url form-control\" type=\"text\" value=\"http://\" />' +\n                 '</div>' +\n                 (!options.disableLinkTarget ?\n                   '<div class=\"checkbox\">' +\n                     '<label>' + '<input type=\"checkbox\" checked> ' + lang.link.openInNewWindow + '</label>' +\n                   '</div>' : ''\n                 );\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-link-btn disabled\" disabled>' + lang.link.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        className: 'link-dialog',\n        title: lang.link.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    /**\n     * toggle update button\n     */\n    this.toggleLinkBtn = function ($linkBtn, $linkText, $linkUrl) {\n      ui.toggleBtn($linkBtn, $linkText.val() && $linkUrl.val());\n    };\n\n    /**\n     * Show link dialog and set event handlers on dialog controls.\n     *\n     * @param {Object} linkInfo\n     * @return {Promise}\n     */\n    this.showLinkDialog = function (linkInfo) {\n      return $.Deferred(function (deferred) {\n        var $linkText = self.$dialog.find('.note-link-text'),\n        $linkUrl = self.$dialog.find('.note-link-url'),\n        $linkBtn = self.$dialog.find('.note-link-btn'),\n        $openInNewWindow = self.$dialog.find('input[type=checkbox]');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // if no url was given, copy text to url\n          if (!linkInfo.url) {\n            linkInfo.url = linkInfo.text;\n          }\n\n          $linkText.val(linkInfo.text);\n\n          var handleLinkTextUpdate = function () {\n            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n            // if linktext was modified by keyup,\n            // stop cloning text from linkUrl\n            linkInfo.text = $linkText.val();\n          };\n\n          $linkText.on('input', handleLinkTextUpdate).on('paste', function () {\n            setTimeout(handleLinkTextUpdate, 0);\n          });\n\n          var handleLinkUrlUpdate = function () {\n            self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n            // display same link on `Text to display` input\n            // when create a new link\n            if (!linkInfo.text) {\n              $linkText.val($linkUrl.val());\n            }\n          };\n\n          $linkUrl.on('input', handleLinkUrlUpdate).on('paste', function () {\n            setTimeout(handleLinkUrlUpdate, 0);\n          }).val(linkInfo.url).trigger('focus');\n\n          self.toggleLinkBtn($linkBtn, $linkText, $linkUrl);\n          self.bindEnterKey($linkUrl, $linkBtn);\n          self.bindEnterKey($linkText, $linkBtn);\n\n          $openInNewWindow.prop('checked', linkInfo.isNewWindow);\n\n          $linkBtn.one('click', function (event) {\n            event.preventDefault();\n\n            deferred.resolve({\n              range: linkInfo.range,\n              url: $linkUrl.val(),\n              text: $linkText.val(),\n              isNewWindow: $openInNewWindow.is(':checked')\n            });\n            self.$dialog.modal('hide');\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          // detach events\n          $linkText.off('input paste keypress');\n          $linkUrl.off('input paste keypress');\n          $linkBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    /**\n     * @param {Object} layoutInfo\n     */\n    this.show = function () {\n      var linkInfo = context.invoke('editor.getLinkInfo');\n\n      context.invoke('editor.saveRange');\n      this.showLinkDialog(linkInfo).then(function (linkInfo) {\n        context.invoke('editor.restoreRange');\n        context.invoke('editor.createLink', linkInfo);\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n    context.memo('help.linkDialog.show', options.langInfo.help['linkDialog.show']);\n  };\n\n  var LinkPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.change summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.link);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-link-popover',\n        callback: function ($node) {\n          var $content = $node.find('.popover-content');\n          $content.prepend('<span><a target=\"_blank\"></a>&nbsp;</span>');\n        }\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.link);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      // Prevent focusing on editable when invoke('code') is executed\n      if (!context.invoke('editor.hasFocus')) {\n        this.hide();\n        return;\n      }\n\n      var rng = context.invoke('editor.createRange');\n      if (rng.isCollapsed() && rng.isOnAnchor()) {\n        var anchor = dom.ancestor(rng.sc, dom.isAnchor);\n        var href = $(anchor).attr('href');\n        this.$popover.find('a').attr('href', href).html(href);\n\n        var pos = dom.posFromPlaceholder(anchor);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var ImageDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var imageLimitation = '';\n      if (options.maximumImageFileSize) {\n        var unit = Math.floor(Math.log(options.maximumImageFileSize) / Math.log(1024));\n        var readableSize = (options.maximumImageFileSize / Math.pow(1024, unit)).toFixed(2) * 1 +\n                           ' ' + ' KMGTP'[unit] + 'B';\n        imageLimitation = '<small>' + lang.image.maximumFileSize + ' : ' + readableSize + '</small>';\n      }\n\n      var body = '<div class=\"form-group note-group-select-from-files\">' +\n                   '<label>' + lang.image.selectFromFiles + '</label>' +\n                   '<input class=\"note-image-input form-control\" type=\"file\" name=\"files\" accept=\"image/*\" multiple=\"multiple\" />' +\n                   imageLimitation +\n                 '</div>' +\n                 '<div class=\"form-group note-group-image-url\" style=\"overflow:auto;\">' +\n                   '<label>' + lang.image.url + '</label>' +\n                   '<input class=\"note-image-url form-control col-md-12\" type=\"text\" />' +\n                 '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-image-btn disabled\" disabled>' + lang.image.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.image.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showImageDialog().then(function (data) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        if (typeof data === 'string') { // image url\n          context.invoke('editor.insertImage', data);\n        } else { // array of files\n          context.invoke('editor.insertImagesOrCallback', data);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showImageDialog = function () {\n      return $.Deferred(function (deferred) {\n        var $imageInput = self.$dialog.find('.note-image-input'),\n            $imageUrl = self.$dialog.find('.note-image-url'),\n            $imageBtn = self.$dialog.find('.note-image-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          // Cloning imageInput to clear element.\n          $imageInput.replaceWith($imageInput.clone()\n            .on('change', function () {\n              deferred.resolve(this.files || this.value);\n            })\n            .val('')\n          );\n\n          $imageBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($imageUrl.val());\n          });\n\n          $imageUrl.on('keyup paste', function () {\n            var url = $imageUrl.val();\n            ui.toggleBtn($imageBtn, url);\n          }).val('').trigger('focus');\n          self.bindEnterKey($imageUrl, $imageBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $imageInput.off('change');\n          $imageUrl.off('keyup paste keypress');\n          $imageBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var ImagePopover = function (context) {\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    this.shouldInitialize = function () {\n      return !list.isEmpty(options.popover.image);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-image-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.image);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function (target) {\n      if (dom.isImg(target)) {\n        var pos = dom.posFromPlaceholder(target);\n        this.$popover.css({\n          display: 'block',\n          left: pos.left,\n          top: pos.top\n        });\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var VideoDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = '<div class=\"form-group row-fluid\">' +\n          '<label>' + lang.video.url + ' <small class=\"text-muted\">' + lang.video.providers + '</small></label>' +\n          '<input class=\"note-video-url form-control span12\" type=\"text\" />' +\n          '</div>';\n      var footer = '<button href=\"#\" class=\"btn btn-primary note-video-btn disabled\" disabled>' + lang.video.insert + '</button>';\n\n      this.$dialog = ui.dialog({\n        title: lang.video.insert,\n        fade: options.dialogsFade,\n        body: body,\n        footer: footer\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    this.bindEnterKey = function ($input, $btn) {\n      $input.on('keypress', function (event) {\n        if (event.keyCode === key.code.ENTER) {\n          $btn.trigger('click');\n        }\n      });\n    };\n\n    this.createVideoNode = function (url) {\n      // video url patterns(youtube, instagram, vimeo, dailymotion, youku, mp4, ogg, webm)\n      var ytRegExp = /^(?:https?:\\/\\/)?(?:www\\.)?(?:youtu\\.be\\/|youtube\\.com\\/(?:embed\\/|v\\/|watch\\?v=|watch\\?.+&v=))((\\w|-){11})(?:\\S+)?$/;\n      var ytMatch = url.match(ytRegExp);\n\n      var igRegExp = /(?:www\\.|\\/\\/)instagram\\.com\\/p\\/(.[a-zA-Z0-9_-]*)/;\n      var igMatch = url.match(igRegExp);\n\n      var vRegExp = /\\/\\/vine\\.co\\/v\\/([a-zA-Z0-9]+)/;\n      var vMatch = url.match(vRegExp);\n\n      var vimRegExp = /\\/\\/(player\\.)?vimeo\\.com\\/([a-z]*\\/)*([0-9]{6,11})[?]?.*/;\n      var vimMatch = url.match(vimRegExp);\n\n      var dmRegExp = /.+dailymotion.com\\/(video|hub)\\/([^_]+)[^#]*(#video=([^_&]+))?/;\n      var dmMatch = url.match(dmRegExp);\n\n      var youkuRegExp = /\\/\\/v\\.youku\\.com\\/v_show\\/id_(\\w+)=*\\.html/;\n      var youkuMatch = url.match(youkuRegExp);\n\n      var mp4RegExp = /^.+.(mp4|m4v)$/;\n      var mp4Match = url.match(mp4RegExp);\n\n      var oggRegExp = /^.+.(ogg|ogv)$/;\n      var oggMatch = url.match(oggRegExp);\n\n      var webmRegExp = /^.+.(webm)$/;\n      var webmMatch = url.match(webmRegExp);\n\n      var $video;\n      if (ytMatch && ytMatch[1].length === 11) {\n        var youtubeId = ytMatch[1];\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.youtube.com/embed/' + youtubeId)\n            .attr('width', '640').attr('height', '360');\n      } else if (igMatch && igMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', 'https://instagram.com/p/' + igMatch[1] + '/embed/')\n            .attr('width', '612').attr('height', '710')\n            .attr('scrolling', 'no')\n            .attr('allowtransparency', 'true');\n      } else if (vMatch && vMatch[0].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', vMatch[0] + '/embed/simple')\n            .attr('width', '600').attr('height', '600')\n            .attr('class', 'vine-embed');\n      } else if (vimMatch && vimMatch[3].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('src', '//player.vimeo.com/video/' + vimMatch[3])\n            .attr('width', '640').attr('height', '360');\n      } else if (dmMatch && dmMatch[2].length) {\n        $video = $('<iframe>')\n            .attr('frameborder', 0)\n            .attr('src', '//www.dailymotion.com/embed/video/' + dmMatch[2])\n            .attr('width', '640').attr('height', '360');\n      } else if (youkuMatch && youkuMatch[1].length) {\n        $video = $('<iframe webkitallowfullscreen mozallowfullscreen allowfullscreen>')\n            .attr('frameborder', 0)\n            .attr('height', '498')\n            .attr('width', '510')\n            .attr('src', '//player.youku.com/embed/' + youkuMatch[1]);\n      } else if (mp4Match || oggMatch || webmMatch) {\n        $video = $('<video controls>')\n            .attr('src', url)\n            .attr('width', '640').attr('height', '360');\n      } else {\n        // this is not a known video link. Now what, Cat? Now what?\n        return false;\n      }\n\n      $video.addClass('note-video-clip');\n\n      return $video[0];\n    };\n\n    this.show = function () {\n      var text = context.invoke('editor.getSelectedText');\n      context.invoke('editor.saveRange');\n      this.showVideoDialog(text).then(function (url) {\n        // [workaround] hide dialog before restore range for IE range focus\n        ui.hideDialog(self.$dialog);\n        context.invoke('editor.restoreRange');\n\n        // build node\n        var $node = self.createVideoNode(url);\n\n        if ($node) {\n          // insert video node\n          context.invoke('editor.insertNode', $node);\n        }\n      }).fail(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n\n    /**\n     * show image dialog\n     *\n     * @param {jQuery} $dialog\n     * @return {Promise}\n     */\n    this.showVideoDialog = function (text) {\n      return $.Deferred(function (deferred) {\n        var $videoUrl = self.$dialog.find('.note-video-url'),\n            $videoBtn = self.$dialog.find('.note-video-btn');\n\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n\n          $videoUrl.val(text).on('input', function () {\n            ui.toggleBtn($videoBtn, $videoUrl.val());\n          }).trigger('focus');\n\n          $videoBtn.click(function (event) {\n            event.preventDefault();\n\n            deferred.resolve($videoUrl.val());\n          });\n\n          self.bindEnterKey($videoUrl, $videoBtn);\n        });\n\n        ui.onDialogHidden(self.$dialog, function () {\n          $videoUrl.off('input');\n          $videoBtn.off('click');\n\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n  };\n\n  var HelpDialog = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var $editor = context.layoutInfo.editor;\n    var options = context.options;\n    var lang = options.langInfo;\n\n    this.createShortCutList = function () {\n      var keyMap = options.keyMap[agent.isMac ? 'mac' : 'pc'];\n      return Object.keys(keyMap).map(function (key) {\n        var command = keyMap[key];\n        var $row = $('<div><div class=\"help-list-item\"/></div>');\n        $row.append($('<label><kbd>' + key + '</kdb></label>').css({\n          'width': 180,\n          'margin-right': 10\n        })).append($('<span/>').html(context.memo('help.' + command) || command));\n        return $row.html();\n      }).join('');\n    };\n\n    this.initialize = function () {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n\n      var body = [\n        '<p class=\"text-center\">',\n        '<a href=\"http://summernote.org/\" target=\"_blank\">Summernote 0.8.2</a>  ',\n        '<a href=\"https://github.com/summernote/summernote\" target=\"_blank\">Project</a>  ',\n        '<a href=\"https://github.com/summernote/summernote/issues\" target=\"_blank\">Issues</a>',\n        '</p>'\n      ].join('');\n\n      this.$dialog = ui.dialog({\n        title: lang.options.help,\n        fade: options.dialogsFade,\n        body: this.createShortCutList(),\n        footer: body,\n        callback: function ($node) {\n          $node.find('.modal-body').css({\n            'max-height': 300,\n            'overflow': 'scroll'\n          });\n        }\n      }).render().appendTo($container);\n    };\n\n    this.destroy = function () {\n      ui.hideDialog(this.$dialog);\n      this.$dialog.remove();\n    };\n\n    /**\n     * show help dialog\n     *\n     * @return {Promise}\n     */\n    this.showHelpDialog = function () {\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function () {\n          context.triggerEvent('dialog.shown');\n          deferred.resolve();\n        });\n        ui.showDialog(self.$dialog);\n      }).promise();\n    };\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n      this.showHelpDialog().then(function () {\n        context.invoke('editor.restoreRange');\n      });\n    };\n  };\n\n  var AirPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var options = context.options;\n\n    var AIR_MODE_POPOVER_X_OFFSET = 20;\n\n    this.events = {\n      'summernote.keyup summernote.mouseup summernote.scroll': function () {\n        self.update();\n      },\n      'summernote.change summernote.dialog.shown': function () {\n        self.hide();\n      },\n      'summernote.focusout': function (we, e) {\n        // [workaround] Firefox doesn't support relatedTarget on focusout\n        //  - Ignore hide action on focus out in FF.\n        if (agent.isFF) {\n          return;\n        }\n\n        if (!e.relatedTarget || !dom.ancestor(e.relatedTarget, func.eq(self.$popover[0]))) {\n          self.hide();\n        }\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return options.airMode && !list.isEmpty(options.popover.air);\n    };\n\n    this.initialize = function () {\n      this.$popover = ui.popover({\n        className: 'note-air-popover'\n      }).render().appendTo('body');\n      var $content = this.$popover.find('.popover-content');\n\n      context.invoke('buttons.build', $content, options.popover.air);\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.update = function () {\n      var styleInfo = context.invoke('editor.currentStyle');\n      if (styleInfo.range && !styleInfo.range.isCollapsed()) {\n        var rect = list.last(styleInfo.range.getClientRects());\n        if (rect) {\n          var bnd = func.rect2bnd(rect);\n          this.$popover.css({\n            display: 'block',\n            left: Math.max(bnd.left + bnd.width / 2, 0) - AIR_MODE_POPOVER_X_OFFSET,\n            top: bnd.top + bnd.height\n          });\n        }\n      } else {\n        this.hide();\n      }\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n  var HintPopover = function (context) {\n    var self = this;\n    var ui = $.summernote.ui;\n\n    var POPOVER_DIST = 5;\n    var hint = context.options.hint || [];\n    var direction = context.options.hintDirection || 'bottom';\n    var hints = $.isArray(hint) ? hint : [hint];\n\n    this.events = {\n      'summernote.keyup': function (we, e) {\n        if (!e.isDefaultPrevented()) {\n          self.handleKeyup(e);\n        }\n      },\n      'summernote.keydown': function (we, e) {\n        self.handleKeydown(e);\n      },\n      'summernote.dialog.shown': function () {\n        self.hide();\n      }\n    };\n\n    this.shouldInitialize = function () {\n      return hints.length > 0;\n    };\n\n    this.initialize = function () {\n      this.lastWordRange = null;\n      this.$popover = ui.popover({\n        className: 'note-hint-popover',\n        hideArrow: true,\n        direction: ''\n      }).render().appendTo('body');\n\n      this.$popover.hide();\n\n      this.$content = this.$popover.find('.popover-content');\n\n      this.$content.on('click', '.note-hint-item', function () {\n        self.$content.find('.active').removeClass('active');\n        $(this).addClass('active');\n        self.replace();\n      });\n    };\n\n    this.destroy = function () {\n      this.$popover.remove();\n    };\n\n    this.selectItem = function ($item) {\n      this.$content.find('.active').removeClass('active');\n      $item.addClass('active');\n\n      this.$content[0].scrollTop = $item[0].offsetTop - (this.$content.innerHeight() / 2);\n    };\n\n    this.moveDown = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $next = $current.next();\n\n      if ($next.length) {\n        this.selectItem($next);\n      } else {\n        var $nextGroup = $current.parent().next();\n\n        if (!$nextGroup.length) {\n          $nextGroup = this.$content.find('.note-hint-group').first();\n        }\n\n        this.selectItem($nextGroup.find('.note-hint-item').first());\n      }\n    };\n\n    this.moveUp = function () {\n      var $current = this.$content.find('.note-hint-item.active');\n      var $prev = $current.prev();\n\n      if ($prev.length) {\n        this.selectItem($prev);\n      } else {\n        var $prevGroup = $current.parent().prev();\n\n        if (!$prevGroup.length) {\n          $prevGroup = this.$content.find('.note-hint-group').last();\n        }\n\n        this.selectItem($prevGroup.find('.note-hint-item').last());\n      }\n    };\n\n    this.replace = function () {\n      var $item = this.$content.find('.note-hint-item.active');\n\n      if ($item.length) {\n        var node = this.nodeFromItem($item);\n        this.lastWordRange.insertNode(node);\n        range.createFromNode(node).collapse().select();\n\n        this.lastWordRange = null;\n        this.hide();\n        context.invoke('editor.focus');\n      }\n\n    };\n\n    this.nodeFromItem = function ($item) {\n      var hint = hints[$item.data('index')];\n      var item = $item.data('item');\n      var node = hint.content ? hint.content(item) : item;\n      if (typeof node === 'string') {\n        node = dom.createText(node);\n      }\n      return node;\n    };\n\n    this.createItemTemplates = function (hintIdx, items) {\n      var hint = hints[hintIdx];\n      return items.map(function (item, idx) {\n        var $item = $('<div class=\"note-hint-item\"/>');\n        $item.append(hint.template ? hint.template(item) : item + '');\n        $item.data({\n          'index': hintIdx,\n          'item': item\n        });\n\n        if (hintIdx === 0 && idx === 0) {\n          $item.addClass('active');\n        }\n        return $item;\n      });\n    };\n\n    this.handleKeydown = function (e) {\n      if (!this.$popover.is(':visible')) {\n        return;\n      }\n\n      if (e.keyCode === key.code.ENTER) {\n        e.preventDefault();\n        this.replace();\n      } else if (e.keyCode === key.code.UP) {\n        e.preventDefault();\n        this.moveUp();\n      } else if (e.keyCode === key.code.DOWN) {\n        e.preventDefault();\n        this.moveDown();\n      }\n    };\n\n    this.searchKeyword = function (index, keyword, callback) {\n      var hint = hints[index];\n      if (hint && hint.match.test(keyword) && hint.search) {\n        var matches = hint.match.exec(keyword);\n        hint.search(matches[1], callback);\n      } else {\n        callback();\n      }\n    };\n\n    this.createGroup = function (idx, keyword) {\n      var $group = $('<div class=\"note-hint-group note-hint-group-' + idx + '\"/>');\n      this.searchKeyword(idx, keyword, function (items) {\n        items = items || [];\n        if (items.length) {\n          $group.html(self.createItemTemplates(idx, items));\n          self.show();\n        }\n      });\n\n      return $group;\n    };\n\n    this.handleKeyup = function (e) {\n      if (list.contains([key.code.ENTER, key.code.UP, key.code.DOWN], e.keyCode)) {\n        if (e.keyCode === key.code.ENTER) {\n          if (this.$popover.is(':visible')) {\n            return;\n          }\n        }\n      } else {\n        var wordRange = context.invoke('editor.createRange').getWordRange();\n        var keyword = wordRange.toString();\n        if (hints.length && keyword) {\n          this.$content.empty();\n\n          var bnd = func.rect2bnd(list.last(wordRange.getClientRects()));\n          if (bnd) {\n\n            this.$popover.hide();\n\n            this.lastWordRange = wordRange;\n\n            hints.forEach(function (hint, idx) {\n              if (hint.match.test(keyword)) {\n                self.createGroup(idx, keyword).appendTo(self.$content);\n              }\n            });\n\n            // set position for popover after group is created\n            if (direction === 'top') {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top - this.$popover.outerHeight() - POPOVER_DIST\n              });\n            } else {\n              this.$popover.css({\n                left: bnd.left,\n                top: bnd.top + bnd.height + POPOVER_DIST\n              });\n            }\n\n          }\n        } else {\n          this.hide();\n        }\n      }\n    };\n\n    this.show = function () {\n      this.$popover.show();\n    };\n\n    this.hide = function () {\n      this.$popover.hide();\n    };\n  };\n\n\n  $.summernote = $.extend($.summernote, {\n    version: '0.8.2',\n    ui: ui,\n    dom: dom,\n\n    plugins: {},\n\n    options: {\n      modules: {\n        'editor': Editor,\n        'clipboard': Clipboard,\n        'dropzone': Dropzone,\n        'codeview': Codeview,\n        'statusbar': Statusbar,\n        'fullscreen': Fullscreen,\n        'handle': Handle,\n        // FIXME: HintPopover must be front of autolink\n        //  - Script error about range when Enter key is pressed on hint popover\n        'hintPopover': HintPopover,\n        'autoLink': AutoLink,\n        'autoSync': AutoSync,\n        'placeholder': Placeholder,\n        'buttons': Buttons,\n        'toolbar': Toolbar,\n        'linkDialog': LinkDialog,\n        'linkPopover': LinkPopover,\n        'imageDialog': ImageDialog,\n        'imagePopover': ImagePopover,\n        'videoDialog': VideoDialog,\n        'helpDialog': HelpDialog,\n        'airPopover': AirPopover\n      },\n\n      buttons: {},\n      \n      lang: 'en-US',\n\n      // toolbar\n      toolbar: [\n        ['style', ['style']],\n        ['font', ['bold', 'underline', 'clear']],\n        ['fontname', ['fontname']],\n        ['color', ['color']],\n        ['para', ['ul', 'ol', 'paragraph']],\n        ['table', ['table']],\n        ['insert', ['link', 'picture', 'video']],\n        ['view', ['fullscreen', 'codeview', 'help']]\n      ],\n\n      // popover\n      popover: {\n        image: [\n          ['imagesize', ['imageSize100', 'imageSize50', 'imageSize25']],\n          ['float', ['floatLeft', 'floatRight', 'floatNone']],\n          ['remove', ['removeMedia']]\n        ],\n        link: [\n          ['link', ['linkDialogShow', 'unlink']]\n        ],\n        air: [\n          ['color', ['color']],\n          ['font', ['bold', 'underline', 'clear']],\n          ['para', ['ul', 'paragraph']],\n          ['table', ['table']],\n          ['insert', ['link', 'picture']]\n        ]\n      },\n\n      // air mode: inline editor\n      airMode: false,\n\n      width: null,\n      height: null,\n\n      focus: false,\n      tabSize: 4,\n      styleWithSpan: true,\n      shortcuts: true,\n      textareaAutoSync: true,\n      direction: null,\n\n      styleTags: ['p', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'],\n\n      fontNames: [\n        'Arial', 'Arial Black', 'Comic Sans MS', 'Courier New',\n        'Helvetica Neue', 'Helvetica', 'Impact', 'Lucida Grande',\n        'Tahoma', 'Times New Roman', 'Verdana'\n      ],\n\n      fontSizes: ['8', '9', '10', '11', '12', '14', '18', '24', '36'],\n\n      // pallete colors(n x n)\n      colors: [\n        ['#000000', '#424242', '#636363', '#9C9C94', '#CEC6CE', '#EFEFEF', '#F7F7F7', '#FFFFFF'],\n        ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],\n        ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],\n        ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],\n        ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],\n        ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],\n        ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],\n        ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']\n      ],\n\n      lineHeights: ['1.0', '1.2', '1.4', '1.5', '1.6', '1.8', '2.0', '3.0'],\n\n      tableClassName: 'table table-bordered',\n\n      insertTableMaxSize: {\n        col: 10,\n        row: 10\n      },\n\n      dialogsInBody: false,\n      dialogsFade: false,\n\n      maximumImageFileSize: null,\n\n      callbacks: {\n        onInit: null,\n        onFocus: null,\n        onBlur: null,\n        onEnter: null,\n        onKeyup: null,\n        onKeydown: null,\n        onImageUpload: null,\n        onImageUploadError: null\n      },\n\n      codemirror: {\n        mode: 'text/html',\n        htmlMode: true,\n        lineNumbers: true\n      },\n\n      keyMap: {\n        pc: {\n          'ENTER': 'insertParagraph',\n          'CTRL+Z': 'undo',\n          'CTRL+Y': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CTRL+B': 'bold',\n          'CTRL+I': 'italic',\n          'CTRL+U': 'underline',\n          'CTRL+SHIFT+S': 'strikethrough',\n          'CTRL+BACKSLASH': 'removeFormat',\n          'CTRL+SHIFT+L': 'justifyLeft',\n          'CTRL+SHIFT+E': 'justifyCenter',\n          'CTRL+SHIFT+R': 'justifyRight',\n          'CTRL+SHIFT+J': 'justifyFull',\n          'CTRL+SHIFT+NUM7': 'insertUnorderedList',\n          'CTRL+SHIFT+NUM8': 'insertOrderedList',\n          'CTRL+LEFTBRACKET': 'outdent',\n          'CTRL+RIGHTBRACKET': 'indent',\n          'CTRL+NUM0': 'formatPara',\n          'CTRL+NUM1': 'formatH1',\n          'CTRL+NUM2': 'formatH2',\n          'CTRL+NUM3': 'formatH3',\n          'CTRL+NUM4': 'formatH4',\n          'CTRL+NUM5': 'formatH5',\n          'CTRL+NUM6': 'formatH6',\n          'CTRL+ENTER': 'insertHorizontalRule',\n          'CTRL+K': 'linkDialog.show'\n        },\n\n        mac: {\n          'ENTER': 'insertParagraph',\n          'CMD+Z': 'undo',\n          'CMD+SHIFT+Z': 'redo',\n          'TAB': 'tab',\n          'SHIFT+TAB': 'untab',\n          'CMD+B': 'bold',\n          'CMD+I': 'italic',\n          'CMD+U': 'underline',\n          'CMD+SHIFT+S': 'strikethrough',\n          'CMD+BACKSLASH': 'removeFormat',\n          'CMD+SHIFT+L': 'justifyLeft',\n          'CMD+SHIFT+E': 'justifyCenter',\n          'CMD+SHIFT+R': 'justifyRight',\n          'CMD+SHIFT+J': 'justifyFull',\n          'CMD+SHIFT+NUM7': 'insertUnorderedList',\n          'CMD+SHIFT+NUM8': 'insertOrderedList',\n          'CMD+LEFTBRACKET': 'outdent',\n          'CMD+RIGHTBRACKET': 'indent',\n          'CMD+NUM0': 'formatPara',\n          'CMD+NUM1': 'formatH1',\n          'CMD+NUM2': 'formatH2',\n          'CMD+NUM3': 'formatH3',\n          'CMD+NUM4': 'formatH4',\n          'CMD+NUM5': 'formatH5',\n          'CMD+NUM6': 'formatH6',\n          'CMD+ENTER': 'insertHorizontalRule',\n          'CMD+K': 'linkDialog.show'\n        }\n      },\n      icons: {\n        'align': 'note-icon-align',\n        'alignCenter': 'note-icon-align-center',\n        'alignJustify': 'note-icon-align-justify',\n        'alignLeft': 'note-icon-align-left',\n        'alignRight': 'note-icon-align-right',\n        'indent': 'note-icon-align-indent',\n        'outdent': 'note-icon-align-outdent',\n        'arrowsAlt': 'note-icon-arrows-alt',\n        'bold': 'note-icon-bold',\n        'caret': 'note-icon-caret',\n        'circle': 'note-icon-circle',\n        'close': 'note-icon-close',\n        'code': 'note-icon-code',\n        'eraser': 'note-icon-eraser',\n        'font': 'note-icon-font',\n        'frame': 'note-icon-frame',\n        'italic': 'note-icon-italic',\n        'link': 'note-icon-link',\n        'unlink': 'note-icon-chain-broken',\n        'magic': 'note-icon-magic',\n        'menuCheck': 'note-icon-check',\n        'minus': 'note-icon-minus',\n        'orderedlist': 'note-icon-orderedlist',\n        'pencil': 'note-icon-pencil',\n        'picture': 'note-icon-picture',\n        'question': 'note-icon-question',\n        'redo': 'note-icon-redo',\n        'square': 'note-icon-square',\n        'strikethrough': 'note-icon-strikethrough',\n        'subscript': 'note-icon-subscript',\n        'superscript': 'note-icon-superscript',\n        'table': 'note-icon-table',\n        'textHeight': 'note-icon-text-height',\n        'trash': 'note-icon-trash',\n        'underline': 'note-icon-underline',\n        'undo': 'note-icon-undo',\n        'unorderedlist': 'note-icon-unorderedlist',\n        'video': 'note-icon-video'\n      }\n    }\n  });\n\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/anniel/Workspace/rede_gsti/resources/~/summernote/dist/summernote.js\n ** module id = 80\n ** module chunks = 2\n **/","module.exports = __webpack_amd_options__;\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/buildin/amd-options.js\n ** module id = 81\n ** module chunks = 2\n **/","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: http://codemirror.net/LICENSE\n\n// This is CodeMirror (http://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    module.exports = mod();\n  else if (typeof define == \"function\" && define.amd) // AMD\n    return define([], mod);\n  else // Plain browser env\n    (this || window).CodeMirror = mod();\n})(function() {\n  \"use strict\";\n\n  // BROWSER SNIFFING\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\n  var webkit = /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) presto_version = Number(presto_version[1]);\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // EDITOR CONSTRUCTOR\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") doc = new Doc(doc, options.mode, null, options.lineSeparator);\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    if (options.autofocus && !mobile) display.input.focus();\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    var cm = this;\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) setTimeout(function() { cm.display.input.reset(true); }, 20);\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || cm.hasFocus())\n      setTimeout(bind(onFocus, this), 20);\n    else\n      onBlur(this);\n\n    for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\n      optionHandlers[opt](this, options[opt], Init);\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) options.finishInit(this);\n    for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      display.lineDiv.style.textRendering = \"auto\";\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = elt(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [elt(\"div\", [d.lineSpace], \"CodeMirror-lines\")], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) d.scroller.draggable = true;\n\n    if (place) {\n      if (place.appendChild) place.appendChild(d.wrapper);\n      else place(d.wrapper);\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    input.init(d);\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line)) return 0;\n\n      var widgetsHeight = 0;\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\n      }\n\n      if (wrapping)\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return widgetsHeight + th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find(0, true);\n      len -= cur.text.length - found.from.ch;\n      cur = found.to.line;\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    };\n  }\n\n  function NativeScrollbars(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function() {\n      if (vert.clientHeight) scroll(vert.scrollTop, \"vertical\");\n    });\n    on(horiz, \"scroll\", function() {\n      if (horiz.clientWidth) scroll(horiz.scrollLeft, \"horizontal\");\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n  }\n\n  NativeScrollbars.prototype = copyObj({\n    update: function(measure) {\n      var needsH = measure.scrollWidth > measure.clientWidth + 1;\n      var needsV = measure.scrollHeight > measure.clientHeight + 1;\n      var sWidth = measure.nativeBarWidth;\n\n      if (needsV) {\n        this.vert.style.display = \"block\";\n        this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n        var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n        // A bug in IE8 can cause this value to be negative, so guard it.\n        this.vert.firstChild.style.height =\n          Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n      } else {\n        this.vert.style.display = \"\";\n        this.vert.firstChild.style.height = \"0\";\n      }\n\n      if (needsH) {\n        this.horiz.style.display = \"block\";\n        this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n        this.horiz.style.left = measure.barLeft + \"px\";\n        var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n        this.horiz.firstChild.style.width =\n          (measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n      } else {\n        this.horiz.style.display = \"\";\n        this.horiz.firstChild.style.width = \"0\";\n      }\n\n      if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n        if (sWidth == 0) this.zeroWidthHack();\n        this.checkedZeroWidth = true;\n      }\n\n      return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0};\n    },\n    setScrollLeft: function(pos) {\n      if (this.horiz.scrollLeft != pos) this.horiz.scrollLeft = pos;\n      if (this.disableHoriz) this.enableZeroWidthBar(this.horiz, this.disableHoriz);\n    },\n    setScrollTop: function(pos) {\n      if (this.vert.scrollTop != pos) this.vert.scrollTop = pos;\n      if (this.disableVert) this.enableZeroWidthBar(this.vert, this.disableVert);\n    },\n    zeroWidthHack: function() {\n      var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n      this.horiz.style.height = this.vert.style.width = w;\n      this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n      this.disableHoriz = new Delayed;\n      this.disableVert = new Delayed;\n    },\n    enableZeroWidthBar: function(bar, delay) {\n      bar.style.pointerEvents = \"auto\";\n      function maybeDisable() {\n        // To find out whether the scrollbar is still visible, we\n        // check whether the element under the pixel in the bottom\n        // left corner of the scrollbar box is the scrollbar box\n        // itself (when the bar is still visible) or its filler child\n        // (when the bar is hidden). If it is still visible, we keep\n        // it enabled, if it's hidden, we disable pointer events.\n        var box = bar.getBoundingClientRect();\n        var elt = document.elementFromPoint(box.left + 1, box.bottom - 1);\n        if (elt != bar) bar.style.pointerEvents = \"none\";\n        else delay.set(1000, maybeDisable);\n      }\n      delay.set(1000, maybeDisable);\n    },\n    clear: function() {\n      var parent = this.horiz.parentNode;\n      parent.removeChild(this.horiz);\n      parent.removeChild(this.vert);\n    }\n  }, NativeScrollbars.prototype);\n\n  function NullScrollbars() {}\n\n  NullScrollbars.prototype = copyObj({\n    update: function() { return {bottom: 0, right: 0}; },\n    setScrollLeft: function() {},\n    setScrollTop: function() {},\n    clear: function() {}\n  }, NullScrollbars.prototype);\n\n  CodeMirror.scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n    }\n\n    cm.display.scrollbars = new CodeMirror.scrollbarModel[cm.options.scrollbarStyle](function(node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function() {\n        if (cm.state.focused) setTimeout(function() { cm.display.input.focus(); }, 0);\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function(pos, axis) {\n      if (axis == \"horizontal\") setScrollLeft(cm, pos);\n      else setScrollTop(cm, pos);\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n  }\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) measure = measureForScrollbars(cm);\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        updateHeightsInViewport(cm);\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\"\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else d.scrollbarFiller.style.display = \"\";\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else d.gutterFiller.style.display = \"\";\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)};\n  }\n\n  // LINE NUMBERS\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          view[i].gutter.style.left = left;\n        if (view[i].gutterBackground)\n          view[i].gutterBackground.style.left = left;\n      }\n      var align = view[i].alignable;\n      if (align) for (var j = 0; j < align.length; j++)\n        align[j].style.left = left;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + \"px\";\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  }\n\n  // DISPLAY DRAWING\n\n  function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  }\n\n  DisplayUpdate.prototype.signal = function(emitter, type) {\n    if (hasHandler(emitter, type))\n      this.events.push(arguments);\n  };\n  DisplayUpdate.prototype.finish = function() {\n    for (var i = 0; i < this.events.length; i++)\n      signal.apply(null, this.events[i]);\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      return false;\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      return false;\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var focused = activeElt();\n    if (toUpdate > 4) display.lineDiv.style.display = \"none\";\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) display.lineDiv.style.display = \"\";\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)};\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          break;\n      }\n      if (!updateDisplayIfNeeded(cm, update)) break;\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], height;\n      if (cur.hidden) continue;\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n      }\n      var diff = cur.line.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\n          updateWidgetHeight(cur.rest[j]);\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\n      line.widgets[i].height = line.widgets[i].node.parentNode.offsetHeight;\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        node.style.display = \"none\";\n      else\n        node.parentNode.removeChild(node);\n      return next;\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) {\n      } else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) cur = rm(cur);\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) updateNumber = false;\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) cur = rm(cur);\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") updateLineText(cm, lineView);\n      else if (type == \"gutter\") updateLineGutter(cm, lineView, lineN, dims);\n      else if (type == \"class\") updateLineClasses(lineView);\n      else if (type == \"widget\") updateLineWidgets(cm, lineView, dims);\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\n    }\n    return lineView.node;\n  }\n\n  function updateLineBackground(lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) cls += \" CodeMirror-linebackground\";\n    if (lineView.background) {\n      if (cls) lineView.background.className = cls;\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n    return buildLineContent(cm, lineView);\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) lineView.node = built.pre;\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(lineView) {\n    updateLineBackground(lineView);\n    if (lineView.line.wrapClass)\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    else if (lineView.node != lineView.text)\n      lineView.node.className = \"\";\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) +\n                                      \"px; width: \" + dims.gutterTotalWidth + \"px\");\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \"\n              + cm.display.lineNumInnerWidth + \"px\"));\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" +\n                                     dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n      }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) lineView.alignable = null;\n    for (var node = lineView.node.firstChild, next; node; node = next) {\n      var next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        lineView.node.removeChild(node);\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) lineView.bgClass = built.bgClass;\n    if (built.textClass) lineView.textClass = built.textClass;\n\n    updateLineClasses(lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node;\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n      insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) return;\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) node.setAttribute(\"cm-ignore-events\", \"true\");\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n    }\n  }\n\n  // POSITION OBJECT\n\n  // A Pos instance represents a position within the text.\n  var Pos = CodeMirror.Pos = function(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  };\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\n\n  function copyPos(x) {return Pos(x.line, x.ch);}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\n\n  // INPUT HANDLING\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) sel = doc.sel;\n\n    var paste = cm.state.pasteIncoming || origin == \"paste\";\n    var textLines = doc.splitLines(inserted), multiPaste = null\n    // When pasing N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            multiPaste.push(doc.splitLines(lastCopied.text[i]));\n        }\n      } else if (textLines.length == sel.ranges.length) {\n        multiPaste = map(textLines, function(l) { return [l]; });\n      }\n    }\n\n    // Normal behavior is to insert the new text into every selection\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      var from = range.from(), to = range.to();\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          from = Pos(from.line, from.ch - deleted);\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n        else if (lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n          from = to = Pos(from.line, 0)\n      }\n      var updateInput = cm.curOp.updateInput;\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      triggerElectric(cm, inserted);\n\n    ensureCursorVisible(cm);\n    cm.curOp.updateInput = updateInput;\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        runInOp(cm, function() { applyTextInput(cm, pasted, 0, null, \"paste\"); });\n      return true;\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) return;\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) continue;\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break;\n          }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))\n          indented = indentLine(cm, range.head.line, \"smart\");\n      }\n      if (indented) signalLater(cm, \"electricInput\", cm, range.head.line);\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges};\n  }\n\n  function disableBrowserMagic(field, spellcheck) {\n    field.setAttribute(\"autocorrect\", \"off\");\n    field.setAttribute(\"autocapitalize\", \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  function TextareaInput(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Tracks when input.reset has punted to just putting a short\n    // string into the textarea instead of the full selection.\n    this.inaccurateSelection = false;\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) te.style.width = \"1000px\";\n    else te.setAttribute(\"wrap\", \"off\");\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) te.style.border = \"1px solid black\";\n    disableBrowserMagic(te);\n    return div;\n  }\n\n  TextareaInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = this.cm;\n\n      // Wraps and hides input textarea\n      var div = this.wrapper = hiddenTextarea();\n      // The semihidden textarea that is focused when the editor is\n      // focused, and receives input.\n      var te = this.textarea = div.firstChild;\n      display.wrapper.insertBefore(div, display.wrapper.firstChild);\n\n      // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n      if (ios) te.style.width = \"0px\";\n\n      on(te, \"input\", function() {\n        if (ie && ie_version >= 9 && input.hasSelection) input.hasSelection = null;\n        input.poll();\n      });\n\n      on(te, \"paste\", function(e) {\n        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n\n        cm.state.pasteIncoming = true;\n        input.fastPoll();\n      });\n\n      function prepareCopyCut(e) {\n        if (signalDOMEvent(cm, e)) return\n        if (cm.somethingSelected()) {\n          lastCopied = {lineWise: false, text: cm.getSelections()};\n          if (input.inaccurateSelection) {\n            input.prevInput = \"\";\n            input.inaccurateSelection = false;\n            te.value = lastCopied.text.join(\"\\n\");\n            selectInput(te);\n          }\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = {lineWise: true, text: ranges.text};\n          if (e.type == \"cut\") {\n            cm.setSelections(ranges.ranges, null, sel_dontScroll);\n          } else {\n            input.prevInput = \"\";\n            te.value = ranges.text.join(\"\\n\");\n            selectInput(te);\n          }\n        }\n        if (e.type == \"cut\") cm.state.cutIncoming = true;\n      }\n      on(te, \"cut\", prepareCopyCut);\n      on(te, \"copy\", prepareCopyCut);\n\n      on(display.scroller, \"paste\", function(e) {\n        if (eventInWidget(display, e) || signalDOMEvent(cm, e)) return;\n        cm.state.pasteIncoming = true;\n        input.focus();\n      });\n\n      // Prevent normal selection in the editor (we handle our own)\n      on(display.lineSpace, \"selectstart\", function(e) {\n        if (!eventInWidget(display, e)) e_preventDefault(e);\n      });\n\n      on(te, \"compositionstart\", function() {\n        var start = cm.getCursor(\"from\");\n        if (input.composing) input.composing.range.clear()\n        input.composing = {\n          start: start,\n          range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n        };\n      });\n      on(te, \"compositionend\", function() {\n        if (input.composing) {\n          input.poll();\n          input.composing.range.clear();\n          input.composing = null;\n        }\n      });\n    },\n\n    prepareSelection: function() {\n      // Redraw the selection and/or cursor\n      var cm = this.cm, display = cm.display, doc = cm.doc;\n      var result = prepareSelection(cm);\n\n      // Move the hidden textarea near the cursor to prevent scrolling artifacts\n      if (cm.options.moveInputWithCursor) {\n        var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n        var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n        result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                            headPos.top + lineOff.top - wrapOff.top));\n        result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                             headPos.left + lineOff.left - wrapOff.left));\n      }\n\n      return result;\n    },\n\n    showSelection: function(drawn) {\n      var cm = this.cm, display = cm.display;\n      removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n      removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n      if (drawn.teTop != null) {\n        this.wrapper.style.top = drawn.teTop + \"px\";\n        this.wrapper.style.left = drawn.teLeft + \"px\";\n      }\n    },\n\n    // Reset the input to correspond to the selection (or to be empty,\n    // when not typing and nothing is selected)\n    reset: function(typing) {\n      if (this.contextMenuPending) return;\n      var minimal, selected, cm = this.cm, doc = cm.doc;\n      if (cm.somethingSelected()) {\n        this.prevInput = \"\";\n        var range = doc.sel.primary();\n        minimal = hasCopyEvent &&\n          (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\n        var content = minimal ? \"-\" : selected || cm.getSelection();\n        this.textarea.value = content;\n        if (cm.state.focused) selectInput(this.textarea);\n        if (ie && ie_version >= 9) this.hasSelection = content;\n      } else if (!typing) {\n        this.prevInput = this.textarea.value = \"\";\n        if (ie && ie_version >= 9) this.hasSelection = null;\n      }\n      this.inaccurateSelection = minimal;\n    },\n\n    getField: function() { return this.textarea; },\n\n    supportsTouch: function() { return false; },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n        try { this.textarea.focus(); }\n        catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n      }\n    },\n\n    blur: function() { this.textarea.blur(); },\n\n    resetPosition: function() {\n      this.wrapper.style.top = this.wrapper.style.left = 0;\n    },\n\n    receivedFocus: function() { this.slowPoll(); },\n\n    // Poll for input changes, using the normal rate of polling. This\n    // runs as long as the editor is focused.\n    slowPoll: function() {\n      var input = this;\n      if (input.pollingFast) return;\n      input.polling.set(this.cm.options.pollInterval, function() {\n        input.poll();\n        if (input.cm.state.focused) input.slowPoll();\n      });\n    },\n\n    // When an event has just come in that is likely to add or change\n    // something in the input textarea, we poll faster, to ensure that\n    // the change appears on the screen quickly.\n    fastPoll: function() {\n      var missed = false, input = this;\n      input.pollingFast = true;\n      function p() {\n        var changed = input.poll();\n        if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n        else {input.pollingFast = false; input.slowPoll();}\n      }\n      input.polling.set(20, p);\n    },\n\n    // Read input from the textarea, and update the document to match.\n    // When something is selected, it is present in the textarea, and\n    // selected (unless it is huge, in which case a placeholder is\n    // used). When nothing is selected, the cursor sits after previously\n    // seen text (can be empty), which is stored in prevInput (we must\n    // not reset the textarea when typing, because that breaks IME).\n    poll: function() {\n      var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n      // Since this is called a *lot*, try to bail out as cheaply as\n      // possible when it is clear that nothing happened. hasSelection\n      // will be the case when there is a lot of text in the textarea,\n      // in which case reading its value would be expensive.\n      if (this.contextMenuPending || !cm.state.focused ||\n          (hasSelection(input) && !prevInput && !this.composing) ||\n          cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n        return false;\n\n      var text = input.value;\n      // If nothing changed, bail.\n      if (text == prevInput && !cm.somethingSelected()) return false;\n      // Work around nonsensical selection resetting in IE9/10, and\n      // inexplicable appearance of private area unicode characters on\n      // some key combos in Mac (#2689).\n      if (ie && ie_version >= 9 && this.hasSelection === text ||\n          mac && /[\\uf700-\\uf7ff]/.test(text)) {\n        cm.display.input.reset();\n        return false;\n      }\n\n      if (cm.doc.sel == cm.display.selForContextMenu) {\n        var first = text.charCodeAt(0);\n        if (first == 0x200b && !prevInput) prevInput = \"\\u200b\";\n        if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\"); }\n      }\n      // Find the part of the input that is actually new\n      var same = 0, l = Math.min(prevInput.length, text.length);\n      while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n\n      var self = this;\n      runInOp(cm, function() {\n        applyTextInput(cm, text.slice(same), prevInput.length - same,\n                       null, self.composing ? \"*compose\" : null);\n\n        // Don't leave long text in the textarea, since it makes further polling slow\n        if (text.length > 1000 || text.indexOf(\"\\n\") > -1) input.value = self.prevInput = \"\";\n        else self.prevInput = text;\n\n        if (self.composing) {\n          self.composing.range.clear();\n          self.composing.range = cm.markText(self.composing.start, cm.getCursor(\"to\"),\n                                             {className: \"CodeMirror-composing\"});\n        }\n      });\n      return true;\n    },\n\n    ensurePolled: function() {\n      if (this.pollingFast && this.poll()) this.pollingFast = false;\n    },\n\n    onKeyPress: function() {\n      if (ie && ie_version >= 9) this.hasSelection = null;\n      this.fastPoll();\n    },\n\n    onContextMenu: function(e) {\n      var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n      var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n      if (!pos || presto) return; // Opera is difficult.\n\n      // Reset the current text selection only if the click is done outside of the selection\n      // and 'resetSelectionOnContextMenu' option is true.\n      var reset = cm.options.resetSelectionOnContextMenu;\n      if (reset && cm.doc.sel.contains(pos) == -1)\n        operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n\n      var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n      input.wrapper.style.cssText = \"position: absolute\"\n      var wrapperBox = input.wrapper.getBoundingClientRect()\n      te.style.cssText = \"position: absolute; width: 30px; height: 30px; top: \" + (e.clientY - wrapperBox.top - 5) +\n        \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px; z-index: 1000; background: \" +\n        (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") +\n        \"; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n      if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\n      display.input.focus();\n      if (webkit) window.scrollTo(null, oldScrollY);\n      display.input.reset();\n      // Adds \"Select all\" to context menu in FF\n      if (!cm.somethingSelected()) te.value = input.prevInput = \" \";\n      input.contextMenuPending = true;\n      display.selForContextMenu = cm.doc.sel;\n      clearTimeout(display.detectingSelectAll);\n\n      // Select-all will be greyed out if there's nothing to select, so\n      // this adds a zero-width space so that we can later check whether\n      // it got selected.\n      function prepareSelectAllHack() {\n        if (te.selectionStart != null) {\n          var selected = cm.somethingSelected();\n          var extval = \"\\u200b\" + (selected ? te.value : \"\");\n          te.value = \"\\u21da\"; // Used to catch context-menu undo\n          te.value = extval;\n          input.prevInput = selected ? \"\" : \"\\u200b\";\n          te.selectionStart = 1; te.selectionEnd = extval.length;\n          // Re-set this, in case some other handler touched the\n          // selection in the meantime.\n          display.selForContextMenu = cm.doc.sel;\n        }\n      }\n      function rehide() {\n        input.contextMenuPending = false;\n        input.wrapper.style.cssText = oldWrapperCSS\n        te.style.cssText = oldCSS;\n        if (ie && ie_version < 9) display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n\n        // Try to detect the user choosing select-all\n        if (te.selectionStart != null) {\n          if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\n          var i = 0, poll = function() {\n            if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n                te.selectionEnd > 0 && input.prevInput == \"\\u200b\")\n              operation(cm, commands.selectAll)(cm);\n            else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\n            else display.input.reset();\n          };\n          display.detectingSelectAll = setTimeout(poll, 200);\n        }\n      }\n\n      if (ie && ie_version >= 9) prepareSelectAllHack();\n      if (captureRightClick) {\n        e_stop(e);\n        var mouseup = function() {\n          off(window, \"mouseup\", mouseup);\n          setTimeout(rehide, 20);\n        };\n        on(window, \"mouseup\", mouseup);\n      } else {\n        setTimeout(rehide, 50);\n      }\n    },\n\n    readOnlyChanged: function(val) {\n      if (!val) this.reset();\n    },\n\n    setUneditable: nothing,\n\n    needsContentAttribute: false\n  }, TextareaInput.prototype);\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  function ContentEditableInput(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.gracePeriod = false;\n  }\n\n  ContentEditableInput.prototype = copyObj({\n    init: function(display) {\n      var input = this, cm = input.cm;\n      var div = input.div = display.lineDiv;\n      disableBrowserMagic(div, cm.options.spellcheck);\n\n      on(div, \"paste\", function(e) {\n        if (signalDOMEvent(cm, e) || handlePaste(e, cm)) return\n        // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n        if (ie_version <= 11) setTimeout(operation(cm, function() {\n          if (!input.pollContent()) regChange(cm);\n        }), 20)\n      })\n\n      on(div, \"compositionstart\", function(e) {\n        var data = e.data;\n        input.composing = {sel: cm.doc.sel, data: data, startData: data};\n        if (!data) return;\n        var prim = cm.doc.sel.primary();\n        var line = cm.getLine(prim.head.line);\n        var found = line.indexOf(data, Math.max(0, prim.head.ch - data.length));\n        if (found > -1 && found <= prim.head.ch)\n          input.composing.sel = simpleSelection(Pos(prim.head.line, found),\n                                                Pos(prim.head.line, found + data.length));\n      });\n      on(div, \"compositionupdate\", function(e) {\n        input.composing.data = e.data;\n      });\n      on(div, \"compositionend\", function(e) {\n        var ours = input.composing;\n        if (!ours) return;\n        if (e.data != ours.startData && !/\\u200b/.test(e.data))\n          ours.data = e.data;\n        // Need a small delay to prevent other code (input event,\n        // selection polling) from doing damage when fired right after\n        // compositionend.\n        setTimeout(function() {\n          if (!ours.handled)\n            input.applyComposition(ours);\n          if (input.composing == ours)\n            input.composing = null;\n        }, 50);\n      });\n\n      on(div, \"touchstart\", function() {\n        input.forceCompositionEnd();\n      });\n\n      on(div, \"input\", function() {\n        if (input.composing) return;\n        if (cm.isReadOnly() || !input.pollContent())\n          runInOp(input.cm, function() {regChange(cm);});\n      });\n\n      function onCopyCut(e) {\n        if (signalDOMEvent(cm, e)) return\n        if (cm.somethingSelected()) {\n          lastCopied = {lineWise: false, text: cm.getSelections()};\n          if (e.type == \"cut\") cm.replaceSelection(\"\", null, \"cut\");\n        } else if (!cm.options.lineWiseCopyCut) {\n          return;\n        } else {\n          var ranges = copyableRanges(cm);\n          lastCopied = {lineWise: true, text: ranges.text};\n          if (e.type == \"cut\") {\n            cm.operation(function() {\n              cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n              cm.replaceSelection(\"\", null, \"cut\");\n            });\n          }\n        }\n        if (e.clipboardData) {\n          e.clipboardData.clearData();\n          var content = lastCopied.text.join(\"\\n\")\n          // iOS exposes the clipboard API, but seems to discard content inserted into it\n          e.clipboardData.setData(\"Text\", content);\n          if (e.clipboardData.getData(\"Text\") == content) {\n            e.preventDefault();\n            return\n          }\n        }\n        // Old-fashioned briefly-focus-a-textarea hack\n        var kludge = hiddenTextarea(), te = kludge.firstChild;\n        cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n        te.value = lastCopied.text.join(\"\\n\");\n        var hadFocus = document.activeElement;\n        selectInput(te);\n        setTimeout(function() {\n          cm.display.lineSpace.removeChild(kludge);\n          hadFocus.focus();\n          if (hadFocus == div) input.showPrimarySelection()\n        }, 50);\n      }\n      on(div, \"copy\", onCopyCut);\n      on(div, \"cut\", onCopyCut);\n    },\n\n    prepareSelection: function() {\n      var result = prepareSelection(this.cm, false);\n      result.focus = this.cm.state.focused;\n      return result;\n    },\n\n    showSelection: function(info, takeFocus) {\n      if (!info || !this.cm.display.view.length) return;\n      if (info.focus || takeFocus) this.showPrimarySelection();\n      this.showMultipleSelections(info);\n    },\n\n    showPrimarySelection: function() {\n      var sel = window.getSelection(), prim = this.cm.doc.sel.primary();\n      var curAnchor = domToPos(this.cm, sel.anchorNode, sel.anchorOffset);\n      var curFocus = domToPos(this.cm, sel.focusNode, sel.focusOffset);\n      if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n          cmp(minPos(curAnchor, curFocus), prim.from()) == 0 &&\n          cmp(maxPos(curAnchor, curFocus), prim.to()) == 0)\n        return;\n\n      var start = posToDOM(this.cm, prim.from());\n      var end = posToDOM(this.cm, prim.to());\n      if (!start && !end) return;\n\n      var view = this.cm.display.view;\n      var old = sel.rangeCount && sel.getRangeAt(0);\n      if (!start) {\n        start = {node: view[0].measure.map[2], offset: 0};\n      } else if (!end) { // FIXME dangerously hacky\n        var measure = view[view.length - 1].measure;\n        var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n        end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};\n      }\n\n      try { var rng = range(start.node, start.offset, end.offset, end.node); }\n      catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n      if (rng) {\n        if (!gecko && this.cm.state.focused) {\n          sel.collapse(start.node, start.offset);\n          if (!rng.collapsed) sel.addRange(rng);\n        } else {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n        if (old && sel.anchorNode == null) sel.addRange(old);\n        else if (gecko) this.startGracePeriod();\n      }\n      this.rememberSelection();\n    },\n\n    startGracePeriod: function() {\n      var input = this;\n      clearTimeout(this.gracePeriod);\n      this.gracePeriod = setTimeout(function() {\n        input.gracePeriod = false;\n        if (input.selectionChanged())\n          input.cm.operation(function() { input.cm.curOp.selectionChanged = true; });\n      }, 20);\n    },\n\n    showMultipleSelections: function(info) {\n      removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n      removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n    },\n\n    rememberSelection: function() {\n      var sel = window.getSelection();\n      this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n      this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n    },\n\n    selectionInEditor: function() {\n      var sel = window.getSelection();\n      if (!sel.rangeCount) return false;\n      var node = sel.getRangeAt(0).commonAncestorContainer;\n      return contains(this.div, node);\n    },\n\n    focus: function() {\n      if (this.cm.options.readOnly != \"nocursor\") this.div.focus();\n    },\n    blur: function() { this.div.blur(); },\n    getField: function() { return this.div; },\n\n    supportsTouch: function() { return true; },\n\n    receivedFocus: function() {\n      var input = this;\n      if (this.selectionInEditor())\n        this.pollSelection();\n      else\n        runInOp(this.cm, function() { input.cm.curOp.selectionChanged = true; });\n\n      function poll() {\n        if (input.cm.state.focused) {\n          input.pollSelection();\n          input.polling.set(input.cm.options.pollInterval, poll);\n        }\n      }\n      this.polling.set(this.cm.options.pollInterval, poll);\n    },\n\n    selectionChanged: function() {\n      var sel = window.getSelection();\n      return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n        sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n    },\n\n    pollSelection: function() {\n      if (!this.composing && !this.gracePeriod && this.selectionChanged()) {\n        var sel = window.getSelection(), cm = this.cm;\n        this.rememberSelection();\n        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n        var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n        if (anchor && head) runInOp(cm, function() {\n          setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n          if (anchor.bad || head.bad) cm.curOp.selectionChanged = true;\n        });\n      }\n    },\n\n    pollContent: function() {\n      var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n      var from = sel.from(), to = sel.to();\n      if (from.line < display.viewFrom || to.line > display.viewTo - 1) return false;\n\n      var fromIndex;\n      if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n        var fromLine = lineNo(display.view[0].line);\n        var fromNode = display.view[0].node;\n      } else {\n        var fromLine = lineNo(display.view[fromIndex].line);\n        var fromNode = display.view[fromIndex - 1].node.nextSibling;\n      }\n      var toIndex = findViewIndex(cm, to.line);\n      if (toIndex == display.view.length - 1) {\n        var toLine = display.viewTo - 1;\n        var toNode = display.lineDiv.lastChild;\n      } else {\n        var toLine = lineNo(display.view[toIndex + 1].line) - 1;\n        var toNode = display.view[toIndex + 1].node.previousSibling;\n      }\n\n      var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n      var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n      while (newText.length > 1 && oldText.length > 1) {\n        if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n        else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n        else break;\n      }\n\n      var cutFront = 0, cutEnd = 0;\n      var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n      while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n        ++cutFront;\n      var newBot = lst(newText), oldBot = lst(oldText);\n      var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                               oldBot.length - (oldText.length == 1 ? cutFront : 0));\n      while (cutEnd < maxCutEnd &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n        ++cutEnd;\n\n      newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd);\n      newText[0] = newText[0].slice(cutFront);\n\n      var chFrom = Pos(fromLine, cutFront);\n      var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n      if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n        replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n        return true;\n      }\n    },\n\n    ensurePolled: function() {\n      this.forceCompositionEnd();\n    },\n    reset: function() {\n      this.forceCompositionEnd();\n    },\n    forceCompositionEnd: function() {\n      if (!this.composing || this.composing.handled) return;\n      this.applyComposition(this.composing);\n      this.composing.handled = true;\n      this.div.blur();\n      this.div.focus();\n    },\n    applyComposition: function(composing) {\n      if (this.cm.isReadOnly())\n        operation(this.cm, regChange)(this.cm)\n      else if (composing.data && composing.data != composing.startData)\n        operation(this.cm, applyTextInput)(this.cm, composing.data, 0, composing.sel);\n    },\n\n    setUneditable: function(node) {\n      node.contentEditable = \"false\"\n    },\n\n    onKeyPress: function(e) {\n      e.preventDefault();\n      if (!this.cm.isReadOnly())\n        operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n    },\n\n    readOnlyChanged: function(val) {\n      this.div.contentEditable = String(val != \"nocursor\")\n    },\n\n    onContextMenu: nothing,\n    resetPosition: nothing,\n\n    needsContentAttribute: true\n  }, ContentEditableInput.prototype);\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) return null;\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result;\n  }\n\n  function badPos(pos, bad) { if (bad) pos.bad = true; return pos; }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) return null;\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break;\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        return locateNodeInLineView(lineView, node, offset);\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), true);\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad);\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) offset = textNode.nodeValue.length;\n    }\n    while (topNode.parentNode != wrapper) topNode = topNode.parentNode;\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n            if (offset < 0 || curNode != textNode) ch = map[j + (offset ? 1 : 0)];\n            return Pos(line, ch);\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) return badPos(found, bad);\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        return badPos(Pos(found.line, found.ch - dist), bad);\n      else\n        dist += after.textContent.length;\n    }\n    for (var before = topNode.previousSibling, dist = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        return badPos(Pos(found.line, found.ch + dist), bad);\n      else\n        dist += before.textContent.length;\n    }\n  }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator();\n    function recognizeMarker(id) { return function(marker) { return marker.id == id; }; }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText != null) {\n          if (cmText == \"\") cmText = node.textContent.replace(/\\u200b/g, \"\");\n          text += cmText;\n          return;\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range = found[0].find()))\n            text += getBetween(cm.doc, range.from, range.to).join(lineSep);\n          return;\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") return;\n        for (var i = 0; i < node.childNodes.length; i++)\n          walk(node.childNodes[i]);\n        if (/^(pre|div|p)$/i.test(node.nodeName))\n          closing = true;\n      } else if (node.nodeType == 3) {\n        var val = node.nodeValue;\n        if (!val) return;\n        if (closing) {\n          text += lineSep;\n          closing = false;\n        }\n        text += val;\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) break;\n      from = from.nextSibling;\n    }\n    return text;\n  }\n\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // SELECTION / CURSOR\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  }\n\n  Selection.prototype = {\n    primary: function() { return this.ranges[this.primIndex]; },\n    equals: function(other) {\n      if (other == this) return true;\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var here = this.ranges[i], there = other.ranges[i];\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\n      }\n      return true;\n    },\n    deepCopy: function() {\n      for (var out = [], i = 0; i < this.ranges.length; i++)\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n      return new Selection(out, this.primIndex);\n    },\n    somethingSelected: function() {\n      for (var i = 0; i < this.ranges.length; i++)\n        if (!this.ranges[i].empty()) return true;\n      return false;\n    },\n    contains: function(pos, end) {\n      if (!end) end = pos;\n      for (var i = 0; i < this.ranges.length; i++) {\n        var range = this.ranges[i];\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n          return i;\n      }\n      return -1;\n    }\n  };\n\n  function Range(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  }\n\n  Range.prototype = {\n    from: function() { return minPos(this.anchor, this.head); },\n    to: function() { return maxPos(this.anchor, this.head); },\n    empty: function() {\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n    }\n  };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(ranges, primIndex) {\n    var prim = ranges[primIndex];\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      if (cmp(prev.to(), cur.from()) >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) --primIndex;\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n  function clipPosArray(doc, array) {\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\n    return out;\n  }\n\n  // SELECTION UPDATES\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(doc, range, head, other) {\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options) {\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head));\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\n    else return sel;\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      sel = filterSelectionChange(doc, sel, options);\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      ensureCursorVisible(doc.cm);\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) return;\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) out = sel.ranges.slice(0, i);\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) break;\n            else {--i; continue;}\n          }\n        }\n        if (!m.atomic) continue;\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff;\n          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n            near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            return skipAtomicInner(doc, near, pos, dir, mayClear);\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n          far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n      }\n    }\n    return pos;\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0);\n    }\n    return found;\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) return clipPos(doc, Pos(pos.line - 1));\n      else return null;\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) return Pos(pos.line + 1, 0);\n      else return null;\n    } else {\n      return new Pos(pos.line, pos.ch + dir);\n    }\n  }\n\n  // SELECTION DRAWING\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (primary === false && i == doc.sel.primIndex) continue;\n      var range = doc.sel.ranges[i];\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) continue;\n      var collapsed = range.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        drawSelectionCursor(cm, range.head, curFragment);\n      if (!collapsed)\n        drawSelectionRange(cm, range, selFragment);\n    }\n    return result;\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left +\n                               \"px; top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) +\n                               \"px; height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, \"left\"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, \"right\");\n          if (dir == \"rtl\") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = leftSide;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = leftSide;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = rightSide;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < leftSide + 1) left = leftSide;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    var sFrom = range.from(), sTo = range.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    else if (cm.options.cursorBlinkRate < 0)\n      display.cursorDiv.style.visibility = \"hidden\";\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.viewTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changedLines = [];\n\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles, tooLong = line.text.length > cm.options.maxHighlightLength;\n        var highlighted = highlightLine(cm, line, tooLong ? copyState(doc.mode, state) : state, true);\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) line.styleClasses = newCls;\n        else if (oldCls) line.styleClasses = null;\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) changedLines.push(doc.frontier);\n        line.stateAfter = tooLong ? state : copyState(doc.mode, state);\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changedLines.length) runInOp(cm, function() {\n      for (var i = 0; i < changedLines.length; i++)\n        regLineChange(cm, changedLines[i], \"text\");\n    });\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingH(display) {\n    if (display.cachedPaddingH) return display.cachedPaddingH;\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\n    return data;\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth; }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineView.rest[i] == line)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\n    for (var i = 0; i < lineView.rest.length; i++)\n      if (lineNo(lineView.rest[i]) > lineN)\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      return cm.display.view[findViewIndex(cm, lineN)];\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      return ext;\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      view = updateExternalMeasurement(cm, line);\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    };\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) ch = -1;\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) prepared.cache[key] = found;\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom};\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map.length; i += 3) {\n      var mStart = map[i], mEnd = map[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) collapse = \"right\";\n      }\n      if (start != null) {\n        node = map[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          collapse = bias;\n        if (bias == \"left\" && start == 0)\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        if (bias == \"right\" && start == mEnd - mStart)\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        break;\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd};\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect\n    if (bias == \"left\") for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) break\n    } else for (var i = rects.length - 1; i >= 0; i--) {\n      if ((rect = rects[i]).left != rect.right) break\n    }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) --start;\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) ++end;\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          rect = node.parentNode.getBoundingClientRect();\n        else\n          rect = getUsefulRect(range(node, start, end).getClientRects(), bias)\n        if (rect.left || rect.right || start == 0) break;\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) collapse = bias = \"right\";\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      else\n        rect = node.getBoundingClientRect();\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\n      else\n        rect = nullRect;\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    for (var i = 0; i < heights.length - 1; i++)\n      if (mid < heights[i]) break;\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) result.bogus = true;\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result;\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      return rect;\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\n        lineView.measure.caches[i] = {};\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"/null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == \"line\") return rect;\n    if (!context) context = \"local\";\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"/null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0, pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find(0, true);\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineN = lineNo(lineObj = mergedPos.to.line);\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), \"line\", lineObj, preparedMeasure);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var outside = ch == from ? fromOutside : toOutside\n        var xDiff = x - (ch == from ? fromX : toX);\n        // This is a kludge to handle the case where the coordinates\n        // are after a line-wrapped line. We should replace it with a\n        // more general handling of cursor positions around line\n        // breaks. (Issue #4078)\n        if (toOutside && !bidi && !/\\s/.test(lineObj.text.charAt(ch)) && xDiff > 0 &&\n            ch < lineObj.text.length && preparedMeasure.view.measure.heights.length > 1) {\n          var charSize = measureCharPrepared(cm, preparedMeasure, ch, \"right\");\n          if (innerOff <= charSize.bottom && innerOff >= charSize.top && Math.abs(x - charSize.right) < xDiff) {\n            outside = false\n            ch++\n            xDiff = x - charSize.right\n          }\n        }\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, outside, xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var operationGroup = null;\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: null,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    if (operationGroup) {\n      operationGroup.ops.push(cm.curOp);\n    } else {\n      cm.curOp.ownsGroup = operationGroup = {\n        ops: [cm.curOp],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        callbacks[i].call(null);\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n      }\n    } while (i < callbacks.length);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp, group = op.ownsGroup;\n    if (!group) return;\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      for (var i = 0; i < group.ops.length; i++)\n        group.ops[i].cm.curOp = null;\n      endOperations(group);\n    }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W1(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_R2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\n      endOperation_W2(ops[i]);\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      endOperation_finish(ops[i]);\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) findMaxLine(cm);\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      op.preparedSelection = display.input.prepareSelection(op.focus);\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt() && (!document.hasFocus || document.hasFocus())\n    if (op.preparedSelection)\n      cm.display.input.showSelection(op.preparedSelection, takeFocus);\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      updateScrollbars(cm, op.barMeasure);\n    if (op.updatedDisplay)\n      setDocumentHeight(cm, op.barMeasure);\n\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      cm.display.input.reset(op.typing);\n    if (takeFocus) ensureFocus(op.cm);\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      display.wheelStartX = display.wheelStartY = null;\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\n      doc.scrollTop = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\n      display.scrollbars.setScrollTop(doc.scrollTop);\n      display.scroller.scrollTop = doc.scrollTop;\n    }\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\n      doc.scrollLeft = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));\n      display.scrollbars.setScrollLeft(doc.scrollLeft);\n      display.scroller.scrollLeft = doc.scrollLeft;\n      alignHorizontally(cm);\n    }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], \"hide\");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], \"unhide\");\n\n    if (display.wrapper.offsetHeight)\n      doc.scrollTop = cm.display.scroller.scrollTop;\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      signal(cm, \"changes\", cm, op.changeObjs);\n    if (op.update)\n      op.update.finish();\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) return f();\n    startOperation(cm);\n    try { return f(); }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) return f.apply(cm, arguments);\n      startOperation(cm);\n      try { return f.apply(cm, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) return f.apply(this, arguments);\n      startOperation(this);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(this); }\n    };\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) return f.apply(this, arguments);\n      startOperation(cm);\n      try { return f.apply(this, arguments); }\n      finally { endOperation(cm); }\n    };\n  }\n\n  // VIEW TRACKING\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array;\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    if (!lendiff) lendiff = 0;\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      display.updateLineNumbers = from;\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        resetView(cm);\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut = viewCuttingPoint(cm, from, from, -1);\n      if (cut) {\n        display.view = display.view.slice(0, cut.index);\n        display.viewTo = cut.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        ext.lineN += lendiff;\n      else if (from < ext.lineN + ext.size)\n        display.externalMeasured = null;\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      display.externalMeasured = null;\n\n    if (line < display.viewFrom || line >= display.viewTo) return;\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) return;\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) arr.push(type);\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) return null;\n    n -= cm.display.viewFrom;\n    if (n < 0) return null;\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) return i;\n    }\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      return {index: index, lineN: newN};\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\n      n += view[i].size;\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) return null;\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN};\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      else if (display.viewFrom < from)\n        display.view = display.view.slice(findViewIndex(cm, from));\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      else if (display.viewTo > to)\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\n    }\n    return dirty;\n  }\n\n  // EVENT HANDLERS\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      on(d.scroller, \"dblclick\", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    else\n      on(d.scroller, \"dblclick\", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    if (!captureRightClick) on(d.scroller, \"contextmenu\", function(e) {onContextMenu(cm, e);});\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function() {d.activeTouch = null;}, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    };\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) return false;\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\n    }\n    function farAway(touch, other) {\n      if (other.left == null) return true;\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20;\n    }\n    on(d.scroller, \"touchstart\", function(e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e)) {\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function() {\n      if (d.activeTouch) d.activeTouch.moved = true;\n    });\n    on(d.scroller, \"touchend\", function(e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          range = new Range(pos, pos);\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          range = cm.findWordAt(pos);\n        else // Triple tap\n          range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, \"DOMMouseScroll\", function(e){onScrollWheel(cm, e);});\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function(e) {if (!signalDOMEvent(cm, e)) e_stop(e);},\n      over: function(e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function(e){onDragStart(cm, e);},\n      drop: operation(cm, onDrop),\n      leave: function(e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function(e) { onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { onBlur(cm, e); });\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != CodeMirror.Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    if (d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth)\n      return;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  // MOUSE EVENTS\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        return true;\n    }\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") return null;\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null; }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords;\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) return;\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n    window.focus();\n\n    switch (e_button(e)) {\n    case 1:\n      // #3261: make sure, that we're not starting a second selection\n      if (cm.state.selectingText)\n        cm.state.selectingText(e);\n      else if (start)\n        leftButtonDown(cm, e, start);\n      else if (e_target(e) == display.scroller)\n        e_preventDefault(e);\n      break;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(function() {display.input.focus();}, 20);\n      e_preventDefault(e);\n      break;\n    case 3:\n      if (captureRightClick) onContextMenu(cm, e);\n      else delayBlurEvent(cm);\n      break;\n    }\n  }\n\n  var lastClick, lastDoubleClick;\n  function leftButtonDown(cm, e, start) {\n    if (ie) setTimeout(bind(ensureFocus, cm), 0);\n    else cm.curOp.focus = activeElt();\n\n    var now = +new Date, type;\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\n      type = \"triple\";\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\n      type = \"double\";\n      lastDoubleClick = {time: now, pos: start};\n    } else {\n      type = \"single\";\n      lastClick = {time: now, pos: start};\n    }\n\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        type == \"single\" && (contained = sel.contains(start)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), start) < 0 || start.xRel > 0) &&\n        (cmp(contained.to(), start) > 0 || start.xRel < 0))\n      leftButtonStartDrag(cm, e, start, modifier);\n    else\n      leftButtonSelect(cm, e, start, type, modifier);\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, e, start, modifier) {\n    var display = cm.display, startTime = +new Date;\n    var dragEnd = operation(cm, function(e2) {\n      if (webkit) display.scroller.draggable = false;\n      cm.state.draggingText = false;\n      off(document, \"mouseup\", dragEnd);\n      off(display.scroller, \"drop\", dragEnd);\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n        e_preventDefault(e2);\n        if (!modifier && +new Date - 200 < startTime)\n          extendSelection(cm.doc, start);\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          setTimeout(function() {document.body.focus(); display.input.focus();}, 20);\n        else\n          display.input.focus();\n      }\n    });\n    // Let the drag handler handle this.\n    if (webkit) display.scroller.draggable = true;\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = mac ? e.altKey : e.ctrlKey\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\n    on(document, \"mouseup\", dragEnd);\n    on(display.scroller, \"drop\", dragEnd);\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, e, start, type, addNew) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(e);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (addNew && !e.shiftKey) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        ourRange = ranges[ourIndex];\n      else\n        ourRange = new Range(start, start);\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (chromeOS ? e.shiftKey && e.metaKey : e.altKey) {\n      type = \"rect\";\n      if (!addNew) ourRange = new Range(start, start);\n      start = posFromMouse(cm, e, true, true);\n      ourIndex = -1;\n    } else if (type == \"double\") {\n      var word = cm.findWordAt(start);\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\n      else\n        ourRange = word;\n    } else if (type == \"triple\") {\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\n      if (cm.display.shift || doc.extend)\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\n      else\n        ourRange = line;\n    } else {\n      ourRange = extendRange(doc, ourRange, start);\n    }\n\n    if (!addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && type == \"single\" && !e.shiftKey) {\n      setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) return;\n      lastPos = pos;\n\n      if (type == \"rect\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          else if (text.length > leftPos)\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n        }\n        if (!ranges.length) ranges.push(new Range(start, start));\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var anchor = oldRange.anchor, head = pos;\n        if (type != \"single\") {\n          if (type == \"double\")\n            var range = cm.findWordAt(pos);\n          else\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\n          if (cmp(range.anchor, anchor) > 0) {\n            head = range.head;\n            anchor = minPos(oldRange.from(), range.anchor);\n          } else {\n            head = range.anchor;\n            anchor = maxPos(oldRange.to(), range.head);\n          }\n        }\n        var ranges = startSel.ranges.slice(0);\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, type == \"rect\");\n      if (!cur) return;\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      e_preventDefault(e);\n      display.input.focus();\n      off(document, \"mousemove\", move);\n      off(document, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function(e) {\n      if (!e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(document, \"mousemove\", move);\n    on(document, \"mouseup\", up);\n  }\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signal(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) return;\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          return;\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function() {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) content = \"\";\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function() {cm.display.input.focus();}, 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData(\"Text\");\n        if (text) {\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            var selected = cm.listSelections();\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) for (var i = 0; i < selected.length; ++i)\n            replaceRange(cm.doc, \"\", selected[i].anchor, selected[i].head, \"drag\");\n          cm.replaceSelection(text, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\"\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) img.parentNode.removeChild(img);\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) return;\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // SCROLL EVENTS\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplaySimple(cm, {top: val});\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (gecko) updateDisplaySimple(cm);\n    startWorker(cm, 100);\n  }\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  var wheelEventDelta = function(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n    return {x: dx, y: dy};\n  };\n  CodeMirror.wheelEventPixels = function(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta;\n  };\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // KEY EVENTS\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) cm.state.suppressEdits = true;\n      if (dropShift) cm.display.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) return result;\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm);\n  }\n\n  var stopSeq = new Delayed;\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) return \"handled\";\n      stopSeq.set(50, function() {\n        if (cm.state.keySeq == seq) {\n          cm.state.keySeq = null;\n          cm.display.input.reset();\n        }\n      });\n      name = seq + \" \" + name;\n    }\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      cm.state.keySeq = name;\n    if (result == \"handled\")\n      signalLater(cm, \"keyHandled\", cm, name, e);\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    if (seq && !result && /\\'$/.test(name)) {\n      e_preventDefault(e);\n      return true;\n    }\n    return !!result;\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) return false;\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function(b) {return doHandleBinding(cm, b, true);})\n          || dispatchKey(cm, name, e, function(b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 return doHandleBinding(cm, b);\n             });\n    } else {\n      return dispatchKey(cm, name, e, function(b) { return doHandleBinding(cm, b); });\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e,\n                       function(b) { return doHandleBinding(cm, b, true); });\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) return;\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection(\"\", null, \"cut\");\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      showCrossHair(cm);\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) this.doc.sel.shift = false;\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    cm.display.input.onKeyPress(e);\n  }\n\n  // FOCUS/BLUR EVENTS\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function() {\n      if (cm.state.delayingBlurEvent) {\n        cm.state.delayingBlurEvent = false;\n        onBlur(cm);\n      }\n    }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent) cm.state.delayingBlurEvent = false;\n\n    if (cm.options.readOnly == \"nocursor\") return;\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) setTimeout(function() { cm.display.input.reset(true); }, 20); // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) return;\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) return;\n    if (signalDOMEvent(cm, e, \"contextmenu\")) return;\n    cm.display.input.onContextMenu(e);\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) return false;\n    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n  }\n\n  // UPDATING\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) return pos;\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    else\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex);\n  }\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) signal(doc.cm, \"beforeChange\", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text});\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) return;\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    if (doc.cm && doc.cm.state.suppressEdits && !allowSelectionOnly) return;\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    for (var i = 0; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        break;\n    }\n    if (i == source.length) return;\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return;\n        }\n        selAfter = event;\n      }\n      else break;\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return;\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) return;\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\n                       Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        regLineChange(doc.cm, l, \"gutter\");\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\n    else updateDoc(doc, change, spans);\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      signalCursorActivity(cm);\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      regChange(cm);\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      regLineChange(cm, from.line, \"text\");\n    else\n      regChange(cm, from.line, to.line + 1, lendiff);\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) signalLater(cm, \"change\", cm, obj);\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == \"string\") code = doc.splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, coords) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) return;\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, \"position: absolute; top: \" +\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + \"px; height: \" +\n                           (coords.bottom - coords.top + scrollGap(cm) + display.barHeight) + \"px; left: \" +\n                           coords.left + \"px; width: 2px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) break;\n    }\n    return coords;\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (y2 - y1 > screen) y2 = y1 + screen;\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = x2 - x1 > screenw;\n    if (tooWide) x2 = x1 + screenw;\n    if (x1 < 10)\n      result.scrollLeft = 0;\n    else if (x1 < screenleft)\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\n    else if (x2 > screenw + screenleft - 3)\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\n    return result;\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollPos(cm, left, top) {\n    if (left != null || top != null) resolveScrollToPos(cm);\n    if (left != null)\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\n    if (top != null)\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor(), from = cur, to = cur;\n    if (!cm.options.lineWrapping) {\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\n      to = Pos(cur.line, cur.ch + 1);\n    }\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\n                                    Math.min(from.top, to.top) - range.margin,\n                                    Math.max(from.right, to.right),\n                                    Math.max(from.bottom, to.bottom) + range.margin);\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n    }\n  }\n\n  // API UTILITIES\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) how = \"add\";\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) how = \"prev\";\n      else state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) line.stateAfter = null;\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) return;\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true;\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\n        var range = doc.sel.ranges[i];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i, new Range(pos, pos));\n          break;\n        }\n      }\n    }\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\n    return line;\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function() {\n      for (var i = kill.length - 1; i >= 0; i--)\n        replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      ensureCursorVisible(cm);\n    });\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return false\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return false\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == \"char\") {\n      moveOnce()\n    } else if (unit == \"column\") {\n      moveOnce(true)\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) type = \"s\";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), pos, origDir, true);\n    if (!cmp(pos, result)) result.hitSide = true;\n    return result;\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  // EDITOR METHODS\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); this.display.input.focus();},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != \"mode\") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || maps[i].name == map) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: methodOp(function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error(\"Overlays may not be stateful.\");\n      insertSorted(this.state.overlays,\n                   {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                    priority: (options && options.priority) || 0},\n                   function(overlay) { return overlay.priority })\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: methodOp(function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: methodOp(function(n, dir, aggressive) {\n      if (typeof dir != \"string\" && typeof dir != \"number\") {\n        if (dir == null) dir = this.options.smartIndent ? \"smart\" : \"prev\";\n        else dir = dir ? \"add\" : \"subtract\";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: methodOp(function(how) {\n      var ranges = this.doc.sel.ranges, end = -1;\n      for (var i = 0; i < ranges.length; i++) {\n        var range = ranges[i];\n        if (!range.empty()) {\n          var from = range.from(), to = range.to();\n          var start = Math.max(end, from.line);\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n          for (var j = start; j < end; ++j)\n            indentLine(this, j, how);\n          var newRanges = this.doc.sel.ranges;\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n        } else if (range.head.line > end) {\n          indentLine(this, range.head.line, how, true);\n          end = range.head.line;\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\n        }\n      }\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      return takeToken(this, pos, precise);\n    },\n\n    getLineTokens: function(line, precise) {\n      return takeToken(this, Pos(line), precise, true);\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      var type;\n      if (ch == 0) type = styles[2];\n      else for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else { type = styles[mid * 2 + 2]; break; }\n      }\n      var cut = type ? type.indexOf(\"cm-overlay \") : -1;\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return found;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == \"string\") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, range = this.doc.sel.primary();\n      if (start == null) pos = range.head;\n      else if (typeof start == \"object\") pos = clipPos(this.doc, start);\n      else pos = start ? range.from() : range.to();\n      return cursorCoords(this, pos, mode || \"page\");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || \"page\");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || \"page\");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, lineObj;\n      if (typeof line == \"number\") {\n        var last = this.doc.first + this.doc.size - 1;\n        if (line < this.doc.first) line = this.doc.first;\n        else if (line > last) { line = last; end = true; }\n        lineObj = getLine(this.doc, line);\n      } else {\n        lineObj = line;\n      }\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\").top +\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: methodOp(function(line, gutterID, value) {\n      return changeLine(this.doc, line, \"gutter\", function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: methodOp(function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regLineChange(cm, i, \"gutter\");\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    lineInfo: function(line) {\n      if (typeof line == \"number\") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = \"absolute\";\n      node.setAttribute(\"cm-ignore-events\", \"true\");\n      this.display.input.setUneditable(node);\n      display.sizer.appendChild(node);\n      if (vert == \"over\") {\n        top = pos.top;\n      } else if (vert == \"above\" || vert == \"near\") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + \"px\";\n      node.style.left = node.style.right = \"\";\n      if (horiz == \"right\") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = \"0px\";\n      } else {\n        if (horiz == \"left\") left = 0;\n        else if (horiz == \"middle\") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + \"px\";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: methodOp(onKeyDown),\n    triggerOnKeyPress: methodOp(onKeyPress),\n    triggerOnKeyUp: onKeyUp,\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd].call(null, this);\n    },\n\n    triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: methodOp(function(dir, unit) {\n      var cm = this;\n      cm.extendSelectionsBy(function(range) {\n        if (cm.display.shift || cm.doc.extend || range.empty())\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\n        else\n          return dir < 0 ? range.from() : range.to();\n      }, sel_move);\n    }),\n\n    deleteH: methodOp(function(dir, unit) {\n      var sel = this.doc.sel, doc = this.doc;\n      if (sel.somethingSelected())\n        doc.replaceSelection(\"\", null, \"+delete\");\n      else\n        deleteNearSelection(this, function(range) {\n          var other = findPosH(doc, range.head, dir, unit, false);\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\n        });\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, \"div\");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: methodOp(function(dir, unit) {\n      var cm = this, doc = this.doc, goals = [];\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\n      doc.extendSelectionsBy(function(range) {\n        if (collapse)\n          return dir < 0 ? range.from() : range.to();\n        var headPos = cursorCoords(cm, range.head, \"div\");\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\n        goals.push(headPos.left);\n        var pos = findPosV(cm, headPos, dir, unit);\n        if (unit == \"page\" && range == doc.sel.primary())\n          addToScrollPos(cm, null, charCoords(cm, pos, \"div\").top - headPos.top);\n        return pos;\n      }, sel_move);\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\n        doc.sel.ranges[i].goalColumn = goals[i];\n    }),\n\n    // Find the word at the given position (as returned by coordsChar).\n    findWordAt: function(pos) {\n      var doc = this.doc, line = getLine(doc, pos.line).text;\n      var start = pos.ch, end = pos.ch;\n      if (line) {\n        var helper = this.getHelper(pos, \"wordChars\");\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n        var startChar = line.charAt(start);\n        var check = isWordChar(startChar, helper)\n          ? function(ch) { return isWordChar(ch, helper); }\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n        while (start > 0 && check(line.charAt(start - 1))) --start;\n        while (end < line.length && check(line.charAt(end))) ++end;\n      }\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\n    },\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n      else\n        rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n\n      signal(this, \"overwriteToggle\", this, this.state.overwrite);\n    },\n    hasFocus: function() { return this.display.input.getField() == activeElt(); },\n    isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit); },\n\n    scrollTo: methodOp(function(x, y) {\n      if (x != null || y != null) resolveScrollToPos(this);\n      if (x != null) this.curOp.scrollLeft = x;\n      if (y != null) this.curOp.scrollTop = y;\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n              clientHeight: displayHeight(this), clientWidth: displayWidth(this)};\n    },\n\n    scrollIntoView: methodOp(function(range, margin) {\n      if (range == null) {\n        range = {from: this.doc.sel.primary().head, to: null};\n        if (margin == null) margin = this.options.cursorScrollMargin;\n      } else if (typeof range == \"number\") {\n        range = {from: Pos(range, 0), to: null};\n      } else if (range.from == null) {\n        range = {from: range, to: null};\n      }\n      if (!range.to) range.to = range.from;\n      range.margin = margin || 0;\n\n      if (range.from.line != null) {\n        resolveScrollToPos(this);\n        this.curOp.scrollToPos = range;\n      } else {\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\n                                      Math.min(range.from.top, range.to.top) - range.margin,\n                                      Math.max(range.from.right, range.to.right),\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\n      }\n    }),\n\n    setSize: methodOp(function(width, height) {\n      var cm = this;\n      function interpret(val) {\n        return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n      }\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\n      var lineNo = cm.display.viewFrom;\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, \"widget\"); break; }\n        ++lineNo;\n      });\n      cm.curOp.forceUpdate = true;\n      signal(cm, \"refresh\", this);\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: methodOp(function() {\n      var oldHeight = this.display.cachedTextHeight;\n      regChange(this);\n      this.curOp.forceUpdate = true;\n      clearCaches(this);\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\n      updateGutterSpace(this);\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n        estimateLineHeights(this);\n      signal(this, \"refresh\", this);\n    }),\n\n    swapDoc: methodOp(function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      this.display.input.reset();\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\n      this.curOp.forceScroll = true;\n      signalLater(this, \"swapDoc\", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input.getField();},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n  // Functions to run when options are changed.\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  // Passed to option handlers when there is no old value.\n  var Init = CodeMirror.Init = {toString: function(){return \"CodeMirror.Init\";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option(\"value\", \"\", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option(\"mode\", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option(\"indentUnit\", 2, loadMode, true);\n  option(\"indentWithTabs\", false);\n  option(\"smartIndent\", true);\n  option(\"tabSize\", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option(\"lineSeparator\", null, function(cm, val) {\n    cm.doc.lineSep = val;\n    if (!val) return;\n    var newBreaks = [], lineNo = cm.doc.first;\n    cm.doc.iter(function(line) {\n      for (var pos = 0;;) {\n        var found = line.text.indexOf(val, pos);\n        if (found == -1) break;\n        pos = found + val.length;\n        newBreaks.push(Pos(lineNo, found));\n      }\n      lineNo++;\n    });\n    for (var i = newBreaks.length - 1; i >= 0; i--)\n      replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))\n  });\n  option(\"specialChars\", /[\\u0000-\\u001f\\u007f\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val, old) {\n    cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n    if (old != CodeMirror.Init) cm.refresh();\n  });\n  option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option(\"electricChars\", true);\n  option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function() {\n    throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n  }, true);\n  option(\"spellcheck\", false, function(cm, val) {\n    cm.getInputField().spellcheck = val\n  }, true);\n  option(\"rtlMoveVisually\", !windows);\n  option(\"wholeLineUpdateBefore\", true);\n\n  option(\"theme\", \"default\", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option(\"keyMap\", \"default\", function(cm, val, old) {\n    var next = getKeyMap(val);\n    var prev = old != CodeMirror.Init && getKeyMap(old);\n    if (prev && prev.detach) prev.detach(cm, next);\n    if (next.attach) next.attach(cm, prev || null);\n  });\n  option(\"extraKeys\", null);\n\n  option(\"lineWrapping\", false, wrappingChanged, true);\n  option(\"gutters\", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"fixedGutter\", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n    cm.refresh();\n  }, true);\n  option(\"coverGutterNextToScrollbar\", false, function(cm) {updateScrollbars(cm);}, true);\n  option(\"scrollbarStyle\", \"native\", function(cm) {\n    initScrollbars(cm);\n    updateScrollbars(cm);\n    cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n    cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n  }, true);\n  option(\"lineNumbers\", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option(\"firstLineNumber\", 1, guttersChanged, true);\n  option(\"lineNumberFormatter\", function(integer) {return integer;}, guttersChanged, true);\n  option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n  option(\"resetSelectionOnContextMenu\", true);\n  option(\"lineWiseCopyCut\", true);\n\n  option(\"readOnly\", false, function(cm, val) {\n    if (val == \"nocursor\") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n    }\n    cm.display.input.readOnlyChanged(val)\n  });\n  option(\"disableInput\", false, function(cm, val) {if (!val) cm.display.input.reset();}, true);\n  option(\"dragDrop\", true, dragDropChanged);\n  option(\"allowDropFileTypes\", null);\n\n  option(\"cursorBlinkRate\", 530);\n  option(\"cursorScrollMargin\", 0);\n  option(\"cursorHeight\", 1, updateSelection, true);\n  option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n  option(\"workTime\", 100);\n  option(\"workDelay\", 100);\n  option(\"flattenSpans\", true, resetModeState, true);\n  option(\"addModeClass\", false, resetModeState, true);\n  option(\"pollInterval\", 100);\n  option(\"undoDepth\", 200, function(cm, val){cm.doc.history.undoDepth = val;});\n  option(\"historyEventDelay\", 1250);\n  option(\"viewportMargin\", 10, function(cm){cm.refresh();}, true);\n  option(\"maxHighlightLength\", 10000, resetModeState, true);\n  option(\"moveInputWithCursor\", true, function(cm, val) {\n    if (!val) cm.display.input.resetPosition();\n  });\n\n  option(\"tabindex\", null, function(cm, val) {\n    cm.display.input.getField().tabIndex = val || \"\";\n  });\n  option(\"autofocus\", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != \"null\") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2)\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") found = {name: found};\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/xml\");\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return CodeMirror.resolveMode(\"application/json\");\n    }\n    if (typeof spec == \"string\") return {name: spec};\n    else return spec || {name: \"null\"};\n  };\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, \"text/plain\");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj[\"_\" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because nested\n  // modes need to do this for their inner modes.\n\n  var copyState = CodeMirror.copyState = function(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  };\n\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  };\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\n    singleSelection: function(cm) {\n      cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n          if (range.head.ch == len && range.head.line < cm.lastLine())\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\n          else\n            return {from: range.head, to: Pos(range.head.line, len)};\n        } else {\n          return {from: range.from(), to: range.to()};\n        }\n      });\n    },\n    deleteLine: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0),\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\n      });\n    },\n    delLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        return {from: Pos(range.from().line, 0), to: range.from()};\n      });\n    },\n    delWrappedLineLeft: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n        return {from: leftPos, to: range.from()};\n      });\n    },\n    delWrappedLineRight: function(cm) {\n      deleteNearSelection(cm, function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n        return {from: range.from(), to: rightPos };\n      });\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    undoSelection: function(cm) {cm.undoSelection();},\n    redoSelection: function(cm) {cm.redoSelection();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\n                            {origin: \"+move\", bias: 1});\n    },\n    goLineStartSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        return lineStartSmart(cm, range.head);\n      }, {origin: \"+move\", bias: 1});\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\n                            {origin: \"+move\", bias: -1});\n    },\n    goLineRight: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({left: 0, top: top}, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function(cm) {\n      cm.extendSelectionsBy(function(range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function(cm) {cm.moveV(-1, \"line\");},\n    goLineDown: function(cm) {cm.moveV(1, \"line\");},\n    goPageUp: function(cm) {cm.moveV(-1, \"page\");},\n    goPageDown: function(cm) {cm.moveV(1, \"page\");},\n    goCharLeft: function(cm) {cm.moveH(-1, \"char\");},\n    goCharRight: function(cm) {cm.moveH(1, \"char\");},\n    goColumnLeft: function(cm) {cm.moveH(-1, \"column\");},\n    goColumnRight: function(cm) {cm.moveH(1, \"column\");},\n    goWordLeft: function(cm) {cm.moveH(-1, \"word\");},\n    goGroupRight: function(cm) {cm.moveH(1, \"group\");},\n    goGroupLeft: function(cm) {cm.moveH(-1, \"group\");},\n    goWordRight: function(cm) {cm.moveH(1, \"word\");},\n    delCharBefore: function(cm) {cm.deleteH(-1, \"char\");},\n    delCharAfter: function(cm) {cm.deleteH(1, \"char\");},\n    delWordBefore: function(cm) {cm.deleteH(-1, \"word\");},\n    delWordAfter: function(cm) {cm.deleteH(1, \"word\");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, \"group\");},\n    delGroupAfter: function(cm) {cm.deleteH(1, \"group\");},\n    indentAuto: function(cm) {cm.indentSelection(\"smart\");},\n    indentMore: function(cm) {cm.indentSelection(\"add\");},\n    indentLess: function(cm) {cm.indentSelection(\"subtract\");},\n    insertTab: function(cm) {cm.replaceSelection(\"\\t\");},\n    insertSoftTab: function(cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection(\"add\");\n      else cm.execCommand(\"insertTab\");\n    },\n    transposeChars: function(cm) {\n      runInOp(cm, function() {\n        var ranges = cm.listSelections(), newSel = [];\n        for (var i = 0; i < ranges.length; i++) {\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n          if (line) {\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                              Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n              if (prev)\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                                prev.charAt(prev.length - 1),\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), \"+transpose\");\n            }\n          }\n          newSel.push(new Range(cur, cur));\n        }\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function(cm) {\n      runInOp(cm, function() {\n        var len = cm.listSelections().length;\n        for (var i = 0; i < len; i++) {\n          var range = cm.listSelections()[i];\n          cm.replaceRange(cm.doc.lineSeparator(), range.anchor, range.head, \"+input\");\n          cm.indentLine(range.from().line + 1, null, true);\n        }\n        ensureCursorVisible(cm);\n      });\n    },\n    openLine: function(cm) {cm.replaceSelection(\"\\n\", \"start\")},\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    fallthrough: \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    fallthrough: [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/), name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) cmd = true;\n      else if (/^a(lt)?$/i.test(mod)) alt = true;\n      else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = true;\n      else if (/^s(hift)$/i.test(mod)) shift = true;\n      else throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt) name = \"Alt-\" + name;\n    if (ctrl) name = \"Ctrl-\" + name;\n    if (cmd) name = \"Cmd-\" + name;\n    if (shift) name = \"Shift-\" + name;\n    return name;\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  CodeMirror.normalizeKeyMap = function(keymap) {\n    var copy = {};\n    for (var keyname in keymap) if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;\n      if (value == \"...\") { delete keymap[keyname]; continue; }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val, name;\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) copy[name] = val;\n        else if (prev != val) throw new Error(\"Inconsistent bindings for \" + name);\n      }\n      delete keymap[keyname];\n    }\n    for (var prop in copy) keymap[prop] = copy[prop];\n    return keymap;\n  };\n\n  var lookupKey = CodeMirror.lookupKey = function(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\")\n        return lookupKey(key, map.fallthrough, handle, context);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n        if (result) return result;\n      }\n    }\n  };\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  var isModifierKey = CodeMirror.isModifierKey = function(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  };\n\n  // Look up the name of a key as indicated by an event object.\n  var keyName = CodeMirror.keyName = function(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) return false;\n    var base = keyNames[event.keyCode], name = base;\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey && base != \"Alt\") name = \"Alt-\" + name;\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") name = \"Ctrl-\" + name;\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") name = \"Cmd-\" + name;\n    if (!noShift && event.shiftKey && base != \"Shift\") name = \"Shift-\" + name;\n    return name;\n  };\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val;\n  }\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      options.tabindex = textarea.tabIndex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function(cm) {\n      cm.save = save;\n      cm.getTextArea = function() { return textarea; };\n      cm.toTextArea = function() {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (typeof textarea.form.submit == \"function\")\n            textarea.form.submit = realSubmit;\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  };\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == \"string\") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == \"string\") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  var nextMarkerId = 0;\n\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n  eventMixin(TextMarker);\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) signalLater(this, \"clear\", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), \"text\");\n      else if (cm) {\n        if (span.to != null) max = lineNo(line);\n        if (span.from != null) min = lineNo(line);\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm.doc);\n    }\n    if (cm) signalLater(cm, \"markerCleared\", cm, this);\n    if (withOp) endOperation(cm);\n    if (this.parent) this.parent.clear();\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function(side, lineObj) {\n    if (side == null && this.type == \"bookmark\") side = 1;\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) return from;\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) return to;\n      }\n    }\n    return from && {from: from, to: to};\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) return;\n    runInOp(cm, function() {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          updateLineHeight(line, line.height + dHeight);\n      }\n    });\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) copyObj(options, marker, false);\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = elt(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        updateMaxLine = true;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, \"beforeCursorEnter\", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, \"text\");\n      if (marker.atomic) reCheckSelection(cm.doc);\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      markers[i].parent = this;\n  };\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, \"clear\");\n  };\n  SharedTextMarker.prototype.find = function(side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.widgetNode = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\n                         function(m) { return m.parent; });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], linked = [marker.primary.doc];;\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    }\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    }\n    return nw;\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    }\n    return nw;\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) return null;\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          newParts.push({from: p.from, to: m.from});\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        return true;\n    }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = merged.find(-1, true).line;\n    return line;\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n    return lines;\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) return lineN;\n    return lineNo(vis);\n  }\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) return lineN;\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) return lineN;\n    while (merged = collapsedSpanAtEnd(line))\n      line = merged.find(1, true).line;\n    return lineNo(line) + 1;\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.widgetNode) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  // LINE WIDGETS\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = CodeMirror.LineWidget = function(doc, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.doc = doc;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      addToScrollPos(cm, null, diff);\n  }\n\n  LineWidget.prototype.clear = function() {\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) line.widgets = null;\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) runInOp(cm, function() {\n      adjustScrollWhenAboveVisible(cm, line, -height);\n      regLineChange(cm, no, \"widget\");\n    });\n  };\n  LineWidget.prototype.changed = function() {\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(line, line.height + diff);\n    if (cm) runInOp(cm, function() {\n      cm.curOp.forceUpdate = true;\n      adjustScrollWhenAboveVisible(cm, line, diff);\n    });\n  };\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    var cm = widget.doc.cm;\n    if (!cm) return 0;\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n      if (widget.noHScroll)\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight;\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(doc, handle, \"widget\", function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\n        cm.curOp.forceUpdate = true;\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        output[prop] = lineClass[2];\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        output[prop] += \" \" + lineClass[2];\n    }\n    return type;\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) return mode.blankLine(state);\n    if (!mode.innerMode) return;\n    var inner = CodeMirror.innerMode(mode, state);\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) inner[0] = CodeMirror.innerMode(mode, state).mode;\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) return style;\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    function getObj(copy) {\n      return {start: stream.start, end: stream.pos,\n              string: stream.current(),\n              type: style || null,\n              state: copy ? copyState(doc.mode, state) : state};\n    }\n\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), state = getStateBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize), tokens;\n    if (asArray) tokens = [];\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, state);\n      if (asArray) tokens.push(getObj(true));\n    }\n    return asArray ? tokens : getObj();\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") extractLineClasses(callBlankLine(mode, state), lineClasses);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) style = \"m-\" + (style ? mName + \" \" + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, lineClasses, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"cm-overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"cm-overlay \" + style;\n          }\n        }\n      }, lineClasses);\n    }\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var state = getStateBefore(cm, lineNo(line));\n      var result = highlightLine(cm, line, line.text.length > cm.options.maxHighlightLength ? copyState(cm.doc.mode, state) : state);\n      line.stateAfter = state;\n      line.styles = result.styles;\n      if (result.classes) line.styleClasses = result.classes;\n      else if (line.styleClasses) line.styleClasses = null;\n      if (updateFrontier === cm.doc.frontier) cm.doc.frontier++;\n    }\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") callBlankLine(mode, state);\n    while (!stream.eol()) {\n      readToken(mode, stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) return null;\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = elt(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: elt(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: (ie || webkit) && cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        if (line.styleClasses.textClass)\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        builder.content.className = \"cm-tab-wrap-hack\";\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token;\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, title, css) {\n    if (!text) return;\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) mustWrap = true;\n      builder.pos += text.length;\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          var txt = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt.setAttribute(\"role\", \"presentation\");\n          txt.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          var txt = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) content.appendChild(elt(\"span\", [txt]));\n          else content.appendChild(txt);\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (title) token.title = title;\n      return builder.content.appendChild(token);\n    }\n    builder.content.appendChild(content);\n  }\n\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) return text\n    var spaceBefore = trailingBefore, result = \"\"\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i)\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        ch = \"\\u00a0\"\n      result += ch\n      spaceBefore = ch == \" \"\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function(builder, text, style, startStyle, endStyle, title, css) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        for (var i = 0; i < order.length; i++) {\n          var part = order[i];\n          if (part.to > start && part.from <= start) break;\n        }\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) builder.map.push(builder.pos, builder.pos + size, widget);\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        widget = builder.content.appendChild(document.createElement(\"span\"));\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = css = \"\";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) spanStyle += \" \" + m.className;\n            if (m.css) css = (css ? css + \";\" : \"\") + m.css;\n            if (m.startStyle && sp.from == pos) spanStartStyle += \" \" + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) (endStyles || (endStyles = [])).push(m.endStyle, sp.to)\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) for (var j = 0; j < endStyles.length; j += 2)\n          if (endStyles[j + 1] == nextChange) spanEndStyle += \" \" + endStyles[j]\n\n        if (!collapsed || collapsed.from == pos) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return;\n          if (collapsed.to == pos) collapsed = false;\n        }\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", title, css);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      for (var i = start, result = []; i < end; ++i)\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\n      return result;\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added = linesFor(1, text.length - 1);\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added = linesFor(1, text.length - 1);\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, height = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine, lineSep) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.extend = false;\n\n    if (typeof text == \"string\") text = this.splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      setSelection(this, simpleSelection(top));\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || this.lineSeparator());\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") line = getLine(this, line);\n      return visualLine(line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var range = this.sel.primary(), pos;\n      if (start == null || start == \"head\") pos = range.head;\n      else if (start == \"anchor\") pos = range.anchor;\n      else if (start == \"end\" || start == \"to\" || start === false) pos = range.to();\n      else pos = range.from();\n      return pos;\n    },\n    listSelections: function() { return this.sel.ranges; },\n    somethingSelected: function() {return this.sel.somethingSelected();},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      if (!ranges.length) return;\n      for (var i = 0, out = []; i < ranges.length; i++)\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\n                           clipPos(this, ranges[i].head));\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      setSelection(this, normalizeSelection(out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) return lines;\n      else return lines.join(lineSep || this.lineSeparator());\n    },\n    getSelections: function(lineSep) {\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) sel = sel.join(lineSep || this.lineSeparator());\n        parts[i] = sel;\n      }\n      return parts;\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        dup[i] = code;\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i = changes.length - 1; i >= 0; i--)\n        makeChange(this, changes[i]);\n      if (newSel) setSelectionReplaceHistory(this, newSel);\n      else if (this.cm) ensureCursorVisible(this.cm);\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend;},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\n      return {undo: done, redo: undone};\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) line[prop] = cls;\n        else if (classTest(cls).test(line[prop])) return false;\n        else line[prop] += \" \" + cls;\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function(line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo = from.line;\n      this.iter(from.line, to.line + 1, function(line) {\n        var spans = line.markedSpans;\n        if (spans) for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||\n                span.from == null && lineNo != from.line ||\n                span.from != null && lineNo == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            found.push(span.marker.parent || span.marker);\n        }\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function(line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + sepSize;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        detachSharedMarkers(findSharedMarkers(this));\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;},\n\n    splitLines: function(str) {\n      if (this.lineSep) return str.split(this.lineSep);\n      return splitLinesAuto(str);\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\"; }\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error(\"This document is already in use.\");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) findMaxLine(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    for (var chunk = doc; !chunk.lines;) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0; i < chunk.children.length; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) array.pop();\n      else break;\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        pushSelectionToHistory(doc.sel, hist.done);\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) hist.done.shift();\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) signal(doc, \"historyAdded\");\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      hist.done[hist.done.length - 1] = sel;\n    else\n      pushSelectionToHistory(sel, hist.done);\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      clearSelectionEvents(hist.undone);\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      dest.push(sel);\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue;\n      }\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT UTILITIES\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  };\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  };\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var on = CodeMirror.on = function(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent(\"on\" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  };\n\n  var noHandlers = []\n  function getHandlers(emitter, type, copy) {\n    var arr = emitter._handlers && emitter._handlers[type]\n    if (copy) return arr && arr.length > 0 ? arr.slice() : noHandlers\n    else return arr || noHandlers\n  }\n\n  var off = CodeMirror.off = function(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent(\"on\" + type, f);\n    else {\n      var handlers = getHandlers(emitter, type, false)\n      for (var i = 0; i < handlers.length; ++i)\n        if (handlers[i] == f) { handlers.splice(i, 1); break; }\n    }\n  };\n\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type, true)\n    if (!handlers.length) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) handlers[i].apply(null, args);\n  };\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type, false)\n    if (!arr.length) return;\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      list.push(bnd(arr[i]));\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      e = {type: e, preventDefault: function() { this.defaultPrevented = true; }};\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) return;\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\n      set.push(arr[i]);\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return \"CodeMirror.Pass\";}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype.set = function(ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        return n + (end - i);\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  };\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  var findColumn = CodeMirror.findColumn = function(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) nextTab = string.length;\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        return pos + Math.min(skipped, goal - col);\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) return pos;\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\n  else if (ie) // Suppress mysterious IE10 errors\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      if (array[i] == elt) return i;\n    return -1;\n  }\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\n    return out;\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value)\n    while (pos < array.length && score(array[pos]) <= priority) pos++\n    array.splice(pos, 0, value)\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) copyObj(props, inst);\n    return inst;\n  };\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) target = {};\n    for (var prop in obj)\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        target[prop] = obj[prop];\n    return target;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  };\n  function isWordChar(ch, helper) {\n    if (!helper) return isWordCharBasic(ch);\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) return true;\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == \"string\") e.appendChild(document.createTextNode(content));\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  var range;\n  if (document.createRange) range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r;\n  };\n  else range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r; }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r;\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  var contains = CodeMirror.contains = function(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      child = child.parentNode;\n    if (parent.contains)\n      return parent.contains(child);\n    do {\n      if (child.nodeType == 11) child = child.host;\n      if (child == parent) return true;\n    } while (child = child.parentNode);\n  };\n\n  function activeElt() {\n    var activeElement = document.activeElement;\n    while (activeElement && activeElement.root && activeElement.root.activeElement)\n      activeElement = activeElement.root.activeElement;\n    return activeElement;\n  }\n  // Older versions of IE throws unspecified error when touching\n  // document.activeElement in some cases (during loading, in iframe)\n  if (ie && ie_version < 11) activeElt = function() {\n    try { return document.activeElement; }\n    catch(e) { return document.body; }\n  };\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\"); }\n  var rmClass = CodeMirror.rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n  var addClass = CodeMirror.addClass = function(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) node.className += (current ? \" \" : \"\") + cls;\n  };\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      if (as[i] && !classTest(as[i]).test(b)) b += \" \" + as[i];\n    return b;\n  }\n\n  // WINDOW-WIDE EVENTS\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.body.getElementsByClassName) return;\n    var byClass = document.body.getElementsByClassName(\"CodeMirror\");\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) f(cm);\n    }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) return;\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100);\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function() {\n      forEachCodeMirror(onBlur);\n    });\n  }\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) return false;\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node;\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) return badBidiRects;\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3);\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = CodeMirror.splitLines = \"\\n\\nb\".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) return true;\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) return badZoomedRects;\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  }\n\n  // KEY NAMES\n\n  var keyNames = CodeMirror.keyNames = {\n    3: \"Enter\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = \"F\" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, \"ltr\");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, \"ltr\");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line = getLine(cm.doc, lineN);\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      lineN = null;\n    }\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS);\n    }\n    return start;\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is needed in order to move 'visually' through bi-directional\n  // text -- i.e., pressing left should make the cursor go left, even\n  // when in RTL text. The tricky part is the 'jumps', where RTL and\n  // LTR text touch each other. This often requires the cursor offset\n  // to move more than one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = \"rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm\";\n    function charType(code) {\n      if (code <= 0xf7) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return \"R\";\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\n      else if (0x6ee <= code && code <= 0x8ac) return \"r\";\n      else if (0x2000 <= code && code <= 0x200b) return \"w\";\n      else if (code == 0x200c) return \"b\";\n      else return \"L\";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = \"L\";\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"m\") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == \"1\" && cur == \"r\") types[i] = \"n\";\n        else if (isStrong.test(type)) { cur = type; if (type == \"r\") types[i] = \"R\"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == \"+\" && prev == \"1\" && types[i+1] == \"1\") types[i] = \"1\";\n        else if (type == \",\" && prev == types[i+1] &&\n                 (prev == \"1\" || prev == \"n\")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == \",\") types[i] = \"N\";\n        else if (type == \"%\") {\n          for (var end = i + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i && types[i-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == \"L\" && type == \"1\") types[i] = \"L\";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == \"L\";\n          var after = (end < len ? types[end] : outerType) == \"L\";\n          var replace = before || after ? \"L\" : \"R\";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push(new BidiSpan(0, start, i));\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != \"L\"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift(new BidiSpan(0, 0, m[0].length));\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push(new BidiSpan(0, len - m[0].length, len));\n      }\n      if (order[0].level == 2)\n        order.unshift(new BidiSpan(1, order[0].to, order[0].to));\n      if (order[0].level != lst(order).level)\n        order.push(new BidiSpan(order[0].level, len, len));\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = \"5.19.0\";\n\n  return CodeMirror;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/anniel/Workspace/rede_gsti/resources/~/codemirror/lib/codemirror.js\n ** module id = 82\n ** module chunks = 2\n **/","(function ($) {\n  $.extend($.summernote.lang, {\n    'pt-BR': {\n      font: {\n        bold: 'Negrito',\n        italic: 'Itlico',\n        underline: 'Sublinhado',\n        clear: 'Remover estilo da fonte',\n        height: 'Altura da linha',\n        name: 'Fonte',\n        strikethrough: 'Riscado',\n        size: 'Tamanho da fonte'\n      },\n      image: {\n        image: 'Imagem',\n        insert: 'Inserir imagem',\n        resizeFull: 'Redimensionar Completamente',\n        resizeHalf: 'Redimensionar pela Metade',\n        resizeQuarter: 'Redimensionar um Quarto',\n        floatLeft: 'Flutuar para Esquerda',\n        floatRight: 'Flutuar para Direira',\n        floatNone: 'No Flutuar',\n        dragImageHere: 'Arraste uma imagem para c',\n        selectFromFiles: 'Selecione a partir dos arquivos',\n        url: 'URL da imagem'\n      },\n      video: {\n        video: 'Vdeo',\n        videoLink: 'Link para vdeo',\n        insert: 'Inserir vdeo',\n        url: 'URL do vdeo?',\n        providers: '(YouTube, Vimeo, Vine, Instagram, DailyMotion ou Youku)'\n      },\n      link: {\n        link: 'Link',\n        insert: 'Inserir link',\n        unlink: 'Remover link',\n        edit: 'Editar',\n        textToDisplay: 'Texto para exibir',\n        url: 'Para qual URL esse link leva?',\n        openInNewWindow: 'Abrir em uma nova janela'\n      },\n      table: {\n        table: 'Tabela'\n      },\n      hr: {\n        insert: 'Inserir linha horizontal'\n      },\n      style: {\n        style: 'Estilo',\n        normal: 'Normal',\n        blockquote: 'Citao',\n        pre: 'Cdigo',\n        h1: 'Ttulo 1',\n        h2: 'Ttulo 2',\n        h3: 'Ttulo 3',\n        h4: 'Ttulo 4',\n        h5: 'Ttulo 5',\n        h6: 'Ttulo 6'\n      },\n      lists: {\n        unordered: 'Lista com marcadores',\n        ordered: 'Lista numerada'\n      },\n      options: {\n        help: 'Ajuda',\n        fullscreen: 'Tela cheia',\n        codeview: 'Ver cdigo-fonte'\n      },\n      paragraph: {\n        paragraph: 'Pargrafo',\n        outdent: 'Menor tabulao',\n        indent: 'Maior tabulao',\n        left: 'Alinhar  esquerda',\n        center: 'Alinhar ao centro',\n        right: 'Alinha  direita',\n        justify: 'Justificado'\n      },\n      color: {\n        recent: 'Cor recente',\n        more: 'Mais cores',\n        background: 'Fundo',\n        foreground: 'Fonte',\n        transparent: 'Transparente',\n        setTransparent: 'Fundo transparente',\n        reset: 'Restaurar',\n        resetToDefault: 'Restaurar padro'\n      },\n      shortcut: {\n        shortcuts: 'Atalhos do teclado',\n        close: 'Fechar',\n        textFormatting: 'Formatao de texto',\n        action: 'Ao',\n        paragraphFormatting: 'Formatao de pargrafo',\n        documentStyle: 'Estilo de documento'\n      },\n      history: {\n        undo: 'Desfazer',\n        redo: 'Refazer'\n      },\n      help: {\n        'insertParagraph': 'Inserir Pargrafo',\n        'undo': 'Desfazer o ltimo comando',\n        'redo': 'Refazer o ltimo comando',\n        'tab': 'Tab',\n        'untab': 'Desfazer tab',\n        'bold': 'Colocar em negrito',\n        'italic': 'Colocar em itlico',\n        'underline': 'Sublinhado',\n        'strikethrough': 'Tachado',\n        'removeFormat': 'Remover estilo',\n        'justifyLeft': 'Alinhar  esquerda',\n        'justifyCenter': 'Centralizar',\n        'justifyRight': 'Alinhar  esquerda',\n        'justifyFull': 'Justificar',\n        'insertUnorderedList': 'Lista no ordenada',\n        'insertOrderedList': 'Lista ordenada',\n        'outdent': 'Recuar pargrafo atual',\n        'indent': 'Avanar pargrafo atual',\n        'formatPara': 'Alterar formato do bloco para pargrafo(tag P)',\n        'formatH1': 'Alterar formato do bloco para H1',\n        'formatH2': 'Alterar formato do bloco para H2',\n        'formatH3': 'Alterar formato do bloco para H3',\n        'formatH4': 'Alterar formato do bloco para H4',\n        'formatH5': 'Alterar formato do bloco para H5',\n        'formatH6': 'Alterar formato do bloco para H6',\n        'insertHorizontalRule': 'Inserir rgua horizontal',\n        'linkDialog.show': 'Inserir um Hiperlink'\n      }\n    }\n  });\n})(jQuery);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** /home/anniel/Workspace/rede_gsti/resources/~/summernote/lang/summernote-pt-BR.js\n ** module id = 83\n ** module chunks = 2\n **/","(function(factory) {\n    /* global define */\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['jquery'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n}(function($) {\n  var embedToSummernote = function (context) {\n    var self = this;\n\n    var options = context.options;\n    var inToolbar = false;\n\n    for (var idx in options.toolbar) {\n      // toolbar => [groupName, [list of button]]\n      var buttons = options.toolbar[idx][1];\n      if ($.inArray('oembed', buttons) > -1) {\n        inToolbar = true;\n        break;\n      }\n    }\n\n    if (!inToolbar) {\n      return;\n    }\n\n    var ui = $.summernote.ui;\n    var $editor = context.layoutInfo.editor;\n    var lang = options.langInfo;\n\n    var oEmbedOptions = {\n      service: 'https://noembed.com/'\n    };\n\n    options.oEmbed = $.extend(oEmbedOptions, options.oEmbed);\n\n    context.memo('button.oembed', function () {\n      var button = ui.button({\n        contents: '<i class=\"note-icon-frame\">',\n        tooltip: lang.oEmbedButton.tooltip,\n        click: function (event) {\n          self.show();\n        }\n      });\n\n      return button.render();\n    });\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n\n      self.showEmbedDialog()\n        .then(function showEmbedDialogCb (data) {\n          context.invoke('editor.restoreRange');\n          self.insertEmbedToEditor(data.uri);\n          ui.hideDialog(self.$dialog);\n        }).fail(function () {\n          context.invoke('editor.restoreRange');\n        });\n    };\n\n    this.showEmbedDialog = function () {\n      self.disableAddButton();\n      self.$embedInput.value = '';\n\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function dialogShownCb () {\n          context.triggerEvent('dialog.shown');\n          self.$embedInput.focus();\n\n          self.$addBtn.on('click', function addEmbedCb (event) {\n            event.preventDefault();\n            deferred.resolve({\n              uri: self.$embedInput.value\n            });\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function dialogHiddenCb () {\n          self.$addBtn.off('click');\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n\n    this.createDialog = function ($container) {\n      var dialogOption = {\n        title: lang.oEmbedDialog.title,\n        body: '<div class=\"form-group\">' +\n        '<label>' + lang.oEmbedDialog.label + '</label>' +\n        '<input id=\"input-autocomplete\" class=\"form-control\" type=\"text\" placeholder=\"' + lang.oEmbedDialog.placeholder + '\" />' +\n        '</div>' +\n        '<div id=\"embed-in-dialog\"></div>',\n        footer: '<button href=\"#\" id=\"btn-add\" class=\"btn btn-primary\">' + lang.oEmbedDialog.button + '</button>',\n        closeOnEscape: true\n      };\n\n      self.$dialog = ui.dialog(dialogOption).render().appendTo($container);\n      self.$addBtn = self.$dialog.find('#btn-add');\n      self.$embedInput = self.$dialog.find('#input-autocomplete')[0];\n      self.$embedContainer = self.$dialog.find('#embed-in-dialog')[0];\n    };\n\n    this.enableAddButton = function() {\n      if (self.$embedInput.value && self.$embedInput.value.length > 0) {\n        self.$addBtn.attr(\"disabled\", false);\n      }\n    };\n\n    this.disableAddButton = function() {\n      self.$addBtn.attr(\"disabled\", true);\n    };\n\n    this.insertEmbedToEditor = function (iframe) {\n      var $div = $('<div>');\n\n\n      $.getJSON(options.oEmbed.service+'?url='+iframe)\n        .done(function (data) {\n          $div.html(self.normalizeEmbed(data.html));\n\n          context.invoke('editor.insertNode', $div[0]);\n          self.$embedContainer.innerHTML = '';\n        });\n    };\n\n    this.normalizeEmbed = function(data){\n\n    if(data){\n      var $div = $('<div>');\n    var $iframe = $(data).find(\"iframe\");\n\n    $div.css({\n      'position': 'relative',\n      'padding-top': '25px',\n      'padding-bottom': '56.25%',\n      'height': '0'\n    });\n    $iframe.css({\n      'position': 'absolute',\n      'top': '0',\n      'left': '0',\n      'width': '100%',\n      'height': '100%'\n    });\n    $iframe.removeAttr(\"width\");\n    $iframe.removeAttr(\"height\");\n\n    $div.html($iframe);\n\n    return $div;\n\n    }  else{\n      console.log(lang);\n      throw new Error(lang.errorMessage.invalid_provider);\n    }\n\n    };\n\n    this.initOembed = function () {\n\n      self.$embedInput.addEventListener('input', function (event) {\n\n        var url = this.value;\n\n        setTimeout(function () {\n          if(options.oEmbed.spinner){\n            self.$embedContainer.innerHTML = options.oEmbed.spinner;\n          }\n\n          $.getJSON(options.oEmbed.service+'?url='+url)\n          .done(function (data) {\n\n              var content;\n              try{\n                content = self.normalizeEmbed(data.html);\n\n              }catch(e){\n\n                content = e.message;\n              }\n\n              $(self.$embedContainer).html(content);\n\n\n            self.enableAddButton();\n          });\n        }, 1000);\n      });\n    };\n\n    this.initialize = function() {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n      self.createDialog($container);\n    };\n\n    this.destroy = function() {\n      ui.hideDialog(self.$dialog);\n      self.$dialog.remove();\n    };\n\n    this.events = {\n      // This will be called after modules are initialized.\n      'summernote.init': function(we, e) {\n        self.initOembed();\n      }\n    };\n\n  };\n\n  $.extend(true, $.summernote, {\n    lang: {\n      'en-US': {\n        oEmbedButton: {\n          tooltip: \"Embed\"\n        },\n        oEmbedDialog: {\n          title: \"Insert Embed\",\n          label: \"Place your embed url link\",\n          placeholder: \"E.g. https://www.youtube.com/watch?v=sJ9HR-kcZHg\",\n          button: \"Insert\"\n        },\n        errorMessage: {\n          invalid_provider: 'Invalid Provider!'\n        }\n      },\n      'pt-BR': {\n        oEmbedButton: {\n          tooltip: \"Adicionar Embed\"\n        },\n        oEmbedDialog: {\n          title: \"Inserir Embed\",\n          label: \"Coloque a url do seu embed\",\n          placeholder: \"Ex.: https://www.youtube.com/watch?v=sJ9HR-kcZHg\",\n          button: \"Inserir\"\n        },\n        errorMessage: {\n          invalid_provider: 'Provedor invlido'\n        }\n      }\n    },\n    plugins: {\n      'oembed': embedToSummernote\n    }\n  });\n}));\n\n\n\n/** WEBPACK FOOTER **\n ** ./vendor/summernote/plugins/summernote-oembed-plugin.js\n **/","(function(factory) {\n    /* global define */\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define(['jquery'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node/CommonJS\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals\n        factory(window.jQuery);\n    }\n}(function($) {\n  'use strict';\n\n  var summernotePrettyprint = function (context) {\n    var self = this;\n    var options = context.options;\n    var inToolbar = false;\n\n    for (var idx in options.toolbar) {\n      var buttons = options.toolbar[idx][1];\n      if ($.inArray('prettyprint', buttons) > -1) {\n        inToolbar = true;\n        break;\n      }\n    }\n\n    if (!inToolbar) { return; }\n\n    var ui = $.summernote.ui;\n    var $editor = context.layoutInfo.editor;\n    var lang = options.langInfo;\n\n    var prettyprintOpitions = {\n      languages: [\n        'bsh', 'c', 'cc', 'cpp', 'cs', 'css', 'csh', 'cyc', 'cv', 'html',\n        'java', 'js', 'm', 'mxml', 'perl', 'pl', 'pm', 'py', 'php', 'rb',\n        'sh', 'sql', 'xhtml', 'xml', 'xsl'\n      ]\n    };\n\n    options.prettyprint = $.extend(prettyprintOpitions, options.prettyprint);\n\n    context.memo('button.prettyprint', function () {\n      var button = ui.button({\n        contents: '{}',\n        tooltip: lang.button.tooltip,\n        click: function (event) {\n          self.show();\n        }\n      });\n\n      return button.render();\n    });\n\n    this.show = function () {\n      context.invoke('editor.saveRange');\n\n      self.showDialog()\n        .then(function showDialogCb (data) {\n          context.invoke('editor.restoreRange');\n          self.insertToEditor(data);\n          ui.hideDialog(self.$dialog);\n        }).fail(function () {\n          context.invoke('editor.restoreRange');\n        });\n    };\n\n    this.showDialog = function () {\n      self.disableAddButton();\n      self.$code.value = '';\n\n      return $.Deferred(function (deferred) {\n        ui.onDialogShown(self.$dialog, function dialogShownCb () {\n          context.triggerEvent('dialog.shown');\n          self.$codeLanguage.focus();\n\n          self.$addBtn.on('click', function addEmbedCb (event) {\n            event.preventDefault();\n            deferred.resolve({\n              language: self.$codeLanguage.value,\n              code: self.$code.value\n            });\n          });\n        });\n\n        ui.onDialogHidden(self.$dialog, function dialogHiddenCb () {\n          self.$addBtn.off('click');\n          if (deferred.state() === 'pending') {\n            deferred.reject();\n          }\n        });\n\n        ui.showDialog(self.$dialog);\n      });\n    };\n\n    this.createDialog = function ($container) {\n\n      var select = '<select class=\"form-control\" id=\"code-language\"><option>' + options.prettyprint.languages.join('</option><option>') + '</option></select>';\n\n      var dialogOption = {\n        title: lang.dialogPrettyfi.title,\n        body: '<div class=\"form-group\">' +\n        '<label>' + lang.dialogPrettyfi.selectLabel + '</label>' +\n        select +\n        '</div>' +\n        '<div class=\"form-group\">' +\n        '<label>' + lang.dialogPrettyfi.codeLabel + '</label>' +\n        '<textarea class=\"form-control\" id=\"code\" rows=\"7\"></textarea>' +\n        '</div>',\n        footer: '<button href=\"#\" id=\"btn-add\" class=\"btn btn-primary\">' + lang.dialogPrettyfi.button + '</button>',\n        closeOnEscape: true\n      };\n\n      self.$dialog = ui.dialog(dialogOption).render().appendTo($container);\n      self.$addBtn = self.$dialog.find('#btn-add');\n      self.$codeLanguage = self.$dialog.find('#code-language')[0];\n      self.$code = self.$dialog.find('#code')[0];\n    };\n\n    this.insertToEditor = function (options) {\n      var innerOptions = {\n        code: '',\n        language: ''\n      };\n\n      var _options = $.extend(innerOptions, options);\n\n      var $node = $('<pre>', {\n        class: 'prettyprint linenums'\n      });\n      var $code = $('<code>');\n      $code.html(_options.code.replace(/</g,\"&lt;\").replace(/>/g,\"&gt;\"));\n      $code.addClass('language-' + _options.language);\n\n      $node.html($code)\n\n      context.invoke('editor.insertNode', $node[0]);\n      self.$code.innerHTML = '';\n    };\n\n    this.enableAddButton = function() {\n      if (!!self.$codeLanguage.value && self.$code.value.length > 0) {\n        self.$addBtn.attr(\"disabled\", false);\n      }\n    };\n\n    this.disableAddButton = function() {\n      self.$addBtn.attr(\"disabled\", true);\n    };\n\n    this.init = function () {\n        self.$code.addEventListener('input', function (event) {\n          self.enableAddButton();\n        }, false);\n        self.$codeLanguage.addEventListener('change', function (event) {\n          self.enableAddButton();\n        }, false);\n    };\n\n    this.initialize = function() {\n      var $container = options.dialogsInBody ? $(document.body) : $editor;\n      self.createDialog($container);\n    };\n\n    this.destroy = function() {\n      ui.hideDialog(self.$dialog);\n      self.$dialog.remove();\n    };\n\n    this.events = {\n      'summernote.init': function(we, e) {\n        self.init();\n      },\n      'summernote.change': function (we, contents) {\n        if (window.PR) {\n          PR.prettyPrintOne(contents);\n        } else {\n          prettyPrintOne(contents);\n        }\n      }\n    };\n  };\n\n  $.extend(true, $.summernote, {\n    lang: {\n      'en-US': {\n        dialogPrettyfi: {\n          title: 'Insert fragment code into editor',\n          selectLabel: 'Choose your language',\n          codeLabel: 'Type your code',\n          button: 'Insert code'\n        },\n        button: {\n          tooltip: 'Insert code'\n        }\n      },\n      'pt-BR': {\n        dialogPrettyfi: {\n          title: 'Adicionar fragmento de cdigo ao editor',\n          selectLabel: 'Escolha a linguagem',\n          codeLabel: 'Digite o seu cdigo aqui',\n          button: 'Inserir cdigo'\n        },\n        button: {\n          tooltip: 'Adicionar cdigo'\n        }\n      }\n    },\n    plugins: {\n      'prettyprint': summernotePrettyprint\n    }\n  });\n}));\n\n\n\n/** WEBPACK FOOTER **\n ** ./vendor/summernote/plugins/summernote-prettyprint-plugin.js\n **/"],"sourceRoot":""}